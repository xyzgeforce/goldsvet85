! function(t) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = t();
    else if ("function" == typeof define && define.amd) define([], t);
    else {
        var e;
        e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, e.PIXI = t()
    }
}(function() {
    var t;
    return function e(t, r, i) {
        function n(o, a) {
            if (!r[o]) {
                if (!t[o]) {
                    var h = "function" == typeof require && require;
                    if (!a && h) return h(o, !0);
                    if (s) return s(o, !0);
                    var u = new Error("Cannot find module '" + o + "'");
                    throw u.code = "MODULE_NOT_FOUND",
                        u;
                }
                var l = r[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var r = t[o][1][e];
                    return n(r ? r : e)
                }, l, l.exports, e, t, r, i)
            }
            return r[o].exports
        }
        for (var s = "function" == typeof require && require, o = 0; o < i.length; o++) n(i[o]);
        return n
    }({
        1: [function(t, e, r) {
            (function(r) {
                t("./polyfill");
                var i = e.exports = t("./core");
                i.extras = t("./extras"), i.filters = t("./filters"), i.interaction = t("./interaction"), i.loaders = t("./loaders"), i.mesh = t("./mesh"), i.ticker = t("./ticker"), i.loader = new i.loaders.Loader, Object.assign(i, t("./deprecation")),
                    r.PIXI = i
            }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
        }, {
            "./core": 25,
            "./deprecation": 74,
            "./extras": 81,
            "./filters": 3,
            "./interaction": 84,
            "./loaders": 87,
            "./mesh": 93,
            "./polyfill": 97,
            "./ticker": 100
        }],
        2: [function(e, r, i) {
            (function(e) {
                ! function() {
                    function i(t) {
                        var e = !1;
                        return function() {
                            if (e) throw new Error("Callback was already called.");
                            e = !0, t.apply(n, arguments)
                        }
                    }
                    var n, s, o = {};
                    n = this, null != n && (s = n.async), o.noConflict = function() {
                        return n.async =
                            s, o
                    };
                    var a = Object.prototype.toString,
                        h = Array.isArray || function(t) {
                            return "[object Array]" === a.call(t)
                        },
                        u = function(t, e) {
                            for (var r = 0; r < t.length; r += 1) e(t[r], r, t)
                        },
                        l = function(t, e) {
                            if (t.map) return t.map(e);
                            var r = [];
                            return u(t, function(t, i, n) {
                                r.push(e(t, i, n))
                            }), r
                        },
                        c = function(t, e, r) {
                            return t.reduce ? t.reduce(e, r) : (u(t, function(t, i, n) {
                                r = e(r, t, i, n)
                            }), r)
                        },
                        d = function(t) {
                            if (Object.keys) return Object.keys(t);
                            var e = [];
                            for (var r in t) t.hasOwnProperty(r) && e.push(r);
                            return e
                        };
                    "undefined" != typeof e && e.nextTick ? (o.nextTick =
                        e.nextTick, "undefined" != typeof setImmediate ? o.setImmediate = function(t) {
                            setImmediate(t)
                        } : o.setImmediate = o.nextTick) : "function" == typeof setImmediate ? (o.nextTick = function(t) {
                        setImmediate(t)
                    }, o.setImmediate = o.nextTick) : (o.nextTick = function(t) {
                        setTimeout(t, 0)
                    }, o.setImmediate = o.nextTick), o.each = function(t, e, r) {
                        function n(e) {
                            e ? (r(e), r = function() {}) : (s += 1, s >= t.length && r())
                        }
                        if (r = r || function() {}, !t.length) return r();
                        var s = 0;
                        u(t, function(t) {
                            e(t, i(n))
                        })
                    }, o.forEach = o.each, o.eachSeries = function(t, e, r) {
                        if (r = r ||
                            function() {}, !t.length) return r();
                        var i = 0,
                            n = function() {
                                e(t[i], function(e) {
                                    e ? (r(e), r = function() {}) : (i += 1, i >= t.length ? r() : n())
                                })
                            };
                        n()
                    }, o.forEachSeries = o.eachSeries, o.eachLimit = function(t, e, r, i) {
                        var n = p(e);
                        n.apply(null, [t, r, i])
                    }, o.forEachLimit = o.eachLimit;
                    var p = function(t) {
                            return function(e, r, i) {
                                if (i = i || function() {}, !e.length || t <= 0) return i();
                                var n = 0,
                                    s = 0,
                                    o = 0;
                                ! function a() {
                                    if (n >= e.length) return i();
                                    for (; o < t && s < e.length;) s += 1, o += 1, r(e[s - 1], function(t) {
                                        t ? (i(t), i = function() {}) : (n += 1, o -= 1, n >= e.length ? i() :
                                            a())
                                    })
                                }()
                            }
                        },
                        f = function(t) {
                            return function() {
                                var e = Array.prototype.slice.call(arguments);
                                return t.apply(null, [o.each].concat(e))
                            }
                        },
                        g = function(t, e) {
                            return function() {
                                var r = Array.prototype.slice.call(arguments);
                                return e.apply(null, [p(t)].concat(r))
                            }
                        },
                        v = function(t) {
                            return function() {
                                var e = Array.prototype.slice.call(arguments);
                                return t.apply(null, [o.eachSeries].concat(e))
                            }
                        },
                        y = function(t, e, r, i) {
                            if (e = l(e, function(t, e) {
                                    return {
                                        index: e,
                                        value: t
                                    }
                                }), i) {
                                var n = [];
                                t(e, function(t, e) {
                                    r(t.value, function(r, i) {
                                        n[t.index] =
                                            i, e(r)
                                    })
                                }, function(t) {
                                    i(t, n)
                                })
                            } else t(e, function(t, e) {
                                r(t.value, function(t) {
                                    e(t)
                                })
                            })
                        };
                    o.map = f(y), o.mapSeries = v(y), o.mapLimit = function(t, e, r, i) {
                        return m(e)(t, r, i)
                    };
                    var m = function(t) {
                        return g(t, y)
                    };
                    o.reduce = function(t, e, r, i) {
                        o.eachSeries(t, function(t, i) {
                            r(e, t, function(t, r) {
                                e = r, i(t)
                            })
                        }, function(t) {
                            i(t, e)
                        })
                    }, o.inject = o.reduce, o.foldl = o.reduce, o.reduceRight = function(t, e, r, i) {
                        var n = l(t, function(t) {
                            return t
                        }).reverse();
                        o.reduce(n, e, r, i)
                    }, o.foldr = o.reduceRight;
                    var x = function(t, e, r, i) {
                        var n = [];
                        e = l(e, function(t,
                            e) {
                            return {
                                index: e,
                                value: t
                            }
                        }), t(e, function(t, e) {
                            r(t.value, function(r) {
                                r && n.push(t), e()
                            })
                        }, function(t) {
                            i(l(n.sort(function(t, e) {
                                return t.index - e.index
                            }), function(t) {
                                return t.value
                            }))
                        })
                    };
                    o.filter = f(x), o.filterSeries = v(x), o.select = o.filter, o.selectSeries = o.filterSeries;
                    var _ = function(t, e, r, i) {
                        var n = [];
                        e = l(e, function(t, e) {
                            return {
                                index: e,
                                value: t
                            }
                        }), t(e, function(t, e) {
                            r(t.value, function(r) {
                                r || n.push(t), e()
                            })
                        }, function(t) {
                            i(l(n.sort(function(t, e) {
                                return t.index - e.index
                            }), function(t) {
                                return t.value
                            }))
                        })
                    };
                    o.reject =
                        f(_), o.rejectSeries = v(_);
                    var E = function(t, e, r, i) {
                        t(e, function(t, e) {
                            r(t, function(r) {
                                r ? (i(t), i = function() {}) : e()
                            })
                        }, function(t) {
                            i()
                        })
                    };
                    o.detect = f(E), o.detectSeries = v(E), o.some = function(t, e, r) {
                        o.each(t, function(t, i) {
                            e(t, function(t) {
                                t && (r(!0), r = function() {}), i()
                            })
                        }, function(t) {
                            r(!1)
                        })
                    }, o.any = o.some, o.every = function(t, e, r) {
                        o.each(t, function(t, i) {
                            e(t, function(t) {
                                t || (r(!1), r = function() {}), i()
                            })
                        }, function(t) {
                            r(!0)
                        })
                    }, o.all = o.every, o.sortBy = function(t, e, r) {
                        o.map(t, function(t, r) {
                            e(t, function(e, i) {
                                e ? r(e) : r(null, {
                                    value: t,
                                    criteria: i
                                })
                            })
                        }, function(t, e) {
                            if (t) return r(t);
                            var i = function(t, e) {
                                var r = t.criteria,
                                    i = e.criteria;
                                return r < i ? -1 : r > i ? 1 : 0
                            };
                            r(null, l(e.sort(i), function(t) {
                                return t.value
                            }))
                        })
                    }, o.auto = function(t, e) {
                        e = e || function() {};
                        var r = d(t),
                            i = r.length;
                        if (!i) return e();
                        var n = {},
                            s = [],
                            a = function(t) {
                                s.unshift(t)
                            },
                            l = function(t) {
                                for (var e = 0; e < s.length; e += 1)
                                    if (s[e] === t) return void s.splice(e, 1)
                            },
                            p = function() {
                                i--, u(s.slice(0), function(t) {
                                    t()
                                })
                            };
                        a(function() {
                            if (!i) {
                                var t = e;
                                e = function() {}, t(null, n)
                            }
                        }), u(r, function(r) {
                            var i =
                                h(t[r]) ? t[r] : [t[r]],
                                s = function(t) {
                                    var i = Array.prototype.slice.call(arguments, 1);
                                    if (i.length <= 1 && (i = i[0]), t) {
                                        var s = {};
                                        u(d(n), function(t) {
                                            s[t] = n[t]
                                        }), s[r] = i, e(t, s), e = function() {}
                                    } else n[r] = i, o.setImmediate(p)
                                },
                                f = i.slice(0, Math.abs(i.length - 1)) || [],
                                g = function() {
                                    return c(f, function(t, e) {
                                        return t && n.hasOwnProperty(e)
                                    }, !0) && !n.hasOwnProperty(r)
                                };
                            if (g()) i[i.length - 1](s, n);
                            else {
                                var v = function() {
                                    g() && (l(v), i[i.length - 1](s, n))
                                };
                                a(v)
                            }
                        })
                    }, o.retry = function(t, e, r) {
                        var i = 5,
                            n = [];
                        "function" == typeof t && (r = e, e = t, t =
                            i), t = parseInt(t, 10) || i;
                        var s = function(i, s) {
                            for (var a = function(t, e) {
                                    return function(r) {
                                        t(function(t, i) {
                                            r(!t || e, {
                                                err: t,
                                                result: i
                                            })
                                        }, s)
                                    }
                                }; t;) n.push(a(e, !(t -= 1)));
                            o.series(n, function(t, e) {
                                e = e[e.length - 1], (i || r)(e.err, e.result)
                            })
                        };
                        return r ? s() : s
                    }, o.waterfall = function(t, e) {
                        if (e = e || function() {}, !h(t)) {
                            var r = new Error("First argument to waterfall must be an array of functions");
                            return e(r)
                        }
                        if (!t.length) return e();
                        var i = function(t) {
                            return function(r) {
                                if (r) e.apply(null, arguments), e = function() {};
                                else {
                                    var n = Array.prototype.slice.call(arguments,
                                            1),
                                        s = t.next();
                                    s ? n.push(i(s)) : n.push(e), o.setImmediate(function() {
                                        t.apply(null, n)
                                    })
                                }
                            }
                        };
                        i(o.iterator(t))()
                    };
                    var b = function(t, e, r) {
                        if (r = r || function() {}, h(e)) t.map(e, function(t, e) {
                            t && t(function(t) {
                                var r = Array.prototype.slice.call(arguments, 1);
                                r.length <= 1 && (r = r[0]), e.call(null, t, r)
                            })
                        }, r);
                        else {
                            var i = {};
                            t.each(d(e), function(t, r) {
                                e[t](function(e) {
                                    var n = Array.prototype.slice.call(arguments, 1);
                                    n.length <= 1 && (n = n[0]), i[t] = n, r(e)
                                })
                            }, function(t) {
                                r(t, i)
                            })
                        }
                    };
                    o.parallel = function(t, e) {
                            b({
                                map: o.map,
                                each: o.each
                            }, t, e)
                        },
                        o.parallelLimit = function(t, e, r) {
                            b({
                                map: m(e),
                                each: p(e)
                            }, t, r)
                        }, o.series = function(t, e) {
                            if (e = e || function() {}, h(t)) o.mapSeries(t, function(t, e) {
                                t && t(function(t) {
                                    var r = Array.prototype.slice.call(arguments, 1);
                                    r.length <= 1 && (r = r[0]), e.call(null, t, r)
                                })
                            }, e);
                            else {
                                var r = {};
                                o.eachSeries(d(t), function(e, i) {
                                    t[e](function(t) {
                                        var n = Array.prototype.slice.call(arguments, 1);
                                        n.length <= 1 && (n = n[0]), r[e] = n, i(t)
                                    })
                                }, function(t) {
                                    e(t, r)
                                })
                            }
                        }, o.iterator = function(t) {
                            var e = function(r) {
                                var i = function() {
                                    return t.length && t[r].apply(null,
                                        arguments), i.next()
                                };
                                return i.next = function() {
                                    return r < t.length - 1 ? e(r + 1) : null
                                }, i
                            };
                            return e(0)
                        }, o.apply = function(t) {
                            var e = Array.prototype.slice.call(arguments, 1);
                            return function() {
                                return t.apply(null, e.concat(Array.prototype.slice.call(arguments)))
                            }
                        };
                    var T = function(t, e, r, i) {
                        var n = [];
                        t(e, function(t, e) {
                            r(t, function(t, r) {
                                n = n.concat(r || []), e(t)
                            })
                        }, function(t) {
                            i(t, n)
                        })
                    };
                    o.concat = f(T), o.concatSeries = v(T), o.whilst = function(t, e, r) {
                        t() ? e(function(i) {
                            return i ? r(i) : void o.whilst(t, e, r)
                        }) : r()
                    }, o.doWhilst = function(t,
                        e, r) {
                        t(function(i) {
                            if (i) return r(i);
                            var n = Array.prototype.slice.call(arguments, 1);
                            e.apply(null, n) ? o.doWhilst(t, e, r) : r()
                        })
                    }, o.until = function(t, e, r) {
                        t() ? r() : e(function(i) {
                            return i ? r(i) : void o.until(t, e, r)
                        })
                    }, o.doUntil = function(t, e, r) {
                        t(function(i) {
                            if (i) return r(i);
                            var n = Array.prototype.slice.call(arguments, 1);
                            e.apply(null, n) ? r() : o.doUntil(t, e, r)
                        })
                    }, o.queue = function(t, e) {
                        function r(t, e, r, i) {
                            return t.started || (t.started = !0), h(e) || (e = [e]), 0 == e.length ? o.setImmediate(function() {
                                t.drain && t.drain()
                            }) : void u(e,
                                function(e) {
                                    var n = {
                                        data: e,
                                        callback: "function" == typeof i ? i : null
                                    };
                                    r ? t.tasks.unshift(n) : t.tasks.push(n), t.saturated && t.tasks.length === t.concurrency && t.saturated(), o.setImmediate(t.process)
                                })
                        }
                        void 0 === e && (e = 1);
                        var n = 0,
                            s = {
                                tasks: [],
                                concurrency: e,
                                saturated: null,
                                empty: null,
                                drain: null,
                                started: !1,
                                paused: !1,
                                push: function(t, e) {
                                    r(s, t, !1, e)
                                },
                                kill: function() {
                                    s.drain = null, s.tasks = []
                                },
                                unshift: function(t, e) {
                                    r(s, t, !0, e)
                                },
                                process: function() {
                                    if (!s.paused && n < s.concurrency && s.tasks.length) {
                                        var e = s.tasks.shift();
                                        s.empty &&
                                            0 === s.tasks.length && s.empty(), n += 1;
                                        var r = function() {
                                                n -= 1, e.callback && e.callback.apply(e, arguments), s.drain && s.tasks.length + n === 0 && s.drain(), s.process()
                                            },
                                            o = i(r);
                                        t(e.data, o)
                                    }
                                },
                                length: function() {
                                    return s.tasks.length
                                },
                                running: function() {
                                    return n
                                },
                                idle: function() {
                                    return s.tasks.length + n === 0
                                },
                                pause: function() {
                                    s.paused !== !0 && (s.paused = !0)
                                },
                                resume: function() {
                                    if (s.paused !== !1) {
                                        s.paused = !1;
                                        for (var t = 1; t <= s.concurrency; t++) o.setImmediate(s.process)
                                    }
                                }
                            };
                        return s
                    }, o.priorityQueue = function(t, e) {
                        function r(t, e) {
                            return t.priority -
                                e.priority
                        }

                        function i(t, e, r) {
                            for (var i = -1, n = t.length - 1; i < n;) {
                                var s = i + (n - i + 1 >>> 1);
                                r(e, t[s]) >= 0 ? i = s : n = s - 1
                            }
                            return i
                        }

                        function n(t, e, n, s) {
                            return t.started || (t.started = !0), h(e) || (e = [e]), 0 == e.length ? o.setImmediate(function() {
                                t.drain && t.drain()
                            }) : void u(e, function(e) {
                                var a = {
                                    data: e,
                                    priority: n,
                                    callback: "function" == typeof s ? s : null
                                };
                                t.tasks.splice(i(t.tasks, a, r) + 1, 0, a), t.saturated && t.tasks.length === t.concurrency && t.saturated(), o.setImmediate(t.process)
                            })
                        }
                        var s = o.queue(t, e);
                        return s.push = function(t, e, r) {
                            n(s, t,
                                e, r)
                        }, delete s.unshift, s
                    }, o.cargo = function(t, e) {
                        var r = !1,
                            i = [],
                            n = {
                                tasks: i,
                                payload: e,
                                saturated: null,
                                empty: null,
                                drain: null,
                                drained: !0,
                                push: function(t, r) {
                                    h(t) || (t = [t]), u(t, function(t) {
                                        i.push({
                                            data: t,
                                            callback: "function" == typeof r ? r : null
                                        }), n.drained = !1, n.saturated && i.length === e && n.saturated()
                                    }), o.setImmediate(n.process)
                                },
                                process: function s() {
                                    if (!r) {
                                        if (0 === i.length) return n.drain && !n.drained && n.drain(), void(n.drained = !0);
                                        var o = "number" == typeof e ? i.splice(0, e) : i.splice(0, i.length),
                                            a = l(o, function(t) {
                                                return t.data
                                            });
                                        n.empty && n.empty(), r = !0, t(a, function() {
                                            r = !1;
                                            var t = arguments;
                                            u(o, function(e) {
                                                e.callback && e.callback.apply(null, t)
                                            }), s()
                                        })
                                    }
                                },
                                length: function() {
                                    return i.length
                                },
                                running: function() {
                                    return r
                                }
                            };
                        return n
                    };
                    var S = function(t) {
                        return function(e) {
                            var r = Array.prototype.slice.call(arguments, 1);
                            e.apply(null, r.concat([function(e) {
                                var r = Array.prototype.slice.call(arguments, 1);
                                "undefined" != typeof console && (e ? console.error && console.error(e) : console[t] && u(r, function(e) {
                                    console[t](e)
                                }))
                            }]))
                        }
                    };
                    o.log = S("log"), o.dir = S("dir"),
                        o.memoize = function(t, e) {
                            var r = {},
                                i = {};
                            e = e || function(t) {
                                return t
                            };
                            var n = function() {
                                var n = Array.prototype.slice.call(arguments),
                                    s = n.pop(),
                                    a = e.apply(null, n);
                                a in r ? o.nextTick(function() {
                                    s.apply(null, r[a])
                                }) : a in i ? i[a].push(s) : (i[a] = [s], t.apply(null, n.concat([function() {
                                    r[a] = arguments;
                                    var t = i[a];
                                    delete i[a];
                                    for (var e = 0, n = t.length; e < n; e++) t[e].apply(null, arguments)
                                }])))
                            };
                            return n.memo = r, n.unmemoized = t, n
                        }, o.unmemoize = function(t) {
                            return function() {
                                return (t.unmemoized || t).apply(null, arguments)
                            }
                        }, o.times =
                        function(t, e, r) {
                            for (var i = [], n = 0; n < t; n++) i.push(n);
                            return o.map(i, e, r)
                        }, o.timesSeries = function(t, e, r) {
                            for (var i = [], n = 0; n < t; n++) i.push(n);
                            return o.mapSeries(i, e, r)
                        }, o.seq = function() {
                            var t = arguments;
                            return function() {
                                var e = this,
                                    r = Array.prototype.slice.call(arguments),
                                    i = r.pop();
                                o.reduce(t, r, function(t, r, i) {
                                    r.apply(e, t.concat([function() {
                                        var t = arguments[0],
                                            e = Array.prototype.slice.call(arguments, 1);
                                        i(t, e)
                                    }]))
                                }, function(t, r) {
                                    i.apply(e, [t].concat(r))
                                })
                            }
                        }, o.compose = function() {
                            return o.seq.apply(null, Array.prototype.reverse.call(arguments))
                        };
                    var w = function(t, e) {
                        var r = function() {
                            var r = this,
                                i = Array.prototype.slice.call(arguments),
                                n = i.pop();
                            return t(e, function(t, e) {
                                t.apply(r, i.concat([e]))
                            }, n)
                        };
                        if (arguments.length > 2) {
                            var i = Array.prototype.slice.call(arguments, 2);
                            return r.apply(this, i)
                        }
                        return r
                    };
                    o.applyEach = f(w), o.applyEachSeries = v(w), o.forever = function(t, e) {
                        function r(i) {
                            if (i) {
                                if (e) return e(i);
                                throw i;
                            }
                            t(r)
                        }
                        r()
                    }, "undefined" != typeof r && r.exports ? r.exports = o : "undefined" != typeof t && t.amd ? t([], function() {
                        return o
                    }) : n.async = o
                }()
            }).call(this,
                e("_process"))
        }, {
            _process: 5
        }],
        3: [function(t, e, r) {}, {}],
        4: [function(t, e, r) {
            (function(t) {
                function e(t, e) {
                    for (var r = 0, i = t.length - 1; i >= 0; i--) {
                        var n = t[i];
                        "." === n ? t.splice(i, 1) : ".." === n ? (t.splice(i, 1), r++) : r && (t.splice(i, 1), r--)
                    }
                    if (e)
                        for (; r--; r) t.unshift("..");
                    return t
                }

                function i(t, e) {
                    if (t.filter) return t.filter(e);
                    for (var r = [], i = 0; i < t.length; i++) e(t[i], i, t) && r.push(t[i]);
                    return r
                }
                var n = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,
                    s = function(t) {
                        return n.exec(t).slice(1)
                    };
                r.resolve = function() {
                        for (var r =
                                "", n = !1, s = arguments.length - 1; s >= -1 && !n; s--) {
                            var o = s >= 0 ? arguments[s] : t.cwd();
                            if ("string" != typeof o) throw new TypeError("Arguments to path.resolve must be strings");
                            o && (r = o + "/" + r, n = "/" === o.charAt(0))
                        }
                        return r = e(i(r.split("/"), function(t) {
                            return !!t
                        }), !n).join("/"), (n ? "/" : "") + r || "."
                    }, r.normalize = function(t) {
                        var n = r.isAbsolute(t),
                            s = "/" === o(t, -1);
                        return t = e(i(t.split("/"), function(t) {
                            return !!t
                        }), !n).join("/"), t || n || (t = "."), t && s && (t += "/"), (n ? "/" : "") + t
                    }, r.isAbsolute = function(t) {
                        return "/" === t.charAt(0)
                    }, r.join =
                    function() {
                        var t = Array.prototype.slice.call(arguments, 0);
                        return r.normalize(i(t, function(t, e) {
                            if ("string" != typeof t) throw new TypeError("Arguments to path.join must be strings");
                            return t
                        }).join("/"))
                    }, r.relative = function(t, e) {
                        function i(t) {
                            for (var e = 0; e < t.length && "" === t[e]; e++);
                            for (var r = t.length - 1; r >= 0 && "" === t[r]; r--);
                            return e > r ? [] : t.slice(e, r - e + 1)
                        }
                        t = r.resolve(t).substr(1), e = r.resolve(e).substr(1);
                        for (var n = i(t.split("/")), s = i(e.split("/")), o = Math.min(n.length, s.length), a = o, h = 0; h < o; h++)
                            if (n[h] !==
                                s[h]) {
                                a = h;
                                break
                            }
                        for (var u = [], h = a; h < n.length; h++) u.push("..");
                        return u = u.concat(s.slice(a)), u.join("/")
                    }, r.sep = "/", r.delimiter = ":", r.dirname = function(t) {
                        var e = s(t),
                            r = e[0],
                            i = e[1];
                        return r || i ? (i && (i = i.substr(0, i.length - 1)), r + i) : "."
                    }, r.basename = function(t, e) {
                        var r = s(t)[2];
                        return e && r.substr(-1 * e.length) === e && (r = r.substr(0, r.length - e.length)), r
                    }, r.extname = function(t) {
                        return s(t)[3]
                    };
                var o = "b" === "ab".substr(-1) ? function(t, e, r) {
                    return t.substr(e, r)
                } : function(t, e, r) {
                    return e < 0 && (e = t.length + e), t.substr(e,
                        r)
                }
            }).call(this, t("_process"))
        }, {
            _process: 5
        }],
        5: [function(t, e, r) {
            function i() {
                if (!a) {
                    a = !0;
                    for (var t, e = o.length; e;) {
                        t = o, o = [];
                        for (var r = -1; ++r < e;) t[r]();
                        e = o.length
                    }
                    a = !1
                }
            }

            function n() {}
            var s = e.exports = {},
                o = [],
                a = !1;
            s.nextTick = function(t) {
                o.push(t), a || setTimeout(i, 0)
            }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {}, s.on = n, s.addListener = n, s.once = n, s.off = n, s.removeListener = n, s.removeAllListeners = n, s.emit = n, s.binding = function(t) {
                throw new Error("process.binding is not supported");
            }, s.cwd = function() {
                return "/"
            }, s.chdir = function(t) {
                throw new Error("process.chdir is not supported");
            }, s.umask = function() {
                return 0
            }
        }, {}],
        6: [function(t, e, r) {
            function i(t, e, r) {
                this.fn = t, this.context = e, this.once = r || !1
            }

            function n() {}
            var s = Object.prototype.hasOwnProperty,
                o = "function" != typeof Object.create && "~";
            n.prototype._events = void 0, n.prototype.eventNames = function() {
                var t, e = this._events,
                    r = [];
                if (!e) return r;
                for (t in e) s.call(e, t) && r.push(o ? t.slice(1) : t);
                return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(e)) :
                    r
            }, n.prototype.listeners = function(t, e) {
                var r = o ? o + t : t,
                    i = this._events && this._events[r];
                if (e) return !!i;
                if (!i) return [];
                if (i.fn) return [i.fn];
                for (var n = 0, s = i.length, a = new Array(s); n < s; n++) a[n] = i[n].fn;
                return a
            }, n.prototype.emit = function(t, e, r, i, n, s) {
                var a = o ? o + t : t;
                if (!this._events || !this._events[a]) return !1;
                var h, u, l = this._events[a],
                    c = arguments.length;
                if ("function" == typeof l.fn) {
                    switch (l.once && this.removeListener(t, l.fn, void 0, !0), c) {
                        case 1:
                            return l.fn.call(l.context), !0;
                        case 2:
                            return l.fn.call(l.context,
                                e), !0;
                        case 3:
                            return l.fn.call(l.context, e, r), !0;
                        case 4:
                            return l.fn.call(l.context, e, r, i), !0;
                        case 5:
                            return l.fn.call(l.context, e, r, i, n), !0;
                        case 6:
                            return l.fn.call(l.context, e, r, i, n, s), !0
                    }
                    for (u = 1, h = new Array(c - 1); u < c; u++) h[u - 1] = arguments[u];
                    l.fn.apply(l.context, h)
                } else {
                    var d, p = l.length;
                    for (u = 0; u < p; u++) switch (l[u].once && this.removeListener(t, l[u].fn, void 0, !0), c) {
                        case 1:
                            l[u].fn.call(l[u].context);
                            break;
                        case 2:
                            l[u].fn.call(l[u].context, e);
                            break;
                        case 3:
                            l[u].fn.call(l[u].context, e, r);
                            break;
                        default:
                            if (!h)
                                for (d =
                                    1, h = new Array(c - 1); d < c; d++) h[d - 1] = arguments[d];
                            l[u].fn.apply(l[u].context, h)
                    }
                }
                return !0
            }, n.prototype.on = function(t, e, r) {
                var n = new i(e, r || this),
                    s = o ? o + t : t;
                return this._events || (this._events = o ? {} : Object.create(null)), this._events[s] ? this._events[s].fn ? this._events[s] = [this._events[s], n] : this._events[s].push(n) : this._events[s] = n, this
            }, n.prototype.once = function(t, e, r) {
                var n = new i(e, r || this, !0),
                    s = o ? o + t : t;
                return this._events || (this._events = o ? {} : Object.create(null)), this._events[s] ? this._events[s].fn ? this._events[s] = [this._events[s], n] : this._events[s].push(n) : this._events[s] = n, this
            }, n.prototype.removeListener = function(t, e, r, i) {
                var n = o ? o + t : t;
                if (!this._events || !this._events[n]) return this;
                var s = this._events[n],
                    a = [];
                if (e)
                    if (s.fn)(s.fn !== e || i && !s.once || r && s.context !== r) && a.push(s);
                    else
                        for (var h = 0, u = s.length; h < u; h++)(s[h].fn !== e || i && !s[h].once || r && s[h].context !== r) && a.push(s[h]);
                return a.length ? this._events[n] = 1 === a.length ? a[0] : a : delete this._events[n], this
            }, n.prototype.removeAllListeners = function(t) {
                return this._events ?
                    (t ? delete this._events[o ? o + t : t] : this._events = o ? {} : Object.create(null), this) : this
            }, n.prototype.off = n.prototype.removeListener, n.prototype.addListener = n.prototype.on, n.prototype.setMaxListeners = function() {
                return this
            }, n.prefixed = o, "undefined" != typeof e && (e.exports = n)
        }, {}],
        7: [function(t, e, r) {
            function i(t) {
                if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined");
                return Object(t)
            }
            e.exports = Object.assign || function(t, e) {
                for (var r, n, s = i(t), o = 1; o < arguments.length; o++) {
                    r = arguments[o],
                        n = Object.keys(Object(r));
                    for (var a = 0; a < n.length; a++) s[n[a]] = r[n[a]]
                }
                return s
            }
        }, {}],
        8: [function(t, e, r) {
            function i() {}

            function n(t, e, r) {
                this.fn = t, this.context = e, this.once = r || !1
            }

            function s() {
                this._events = new i, this._eventsCount = 0
            }
            var o = Object.prototype.hasOwnProperty,
                a = "~";
            Object.create && (i.prototype = Object.create(null), (new i).__proto__ || (a = !1)), s.prototype.eventNames = function() {
                var t, e, r = [];
                if (0 === this._eventsCount) return r;
                for (e in t = this._events) o.call(t, e) && r.push(a ? e.slice(1) : e);
                return Object.getOwnPropertySymbols ?
                    r.concat(Object.getOwnPropertySymbols(t)) : r
            }, s.prototype.listeners = function(t, e) {
                var r = a ? a + t : t,
                    i = this._events[r];
                if (e) return !!i;
                if (!i) return [];
                if (i.fn) return [i.fn];
                for (var n = 0, s = i.length, o = new Array(s); n < s; n++) o[n] = i[n].fn;
                return o
            }, s.prototype.emit = function(t, e, r, i, n, s) {
                var o = a ? a + t : t;
                if (!this._events[o]) return !1;
                var h, u, l = this._events[o],
                    c = arguments.length;
                if (l.fn) {
                    switch (l.once && this.removeListener(t, l.fn, void 0, !0), c) {
                        case 1:
                            return l.fn.call(l.context), !0;
                        case 2:
                            return l.fn.call(l.context, e), !0;
                        case 3:
                            return l.fn.call(l.context, e, r), !0;
                        case 4:
                            return l.fn.call(l.context, e, r, i), !0;
                        case 5:
                            return l.fn.call(l.context, e, r, i, n), !0;
                        case 6:
                            return l.fn.call(l.context, e, r, i, n, s), !0
                    }
                    for (u = 1, h = new Array(c - 1); u < c; u++) h[u - 1] = arguments[u];
                    l.fn.apply(l.context, h)
                } else {
                    var d, p = l.length;
                    for (u = 0; u < p; u++) switch (l[u].once && this.removeListener(t, l[u].fn, void 0, !0), c) {
                        case 1:
                            l[u].fn.call(l[u].context);
                            break;
                        case 2:
                            l[u].fn.call(l[u].context, e);
                            break;
                        case 3:
                            l[u].fn.call(l[u].context, e, r);
                            break;
                        case 4:
                            l[u].fn.call(l[u].context,
                                e, r, i);
                            break;
                        default:
                            if (!h)
                                for (d = 1, h = new Array(c - 1); d < c; d++) h[d - 1] = arguments[d];
                            l[u].fn.apply(l[u].context, h)
                    }
                }
                return !0
            }, s.prototype.on = function(t, e, r) {
                var i = new n(e, r || this),
                    s = a ? a + t : t;
                return this._events[s] ? this._events[s].fn ? this._events[s] = [this._events[s], i] : this._events[s].push(i) : (this._events[s] = i, this._eventsCount++), this
            }, s.prototype.once = function(t, e, r) {
                var i = new n(e, r || this, !0),
                    s = a ? a + t : t;
                return this._events[s] ? this._events[s].fn ? this._events[s] = [this._events[s], i] : this._events[s].push(i) :
                    (this._events[s] = i, this._eventsCount++), this
            }, s.prototype.removeListener = function(t, e, r, n) {
                var s = a ? a + t : t;
                if (!this._events[s]) return this;
                if (!e) return 0 === --this._eventsCount ? this._events = new i : delete this._events[s], this;
                var o = this._events[s];
                if (o.fn) o.fn !== e || n && !o.once || r && o.context !== r || (0 === --this._eventsCount ? this._events = new i : delete this._events[s]);
                else {
                    for (var h = 0, u = [], l = o.length; h < l; h++)(o[h].fn !== e || n && !o[h].once || r && o[h].context !== r) && u.push(o[h]);
                    u.length ? this._events[s] = 1 === u.length ?
                        u[0] : u : 0 === --this._eventsCount ? this._events = new i : delete this._events[s]
                }
                return this
            }, s.prototype.removeAllListeners = function(t) {
                var e;
                return t ? (e = a ? a + t : t, this._events[e] && (0 === --this._eventsCount ? this._events = new i : delete this._events[e])) : (this._events = new i, this._eventsCount = 0), this
            }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prototype.setMaxListeners = function() {
                return this
            }, s.prefixed = a, s.EventEmitter = s, "undefined" != typeof e && (e.exports = s)
        }, {}],
        9: [function(t,
            e, r) {
            e.exports = function(t, e) {
                e = e || {};
                for (var r = {
                            key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
                            q: {
                                name: "queryKey",
                                parser: /(?:^|&)([^&=]*)=?([^&]*)/g
                            },
                            parser: {
                                strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                                loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
                            }
                        },
                        i = r.parser[e.strictMode ? "strict" : "loose"].exec(t), n = {}, s = 14; s--;) n[r.key[s]] = i[s] || "";
                return n[r.q.name] = {}, n[r.key[12]].replace(r.q.parser, function(t, e, i) {
                    e && (n[r.q.name][e] = i)
                }), n
            }
        }, {}],
        10: [function(t, e, r) {
            function i(t, e) {
                a.call(this), e = e || h, this.baseUrl = t || "", this.progress = 0, this.loading = !1, this._progressChunk = 0, this._beforeMiddleware = [], this._afterMiddleware = [], this._boundLoadResource = this._loadResource.bind(this), this._buffer = [], this._numToLoad = 0, this._queue = s.queue(this._boundLoadResource, e),
                    this.resources = {}
            }
            var n = t("parse-uri"),
                s = t("./async"),
                o = t("./Resource"),
                a = t("eventemitter3"),
                h = 10,
                u = 100;
            i.prototype = Object.create(a.prototype), i.prototype.constructor = i, e.exports = i, i.prototype.add = i.prototype.enqueue = function(t, e, r, i) {
                    if (Array.isArray(t)) {
                        for (var n = 0; n < t.length; ++n) this.add(t[n]);
                        return this
                    }
                    if ("object" == typeof t && (i = e || t.callback || t.onComplete, r = t, e = t.url, t = t.name || t.key || t.url), "string" != typeof e && (i = r, r = e, e = t), "string" != typeof e) throw new Error("No url passed to add resource to loader.");
                    if ("function" == typeof r && (i = r, r = null), this.resources[t]) throw new Error('Resource with name "' + t + '" already exists.');
                    return e = this._prepareUrl(e), this.resources[t] = new o(t, e, r), "function" == typeof i && this.resources[t].once("afterMiddleware", i), this._numToLoad++, this._queue.started ? (this._queue.push(this.resources[t]), this._progressChunk = (u - this.progress) / (this._queue.length() + this._queue.running())) : (this._buffer.push(this.resources[t]), this._progressChunk = u / this._buffer.length), this
                }, i.prototype.before =
                i.prototype.pre = function(t) {
                    return this._beforeMiddleware.push(t), this
                }, i.prototype.after = i.prototype.use = function(t) {
                    return this._afterMiddleware.push(t), this
                }, i.prototype.reset = function() {
                    this.progress = 0, this.loading = !1, this._progressChunk = 0, this._buffer.length = 0, this._numToLoad = 0, this._queue.kill(), this._queue.started = !1;
                    for (var t in this.resources) {
                        var e = this.resources[t];
                        e.off("complete", this._onLoad, this), e.isLoading && e.abort()
                    }
                    return this.resources = {}, this
                }, i.prototype.load = function(t) {
                    if ("function" ==
                        typeof t && this.once("complete", t), this._queue.started) return this;
                    this.emit("start", this), this.loading = !0;
                    for (var e = 0; e < this._buffer.length; ++e) this._queue.push(this._buffer[e]);
                    return this._buffer.length = 0, this
                }, i.prototype._prepareUrl = function(t) {
                    var e = n(t, {
                        strictMode: !0
                    });
                    return e.protocol || !e.path || 0 === e.path.indexOf("//") ? t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && "/" !== t.charAt(0) ? this.baseUrl + "/" + t : this.baseUrl + t
                }, i.prototype._loadResource = function(t, e) {
                    var r =
                        this;
                    t._dequeue = e, s.eachSeries(this._beforeMiddleware, function(e, i) {
                        e.call(r, t, function() {
                            i(t.isComplete ? {} : null)
                        })
                    }, function() {
                        t.isComplete ? r._onLoad(t) : (t.once("complete", r._onLoad, r), t.load())
                    })
                }, i.prototype._onComplete = function() {
                    this.loading = !1, this.emit("complete", this, this.resources)
                }, i.prototype._onLoad = function(t) {
                    var e = this;
                    s.eachSeries(this._afterMiddleware, function(r, i) {
                        r.call(e, t, i)
                    }, function() {
                        t.emit("afterMiddleware", t), e._numToLoad--, e.progress += e._progressChunk, e.emit("progress",
                            e, t), t.error ? e.emit("error", t.error, e, t) : e.emit("load", e, t), 0 === e._numToLoad && (e.progress = 100, e._onComplete())
                    }), t._dequeue()
                }, i.LOAD_TYPE = o.LOAD_TYPE, i.XHR_RESPONSE_TYPE = o.XHR_RESPONSE_TYPE
        }, {
            "./Resource": 11,
            "./async": 12,
            eventemitter3: 8,
            "parse-uri": 9
        }],
        11: [function(t, e, r) {
            function i(t, e, r) {
                if (o.call(this), r = r || {}, "string" != typeof t || "string" != typeof e) throw new Error("Both name and url are required for constructing a resource.");
                this.name = t, this.url = e, this.isDataUrl = 0 === this.url.indexOf("data:"),
                    this.data = null, this.crossOrigin = r.crossOrigin === !0 ? "anonymous" : r.crossOrigin, this.loadType = r.loadType || this._determineLoadType(), this.xhrType = r.xhrType, this.metadata = r.metadata || {}, this.error = null, this.xhr = null, this.isJson = !1, this.isXml = !1, this.isImage = !1, this.isAudio = !1, this.isVideo = !1, this.isComplete = !1, this.isLoading = !1, this._dequeue = null, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundXhrOnError =
                    this._xhrOnError.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this)
            }

            function n(t) {
                return t.toString().replace("object ", "")
            }

            function s(t, e, r) {
                e && 0 === e.indexOf(".") && (e = e.substring(1)), e && (t[e] = r)
            }
            var o = t("eventemitter3"),
                a = t("parse-uri"),
                h = !(!window.XDomainRequest || "withCredentials" in new XMLHttpRequest),
                u = null,
                l = 0,
                c = 200,
                d = 204;
            i.prototype = Object.create(o.prototype), i.prototype.constructor =
                i, e.exports = i, i.prototype.complete = function() {
                    if (this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null)), this.isComplete) throw new Error("Complete called again for an already completed resource.");
                    this.isComplete = !0, this.isLoading = !1, this.emit("complete", this)
                }, i.prototype.abort = function(t) {
                    if (!this.error) {
                        if (this.error = new Error(t), this.xhr) this.xhr.abort();
                        else if (this.xdr) this.xdr.abort();
                        else if (this.data)
                            if ("undefined" != typeof this.data.src) this.data.src = "";
                            else
                                for (; this.data.firstChild;) this.data.removeChild(this.data.firstChild);
                        this.complete()
                    }
                }, i.prototype.load = function(t) {
                    if (!this.isLoading)
                        if (this.isComplete) {
                            if (t) {
                                var e = this;
                                setTimeout(function() {
                                    t(e)
                                }, 1)
                            }
                        } else switch (t && this.once("complete", t), this.isLoading = !0, this.emit("start", this), this.crossOrigin !== !1 && "string" == typeof this.crossOrigin || (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
                            case i.LOAD_TYPE.IMAGE:
                                this._loadElement("image");
                                break;
                            case i.LOAD_TYPE.AUDIO:
                                this._loadSourceElement("audio");
                                break;
                            case i.LOAD_TYPE.VIDEO:
                                this._loadSourceElement("video");
                                break;
                            case i.LOAD_TYPE.XHR:
                            default:
                                h && this.crossOrigin ? this._loadXdr() : this._loadXhr()
                        }
                }, i.prototype._loadElement = function(t) {
                    this.metadata.loadElement ? this.data = this.metadata.loadElement : "image" === t && "undefined" != typeof window.Image ? this.data = new Image : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src =
                        this.url);
                    var e = "is" + t[0].toUpperCase() + t.substring(1);
                    this[e] === !1 && (this[e] = !0), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1)
                }, i.prototype._loadSourceElement = function(t) {
                    if (this.metadata.loadElement ? this.data = this.metadata.loadElement : "audio" === t && "undefined" != typeof window.Audio ? this.data = new Audio : this.data = document.createElement(t), null === this.data) return void this.abort("Unsupported element " +
                        t);
                    if (!this.metadata.skipSource)
                        if (navigator.isCocoonJS) this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
                        else if (Array.isArray(this.url))
                        for (var e = 0; e < this.url.length; ++e) this.data.appendChild(this._createSource(t, this.url[e]));
                    else this.data.appendChild(this._createSource(t, this.url));
                    this["is" + t[0].toUpperCase() + t.substring(1)] = !0, this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load()
                }, i.prototype._loadXhr = function() {
                    "string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
                    var t = this.xhr = new XMLHttpRequest;
                    t.open("GET", this.url, !0), this.xhrType === i.XHR_RESPONSE_TYPE.JSON || this.xhrType === i.XHR_RESPONSE_TYPE.DOCUMENT ? t.responseType = i.XHR_RESPONSE_TYPE.TEXT : t.responseType = this.xhrType, t.addEventListener("error", this._boundXhrOnError, !1), t.addEventListener("abort", this._boundXhrOnAbort, !1), t.addEventListener("progress", this._boundOnProgress, !1), t.addEventListener("load", this._boundXhrOnLoad, !1), t.send()
                }, i.prototype._loadXdr = function() {
                    "string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
                    var t = this.xhr = new XDomainRequest;
                    t.timeout = 5E3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXdrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout(function() {
                        t.send()
                    }, 0)
                }, i.prototype._createSource = function(t,
                    e, r) {
                    r || (r = t + "/" + e.substr(e.lastIndexOf(".") + 1));
                    var i = document.createElement("source");
                    return i.src = e, i.type = r, i
                }, i.prototype._onError = function(t) {
                    this.abort("Failed to load element using " + t.target.nodeName)
                }, i.prototype._onProgress = function(t) {
                    t && t.lengthComputable && this.emit("progress", this, t.loaded / t.total)
                }, i.prototype._xhrOnError = function() {
                    var t = this.xhr;
                    this.abort(n(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"')
                }, i.prototype._xhrOnAbort = function() {
                    this.abort(n(this.xhr) +
                        " Request was aborted by the user.")
                }, i.prototype._xdrOnTimeout = function() {
                    this.abort(n(this.xhr) + " Request timed out.")
                }, i.prototype._xhrOnLoad = function() {
                    var t = this.xhr,
                        e = "undefined" == typeof t.status ? t.status : c;
                    if (!(e === c || e === d || e === l && t.responseText.length > 0)) return void this.abort("[" + t.status + "]" + t.statusText + ":" + t.responseURL);
                    if (this.xhrType === i.XHR_RESPONSE_TYPE.TEXT) this.data = t.responseText;
                    else if (this.xhrType === i.XHR_RESPONSE_TYPE.JSON) try {
                        this.data = JSON.parse(t.responseText), this.isJson = !0
                    } catch (r) {
                        return void this.abort("Error trying to parse loaded json:", r)
                    } else if (this.xhrType === i.XHR_RESPONSE_TYPE.DOCUMENT) try {
                        if (window.DOMParser) {
                            var n = new DOMParser;
                            this.data = n.parseFromString(t.responseText, "text/xml")
                        } else {
                            var s = document.createElement("div");
                            s.innerHTML = t.responseText, this.data = s
                        }
                        this.isXml = !0
                    } catch (r) {
                        return void this.abort("Error trying to parse loaded xml:", r)
                    } else this.data = t.response || t.responseText;
                    this.complete()
                }, i.prototype._determineCrossOrigin = function(t, e) {
                    if (0 ===
                        t.indexOf("data:")) return "";
                    e = e || window.location, u || (u = document.createElement("a")), u.href = t, t = a(u.href, {
                        strictMode: !0
                    });
                    var r = !t.port && "" === e.port || t.port === e.port,
                        i = t.protocol ? t.protocol + ":" : "";
                    return t.host === e.hostname && r && i === e.protocol ? "" : "anonymous"
                }, i.prototype._determineXhrType = function() {
                    return i._xhrTypeMap[this._getExtension()] || i.XHR_RESPONSE_TYPE.TEXT
                }, i.prototype._determineLoadType = function() {
                    return i._loadTypeMap[this._getExtension()] || i.LOAD_TYPE.XHR
                }, i.prototype._getExtension = function() {
                    var t =
                        this.url,
                        e = "";
                    if (this.isDataUrl) {
                        var r = t.indexOf("/");
                        e = t.substring(r + 1, t.indexOf(";", r))
                    } else {
                        var i = t.indexOf("?");
                        i !== -1 && (t = t.substring(0, i)), e = t.substring(t.lastIndexOf(".") + 1)
                    }
                    return e.toLowerCase()
                }, i.prototype._getMimeFromXhrType = function(t) {
                    switch (t) {
                        case i.XHR_RESPONSE_TYPE.BUFFER:
                            return "application/octet-binary";
                        case i.XHR_RESPONSE_TYPE.BLOB:
                            return "application/blob";
                        case i.XHR_RESPONSE_TYPE.DOCUMENT:
                            return "application/xml";
                        case i.XHR_RESPONSE_TYPE.JSON:
                            return "application/json";
                        case i.XHR_RESPONSE_TYPE.DEFAULT:
                        case i.XHR_RESPONSE_TYPE.TEXT:
                        default:
                            return "text/plain"
                    }
                },
                i.LOAD_TYPE = {
                    XHR: 1,
                    IMAGE: 2,
                    AUDIO: 3,
                    VIDEO: 4
                }, i.XHR_RESPONSE_TYPE = {
                    DEFAULT: "text",
                    BUFFER: "arraybuffer",
                    BLOB: "blob",
                    DOCUMENT: "document",
                    JSON: "json",
                    TEXT: "text"
                }, i._loadTypeMap = {
                    gif: i.LOAD_TYPE.IMAGE,
                    png: i.LOAD_TYPE.IMAGE,
                    bmp: i.LOAD_TYPE.IMAGE,
                    jpg: i.LOAD_TYPE.IMAGE,
                    jpeg: i.LOAD_TYPE.IMAGE,
                    tif: i.LOAD_TYPE.IMAGE,
                    tiff: i.LOAD_TYPE.IMAGE,
                    webp: i.LOAD_TYPE.IMAGE,
                    tga: i.LOAD_TYPE.IMAGE,
                    "svg+xml": i.LOAD_TYPE.IMAGE
                }, i._xhrTypeMap = {
                    xhtml: i.XHR_RESPONSE_TYPE.DOCUMENT,
                    html: i.XHR_RESPONSE_TYPE.DOCUMENT,
                    htm: i.XHR_RESPONSE_TYPE.DOCUMENT,
                    xml: i.XHR_RESPONSE_TYPE.DOCUMENT,
                    tmx: i.XHR_RESPONSE_TYPE.DOCUMENT,
                    tsx: i.XHR_RESPONSE_TYPE.DOCUMENT,
                    svg: i.XHR_RESPONSE_TYPE.DOCUMENT,
                    gif: i.XHR_RESPONSE_TYPE.BLOB,
                    png: i.XHR_RESPONSE_TYPE.BLOB,
                    bmp: i.XHR_RESPONSE_TYPE.BLOB,
                    jpg: i.XHR_RESPONSE_TYPE.BLOB,
                    jpeg: i.XHR_RESPONSE_TYPE.BLOB,
                    tif: i.XHR_RESPONSE_TYPE.BLOB,
                    tiff: i.XHR_RESPONSE_TYPE.BLOB,
                    webp: i.XHR_RESPONSE_TYPE.BLOB,
                    tga: i.XHR_RESPONSE_TYPE.BLOB,
                    json: i.XHR_RESPONSE_TYPE.JSON,
                    text: i.XHR_RESPONSE_TYPE.TEXT,
                    txt: i.XHR_RESPONSE_TYPE.TEXT
                }, i.setExtensionLoadType =
                function(t, e) {
                    s(i._loadTypeMap, t, e)
                }, i.setExtensionXhrType = function(t, e) {
                    s(i._xhrTypeMap, t, e)
                }
        }, {
            eventemitter3: 8,
            "parse-uri": 9
        }],
        12: [function(t, e, r) {
            function i() {}

            function n(t, e, r) {
                var i = 0,
                    n = t.length;
                ! function s(o) {
                    return o || i === n ? void(r && r(o)) : void e(t[i++], s)
                }()
            }

            function s(t) {
                return function() {
                    if (null === t) throw new Error("Callback was already called.");
                    var e = t;
                    t = null, e.apply(this, arguments)
                }
            }

            function o(t, e) {
                function r(t, e, r) {
                    if (null != r && "function" != typeof r) throw new Error("task callback must be a function");
                    if (a.started = !0, null == t && a.idle()) return void setTimeout(function() {
                        a.drain()
                    }, 1);
                    var n = {
                        data: t,
                        callback: "function" == typeof r ? r : i
                    };
                    e ? a._tasks.unshift(n) : a._tasks.push(n), setTimeout(function() {
                        a.process()
                    }, 1)
                }

                function n(t) {
                    return function() {
                        o -= 1, t.callback.apply(t, arguments), null != arguments[0] && a.error(arguments[0], t.data), o <= a.concurrency - a.buffer && a.unsaturated(), a.idle() && a.drain(), a.process()
                    }
                }
                if (null == e) e = 1;
                else if (0 === e) throw new Error("Concurrency must not be zero");
                var o = 0,
                    a = {
                        _tasks: [],
                        concurrency: e,
                        saturated: i,
                        unsaturated: i,
                        buffer: e / 4,
                        empty: i,
                        drain: i,
                        error: i,
                        started: !1,
                        paused: !1,
                        push: function(t, e) {
                            r(t, !1, e)
                        },
                        kill: function() {
                            a.drain = i, a._tasks = []
                        },
                        unshift: function(t, e) {
                            r(t, !0, e)
                        },
                        process: function() {
                            for (; !a.paused && o < a.concurrency && a._tasks.length;) {
                                var e = a._tasks.shift();
                                0 === a._tasks.length && a.empty(), o += 1, o === a.concurrency && a.saturated(), t(e.data, s(n(e)))
                            }
                        },
                        length: function() {
                            return a._tasks.length
                        },
                        running: function() {
                            return o
                        },
                        idle: function() {
                            return a._tasks.length + o === 0
                        },
                        pause: function() {
                            a.paused !==
                                !0 && (a.paused = !0)
                        },
                        resume: function() {
                            if (a.paused !== !1) {
                                a.paused = !1;
                                for (var t = 1; t <= a.concurrency; t++) a.process()
                            }
                        }
                    };
                return a
            }
            e.exports = {
                eachSeries: n,
                queue: o
            }
        }, {}],
        13: [function(t, e, r) {
            e.exports = {
                _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                encodeBinary: function(t) {
                    for (var e, r = "", i = new Array(4), n = 0, s = 0, o = 0; n < t.length;) {
                        for (e = new Array(3), s = 0; s < e.length; s++) n < t.length ? e[s] = 255 & t.charCodeAt(n++) : e[s] = 0;
                        switch (i[0] = e[0] >> 2, i[1] = (3 & e[0]) << 4 | e[1] >> 4, i[2] = (15 & e[1]) << 2 | e[2] >>
                            6, i[3] = 63 & e[2], o = n - (t.length - 1)) {
                            case 2:
                                i[3] = 64, i[2] = 64;
                                break;
                            case 1:
                                i[3] = 64
                        }
                        for (s = 0; s < i.length; s++) r += this._keyStr.charAt(i[s])
                    }
                    return r
                }
            }
        }, {}],
        14: [function(t, e, r) {
            e.exports = t("./Loader"), e.exports.Resource = t("./Resource"), e.exports.middleware = {
                caching: {
                    memory: t("./middlewares/caching/memory")
                },
                parsing: {
                    blob: t("./middlewares/parsing/blob")
                }
            }, e.exports.async = t("./async")
        }, {
            "./Loader": 10,
            "./Resource": 11,
            "./async": 12,
            "./middlewares/caching/memory": 15,
            "./middlewares/parsing/blob": 16
        }],
        15: [function(t,
            e, r) {
            var i = {};
            e.exports = function() {
                return function(t, e) {
                    i[t.url] ? (t.data = i[t.url], t.complete()) : t.once("complete", function() {
                        i[this.url] = this.data
                    }), e()
                }
            }
        }, {}],
        16: [function(t, e, r) {
            var i = t("../../Resource"),
                n = t("../../b64"),
                s = window.URL || window.webkitURL;
            e.exports = function() {
                return function(t, e) {
                    if (!t.data) return void e();
                    if (t.xhr && t.xhrType === i.XHR_RESPONSE_TYPE.BLOB)
                        if (window.Blob && "string" != typeof t.data) {
                            if (0 === t.data.type.indexOf("image")) {
                                var r = s.createObjectURL(t.data);
                                return t.blob = t.data,
                                    t.data = new Image, t.data.src = r, t.isImage = !0, void(t.data.onload = function() {
                                        s.revokeObjectURL(r), t.data.onload = null, e()
                                    })
                            }
                        } else {
                            var o = t.xhr.getResponseHeader("content-type");
                            if (o && 0 === o.indexOf("image")) return t.data = new Image, t.data.src = "data:" + o + ";base64," + n.encodeBinary(t.xhr.responseText), t.isImage = !0, void(t.data.onload = function() {
                                t.data.onload = null, e()
                            })
                        }
                    e()
                }
            }
        }, {
            "../../Resource": 11,
            "../../b64": 13
        }],
        17: [function(t, e, r) {
            e.exports = {
                name: "pixi.js",
                version: "3.0.2",
                description: "Pixi.js is a fast lightweight 2D library that works across all devices.",
                author: "Mat Groves",
                contributors: ["Chad Engler <chad@pantherdev.com>", "Richard Davey <rdavey@gmail.com>"],
                main: "./src/index.js",
                homepage: "http://goodboydigital.com/",
                bugs: "https://github.com/GoodBoyDigital/pixi.js/issues",
                license: "MIT",
                repository: {
                    type: "git",
                    url: "https://github.com/GoodBoyDigital/pixi.js.git"
                },
                scripts: {
                    test: "gulp && testem ci",
                    docs: "jsdoc -c ./gulp/util/jsdoc.conf.json -R README.md"
                },
                dependencies: {
                    async: "^0.9.0",
                    brfs: "^1.4.0",
                    eventemitter3: "^1.0.1",
                    "object-assign": "^2.0.0",
                    "resource-loader": "^1.5.2"
                },
                devDependencies: {
                    browserify: "^9.0.8",
                    chai: "^2.2.0",
                    del: "^1.1.1",
                    gulp: "^3.8.11",
                    "gulp-cached": "^1.0.4",
                    "gulp-concat": "^2.5.2",
                    "gulp-debug": "^2.0.1",
                    "gulp-jshint": "^1.10.0",
                    "gulp-mirror": "^0.4.0",
                    "gulp-plumber": "^1.0.0",
                    "gulp-rename": "^1.2.2",
                    "gulp-sourcemaps": "^1.5.2",
                    "gulp-uglify": "^1.2.0",
                    "gulp-util": "^3.0.4",
                    "ink-docstrap": "git+https://github.com/Pilatch/docstrap.git",
                    jsdoc: "^3.3.0-beta3",
                    "jshint-summary": "^0.4.0",
                    minimist: "^1.1.1",
                    mocha: "^2.2.4",
                    "require-dir": "^0.3.0",
                    "run-sequence": "^1.0.2",
                    testem: "^0.8.2",
                    "vinyl-buffer": "^1.0.0",
                    "vinyl-source-stream": "^1.1.0",
                    watchify: "^3.1.2"
                },
                browserify: {
                    transform: ["brfs"]
                }
            }
        }, {}],
        18: [function(t, e, r) {
            e.exports = {
                VERSION: t("../../package.json").version,
                PI_2: 2 * Math.PI,
                RAD_TO_DEG: 180 / Math.PI,
                DEG_TO_RAD: Math.PI / 180,
                TARGET_FPMS: .06,
                RENDERER_TYPE: {
                    UNKNOWN: 0,
                    WEBGL: 1,
                    CANVAS: 2
                },
                BLEND_MODES: {
                    NORMAL: 0,
                    ADD: 1,
                    MULTIPLY: 2,
                    SCREEN: 3,
                    OVERLAY: 4,
                    DARKEN: 5,
                    LIGHTEN: 6,
                    COLOR_DODGE: 7,
                    COLOR_BURN: 8,
                    HARD_LIGHT: 9,
                    SOFT_LIGHT: 10,
                    DIFFERENCE: 11,
                    EXCLUSION: 12,
                    HUE: 13,
                    SATURATION: 14,
                    COLOR: 15,
                    LUMINOSITY: 16,
                    SOURCE_OUT: 17,
                    SOURCE_IN: 18,
                    DESTINATION_OUT: 19,
                    DESTINATION_IN: 20
                },
                SCALE_MODES: {
                    DEFAULT: 0,
                    LINEAR: 0,
                    NEAREST: 1
                },
                RETINA_PREFIX: /@(.+)x/,
                RESOLUTION: 1,
                FILTER_RESOLUTION: 1,
                DEFAULT_RENDER_OPTIONS: {
                    view: null,
                    resolution: 1,
                    antialias: !1,
                    forceFXAA: !1,
                    autoResize: !1,
                    transparent: !1,
                    backgroundColor: 0,
                    clearBeforeRender: !0,
                    preserveDrawingBuffer: !1
                },
                SHAPES: {
                    POLY: 0,
                    RECT: 1,
                    CIRC: 2,
                    ELIP: 3,
                    RREC: 4
                },
                SPRITE_BATCH_SIZE: 2E3
            }
        }, {
            "../../package.json": 17
        }],
        19: [function(t, e, r) {
            function i() {
                s.call(this), this.children = []
            }
            var n = t("../math"),
                s = t("./DisplayObject"),
                o = t("../textures/RenderTexture"),
                a = new n.Matrix;
            i.prototype = Object.create(s.prototype), i.prototype.constructor = i, e.exports = i, Object.defineProperties(i.prototype, {
                width: {
                    get: function() {
                        return this.scale.x * this.getLocalBounds().width
                    },
                    set: function(t) {
                        var e = this.getLocalBounds().width;
                        0 !== e ? this.scale.x = t / e : this.scale.x = 1, this._width = t
                    }
                },
                height: {
                    get: function() {
                        return this.scale.y * this.getLocalBounds().height
                    },
                    set: function(t) {
                        var e = this.getLocalBounds().height;
                        0 !== e ? this.scale.y =
                            t / e : this.scale.y = 1, this._height = t
                    }
                }
            }), i.prototype.addChild = function(t) {
                return this.addChildAt(t, this.children.length)
            }, i.prototype.addChildAt = function(t, e) {
                if (t === this) return t;
                if (e >= 0 && e <= this.children.length) return t.parent && t.parent.removeChild(t), t.parent = this, this.children.splice(e, 0, t), t;
                throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length);
            }, i.prototype.swapChildren = function(t, e) {
                if (t !== e) {
                    var r = this.getChildIndex(t),
                        i = this.getChildIndex(e);
                    if (r < 0 ||
                        i < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be children of the caller.");
                    this.children[r] = e, this.children[i] = t
                }
            }, i.prototype.getChildIndex = function(t) {
                var e = this.children.indexOf(t);
                if (e === -1) throw new Error("The supplied DisplayObject must be a child of the caller");
                return e
            }, i.prototype.setChildIndex = function(t, e) {
                if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
                var r = this.getChildIndex(t);
                this.children.splice(r, 1), this.children.splice(e,
                    0, t)
            }, i.prototype.getChildAt = function(t) {
                if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject is not a child of the caller");
                return this.children[t]
            }, i.prototype.removeChild = function(t) {
                var e = this.children.indexOf(t);
                if (e !== -1) return this.removeChildAt(e)
            }, i.prototype.removeChildAt = function(t) {
                var e = this.getChildAt(t);
                return e.parent = null, this.children.splice(t, 1), e
            }, i.prototype.removeChildren = function(t,
                e) {
                var r = t || 0,
                    i = "number" == typeof e ? e : this.children.length,
                    n = i - r;
                if (n > 0 && n <= i) {
                    for (var s = this.children.splice(r, n), o = 0; o < s.length; ++o) s[o].parent = null;
                    return s
                }
                if (0 === n && 0 === this.children.length) return [];
                throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
            }, i.prototype.generateTexture = function(t, e, r) {
                var i = this.getLocalBounds(),
                    n = new o(t, 0 | i.width, 0 | i.height, t, r, e);
                return a.tx = -i.x, a.ty = -i.y, n.render(this, a), n
            }, i.prototype.updateTransform = function() {
                if (this.visible) {
                    if (0 !=
                        this.dirtyWT && (this.displayObjectUpdateTransform(), this.dirtyWT = !0), 0 != this.dirtyChildren || 0 != this.dirtyWT)
                        for (var t = 0, e = this.children.length; t < e; ++t) 1 == this.dirtyWT && (this.children[t].dirtyWT = !0), this.children[t].updateTransform();
                    this.dirtyWT = !1, this.dirtyChildren = !1
                }
            }, i.prototype.containerUpdateTransform = i.prototype.updateTransform, i.prototype.getBounds = function() {
                if (!this._currentBounds) {
                    if (0 === this.children.length) return n.Rectangle.EMPTY;
                    for (var t, e, r, i = 1 / 0, s = 1 / 0, o = -(1 / 0), a = -(1 / 0), h = !1, u = 0,
                            l = this.children.length; u < l; ++u) {
                        var c = this.children[u];
                        c.visible && (h = !0, t = this.children[u].getBounds(), i = i < t.x ? i : t.x, s = s < t.y ? s : t.y, e = t.width + t.x, r = t.height + t.y, o = o > e ? o : e, a = a > r ? a : r)
                    }
                    if (!h) return n.Rectangle.EMPTY;
                    var d = this._bounds;
                    d.x = i, d.y = s, d.width = o - i, d.height = a - s, this._currentBounds = d
                }
                return this._currentBounds
            }, i.prototype.containerGetBounds = i.prototype.getBounds, i.prototype.getLocalBounds = function() {
                var t = this.worldTransform;
                this.worldTransform = n.Matrix.IDENTITY;
                for (var e = 0, r = this.children.length; e <
                    r; ++e) this.children[e].updateTransform();
                return this.worldTransform = t, this._currentBounds = null, this.getBounds(n.Matrix.IDENTITY)
            }, i.prototype.renderWebGL = function(t) {
                if (this.visible && !(this.worldAlpha <= 0) && this.renderable) {
                    var e, r;
                    if (this._mask || this._filters) {
                        for (t.currentRenderer.flush(), this._filters && t.filterManager.pushFilter(this, this._filters), this._mask && t.maskManager.pushMask(this, this._mask), t.currentRenderer.start(), this._renderWebGL(t), e = 0, r = this.children.length; e < r; e++) this.children[e].renderWebGL(t);
                        t.currentRenderer.flush(), this._mask && t.maskManager.popMask(this, this._mask), this._filters && t.filterManager.popFilter(), t.currentRenderer.start()
                    } else
                        for (this._renderWebGL(t), e = 0, r = this.children.length; e < r; ++e) this.children[e].renderWebGL(t)
                }
            }, i.prototype._renderWebGL = function(t) {}, i.prototype._renderCanvas = function(t) {}, i.prototype.renderCanvas = function(t) {
                if (this.visible && !(this.alpha <= 0) && this.renderable) {
                    this._mask && t.maskManager.pushMask(this._mask, t), this._renderCanvas(t);
                    for (var e = 0, r = this.children.length; e <
                        r; ++e) this.children[e].renderCanvas(t);
                    this._mask && t.maskManager.popMask(t)
                }
            }, i.prototype.destroy = function(t) {
                if (s.prototype.destroy.call(this), t)
                    for (var e = 0, r = this.children.length; e < r; ++e) this.children[e].destroy(t);
                this.removeChildren(), this.children = null
            }
        }, {
            "../math": 29,
            "../textures/RenderTexture": 67,
            "./DisplayObject": 20
        }],
        20: [function(t, e, r) {
            function i() {
                o.call(this), this.position = new n.Point, this.scale = new n.Point(1, 1), this.pivot = new n.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0,
                    this.renderable = !0, this.parent = null, this.worldAlpha = 1, this.worldTransform = new n.Matrix, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new n.Rectangle(0, 0, 1, 1), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cachedObject = null
            }
            var n = t("../math"),
                s = t("../textures/RenderTexture"),
                o = t("eventemitter3"),
                a = t("../const"),
                h = new n.Matrix;
            i.prototype = Object.create(o.prototype), i.prototype.constructor = i, e.exports = i, Object.defineProperties(i.prototype, {
                    x: {
                        get: function() {
                            return this.position.x
                        },
                        set: function(t) {
                            this.position.x = t
                        }
                    },
                    y: {
                        get: function() {
                            return this.position.y
                        },
                        set: function(t) {
                            this.position.y = t
                        }
                    },
                    worldVisible: {
                        get: function() {
                            var t = this;
                            do {
                                if (!t.visible) return !1;
                                t = t.parent
                            } while (t);
                            return !0
                        }
                    },
                    mask: {
                        get: function() {
                            return this._mask
                        },
                        set: function(t) {
                            this._mask && (this._mask.renderable = !0), this._mask = t, this._mask && (this._mask.renderable = !1)
                        }
                    },
                    filters: {
                        get: function() {
                            return this._filters && this._filters.slice()
                        },
                        set: function(t) {
                            this._filters = t && t.slice()
                        }
                    }
                }), i.prototype.updateTransform =
                function() {
                    if (0 != this.dirtyWT) {
                        var t, e, r, i, n, s, o = this.parent.worldTransform,
                            h = this.worldTransform;
                        this.rotation % a.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), t = this._cr * this.scale.x, e = this._sr * this.scale.x, r = -this._sr * this.scale.y, i = this._cr * this.scale.y, n = this.position.x, s = this.position.y, (this.pivot.x || this.pivot.y) && (n -= this.pivot.x * t + this.pivot.y * r, s -= this.pivot.x * e + this.pivot.y * i), h.a = t * o.a + e * o.c,
                            h.b = t * o.b + e * o.d, h.c = r * o.a + i * o.c, h.d = r * o.b + i * o.d, h.tx = n * o.a + s * o.c + o.tx, h.ty = n * o.b + s * o.d + o.ty) : (t = this.scale.x, i = this.scale.y, n = this.position.x - this.pivot.x * t, s = this.position.y - this.pivot.y * i, h.a = t * o.a, h.b = t * o.b, h.c = i * o.c, h.d = i * o.d, h.tx = n * o.a + s * o.c + o.tx, h.ty = n * o.b + s * o.d + o.ty), this.worldAlpha = this.alpha * this.parent.worldAlpha, this._currentBounds = null, this.dirtyWT = !1
                    }
                }, i.prototype.displayObjectUpdateTransform = i.prototype.updateTransform, i.prototype.getBounds = function(t) {
                    return n.Rectangle.EMPTY
                }, i.prototype.getLocalBounds =
                function() {
                    return this.getBounds(n.Matrix.IDENTITY)
                }, i.prototype.toGlobal = function(t) {
                    return this.displayObjectUpdateTransform(), this.worldTransform.apply(t)
                }, i.prototype.toLocal = function(t, e) {
                    return e && (t = e.toGlobal(t)), this.displayObjectUpdateTransform(), this.worldTransform.applyInverse(t)
                }, i.prototype.renderWebGL = function(t) {}, i.prototype.renderCanvas = function(t) {}, i.prototype.generateTexture = function(t, e, r) {
                    var i = this.getLocalBounds(),
                        n = new s(t, 0 | i.width, 0 | i.height, t, r, e);
                    return h.tx = -i.x, h.ty = -i.y, n.render(this, h), n
                }, i.prototype.destroy = function() {
                    this.position = null, this.scale = null, this.pivot = null, this.parent = null, this._bounds = null, this._currentBounds = null, this._mask = null, this.worldTransform = null, this.filterArea = null
                }
        }, {
            "../const": 18,
            "../math": 29,
            "../textures/RenderTexture": 67,
            eventemitter3: 6
        }],
        21: [function(t, e, r) {
            function i() {
                n.call(this), this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this._prevTint = 16777215, this.blendMode = c.BLEND_MODES.NORMAL,
                    this.currentPath = null, this._webGL = {}, this.isMask = !1, this.boundsPadding = 0, this._localBounds = new l.Rectangle(0, 0, 1, 1), this.dirty = !0, this.glDirty = !1, this.boundsDirty = !0, this.cachedSpriteDirty = !1
            }
            var n = t("../display/Container"),
                s = t("../sprites/Sprite"),
                o = t("../textures/Texture"),
                a = t("../renderers/canvas/utils/CanvasBuffer"),
                h = t("../renderers/canvas/utils/CanvasGraphics"),
                u = t("./GraphicsData"),
                l = t("../math"),
                c = t("../const"),
                d = new l.Point;
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i,
                e.exports = i, Object.defineProperties(i.prototype, {}), i.prototype.clone = function() {
                    var t = new i;
                    t.renderable = this.renderable, t.fillAlpha = this.fillAlpha, t.lineWidth = this.lineWidth, t.lineColor = this.lineColor, t.tint = this.tint, t.blendMode = this.blendMode, t.isMask = this.isMask, t.boundsPadding = this.boundsPadding, t.dirty = this.dirty, t.glDirty = this.glDirty, t.cachedSpriteDirty = this.cachedSpriteDirty;
                    for (var e = 0; e < this.graphicsData.length; ++e) t.graphicsData.push(this.graphicsData[e].clone());
                    return t.currentPath =
                        t.graphicsData[t.graphicsData.length - 1], t.updateLocalBounds(), t
                }, i.prototype.lineStyle = function(t, e, r) {
                    return this.lineWidth = t || 0, this.lineColor = e || 0, this.lineAlpha = void 0 === r ? 1 : r, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new l.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this
                }, i.prototype.moveTo = function(t, e) {
                    return this.drawShape(new l.Polygon([t,
                        e
                    ])), this
                }, i.prototype.lineTo = function(t, e) {
                    return this.currentPath.shape.points.push(t, e), this.dirty = !0, this
                }, i.prototype.quadraticCurveTo = function(t, e, r, i) {
                    this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
                    var n, s, o = 20,
                        a = this.currentPath.shape.points;
                    0 === a.length && this.moveTo(0, 0);
                    for (var h = a[a.length - 2], u = a[a.length - 1], l = 0, c = 1; c <= o; ++c) l = c / o, n = h + (t - h) * l, s = u + (e - u) * l, a.push(n + (t + (r - t) * l - n) * l, s + (e + (i - e) * l - s) * l);
                    return this.dirty = this.boundsDirty = !0, this
                }, i.prototype.bezierCurveTo = function(t, e, r, i, n, s) {
                    this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
                    for (var o, a, h, u, l, c = 20, d = this.currentPath.shape.points, p = d[d.length - 2], f = d[d.length - 1], g = 0, v = 1; v <= c; ++v) g = v / c, o = 1 - g, a = o * o, h = a * o, u = g * g, l = u * g, d.push(h * p + 3 * a * g * t + 3 * o * u * r + l * n, h * f + 3 * a * g * e + 3 * o * u * i + l * s);
                    return this.dirty = this.boundsDirty = !0, this
                }, i.prototype.arcTo = function(t, e, r, i, n) {
                    this.currentPath ? 0 === this.currentPath.shape.points.length &&
                        this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
                    var s = this.currentPath.shape.points,
                        o = s[s.length - 2],
                        a = s[s.length - 1],
                        h = a - e,
                        u = o - t,
                        l = i - e,
                        c = r - t,
                        d = Math.abs(h * c - u * l);
                    if (d < 1E-8 || 0 === n) s[s.length - 2] === t && s[s.length - 1] === e || s.push(t, e);
                    else {
                        var p = h * h + u * u,
                            f = l * l + c * c,
                            g = h * l + u * c,
                            v = n * Math.sqrt(p) / d,
                            y = n * Math.sqrt(f) / d,
                            m = v * g / p,
                            x = y * g / f,
                            _ = v * c + y * u,
                            E = v * l + y * h,
                            b = u * (y + m),
                            T = h * (y + m),
                            S = c * (v + x),
                            w = l * (v + x),
                            R = Math.atan2(T - E, b - _),
                            A = Math.atan2(w - E, S - _);
                        this.arc(_ + t, E + e, n, R, A, u * l > c * h)
                    }
                    return this.dirty = this.boundsDirty = !0,
                        this
                }, i.prototype.arc = function(t, e, r, i, n, s) {
                    if (s = s || !1, i === n) return this;
                    !s && n <= i ? n += 2 * Math.PI : s && i <= n && (i += 2 * Math.PI);
                    var o = s ? (i - n) * -1 : n - i,
                        a = 40 * Math.ceil(Math.abs(o) / (2 * Math.PI));
                    if (0 === o) return this;
                    var h = t + Math.cos(i) * r,
                        u = e + Math.sin(i) * r;
                    this.currentPath ? s && this.filling ? this.currentPath.shape.points.push(t, e) : this.currentPath.shape.points.push(h, u) : s && this.filling ? this.moveTo(t, e) : this.moveTo(h, u);
                    for (var l = this.currentPath.shape.points, c = o / (2 * a), d = 2 * c, p = Math.cos(c), f = Math.sin(c), g = a - 1, v = g % 1 / g,
                            y = 0; y <= g; y++) {
                        var m = y + v * y,
                            x = c + i + d * m,
                            _ = Math.cos(x),
                            E = -Math.sin(x);
                        l.push((p * _ + f * E) * r + t, (p * -E + f * _) * r + e)
                    }
                    return this.dirty = this.boundsDirty = !0, this
                }, i.prototype.beginFill = function(t, e) {
                    return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = void 0 === e ? 1 : e, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this
                }, i.prototype.endFill = function() {
                    return this.filling = !1, this.fillColor =
                        null, this.fillAlpha = 1, this
                }, i.prototype.drawRect = function(t, e, r, i) {
                    return this.drawShape(new l.Rectangle(t, e, r, i)), this
                }, i.prototype.drawRoundedRect = function(t, e, r, i, n) {
                    return this.drawShape(new l.RoundedRectangle(t, e, r, i, n)), this
                }, i.prototype.drawCircle = function(t, e, r) {
                    return this.drawShape(new l.Circle(t, e, r)), this
                }, i.prototype.drawEllipse = function(t, e, r, i) {
                    return this.drawShape(new l.Ellipse(t, e, r, i)), this
                }, i.prototype.drawPolygon = function(t) {
                    var e = t;
                    if (!Array.isArray(e)) {
                        e = new Array(arguments.length);
                        for (var r = 0; r < e.length; ++r) e[r] = arguments[r]
                    }
                    return this.drawShape(new l.Polygon(e)), this
                }, i.prototype.clear = function() {
                    return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this.clearDirty = !0, this.graphicsData = [], this
                }, i.prototype.generateTexture = function(t, e, r) {
                    e = e || 1;
                    var i = this.getLocalBounds(),
                        n = new a(i.width * e, i.height * e),
                        s = o.fromCanvas(n.canvas, r);
                    return s.baseTexture.resolution = e, n.context.scale(e, e), n.context.translate(-i.x, -i.y), h.renderGraphics(this, n.context), s
                }, i.prototype._renderWebGL =
                function(t) {
                    this.glDirty && (this.dirty = !0, this.glDirty = !1), t.setObjectRenderer(t.plugins.graphics), t.plugins.graphics.render(this)
                }, i.prototype._renderCanvas = function(t) {
                    if (this.isMask !== !0) {
                        if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void s.prototype._renderCanvas.call(this._cachedSprite,
                            t);
                        var e = t.context,
                            r = this.worldTransform;
                        this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = t.blendModes[t.currentBlendMode]);
                        var i = t.resolution;
                        e.setTransform(r.a * i, r.b * i, r.c * i, r.d * i, r.tx * i, r.ty * i), h.renderGraphics(this, e)
                    }
                }, i.prototype.getBounds = function(t) {
                    if (!this._currentBounds) {
                        if (!this.renderable) return l.Rectangle.EMPTY;
                        this.boundsDirty && (this.updateLocalBounds(), this.glDirty = !0, this.cachedSpriteDirty = !0, this.boundsDirty = !1);
                        var e = this._localBounds,
                            r = e.x,
                            i = e.width + e.x,
                            n = e.y,
                            s = e.height + e.y,
                            o = t || this.worldTransform,
                            a = o.a,
                            h = o.b,
                            u = o.c,
                            c = o.d,
                            d = o.tx,
                            p = o.ty,
                            f = a * i + u * s + d,
                            g = c * s + h * i + p,
                            v = a * r + u * s + d,
                            y = c * s + h * r + p,
                            m = a * r + u * n + d,
                            x = c * n + h * r + p,
                            _ = a * i + u * n + d,
                            E = c * n + h * i + p,
                            b = f,
                            T = g,
                            S = f,
                            w = g;
                        S = v < S ? v : S, S = m < S ? m : S, S = _ < S ? _ : S, w = y < w ? y : w, w = x < w ? x : w, w = E < w ? E : w, b = v > b ? v : b, b = m > b ? m : b, b = _ > b ? _ : b, T = y > T ? y : T, T = x > T ? x : T, T = E > T ? E : T, this._bounds.x = S, this._bounds.width = b - S, this._bounds.y = w, this._bounds.height = T - w, this._currentBounds = this._bounds
                    }
                    return this._currentBounds
                }, i.prototype.containsPoint =
                function(t) {
                    this.worldTransform.applyInverse(t, d);
                    for (var e = this.graphicsData, r = 0; r < e.length; r++) {
                        var i = e[r];
                        if (i.fill && i.shape && i.shape.contains(d.x, d.y)) return !0
                    }
                    return !1
                }, i.prototype.updateLocalBounds = function() {
                    var t = 1 / 0,
                        e = -(1 / 0),
                        r = 1 / 0,
                        i = -(1 / 0);
                    if (this.graphicsData.length)
                        for (var n, s, o, a, h, u, l = 0; l < this.graphicsData.length; l++) {
                            var d = this.graphicsData[l],
                                p = d.type,
                                f = d.lineWidth;
                            if (n = d.shape, p === c.SHAPES.RECT || p === c.SHAPES.RREC) o = n.x - f / 2, a = n.y - f / 2, h = n.width + f, u = n.height + f, t = o < t ? o : t, e = o + h > e ? o + h : e,
                                r = a < r ? a : r, i = a + u > i ? a + u : i;
                            else if (p === c.SHAPES.CIRC) o = n.x, a = n.y, h = n.radius + f / 2, u = n.radius + f / 2, t = o - h < t ? o - h : t, e = o + h > e ? o + h : e, r = a - u < r ? a - u : r, i = a + u > i ? a + u : i;
                            else if (p === c.SHAPES.ELIP) o = n.x, a = n.y, h = n.width + f / 2, u = n.height + f / 2, t = o - h < t ? o - h : t, e = o + h > e ? o + h : e, r = a - u < r ? a - u : r, i = a + u > i ? a + u : i;
                            else {
                                s = n.points;
                                for (var g = 0; g < s.length; g += 2) o = s[g], a = s[g + 1], t = o - f < t ? o - f : t, e = o + f > e ? o + f : e, r = a - f < r ? a - f : r, i = a + f > i ? a + f : i
                            }
                        } else t = 0, e = 0, r = 0, i = 0;
                    var v = this.boundsPadding;
                    this._localBounds.x = t - v, this._localBounds.width = e - t + 2 * v, this._localBounds.y =
                        r - v, this._localBounds.height = i - r + 2 * v
                }, i.prototype.drawShape = function(t) {
                    this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null;
                    var e = new u(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, t);
                    return this.graphicsData.push(e), e.type === c.SHAPES.POLY && (e.shape.closed = this.filling, this.currentPath = e), this.dirty = this.boundsDirty = !0, e
                }, i.prototype.destroy = function() {
                    n.prototype.destroy.apply(this, arguments);
                    for (var t =
                            0; t < this.graphicsData.length; ++t) this.graphicsData[t].destroy();
                    for (var e in this._webgl)
                        for (var r = 0; r < this._webgl[e].data.length; ++r) this._webgl[e].data[r].destroy();
                    this.graphicsData = null, this.currentPath = null, this._webgl = null, this._localBounds = null
                }
        }, {
            "../const": 18,
            "../display/Container": 19,
            "../math": 29,
            "../renderers/canvas/utils/CanvasBuffer": 41,
            "../renderers/canvas/utils/CanvasGraphics": 42,
            "../sprites/Sprite": 63,
            "../textures/Texture": 68,
            "./GraphicsData": 22
        }],
        22: [function(t, e, r) {
            function i(t,
                e, r, i, n, s, o) {
                this.lineWidth = t, this.lineColor = e, this.lineAlpha = r, this._lineTint = e, this.fillColor = i, this.fillAlpha = n, this._fillTint = i, this.fill = s, this.shape = o, this.type = o.type
            }
            i.prototype.constructor = i, e.exports = i, i.prototype.clone = function() {
                return new i(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
            }, i.prototype.destroy = function() {
                this.shape = null
            }
        }, {}],
        23: [function(t, e, r) {
            function i(t) {
                a.call(this, t), this.graphicsDataPool = [], this.primitiveShader = null,
                    this.complexPrimitiveShader = null
            }
            var n = t("../../utils"),
                s = t("../../math"),
                o = t("../../const"),
                a = t("../../renderers/webgl/utils/ObjectRenderer"),
                h = t("../../renderers/webgl/WebGLRenderer"),
                u = t("./WebGLGraphicsData");
            i.prototype = Object.create(a.prototype), i.prototype.constructor = i, e.exports = i, h.registerPlugin("graphics", i), i.prototype.onContextChange = function() {}, i.prototype.destroy = function() {
                a.prototype.destroy.call(this);
                for (var t = 0; t < this.graphicsDataPool.length; ++t) this.graphicsDataPool[t].destroy();
                this.graphicsDataPool = null
            }, i.prototype.render = function(t) {
                var e, r = this.renderer,
                    i = r.gl,
                    s = r.shaderManager.plugins.primitiveShader;
                t.dirty && this.updateGraphics(t, i);
                var o = t._webGL[i.id];
                r.blendModeManager.setBlendMode(t.blendMode);
                for (var a = 0; a < o.data.length; a++) 1 === o.data[a].mode ? (e = o.data[a], r.stencilManager.pushStencil(t, e, r), i.drawElements(i.TRIANGLE_FAN, 4, i.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), r.stencilManager.popStencil(t, e, r)) : (e = o.data[a], s = r.shaderManager.primitiveShader, r.shaderManager.setShader(s),
                    i.uniformMatrix3fv(s.uniforms.translationMatrix._location, !1, t.worldTransform.toArray(!0)), i.uniformMatrix3fv(s.uniforms.projectionMatrix._location, !1, r.currentRenderTarget.projectionMatrix.toArray(!0)), i.uniform3fv(s.uniforms.tint._location, n.hex2rgb(t.tint)), i.uniform1f(s.uniforms.alpha._location, t.worldAlpha), i.bindBuffer(i.ARRAY_BUFFER, e.buffer), i.vertexAttribPointer(s.attributes.aVertexPosition, 2, i.FLOAT, !1, 24, 0), i.vertexAttribPointer(s.attributes.aColor, 4, i.FLOAT, !1, 24, 8), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,
                        e.indexBuffer), i.drawElements(i.TRIANGLE_STRIP, e.indices.length, i.UNSIGNED_SHORT, 0))
            }, i.prototype.updateGraphics = function(t) {
                var e = this.renderer.gl,
                    r = t._webGL[e.id];
                r || (r = t._webGL[e.id] = {
                    lastIndex: 0,
                    data: [],
                    gl: e
                }), t.dirty = !1;
                var i;
                if (t.clearDirty) {
                    for (t.clearDirty = !1, i = 0; i < r.data.length; i++) {
                        var n = r.data[i];
                        n.reset(), this.graphicsDataPool.push(n)
                    }
                    r.data = [], r.lastIndex = 0
                }
                var s;
                for (i = r.lastIndex; i < t.graphicsData.length; i++) {
                    var a = t.graphicsData[i];
                    if (a.type === o.SHAPES.POLY) {
                        if (a.points = a.shape.points.slice(),
                            a.shape.closed && (a.points[0] === a.points[a.points.length - 2] && a.points[1] === a.points[a.points.length - 1] || a.points.push(a.points[0], a.points[1])), a.fill && a.points.length >= 6)
                            if (a.points.length < 12) {
                                s = this.switchMode(r, 0);
                                var h = this.buildPoly(a, s);
                                h || (s = this.switchMode(r, 1), this.buildComplexPoly(a, s))
                            } else s = this.switchMode(r, 1), this.buildComplexPoly(a, s);
                        a.lineWidth > 0 && (s = this.switchMode(r, 0), this.buildLine(a, s))
                    } else s = this.switchMode(r, 0), a.type === o.SHAPES.RECT ? this.buildRectangle(a, s) : a.type === o.SHAPES.CIRC ||
                        a.type === o.SHAPES.ELIP ? this.buildCircle(a, s) : a.type === o.SHAPES.RREC && this.buildRoundedRectangle(a, s);
                    r.lastIndex++
                }
                for (i = 0; i < r.data.length; i++) s = r.data[i], s.dirty && s.upload()
            }, i.prototype.switchMode = function(t, e) {
                var r;
                return t.data.length ? (r = t.data[t.data.length - 1], (r.points.length > 32E4 || r.mode !== e || 1 === e) && (r = this.graphicsDataPool.pop() || new u(t.gl), r.mode = e, t.data.push(r))) : (r = this.graphicsDataPool.pop() || new u(t.gl), r.mode = e, t.data.push(r)), r.dirty = !0, r
            }, i.prototype.buildRectangle = function(t,
                e) {
                var r = t.shape,
                    i = r.x,
                    s = r.y,
                    o = r.width,
                    a = r.height;
                if (t.fill) {
                    var h = n.hex2rgb(t.fillColor),
                        u = t.fillAlpha,
                        l = h[0] * u,
                        c = h[1] * u,
                        d = h[2] * u,
                        p = e.points,
                        f = e.indices,
                        g = p.length / 6;
                    p.push(i, s), p.push(l, c, d, u), p.push(i + o, s), p.push(l, c, d, u), p.push(i, s + a), p.push(l, c, d, u), p.push(i + o, s + a), p.push(l, c, d, u), f.push(g, g, g + 1, g + 2, g + 3, g + 3)
                }
                if (t.lineWidth) {
                    var v = t.points;
                    t.points = [i, s, i + o, s, i + o, s + a, i, s + a, i, s], this.buildLine(t, e), t.points = v
                }
            }, i.prototype.buildRoundedRectangle = function(t, e) {
                var r = t.shape,
                    i = r.x,
                    s = r.y,
                    o = r.width,
                    a = r.height,
                    h = r.radius,
                    u = [];
                if (u.push(i, s + h), this.quadraticBezierCurve(i, s + a - h, i, s + a, i + h, s + a, u), this.quadraticBezierCurve(i + o - h, s + a, i + o, s + a, i + o, s + a - h, u), this.quadraticBezierCurve(i + o, s + h, i + o, s, i + o - h, s, u), this.quadraticBezierCurve(i + h, s, i, s, i, s + h + 1E-10, u), t.fill) {
                    var l = n.hex2rgb(t.fillColor),
                        c = t.fillAlpha,
                        d = l[0] * c,
                        p = l[1] * c,
                        f = l[2] * c,
                        g = e.points,
                        v = e.indices,
                        y = g.length / 6,
                        m = n.PolyK.Triangulate(u),
                        x = 0;
                    for (x = 0; x < m.length; x += 3) v.push(m[x] + y), v.push(m[x] + y), v.push(m[x + 1] + y), v.push(m[x + 2] + y), v.push(m[x + 2] + y);
                    for (x = 0; x < u.length; x++) g.push(u[x], u[++x], d, p, f, c)
                }
                if (t.lineWidth) {
                    var _ = t.points;
                    t.points = u, this.buildLine(t, e), t.points = _
                }
            }, i.prototype.quadraticBezierCurve = function(t, e, r, i, n, s, o) {
                function a(t, e, r) {
                    var i = e - t;
                    return t + i * r
                }
                for (var h, u, l, c, d, p, f = 20, g = o || [], v = 0, y = 0; y <= f; y++) v = y / f, h = a(t, r, v), u = a(e, i, v), l = a(r, n, v), c = a(i, s, v), d = a(h, l, v), p = a(u, c, v), g.push(d, p);
                return g
            }, i.prototype.buildCircle = function(t, e) {
                var r, i, s = t.shape,
                    a = s.x,
                    h = s.y;
                t.type === o.SHAPES.CIRC ? (r = s.radius, i = s.radius) : (r = s.width, i = s.height);
                var u = 40,
                    l = 2 * Math.PI / u,
                    c = 0;
                if (t.fill) {
                    var d = n.hex2rgb(t.fillColor),
                        p = t.fillAlpha,
                        f = d[0] * p,
                        g = d[1] * p,
                        v = d[2] * p,
                        y = e.points,
                        m = e.indices,
                        x = y.length / 6;
                    for (m.push(x), c = 0; c < u + 1; c++) y.push(a, h, f, g, v, p), y.push(a + Math.sin(l * c) * r, h + Math.cos(l * c) * i, f, g, v, p), m.push(x++, x++);
                    m.push(x - 1)
                }
                if (t.lineWidth) {
                    var _ = t.points;
                    for (t.points = [], c = 0; c < u + 1; c++) t.points.push(a + Math.sin(l * c) * r, h + Math.cos(l * c) * i);
                    this.buildLine(t, e), t.points = _
                }
            }, i.prototype.buildLine = function(t, e) {
                var r = 0,
                    i = t.points;
                if (0 !== i.length) {
                    if (t.lineWidth %
                        2)
                        for (r = 0; r < i.length; r++) i[r] += .5;
                    var o = new s.Point(i[0], i[1]),
                        a = new s.Point(i[i.length - 2], i[i.length - 1]);
                    if (o.x === a.x && o.y === a.y) {
                        i = i.slice(), i.pop(), i.pop(), a = new s.Point(i[i.length - 2], i[i.length - 1]);
                        var h = a.x + .5 * (o.x - a.x),
                            u = a.y + .5 * (o.y - a.y);
                        i.unshift(h, u), i.push(h, u)
                    }
                    var l, c, d, p, f, g, v, y, m, x, _, E, b, T, S, w, R, A, M, C, O, P, D, L = e.points,
                        B = e.indices,
                        N = i.length / 2,
                        I = i.length,
                        F = L.length / 6,
                        U = t.lineWidth / 2,
                        k = n.hex2rgb(t.lineColor),
                        G = t.lineAlpha,
                        j = k[0] * G,
                        W = k[1] * G,
                        Y = k[2] * G;
                    for (d = i[0], p = i[1], f = i[2], g = i[3], m = -(p -
                            g), x = d - f, D = Math.sqrt(m * m + x * x), m /= D, x /= D, m *= U, x *= U, L.push(d - m, p - x, j, W, Y, G), L.push(d + m, p + x, j, W, Y, G), r = 1; r < N - 1; r++) d = i[2 * (r - 1)], p = i[2 * (r - 1) + 1], f = i[2 * r], g = i[2 * r + 1], v = i[2 * (r + 1)], y = i[2 * (r + 1) + 1], m = -(p - g), x = d - f, D = Math.sqrt(m * m + x * x), m /= D, x /= D, m *= U, x *= U, _ = -(g - y), E = f - v, D = Math.sqrt(_ * _ + E * E), _ /= D, E /= D, _ *= U, E *= U, S = -x + p - (-x + g), w = -m + f - (-m + d), R = (-m + d) * (-x + g) - (-m + f) * (-x + p), A = -E + y - (-E + g), M = -_ + f - (-_ + v), C = (-_ + v) * (-E + g) - (-_ + f) * (-E + y), O = S * M - A * w, Math.abs(O) < .1 ? (O += 10.1, L.push(f - m, g - x, j, W, Y, G), L.push(f + m, g + x, j, W, Y, G)) : (l =
                        (w * C - M * R) / O, c = (A * R - S * C) / O, P = (l - f) * (l - f) + (c - g) + (c - g), P > 19600 ? (b = m - _, T = x - E, D = Math.sqrt(b * b + T * T), b /= D, T /= D, b *= U, T *= U, L.push(f - b, g - T), L.push(j, W, Y, G), L.push(f + b, g + T), L.push(j, W, Y, G), L.push(f - b, g - T), L.push(j, W, Y, G), I++) : (L.push(l, c), L.push(j, W, Y, G), L.push(f - (l - f), g - (c - g)), L.push(j, W, Y, G)));
                    for (d = i[2 * (N - 2)], p = i[2 * (N - 2) + 1], f = i[2 * (N - 1)], g = i[2 * (N - 1) + 1], m = -(p - g), x = d - f, D = Math.sqrt(m * m + x * x), m /= D, x /= D, m *= U, x *= U, L.push(f - m, g - x), L.push(j, W, Y, G), L.push(f + m, g + x), L.push(j, W, Y, G), B.push(F), r = 0; r < I; r++) B.push(F++);
                    B.push(F -
                        1)
                }
            }, i.prototype.buildComplexPoly = function(t, e) {
                var r = t.points.slice();
                if (!(r.length < 6)) {
                    var i = e.indices;
                    e.points = r, e.alpha = t.fillAlpha, e.color = n.hex2rgb(t.fillColor);
                    for (var s, o, a = 1 / 0, h = -(1 / 0), u = 1 / 0, l = -(1 / 0), c = 0; c < r.length; c += 2) s = r[c], o = r[c + 1], a = s < a ? s : a, h = s > h ? s : h, u = o < u ? o : u, l = o > l ? o : l;
                    r.push(a, u, h, u, h, l, a, l);
                    var d = r.length / 2;
                    for (c = 0; c < d; c++) i.push(c)
                }
            }, i.prototype.buildPoly = function(t, e) {
                var r = t.points;
                if (!(r.length < 6)) {
                    var i = e.points,
                        s = e.indices,
                        o = r.length / 2,
                        a = n.hex2rgb(t.fillColor),
                        h = t.fillAlpha,
                        u = a[0] * h,
                        l = a[1] * h,
                        c = a[2] * h,
                        d = n.PolyK.Triangulate(r);
                    if (!d) return !1;
                    var p = i.length / 6,
                        f = 0;
                    for (f = 0; f < d.length; f += 3) s.push(d[f] + p), s.push(d[f] + p), s.push(d[f + 1] + p), s.push(d[f + 2] + p), s.push(d[f + 2] + p);
                    for (f = 0; f < o; f++) i.push(r[2 * f], r[2 * f + 1], u, l, c, h);
                    return !0
                }
            }
        }, {
            "../../const": 18,
            "../../math": 29,
            "../../renderers/webgl/WebGLRenderer": 45,
            "../../renderers/webgl/utils/ObjectRenderer": 59,
            "../../utils": 72,
            "./WebGLGraphicsData": 24
        }],
        24: [function(t, e, r) {
            function i(t) {
                this.gl = t, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0, this.glPoints = null, this.glIndices = null
            }
            i.prototype.constructor = i, e.exports = i, i.prototype.reset = function() {
                this.points.length = 0, this.indices.length = 0
            }, i.prototype.upload = function() {
                var t = this.gl;
                this.glPoints = new Float32Array(this.points), t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW), this.glIndices = new Uint16Array(this.indices), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,
                    this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndices, t.STATIC_DRAW), this.dirty = !1
            }, i.prototype.destroy = function() {
                this.gl = null, this.color = null, this.points = null, this.indices = null, this.gl.deleteBuffer(this.buffer), this.gl.deleteBuffer(this.indexBuffer), this.buffer = null, this.indexBuffer = null, this.glPoints = null, this.glIndices = null
            }
        }, {}],
        25: [function(t, e, r) {
            var i = e.exports = Object.assign(t("./const"), t("./math"), {
                utils: t("./utils"),
                math: t("./math"),
                DisplayObject: t("./display/DisplayObject"),
                Container: t("./display/Container"),
                Sprite: t("./sprites/Sprite"),
                ParticleContainer: t("./particles/ParticleContainer"),
                SpriteRenderer: t("./sprites/webgl/SpriteRenderer"),
                ParticleRenderer: t("./particles/webgl/ParticleRenderer"),
                Text: t("./text/Text"),
                Graphics: t("./graphics/Graphics"),
                GraphicsData: t("./graphics/GraphicsData"),
                GraphicsRenderer: t("./graphics/webgl/GraphicsRenderer"),
                Texture: t("./textures/Texture"),
                BaseTexture: t("./textures/BaseTexture"),
                RenderTexture: t("./textures/RenderTexture"),
                VideoBaseTexture: t("./textures/VideoBaseTexture"),
                TextureUvs: t("./textures/TextureUvs"),
                CanvasRenderer: t("./renderers/canvas/CanvasRenderer"),
                CanvasGraphics: t("./renderers/canvas/utils/CanvasGraphics"),
                CanvasBuffer: t("./renderers/canvas/utils/CanvasBuffer"),
                WebGLRenderer: t("./renderers/webgl/WebGLRenderer"),
                ShaderManager: t("./renderers/webgl/managers/ShaderManager"),
                Shader: t("./renderers/webgl/shaders/Shader"),
                ObjectRenderer: t("./renderers/webgl/utils/ObjectRenderer"),
                RenderTarget: t("./renderers/webgl/utils/RenderTarget"),
                AbstractFilter: t("./renderers/webgl/filters/AbstractFilter"),
                autoDetectRenderer: function(t, e, r, n) {
                    return t = t || 800, e = e || 600, !n && i.utils.isWebGLSupported() ? new i.WebGLRenderer(t, e, r) : new i.CanvasRenderer(t, e, r)
                }
            })
        }, {
            "./const": 18,
            "./display/Container": 19,
            "./display/DisplayObject": 20,
            "./graphics/Graphics": 21,
            "./graphics/GraphicsData": 22,
            "./graphics/webgl/GraphicsRenderer": 23,
            "./math": 29,
            "./particles/ParticleContainer": 35,
            "./particles/webgl/ParticleRenderer": 37,
            "./renderers/canvas/CanvasRenderer": 40,
            "./renderers/canvas/utils/CanvasBuffer": 41,
            "./renderers/canvas/utils/CanvasGraphics": 42,
            "./renderers/webgl/WebGLRenderer": 45,
            "./renderers/webgl/filters/AbstractFilter": 46,
            "./renderers/webgl/managers/ShaderManager": 52,
            "./renderers/webgl/shaders/Shader": 57,
            "./renderers/webgl/utils/ObjectRenderer": 59,
            "./renderers/webgl/utils/RenderTarget": 61,
            "./sprites/Sprite": 63,
            "./sprites/webgl/SpriteRenderer": 64,
            "./text/Text": 65,
            "./textures/BaseTexture": 66,
            "./textures/RenderTexture": 67,
            "./textures/Texture": 68,
            "./textures/TextureUvs": 69,
            "./textures/VideoBaseTexture": 70,
            "./utils": 72
        }],
        26: [function(t, e,
            r) {
            function i(t) {
                return t < 0 ? -1 : t > 0 ? 1 : 0
            }

            function n() {
                for (var t = 0; t < 16; t++) {
                    var e = [];
                    c.push(e);
                    for (var r = 0; r < 16; r++)
                        for (var n = i(s[t] * s[r] + a[t] * o[r]), d = i(o[t] * s[r] + h[t] * o[r]), p = i(s[t] * a[r] + a[t] * h[r]), f = i(o[t] * a[r] + h[t] * h[r]), g = 0; g < 16; g++)
                            if (s[g] === n && o[g] === d && a[g] === p && h[g] === f) {
                                e.push(g);
                                break
                            }
                }
                for (t = 0; t < 16; t++) {
                    var v = new l;
                    v.set(s[t], o[t], a[t], h[t], 0, 0), u.push(v)
                }
            }
            var s = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
                o = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
                a = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
                h = [1,
                    1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1
                ],
                u = [],
                l = t("./Matrix"),
                c = [];
            n();
            var d = {
                E: 0,
                SE: 1,
                S: 2,
                SW: 3,
                W: 4,
                NW: 5,
                N: 6,
                NE: 7,
                MIRROR_VERTICAL: 8,
                MIRROR_HORIZONTAL: 12,
                uX: function(t) {
                    return s[t]
                },
                uY: function(t) {
                    return o[t]
                },
                vX: function(t) {
                    return a[t]
                },
                vY: function(t) {
                    return h[t]
                },
                inv: function(t) {
                    return 8 & t ? 15 & t : 7 & -t
                },
                add: function(t, e) {
                    return c[t][e]
                },
                sub: function(t, e) {
                    return c[t][d.inv(e)]
                },
                rotate180: function(t) {
                    return 4 ^ t
                },
                isSwapWidthHeight: function(t) {
                    return 2 === (3 & t)
                },
                byDirection: function(t, e) {
                    return 2 * Math.abs(t) <=
                        Math.abs(e) ? e >= 0 ? d.S : d.N : 2 * Math.abs(e) <= Math.abs(t) ? t > 0 ? d.E : d.W : e > 0 ? t > 0 ? d.SE : d.SW : t > 0 ? d.NE : d.NW
                },
                matrixAppendRotationInv: function(t, e, r, i) {
                    var n = u[d.inv(e)];
                    r = r || 0, i = i || 0, n.tx = r, n.ty = i, t.append(n)
                }
            };
            e.exports = d
        }, {
            "./Matrix": 27
        }],
        27: [function(t, e, r) {
            function i() {
                this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0
            }
            var n = t("./Point");
            i.prototype.constructor = i, e.exports = i, i.prototype.fromArray = function(t) {
                this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5]
            }, i.prototype.set = function(t,
                e, r, i, n, s) {
                return this.a = t, this.b = e, this.c = r, this.d = i, this.tx = n, this.ty = s, this
            }, i.prototype.toArray = function(t) {
                this.array || (this.array = new Float32Array(9));
                var e = this.array;
                return t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty, e[8] = 1) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0, e[8] = 1), e
            }, i.prototype.apply = function(t, e) {
                e = e || new n;
                var r = t.x,
                    i = t.y;
                return e.x = this.a * r + this.c * i + this.tx, e.y = this.b * r + this.d * i + this.ty,
                    e
            }, i.prototype.applyInverse = function(t, e) {
                e = e || new n;
                var r = 1 / (this.a * this.d + this.c * -this.b),
                    i = t.x,
                    s = t.y;
                return e.x = this.d * r * i + -this.c * r * s + (this.ty * this.c - this.tx * this.d) * r, e.y = this.a * r * s + -this.b * r * i + (-this.ty * this.a + this.tx * this.b) * r, e
            }, i.prototype.translate = function(t, e) {
                return this.tx += t, this.ty += e, this
            }, i.prototype.scale = function(t, e) {
                return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
            }, i.prototype.rotate = function(t) {
                var e = Math.cos(t),
                    r = Math.sin(t),
                    i = this.a,
                    n = this.c,
                    s = this.tx;
                return this.a = i * e - this.b * r, this.b = i * r + this.b * e, this.c = n * e - this.d * r, this.d = n * r + this.d * e, this.tx = s * e - this.ty * r, this.ty = s * r + this.ty * e, this
            }, i.prototype.append = function(t) {
                var e = this.a,
                    r = this.b,
                    i = this.c,
                    n = this.d;
                return this.a = t.a * e + t.b * i, this.b = t.a * r + t.b * n, this.c = t.c * e + t.d * i, this.d = t.c * r + t.d * n, this.tx = t.tx * e + t.ty * i + this.tx, this.ty = t.tx * r + t.ty * n + this.ty, this
            }, i.prototype.prepend = function(t) {
                var e = this.tx;
                if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) {
                    var r = this.a,
                        i = this.c;
                    this.a = r * t.a + this.b * t.c, this.b = r * t.b +
                        this.b * t.d, this.c = i * t.a + this.d * t.c, this.d = i * t.b + this.d * t.d
                }
                return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this
            }, i.prototype.invert = function() {
                var t = this.a,
                    e = this.b,
                    r = this.c,
                    i = this.d,
                    n = this.tx,
                    s = t * i - e * r;
                return this.a = i / s, this.b = -e / s, this.c = -r / s, this.d = t / s, this.tx = (r * this.ty - i * n) / s, this.ty = -(t * this.ty - e * n) / s, this
            }, i.prototype.identity = function() {
                return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this
            }, i.prototype.clone = function() {
                var t = new i;
                return t.a = this.a, t.b = this.b,
                    t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
            }, i.prototype.copy = function(t) {
                return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
            }, i.IDENTITY = new i, i.TEMP_MATRIX = new i
        }, {
            "./Point": 28
        }],
        28: [function(t, e, r) {
            function i(t, e) {
                this.x = t || 0, this.y = e || 0
            }
            i.prototype.constructor = i, e.exports = i, i.prototype.clone = function() {
                return new i(this.x, this.y)
            }, i.prototype.copy = function(t) {
                this.set(t.x, t.y)
            }, i.prototype.equals = function(t) {
                return t.x === this.x && t.y === this.y
            }, i.prototype.set = function(t,
                e) {
                this.x = t || 0, this.y = e || (0 !== e ? this.x : 0)
            }
        }, {}],
        29: [function(t, e, r) {
            e.exports = {
                Point: t("./Point"),
                Matrix: t("./Matrix"),
                Circle: t("./shapes/Circle"),
                Ellipse: t("./shapes/Ellipse"),
                Polygon: t("./shapes/Polygon"),
                Rectangle: t("./shapes/Rectangle"),
                RoundedRectangle: t("./shapes/RoundedRectangle")
            }
        }, {
            "./Matrix": 27,
            "./Point": 28,
            "./shapes/Circle": 30,
            "./shapes/Ellipse": 31,
            "./shapes/Polygon": 32,
            "./shapes/Rectangle": 33,
            "./shapes/RoundedRectangle": 34
        }],
        30: [function(t, e, r) {
            function i(t, e, r) {
                this.x = t || 0, this.y = e ||
                    0, this.radius = r || 0, this.type = s.SHAPES.CIRC
            }
            var n = t("./Rectangle"),
                s = t("../../const");
            i.prototype.constructor = i, e.exports = i, i.prototype.clone = function() {
                return new i(this.x, this.y, this.radius)
            }, i.prototype.contains = function(t, e) {
                if (this.radius <= 0) return !1;
                var r = this.x - t,
                    i = this.y - e,
                    n = this.radius * this.radius;
                return r *= r, i *= i, r + i <= n
            }, i.prototype.getBounds = function() {
                return new n(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius)
            }
        }, {
            "../../const": 18,
            "./Rectangle": 33
        }],
        31: [function(t, e,
            r) {
            function i(t, e, r, i) {
                this.x = t || 0, this.y = e || 0, this.width = r || 0, this.height = i || 0, this.type = s.SHAPES.ELIP
            }
            var n = t("./Rectangle"),
                s = t("../../const");
            i.prototype.constructor = i, e.exports = i, i.prototype.clone = function() {
                return new i(this.x, this.y, this.width, this.height)
            }, i.prototype.contains = function(t, e) {
                if (this.width <= 0 || this.height <= 0) return !1;
                var r = (t - this.x) / this.width,
                    i = (e - this.y) / this.height;
                return r *= r, i *= i, r + i <= 1
            }, i.prototype.getBounds = function() {
                return new n(this.x - this.width, this.y - this.height,
                    this.width, this.height)
            }
        }, {
            "../../const": 18,
            "./Rectangle": 33
        }],
        32: [function(t, e, r) {
            function i(t) {
                var e = t;
                if (!Array.isArray(e)) {
                    e = new Array(arguments.length);
                    for (var r = 0; r < e.length; ++r) e[r] = arguments[r]
                }
                if (e[0] instanceof n) {
                    for (var i = [], o = 0, a = e.length; o < a; o++) i.push(e[o].x, e[o].y);
                    e = i
                }
                this.closed = !0, this.points = e, this.type = s.SHAPES.POLY
            }
            var n = t("../Point"),
                s = t("../../const");
            i.prototype.constructor = i, e.exports = i, i.prototype.clone = function() {
                return new i(this.points.slice())
            }, i.prototype.contains = function(t,
                e) {
                for (var r = !1, i = this.points.length / 2, n = 0, s = i - 1; n < i; s = n++) {
                    var o = this.points[2 * n],
                        a = this.points[2 * n + 1],
                        h = this.points[2 * s],
                        u = this.points[2 * s + 1],
                        l = a > e != u > e && t < (h - o) * (e - a) / (u - a) + o;
                    l && (r = !r)
                }
                return r
            }
        }, {
            "../../const": 18,
            "../Point": 28
        }],
        33: [function(t, e, r) {
            function i(t, e, r, i) {
                this.x = t || 0, this.y = e || 0, this.width = r || 0, this.height = i || 0, this.type = n.SHAPES.RECT
            }
            var n = t("../../const");
            i.prototype.constructor = i, e.exports = i, i.EMPTY = new i(0, 0, 0, 0), i.prototype.clone = function() {
                return new i(this.x, this.y, this.width,
                    this.height)
            }, i.prototype.contains = function(t, e) {
                return !(this.width <= 0 || this.height <= 0) && (t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height)
            }
        }, {
            "../../const": 18
        }],
        34: [function(t, e, r) {
            function i(t, e, r, i, s) {
                this.x = t || 0, this.y = e || 0, this.width = r || 0, this.height = i || 0, this.radius = s || 20, this.type = n.SHAPES.RREC
            }
            var n = t("../../const");
            i.prototype.constructor = i, e.exports = i, i.prototype.clone = function() {
                return new i(this.x, this.y, this.width, this.height, this.radius)
            }, i.prototype.contains = function(t,
                e) {
                return !(this.width <= 0 || this.height <= 0) && (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height)
            }
        }, {
            "../../const": 18
        }],
        35: [function(t, e, r) {
            function i(t, e) {
                n.call(this), this._properties = [!1, !0, !1, !1, !1], this._size = t || 15E3, this._buffers = null, this._updateStatic = !1, this.interactiveChildren = !1, this.blendMode = s.BLEND_MODES.NORMAL, this.roundPixels = !0, this.setProperties(e)
            }
            var n = t("../display/Container"),
                s = t("../const");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports =
                i, i.prototype.setProperties = function(t) {
                    t && (this._properties[0] = "scale" in t ? !!t.scale : this._properties[0], this._properties[1] = "position" in t ? !!t.position : this._properties[1], this._properties[2] = "rotation" in t ? !!t.rotation : this._properties[2], this._properties[3] = "uvs" in t ? !!t.uvs : this._properties[3], this._properties[4] = "alpha" in t ? !!t.alpha : this._properties[4])
                }, i.prototype.updateTransform = function() {
                    this.displayObjectUpdateTransform()
                }, i.prototype.renderWebGL = function(t) {
                    this.visible && !(this.worldAlpha <=
                        0) && this.children.length && this.renderable && (t.setObjectRenderer(t.plugins.particle), t.plugins.particle.render(this))
                }, i.prototype.addChildAt = function(t, e) {
                    if (t === this) return t;
                    if (e >= 0 && e <= this.children.length) return t.parent && t.parent.removeChild(t), t.parent = this, this.children.splice(e, 0, t), this._updateStatic = !0, t;
                    throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length);
                }, i.prototype.removeChildAt = function(t) {
                    var e = this.getChildAt(t);
                    return e.parent = null, this.children.splice(t,
                        1), this._updateStatic = !0, e
                }, i.prototype.renderCanvas = function(t) {
                    if (this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable) {
                        var e = t.context,
                            r = this.worldTransform,
                            i = !0,
                            n = 0,
                            s = 0,
                            o = 0,
                            a = 0;
                        e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
                        for (var h = 0; h < this.children.length; ++h) {
                            var u = this.children[h];
                            if (u.visible) {
                                var l = u.texture.frame;
                                if (e.globalAlpha = this.worldAlpha * u.alpha, u.rotation % (2 * Math.PI) === 0) i && (e.setTransform(r.a, r.b, r.c, r.d, r.tx, r.ty), i = !1), n = u.anchor.x *
                                    (-l.width * u.scale.x) + u.position.x + .5, s = u.anchor.y * (-l.height * u.scale.y) + u.position.y + .5, o = l.width * u.scale.x, a = l.height * u.scale.y;
                                else {
                                    i || (i = !0), u.displayObjectUpdateTransform();
                                    var c = u.worldTransform;
                                    t.roundPixels ? e.setTransform(c.a, c.b, c.c, c.d, 0 | c.tx, 0 | c.ty) : e.setTransform(c.a, c.b, c.c, c.d, c.tx, c.ty), n = u.anchor.x * -l.width + .5, s = u.anchor.y * -l.height + .5, o = l.width, a = l.height
                                }
                                e.drawImage(u.texture.baseTexture.source, l.x, l.y, l.width, l.height, n, s, o, a)
                            }
                        }
                    }
                }, i.prototype.destroy = function() {
                    if (n.prototype.destroy.apply(this,
                            arguments), this._buffers)
                        for (var t = 0; t < this._buffers.length; ++t) this._buffers.destroy();
                    this._properties = null, this._buffers = null
                }
        }, {
            "../const": 18,
            "../display/Container": 19
        }],
        36: [function(t, e, r) {
            function i(t, e, r) {
                this.gl = t, this.vertSize = 2, this.vertByteSize = 4 * this.vertSize, this.size = r, this.dynamicProperties = [], this.staticProperties = [];
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.dynamic ? this.dynamicProperties.push(n) : this.staticProperties.push(n)
                }
                this.staticStride = 0, this.staticBuffer = null, this.staticData =
                    null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.initBuffers()
            }
            i.prototype.constructor = i, e.exports = i, i.prototype.initBuffers = function() {
                var t, e, r = this.gl,
                    i = 0;
                for (this.dynamicStride = 0, t = 0; t < this.dynamicProperties.length; t++) e = this.dynamicProperties[t], e.offset = i, i += e.size, this.dynamicStride += e.size;
                this.dynamicData = new Float32Array(this.size * this.dynamicStride * 4), this.dynamicBuffer = r.createBuffer(), r.bindBuffer(r.ARRAY_BUFFER, this.dynamicBuffer), r.bufferData(r.ARRAY_BUFFER,
                    this.dynamicData, r.DYNAMIC_DRAW);
                var n = 0;
                for (this.staticStride = 0, t = 0; t < this.staticProperties.length; t++) e = this.staticProperties[t], e.offset = n, n += e.size, this.staticStride += e.size;
                this.staticData = new Float32Array(this.size * this.staticStride * 4), this.staticBuffer = r.createBuffer(), r.bindBuffer(r.ARRAY_BUFFER, this.staticBuffer), r.bufferData(r.ARRAY_BUFFER, this.staticData, r.DYNAMIC_DRAW)
            }, i.prototype.uploadDynamic = function(t, e, r) {
                for (var i = this.gl, n = 0; n < this.dynamicProperties.length; n++) {
                    var s = this.dynamicProperties[n];
                    s.uploadFunction(t, e, r, this.dynamicData, this.dynamicStride, s.offset)
                }
                i.bindBuffer(i.ARRAY_BUFFER, this.dynamicBuffer), i.bufferSubData(i.ARRAY_BUFFER, 0, this.dynamicData)
            }, i.prototype.uploadStatic = function(t, e, r) {
                for (var i = this.gl, n = 0; n < this.staticProperties.length; n++) {
                    var s = this.staticProperties[n];
                    s.uploadFunction(t, e, r, this.staticData, this.staticStride, s.offset)
                }
                i.bindBuffer(i.ARRAY_BUFFER, this.staticBuffer), i.bufferSubData(i.ARRAY_BUFFER, 0, this.staticData)
            }, i.prototype.bind = function() {
                var t, e, r =
                    this.gl;
                for (r.bindBuffer(r.ARRAY_BUFFER, this.dynamicBuffer), t = 0; t < this.dynamicProperties.length; t++) e = this.dynamicProperties[t], r.vertexAttribPointer(e.attribute, e.size, r.FLOAT, !1, 4 * this.dynamicStride, 4 * e.offset);
                for (r.bindBuffer(r.ARRAY_BUFFER, this.staticBuffer), t = 0; t < this.staticProperties.length; t++) e = this.staticProperties[t], r.vertexAttribPointer(e.attribute, e.size, r.FLOAT, !1, 4 * this.staticStride, 4 * e.offset)
            }, i.prototype.destroy = function() {
                this.dynamicProperties = null, this.dynamicData = null, this.gl.deleteBuffer(this.dynamicBuffer),
                    this.staticProperties = null, this.staticData = null, this.gl.deleteBuffer(this.staticBuffer)
            }
        }, {}],
        37: [function(t, e, r) {
            function i(t) {
                n.call(this, t), this.size = 250;
                var e = 6 * this.size;
                this.indices = new Uint16Array(e);
                for (var r = 0, i = 0; r < e; r += 6, i += 4) this.indices[r + 0] = i + 0, this.indices[r + 1] = i + 1, this.indices[r + 2] = i + 2, this.indices[r + 3] = i + 0, this.indices[r + 4] = i + 2, this.indices[r + 5] = i + 3;
                this.shader = null, this.indexBuffer = null, this.properties = null, this.tempMatrix = new h.Matrix
            }
            var n = t("../../renderers/webgl/utils/ObjectRenderer"),
                s = t("../../renderers/webgl/WebGLRenderer"),
                o = t("./ParticleShader"),
                a = t("./ParticleBuffer"),
                h = t("../../math");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i, s.registerPlugin("particle", i), i.prototype.onContextChange = function() {
                    var t = this.renderer.gl;
                    this.shader = new o(this.renderer.shaderManager), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), this.properties = [{
                        attribute: this.shader.attributes.aVertexPosition,
                        dynamic: !1,
                        size: 2,
                        uploadFunction: this.uploadVertices,
                        offset: 0
                    }, {
                        attribute: this.shader.attributes.aPositionCoord,
                        dynamic: !0,
                        size: 2,
                        uploadFunction: this.uploadPosition,
                        offset: 0
                    }, {
                        attribute: this.shader.attributes.aRotation,
                        dynamic: !1,
                        size: 1,
                        uploadFunction: this.uploadRotation,
                        offset: 0
                    }, {
                        attribute: this.shader.attributes.aTextureCoord,
                        dynamic: !1,
                        size: 2,
                        uploadFunction: this.uploadUvs,
                        offset: 0
                    }, {
                        attribute: this.shader.attributes.aColor,
                        dynamic: !1,
                        size: 1,
                        uploadFunction: this.uploadAlpha,
                        offset: 0
                    }]
                }, i.prototype.start =
                function() {
                    var t = this.renderer.gl;
                    t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                    var e = this.shader;
                    this.renderer.shaderManager.setShader(e)
                }, i.prototype.render = function(t) {
                    var e = t.children,
                        r = e.length,
                        i = t._size;
                    if (0 !== r) {
                        r > i && (r = i), t._buffers || (t._buffers = this.generateBuffers(t)), this.renderer.blendModeManager.setBlendMode(t.blendMode);
                        var n = this.renderer.gl,
                            s = t.worldTransform.copy(this.tempMatrix);
                        s.prepend(this.renderer.currentRenderTarget.projectionMatrix), n.uniformMatrix3fv(this.shader.uniforms.projectionMatrix._location, !1, s.toArray(!0)), n.uniform1f(this.shader.uniforms.uAlpha._location, t.worldAlpha);
                        var o = t._updateStatic,
                            a = e[0]._texture.baseTexture;
                        if (a._glTextures[n.id]) n.bindTexture(n.TEXTURE_2D, a._glTextures[n.id]);
                        else {
                            if (!this.renderer.updateTexture(a)) return;
                            this.properties[0].dynamic && this.properties[3].dynamic || (o = !0)
                        }
                        for (var h = 0, u = 0; u < r; u += this.size) {
                            var l = r - u;
                            l > this.size && (l = this.size);
                            var c = t._buffers[h++];
                            c.uploadDynamic(e, u, l), o && c.uploadStatic(e, u, l), c.bind(this.shader), n.drawElements(n.TRIANGLES,
                                6 * l, n.UNSIGNED_SHORT, 0), this.renderer.drawCount++
                        }
                        t._updateStatic = !1
                    }
                }, i.prototype.generateBuffers = function(t) {
                    var e, r = this.renderer.gl,
                        i = [],
                        n = t._size;
                    for (e = 0; e < t._properties.length; e++) this.properties[e].dynamic = t._properties[e];
                    for (e = 0; e < n; e += this.size) i.push(new a(r, this.properties, this.size, this.shader));
                    return i
                }, i.prototype.uploadVertices = function(t, e, r, i, n, s) {
                    for (var o, a, h, u, l, c, d, p, f, g = 0; g < r; g++) o = t[e + g], a = o._texture, u = o.scale.x, l = o.scale.y, a.trim ? (h = a.trim, d = h.x - o.anchor.x * h.width, c = d + a.crop.width,
                        f = h.y - o.anchor.y * h.height, p = f + a.crop.height) : (c = a._frame.width * (1 - o.anchor.x), d = a._frame.width * -o.anchor.x, p = a._frame.height * (1 - o.anchor.y), f = a._frame.height * -o.anchor.y), i[s] = d * u, i[s + 1] = f * l, i[s + n] = c * u, i[s + n + 1] = f * l, i[s + 2 * n] = c * u, i[s + 2 * n + 1] = p * l, i[s + 3 * n] = d * u, i[s + 3 * n + 1] = p * l, s += 4 * n
                }, i.prototype.uploadPosition = function(t, e, r, i, n, s) {
                    for (var o = 0; o < r; o++) {
                        var a = t[e + o].position;
                        i[s] = a.x, i[s + 1] = a.y, i[s + n] = a.x, i[s + n + 1] = a.y, i[s + 2 * n] = a.x, i[s + 2 * n + 1] = a.y, i[s + 3 * n] = a.x, i[s + 3 * n + 1] = a.y, s += 4 * n
                    }
                }, i.prototype.uploadRotation =
                function(t, e, r, i, n, s) {
                    for (var o = 0; o < r; o++) {
                        var a = t[e + o].rotation;
                        i[s] = a, i[s + n] = a, i[s + 2 * n] = a, i[s + 3 * n] = a, s += 4 * n
                    }
                }, i.prototype.uploadUvs = function(t, e, r, i, n, s) {
                    for (var o = 0; o < r; o++) {
                        var a = t[e + o]._texture._uvs;
                        a ? (i[s] = a.x0, i[s + 1] = a.y0, i[s + n] = a.x1, i[s + n + 1] = a.y1, i[s + 2 * n] = a.x2, i[s + 2 * n + 1] = a.y2, i[s + 3 * n] = a.x3, i[s + 3 * n + 1] = a.y3, s += 4 * n) : (i[s] = 0, i[s + 1] = 0, i[s + n] = 0, i[s + n + 1] = 0, i[s + 2 * n] = 0, i[s + 2 * n + 1] = 0, i[s + 3 * n] = 0, i[s + 3 * n + 1] = 0, s += 4 * n)
                    }
                }, i.prototype.uploadAlpha = function(t, e, r, i, n, s) {
                    for (var o = 0; o < r; o++) {
                        var a = t[e + o].alpha;
                        i[s] = a, i[s + n] = a, i[s + 2 * n] = a, i[s + 3 * n] = a, s += 4 * n
                    }
                }, i.prototype.destroy = function() {
                    this.renderer.gl && this.renderer.gl.deleteBuffer(this.indexBuffer), n.prototype.destroy.apply(this, arguments), this.shader.destroy(), this.indices = null, this.tempMatrix = null
                }
        }, {
            "../../math": 29,
            "../../renderers/webgl/WebGLRenderer": 45,
            "../../renderers/webgl/utils/ObjectRenderer": 59,
            "./ParticleBuffer": 36,
            "./ParticleShader": 38
        }],
        38: [function(t, e, r) {
            function i(t) {
                n.call(this, t, ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;",
                    "attribute float aColor;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "uniform mat3 projectionMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "void main(void){", "   vec2 v = aVertexPosition;", "   v.x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);", "   v.y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);", "   v = v + aPositionCoord;", "   gl_Position = vec4((projectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);",
                    "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"
                ].join("\n"), ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "uniform float uAlpha;", "void main(void){", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor * uAlpha ;", "}"].join("\n"), {
                    uAlpha: {
                        type: "1f",
                        value: 1
                    }
                }, {
                    aPositionCoord: 0,
                    aRotation: 0
                })
            }
            var n = t("../../renderers/webgl/shaders/TextureShader");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports =
                i
        }, {
            "../../renderers/webgl/shaders/TextureShader": 58
        }],
        39: [function(t, e, r) {
            function i(t, e, r, i) {
                if (a.call(this), n.sayHello(t), i)
                    for (var h in o.DEFAULT_RENDER_OPTIONS) "undefined" == typeof i[h] && (i[h] = o.DEFAULT_RENDER_OPTIONS[h]);
                else i = o.DEFAULT_RENDER_OPTIONS;
                this.type = o.RENDERER_TYPE.UNKNOWN, this.width = e || 800, this.height = r || 600, this.view = i.view || document.createElement("canvas"), this.resolution = i.resolution, this.transparent = i.transparent, this.autoResize = i.autoResize || !1, this.blendModes = null, this.preserveDrawingBuffer =
                    i.preserveDrawingBuffer, this.clearBeforeRender = i.clearBeforeRender, this._backgroundColor = 0, this._backgroundColorRgb = [0, 0, 0], this._backgroundColorString = "#000000", this.backgroundColor = i.backgroundColor || this._backgroundColor, this._tempDisplayObjectParent = {
                        worldTransform: new s.Matrix,
                        worldAlpha: 1,
                        children: []
                    }, this._lastObjectRendered = this._tempDisplayObjectParent
            }
            var n = t("../utils"),
                s = t("../math"),
                o = t("../const"),
                a = t("eventemitter3");
            i.prototype = Object.create(a.prototype), i.prototype.constructor = i,
                e.exports = i, Object.defineProperties(i.prototype, {
                    backgroundColor: {
                        get: function() {
                            return this._backgroundColor
                        },
                        set: function(t) {
                            this._backgroundColor = t, this._backgroundColorString = n.hex2string(t), n.hex2rgb(t, this._backgroundColorRgb)
                        }
                    }
                }), i.prototype.resize = function(t, e) {
                    this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution +
                        "px")
                }, i.prototype.destroy = function(t) {
                    t && this.view.parent && this.view.parent.removeChild(this.view), this.type = o.RENDERER_TYPE.UNKNOWN, this.width = 0, this.height = 0, this.view = null, this.resolution = 0, this.transparent = !1, this.autoResize = !1, this.blendModes = null, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !1, this._backgroundColor = 0, this._backgroundColorRgb = null, this._backgroundColorString = null
                }
        }, {
            "../const": 18,
            "../math": 29,
            "../utils": 72,
            eventemitter3: 6
        }],
        40: [function(t, e, r) {
            function i(t, e, r) {
                n.call(this,
                    "Canvas", t, e, r), this.type = h.RENDERER_TYPE.CANVAS, this.context = this.view.getContext("2d", {
                    alpha: this.transparent
                }), this.refresh = !0, this.maskManager = new s, this.roundPixels = !1, this.currentScaleMode = h.SCALE_MODES.DEFAULT, this.currentBlendMode = h.BLEND_MODES.NORMAL, this.smoothProperty = "imageSmoothingEnabled", this.context.imageSmoothingEnabled || (this.context.webkitImageSmoothingEnabled ? this.smoothProperty = "webkitImageSmoothingEnabled" : this.context.mozImageSmoothingEnabled ? this.smoothProperty = "mozImageSmoothingEnabled" :
                    this.context.oImageSmoothingEnabled ? this.smoothProperty = "oImageSmoothingEnabled" : this.context.msImageSmoothingEnabled && (this.smoothProperty = "msImageSmoothingEnabled")), this.initPlugins(), this._mapBlendModes(), this._tempDisplayObjectParent = {
                    worldTransform: new a.Matrix,
                    worldAlpha: 1
                }, this.resize(t, e)
            }
            var n = t("../SystemRenderer"),
                s = t("./utils/CanvasMaskManager"),
                o = t("../../utils"),
                a = t("../../math"),
                h = t("../../const");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i, o.pluginTarget.mixin(i),
                i.prototype.render = function(t) {
                    var e = t.parent;
                    this._lastObjectRendered = t, t.parent = this._tempDisplayObjectParent, t.updateTransform(), t.parent = e, this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.currentBlendMode = h.BLEND_MODES.NORMAL, this.context.globalCompositeOperation = this.blendModes[h.BLEND_MODES.NORMAL], navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width,
                        this.height) : (this.context.fillStyle = this._backgroundColorString, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t, this.context)
                }, i.prototype.destroy = function(t) {
                    this.destroyPlugins(), n.prototype.destroy.call(this, t), this.context = null, this.refresh = !0, this.maskManager.destroy(), this.maskManager = null, this.roundPixels = !1, this.currentScaleMode = 0, this.currentBlendMode = 0, this.smoothProperty = null
                }, i.prototype.renderDisplayObject = function(t, e) {
                    var r = this.context;
                    this.context =
                        e, t.renderCanvas(this), this.context = r
                }, i.prototype._mapBlendModes = function() {
                    this.blendModes || (this.blendModes = {}, o.canUseNewCanvasBlendModes() ? (this.blendModes[h.BLEND_MODES.NORMAL] = "source-over", this.blendModes[h.BLEND_MODES.ADD] = "lighter", this.blendModes[h.BLEND_MODES.MULTIPLY] = "multiply", this.blendModes[h.BLEND_MODES.SCREEN] = "screen", this.blendModes[h.BLEND_MODES.OVERLAY] = "overlay", this.blendModes[h.BLEND_MODES.DARKEN] = "darken", this.blendModes[h.BLEND_MODES.LIGHTEN] = "lighten", this.blendModes[h.BLEND_MODES.COLOR_DODGE] =
                        "color-dodge", this.blendModes[h.BLEND_MODES.COLOR_BURN] = "color-burn", this.blendModes[h.BLEND_MODES.HARD_LIGHT] = "hard-light", this.blendModes[h.BLEND_MODES.SOFT_LIGHT] = "soft-light", this.blendModes[h.BLEND_MODES.DIFFERENCE] = "difference", this.blendModes[h.BLEND_MODES.EXCLUSION] = "exclusion", this.blendModes[h.BLEND_MODES.HUE] = "hue", this.blendModes[h.BLEND_MODES.SATURATION] = "saturation", this.blendModes[h.BLEND_MODES.COLOR] = "color", this.blendModes[h.BLEND_MODES.LUMINOSITY] = "luminosity", this.blendModes[h.BLEND_MODES.SOURCE_OUT] =
                        "source-out", this.blendModes[h.BLEND_MODES.SOURCE_IN] = "source-in", this.blendModes[h.BLEND_MODES.DESTINATION_OUT] = "destination-out", this.blendModes[h.BLEND_MODES.DESTINATION_IN] = "destination-in") : (this.blendModes[h.BLEND_MODES.NORMAL] = "source-over", this.blendModes[h.BLEND_MODES.ADD] = "lighter", this.blendModes[h.BLEND_MODES.MULTIPLY] = "source-over", this.blendModes[h.BLEND_MODES.SCREEN] = "source-over", this.blendModes[h.BLEND_MODES.OVERLAY] = "source-over", this.blendModes[h.BLEND_MODES.DARKEN] = "source-over",
                        this.blendModes[h.BLEND_MODES.LIGHTEN] = "source-over", this.blendModes[h.BLEND_MODES.COLOR_DODGE] = "source-over", this.blendModes[h.BLEND_MODES.COLOR_BURN] = "source-over", this.blendModes[h.BLEND_MODES.HARD_LIGHT] = "source-over", this.blendModes[h.BLEND_MODES.SOFT_LIGHT] = "source-over", this.blendModes[h.BLEND_MODES.DIFFERENCE] = "source-over", this.blendModes[h.BLEND_MODES.EXCLUSION] = "source-over", this.blendModes[h.BLEND_MODES.HUE] = "source-over", this.blendModes[h.BLEND_MODES.SATURATION] = "source-over", this.blendModes[h.BLEND_MODES.COLOR] =
                        "source-over", this.blendModes[h.BLEND_MODES.LUMINOSITY] = "source-over", this.blendModes[h.BLEND_MODES.SOURCE_OUT] = "source-out", this.blendModes[h.BLEND_MODES.SOURCE_IN] = "source-in", this.blendModes[h.BLEND_MODES.DESTINATION_OUT] = "destination-out", this.blendModes[h.BLEND_MODES.DESTINATION_IN] = "destination-in"))
                }
        }, {
            "../../const": 18,
            "../../math": 29,
            "../../utils": 72,
            "../SystemRenderer": 39,
            "./utils/CanvasMaskManager": 43
        }],
        41: [function(t, e, r) {
            function i(t, e) {
                this.canvas = document.createElement("canvas"), this.context =
                    this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = e
            }
            i.prototype.constructor = i, e.exports = i, Object.defineProperties(i.prototype, {
                width: {
                    get: function() {
                        return this.canvas.width
                    },
                    set: function(t) {
                        this.canvas.width = t
                    }
                },
                height: {
                    get: function() {
                        return this.canvas.height
                    },
                    set: function(t) {
                        this.canvas.height = t
                    }
                }
            }), i.prototype.clear = function() {
                this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
            }, i.prototype.resize = function(t, e) {
                this.canvas.width =
                    t, this.canvas.height = e
            }, i.prototype.destroy = function() {
                this.context = null, this.canvas = null
            }
        }, {}],
        42: [function(t, e, r) {
            var i = t("../../../const"),
                n = e.exports = {};
            n.renderGraphics = function(t, e) {
                var r = t.worldAlpha;
                t.dirty && (this.updateGraphicsTint(t), t.dirty = !1);
                for (var n = 0; n < t.graphicsData.length; n++) {
                    var s = t.graphicsData[n],
                        o = s.shape,
                        a = s._fillTint,
                        h = s._lineTint;
                    if (e.lineWidth = s.lineWidth, s.type === i.SHAPES.POLY) {
                        e.beginPath();
                        var u = o.points;
                        e.moveTo(u[0], u[1]);
                        for (var l = 1; l < u.length / 2; l++) e.lineTo(u[2 *
                            l], u[2 * l + 1]);
                        o.closed && e.lineTo(u[0], u[1]), u[0] === u[u.length - 2] && u[1] === u[u.length - 1] && e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * r, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * r, e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.stroke())
                    } else if (s.type === i.SHAPES.RECT)(s.fillColor || 0 === s.fillColor) && (e.globalAlpha = s.fillAlpha * r, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fillRect(o.x, o.y, o.width, o.height)),
                        s.lineWidth && (e.globalAlpha = s.lineAlpha * r, e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.strokeRect(o.x, o.y, o.width, o.height));
                    else if (s.type === i.SHAPES.CIRC) e.beginPath(), e.arc(o.x, o.y, o.radius, 0, 2 * Math.PI), e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * r, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * r, e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.stroke());
                    else if (s.type === i.SHAPES.ELIP) {
                        var c = 2 * o.width,
                            d = 2 *
                            o.height,
                            p = o.x - c / 2,
                            f = o.y - d / 2;
                        e.beginPath();
                        var g = .5522848,
                            v = c / 2 * g,
                            y = d / 2 * g,
                            m = p + c,
                            x = f + d,
                            _ = p + c / 2,
                            E = f + d / 2;
                        e.moveTo(p, E), e.bezierCurveTo(p, E - y, _ - v, f, _, f), e.bezierCurveTo(_ + v, f, m, E - y, m, E), e.bezierCurveTo(m, E + y, _ + v, x, _, x), e.bezierCurveTo(_ - v, x, p, E + y, p, E), e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * r, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * r, e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.stroke())
                    } else if (s.type === i.SHAPES.RREC) {
                        var b =
                            o.x,
                            T = o.y,
                            S = o.width,
                            w = o.height,
                            R = o.radius,
                            A = Math.min(S, w) / 2 | 0;
                        R = R > A ? A : R, e.beginPath(), e.moveTo(b, T + R), e.lineTo(b, T + w - R), e.quadraticCurveTo(b, T + w, b + R, T + w), e.lineTo(b + S - R, T + w), e.quadraticCurveTo(b + S, T + w, b + S, T + w - R), e.lineTo(b + S, T + R), e.quadraticCurveTo(b + S, T, b + S - R, T), e.lineTo(b + R, T), e.quadraticCurveTo(b, T, b, T + R), e.closePath(), (s.fillColor || 0 === s.fillColor) && (e.globalAlpha = s.fillAlpha * r, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * r, e.strokeStyle =
                            "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.stroke())
                    }
                }
            }, n.renderGraphicsMask = function(t, e) {
                var r = t.graphicsData.length;
                if (0 !== r) {
                    e.beginPath();
                    for (var n = 0; n < r; n++) {
                        var s = t.graphicsData[n],
                            o = s.shape;
                        if (s.type === i.SHAPES.POLY) {
                            var a = o.points;
                            e.moveTo(a[0], a[1]);
                            for (var h = 1; h < a.length / 2; h++) e.lineTo(a[2 * h], a[2 * h + 1]);
                            a[0] === a[a.length - 2] && a[1] === a[a.length - 1] && e.closePath()
                        } else if (s.type === i.SHAPES.RECT) e.rect(o.x, o.y, o.width, o.height), e.closePath();
                        else if (s.type === i.SHAPES.CIRC) e.arc(o.x, o.y, o.radius,
                            0, 2 * Math.PI), e.closePath();
                        else if (s.type === i.SHAPES.ELIP) {
                            var u = 2 * o.width,
                                l = 2 * o.height,
                                c = o.x - u / 2,
                                d = o.y - l / 2,
                                p = .5522848,
                                f = u / 2 * p,
                                g = l / 2 * p,
                                v = c + u,
                                y = d + l,
                                m = c + u / 2,
                                x = d + l / 2;
                            e.moveTo(c, x), e.bezierCurveTo(c, x - g, m - f, d, m, d), e.bezierCurveTo(m + f, d, v, x - g, v, x), e.bezierCurveTo(v, x + g, m + f, y, m, y), e.bezierCurveTo(m - f, y, c, x + g, c, x), e.closePath()
                        } else if (s.type === i.SHAPES.RREC) {
                            var _ = o.x,
                                E = o.y,
                                b = o.width,
                                T = o.height,
                                S = o.radius,
                                w = Math.min(b, T) / 2 | 0;
                            S = S > w ? w : S, e.moveTo(_, E + S), e.lineTo(_, E + T - S), e.quadraticCurveTo(_, E + T, _ + S, E + T),
                                e.lineTo(_ + b - S, E + T), e.quadraticCurveTo(_ + b, E + T, _ + b, E + T - S), e.lineTo(_ + b, E + S), e.quadraticCurveTo(_ + b, E, _ + b - S, E), e.lineTo(_ + S, E), e.quadraticCurveTo(_, E, _, E + S), e.closePath()
                        }
                    }
                }
            }, n.updateGraphicsTint = function(t) {
                if (16777215 !== t.tint)
                    for (var e = (t.tint >> 16 & 255) / 255, r = (t.tint >> 8 & 255) / 255, i = (255 & t.tint) / 255, n = 0; n < t.graphicsData.length; n++) {
                        var s = t.graphicsData[n],
                            o = 0 | s.fillColor,
                            a = 0 | s.lineColor;
                        s._fillTint = ((o >> 16 & 255) / 255 * e * 255 << 16) + ((o >> 8 & 255) / 255 * r * 255 << 8) + (255 & o) / 255 * i * 255, s._lineTint = ((a >> 16 & 255) / 255 *
                            e * 255 << 16) + ((a >> 8 & 255) / 255 * r * 255 << 8) + (255 & a) / 255 * i * 255
                    }
            }
        }, {
            "../../../const": 18
        }],
        43: [function(t, e, r) {
            function i() {}
            var n = t("./CanvasGraphics");
            i.prototype.constructor = i, e.exports = i, i.prototype.pushMask = function(t, e) {
                e.context.save();
                var r = t.alpha,
                    i = t.worldTransform,
                    s = e.resolution;
                e.context.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, i.tx * s, i.ty * s), t.texture || (n.renderGraphicsMask(t, e.context), e.context.clip()), t.worldAlpha = r
            }, i.prototype.popMask = function(t) {
                t.context.restore()
            }
        }, {
            "./CanvasGraphics": 42
        }],
        44: [function(t, e, r) {
            var i = t("../../../utils"),
                n = e.exports = {};
            n.getTintedTexture = function(t, e) {
                var r = t.texture;
                e = n.roundColor(e);
                var i = "#" + ("00000" + (0 | e).toString(16)).substr(-6);
                if (r.tintCache = r.tintCache || {}, r.tintCache[i]) return r.tintCache[i];
                var s = n.canvas || document.createElement("canvas");
                if (n.tintMethod(r, e, s), n.convertTintToImage) {
                    var o = new Image;
                    o.src = s.toDataURL(), r.tintCache[i] = o
                } else r.tintCache[i] = s, n.canvas = null;
                return s
            }, n.tintWithMultiply = function(t, e, r) {
                var i = r.getContext("2d"),
                    n =
                    t.crop;
                r.width = n.width, r.height = n.height, i.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), i.fillRect(0, 0, n.width, n.height), i.globalCompositeOperation = "multiply", i.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), i.globalCompositeOperation = "destination-atop", i.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height)
            }, n.tintWithOverlay = function(t, e, r) {
                var i = r.getContext("2d"),
                    n = t.crop;
                r.width = n.width, r.height = n.height, i.globalCompositeOperation =
                    "copy", i.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), i.fillRect(0, 0, n.width, n.height), i.globalCompositeOperation = "destination-atop", i.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height)
            }, n.tintWithPerPixel = function(t, e, r) {
                var n = r.getContext("2d"),
                    s = t.crop;
                r.width = s.width, r.height = s.height, n.globalCompositeOperation = "copy", n.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height);
                for (var o = i.hex2rgb(e), a = o[0], h = o[1], u = o[2], l = n.getImageData(0,
                        0, s.width, s.height), c = l.data, d = 0; d < c.length; d += 4) c[d + 0] *= a, c[d + 1] *= h, c[d + 2] *= u;
                n.putImageData(l, 0, 0)
            }, n.roundColor = function(t) {
                var e = n.cacheStepsPerColorChannel,
                    r = i.hex2rgb(t);
                return r[0] = Math.min(255, r[0] / e * e), r[1] = Math.min(255, r[1] / e * e), r[2] = Math.min(255, r[2] / e * e), i.rgb2hex(r)
            }, n.cacheStepsPerColorChannel = 8, n.convertTintToImage = !1, n.canUseMultiply = i.canUseNewCanvasBlendModes(), n.tintMethod = n.canUseMultiply ? n.tintWithMultiply : n.tintWithPerPixel
        }, {
            "../../../utils": 72
        }],
        45: [function(t, e, r) {
            function i(t,
                e, r) {
                r = r || {}, n.call(this, "WebGL", t, e, r), this.type = f.RENDERER_TYPE.WEBGL, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), this.view.addEventListener("webglcontextlost", this.handleContextLost, !1), this.view.addEventListener("webglcontextrestored", this.handleContextRestored, !1), this._useFXAA = !!r.forceFXAA && r.antialias, this._FXAAFilter = null, this._contextOptions = {
                    alpha: this.transparent,
                    antialias: r.antialias,
                    premultipliedAlpha: this.transparent &&
                        "notMultiplied" !== this.transparent,
                    stencil: !0,
                    preserveDrawingBuffer: r.preserveDrawingBuffer
                }, this.drawCount = 0, this.shaderManager = new s(this), this.maskManager = new o(this), this.stencilManager = new a(this), this.filterManager = new h(this), this.blendModeManager = new u(this), this.currentRenderTarget = null, this.currentRenderer = new c(this), this.initPlugins(), this._initContext(), this._mapBlendModes(), this._renderTargetStack = []
            }
            var n = t("../SystemRenderer"),
                s = t("./managers/ShaderManager"),
                o = t("./managers/MaskManager"),
                a = t("./managers/StencilManager"),
                h = t("./managers/FilterManager"),
                u = t("./managers/BlendModeManager"),
                l = t("./utils/RenderTarget"),
                c = t("./utils/ObjectRenderer"),
                d = t("./filters/FXAAFilter"),
                p = t("../../utils"),
                f = t("../../const");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i, p.pluginTarget.mixin(i), i.glContextId = 0, i.prototype._initContext = function() {
                    var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
                    if (this.gl =
                        t, !t) throw new Error("This browser does not support webGL. Try using the canvas renderer");
                    this.glContextId = i.glContextId++, t.id = this.glContextId, t.renderer = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.renderTarget = new l(this.gl, this.width, this.height, null, this.resolution, !0), this.setRenderTarget(this.renderTarget), this.emit("context", t), this.resize(this.width, this.height), this._useFXAA || (this._useFXAA = this._contextOptions.antialias && !t.getContextAttributes().antialias),
                        this._useFXAA && (window.console.warn("FXAA antialiasing being used instead of native antialiasing"), this._FXAAFilter = [new d])
                }, i.prototype.render = function(t) {
                    if (!this.gl.isContextLost()) {
                        this.drawCount = 0, this._lastObjectRendered = t, this._useFXAA && (this._FXAAFilter[0].uniforms.resolution.value.x = this.width, this._FXAAFilter[0].uniforms.resolution.value.y = this.height, t.filterArea = this.renderTarget.size, t.filters = this._FXAAFilter);
                        var e = t.parent;
                        t.parent = this._tempDisplayObjectParent, t.updateTransform(),
                            t.parent = e;
                        var r = this.gl;
                        this.setRenderTarget(this.renderTarget), this.clearBeforeRender && (this.transparent ? r.clearColor(0, 0, 0, 0) : r.clearColor(this._backgroundColorRgb[0], this._backgroundColorRgb[1], this._backgroundColorRgb[2], 1), r.clear(r.COLOR_BUFFER_BIT)), this.renderDisplayObject(t, this.renderTarget)
                    }
                }, i.prototype.renderDisplayObject = function(t, e, r) {
                    this.setRenderTarget(e), r && e.clear(), this.filterManager.setFilterStack(e.filterStack), t.renderWebGL(this), this.currentRenderer.flush()
                }, i.prototype.setObjectRenderer =
                function(t) {
                    this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start())
                }, i.prototype.setRenderTarget = function(t) {
                    this.currentRenderTarget !== t && (this.currentRenderTarget = t, this.currentRenderTarget.activate(), this.stencilManager.setMaskStack(t.stencilMaskStack))
                }, i.prototype.resize = function(t, e) {
                    n.prototype.resize.call(this, t, e), this.gl.viewport(0, 0, this.width, this.height), this.filterManager.resize(t, e), this.renderTarget.resize(t, e), this.currentRenderTarget ===
                        this.renderTarget && this.renderTarget.activate()
                }, i.prototype.updateTexture = function(t) {
                    if (t = t.baseTexture || t, t.hasLoaded) {
                        var e = this.gl;
                        return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture(), t.on("update", this.updateTexture, this), t.on("dispose", this.destroyTexture, this)), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), e.texImage2D(e.TEXTURE_2D, 0, t.hasAlpha ? e.RGBA : e.RGB, t.hasAlpha ? e.RGBA : e.RGB, e.UNSIGNED_BYTE, t.source),
                            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === f.SCALE_MODES.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && t.isPowerOfTwo ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === f.SCALE_MODES.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === f.SCALE_MODES.LINEAR ? e.LINEAR : e.NEAREST), t.isPowerOfTwo ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D,
                                e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), t._glTextures[e.id]
                    }
                }, i.prototype.destroyTexture = function(t) {
                    t = t.baseTexture || t, t.hasLoaded && t._glTextures[this.gl.id] && this.gl.deleteTexture(t._glTextures[this.gl.id])
                }, i.prototype.handleContextLost = function(t) {
                    t.preventDefault()
                }, i.prototype.handleContextRestored = function() {
                    this._initContext();
                    for (var t in p.BaseTextureCache) p.BaseTextureCache[t]._glTextures.length =
                        0
                }, i.prototype.destroy = function(t) {
                    this.destroyPlugins(), this.view.removeEventListener("webglcontextlost", this.handleContextLost), this.view.removeEventListener("webglcontextrestored", this.handleContextRestored), n.prototype.destroy.call(this, t), this.uuid = 0, this.shaderManager.destroy(), this.maskManager.destroy(), this.stencilManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.maskManager = null, this.filterManager = null, this.blendModeManager = null, this.handleContextLost = null, this.handleContextRestored =
                        null, this._contextOptions = null, this.drawCount = 0, this.gl = null
                }, i.prototype._mapBlendModes = function() {
                    var t = this.gl;
                    this.blendModes || (this.blendModes = {}, this.blendModes[f.BLEND_MODES.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.ADD] = [t.ONE, t.DST_ALPHA], this.blendModes[f.BLEND_MODES.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.SCREEN] = [t.SRC_ALPHA, t.ONE], this.blendModes[f.BLEND_MODES.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], this.blendModes[f.BLEND_MODES.SOURCE_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO], this.blendModes[f.BLEND_MODES.SOURCE_IN] = [t.DST_ALPHA, t.ZERO], this.blendModes[f.BLEND_MODES.DESTINATION_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA],
                        this.blendModes[f.BLEND_MODES.DESTINATION_IN] = [t.ZERO, t.SRC_ALPHA])
                }
        }, {
            "../../const": 18,
            "../../utils": 72,
            "../SystemRenderer": 39,
            "./filters/FXAAFilter": 47,
            "./managers/BlendModeManager": 49,
            "./managers/FilterManager": 50,
            "./managers/MaskManager": 51,
            "./managers/ShaderManager": 52,
            "./managers/StencilManager": 53,
            "./utils/ObjectRenderer": 59,
            "./utils/RenderTarget": 61
        }],
        46: [function(t, e, r) {
                function i(t, e, r) {
                    this.shaders = [], this.padding = 0, this.uniforms = r || {}, this.vertexSrc = t || n.defaultVertexSrc, this.fragmentSrc =
                        e || n.defaultFragmentSrc
                }
                var n = t("../shaders/TextureShader");
                i.prototype.constructor = i, e.exports = i, i.prototype.getShader = function(t) {
                    var e = t.gl,
                        r = this.shaders[e.id];
                    return r || (r = new n(t.shaderManager, this.vertexSrc, this.fragmentSrc, this.uniforms, this.attributes), this.shaders[e.id] = r), r
                }, i.prototype.applyFilter = function(t, e, r, i) {
                    var n = this.getShader(t);
                    t.filterManager.applyFilter(n, e, r, i)
                }, i.prototype.syncUniform = function(t) {
                    for (var e = 0, r = this.shaders.length; e < r; ++e) this.shaders[e].syncUniform(t)
                }
            },
            {
                "../shaders/TextureShader": 58
            }
        ],
        47: [function(t, e, r) {
            function i() {
                n.call(this, "\nprecision mediump float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform vec2 resolution;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvarying vec2 vResolution;\n\n//texcoords computed in vertex step\n//to avoid dependent texture reads\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n            out vec2 v_rgbNW, out vec2 v_rgbNE,\n            out vec2 v_rgbSW, out vec2 v_rgbSE,\n            out vec2 v_rgbM) {\n    vec2 inverseVP = 1.0 / resolution.xy;\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n   vResolution = resolution;\n\n   //compute the texture coords and send them to varyings\n   texcoords(aTextureCoord * resolution, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n",
                    'precision lowp float;\n\n\n/**\nBasic FXAA implementation based on the code on geeks3d.com with the\nmodification that the texture2DLod stuff was removed since it\'s\nunsupported by WebGL.\n\n--\n\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\n\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE,\n            vec2 v_rgbSW, vec2 v_rgbSE,\n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vResolution;\n\n//texcoords computed in vertex step\n//to avoid dependent texture reads\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nuniform sampler2D uSampler;\n\n\nvoid main(void){\n\n    gl_FragColor = fxaa(uSampler, vTextureCoord * vResolution, vResolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n}\n', {
                        resolution: {
                            type: "v2",
                            value: {
                                x: 1,
                                y: 1
                            }
                        }
                    })
            }
            var n = t("./AbstractFilter");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i, i.prototype.applyFilter = function(t, e, r) {
                var i = t.filterManager,
                    n = this.getShader(t);
                i.applyFilter(n, e, r)
            }
        }, {
            "./AbstractFilter": 46
        }],
        48: [function(t, e, r) {
            function i(t) {
                var e = new s.Matrix;
                n.call(this, "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
                    "precision lowp float;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform sampler2D mask;\n\nvoid main(void)\n{\n    // check clip! this will stop the mask bleeding out from the edges\n    vec2 text = abs( vMaskCoord - 0.5 );\n    text = step(0.5, text);\n    float clip = 1.0 - max(text.y, text.x);\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    original *= (masky.r * masky.a * alpha * clip);\n    gl_FragColor = original;\n}\n", {
                        mask: {
                            type: "sampler2D",
                            value: t._texture
                        },
                        alpha: {
                            type: "f",
                            value: 1
                        },
                        otherMatrix: {
                            type: "mat3",
                            value: e.toArray(!0)
                        }
                    }), this.maskSprite = t, this.maskMatrix = e
            }
            var n = t("./AbstractFilter"),
                s = t("../../../math");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i, i.prototype.applyFilter = function(t, e, r) {
                var i = t.filterManager;
                this.uniforms.mask.value = this.maskSprite._texture, i.calculateMappedMatrix(e.frame, this.maskSprite, this.maskMatrix), this.uniforms.otherMatrix.value = this.maskMatrix.toArray(!0),
                    this.uniforms.alpha.value = this.maskSprite.worldAlpha;
                var n = this.getShader(t);
                i.applyFilter(n, e, r)
            }, Object.defineProperties(i.prototype, {
                map: {
                    get: function() {
                        return this.uniforms.mask.value
                    },
                    set: function(t) {
                        this.uniforms.mask.value = t
                    }
                },
                offset: {
                    get: function() {
                        return this.uniforms.offset.value
                    },
                    set: function(t) {
                        this.uniforms.offset.value = t
                    }
                }
            })
        }, {
            "../../../math": 29,
            "./AbstractFilter": 46
        }],
        49: [function(t, e, r) {
            function i(t) {
                n.call(this, t), this.currentBlendMode = 99999
            }
            var n = t("./WebGLManager");
            i.prototype =
                Object.create(n.prototype), i.prototype.constructor = i, e.exports = i, i.prototype.setBlendMode = function(t) {
                    if (this.currentBlendMode === t) return !1;
                    this.currentBlendMode = t;
                    var e = this.renderer.blendModes[this.currentBlendMode];
                    return this.renderer.gl.blendFunc(e[0], e[1]), !0
                }
        }, {
            "./WebGLManager": 54
        }],
        50: [function(t, e, r) {
            function i(t) {
                n.call(this, t), this.filterStack = [], this.filterStack.push({
                    renderTarget: t.currentRenderTarget,
                    filter: [],
                    bounds: null
                }), this.texturePool = [], this.textureSize = new h.Rectangle(0, 0, t.width,
                    t.height), this.currentFrame = null
            }
            var n = t("./WebGLManager"),
                s = t("../utils/RenderTarget"),
                o = t("../../../const"),
                a = t("../utils/Quad"),
                h = t("../../../math");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i, i.prototype.onContextChange = function() {
                    this.texturePool.length = 0;
                    var t = this.renderer.gl;
                    this.quad = new a(t)
                }, i.prototype.setFilterStack = function(t) {
                    this.filterStack = t
                }, i.prototype.pushFilter = function(t, e) {
                    var r = t.filterArea ? t.filterArea.clone() : t.getBounds();
                    r.x = 0 | r.x, r.y =
                        0 | r.y, r.width = 0 | r.width, r.height = 0 | r.height;
                    var i = 0 | e[0].padding;
                    if (r.x -= i, r.y -= i, r.width += 2 * i, r.height += 2 * i, this.renderer.currentRenderTarget.transform) {
                        var n = this.renderer.currentRenderTarget.transform;
                        r.x += n.tx, r.y += n.ty, this.capFilterArea(r), r.x -= n.tx, r.y -= n.ty
                    } else this.capFilterArea(r);
                    if (r.width > 0 && r.height > 0) {
                        this.currentFrame = r;
                        var s = this.getRenderTarget();
                        this.renderer.setRenderTarget(s), s.clear(), this.filterStack.push({
                            renderTarget: s,
                            filter: e
                        })
                    } else this.filterStack.push({
                        renderTarget: null,
                        filter: e
                    })
                }, i.prototype.popFilter = function() {
                    var t = this.filterStack.pop(),
                        e = this.filterStack[this.filterStack.length - 1],
                        r = t.renderTarget;
                    if (t.renderTarget) {
                        var i = e.renderTarget,
                            n = this.renderer.gl;
                        this.currentFrame = r.frame, this.quad.map(this.textureSize, r.frame), n.bindBuffer(n.ARRAY_BUFFER, this.quad.vertexBuffer), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, this.quad.indexBuffer);
                        var s = t.filter;
                        if (n.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aVertexPosition, 2, n.FLOAT, !1, 0, 0), n.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aTextureCoord,
                                2, n.FLOAT, !1, 0, 32), n.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aColor, 4, n.FLOAT, !1, 0, 64), this.renderer.blendModeManager.setBlendMode(o.BLEND_MODES.NORMAL), 1 === s.length) s[0].uniforms.dimensions && (s[0].uniforms.dimensions.value[0] = this.renderer.width, s[0].uniforms.dimensions.value[1] = this.renderer.height, s[0].uniforms.dimensions.value[2] = this.quad.vertices[0], s[0].uniforms.dimensions.value[3] = this.quad.vertices[5]), s[0].applyFilter(this.renderer, r, i), this.returnRenderTarget(r);
                        else {
                            for (var a = r, h = this.getRenderTarget(!0), u = 0; u < s.length - 1; u++) {
                                var l = s[u];
                                l.uniforms.dimensions && (l.uniforms.dimensions.value[0] = this.renderer.width, l.uniforms.dimensions.value[1] = this.renderer.height, l.uniforms.dimensions.value[2] = this.quad.vertices[0], l.uniforms.dimensions.value[3] = this.quad.vertices[5]), l.applyFilter(this.renderer, a, h);
                                var c = a;
                                a = h, h = c
                            }
                            s[s.length - 1].applyFilter(this.renderer, a, i), this.returnRenderTarget(a), this.returnRenderTarget(h)
                        }
                        return t.filter
                    }
                }, i.prototype.getRenderTarget =
                function(t) {
                    var e = this.texturePool.pop() || new s(this.renderer.gl, this.textureSize.width, this.textureSize.height, o.SCALE_MODES.LINEAR, this.renderer.resolution * o.FILTER_RESOLUTION);
                    return e.frame = this.currentFrame, t && e.clear(!0), e
                }, i.prototype.returnRenderTarget = function(t) {
                    this.texturePool.push(t)
                }, i.prototype.applyFilter = function(t, e, r, i) {
                    var n = this.renderer.gl;
                    this.renderer.setRenderTarget(r), i && r.clear(), this.renderer.shaderManager.setShader(t), t.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(!0),
                        t.syncUniforms(), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, e.texture), n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0)
                }, i.prototype.calculateMappedMatrix = function(t, e, r) {
                    var i = e.worldTransform.copy(h.Matrix.TEMP_MATRIX),
                        n = e._texture.baseTexture,
                        s = r.identity(),
                        o = this.textureSize.height / this.textureSize.width;
                    s.translate(t.x / this.textureSize.width, t.y / this.textureSize.height), s.scale(1, o);
                    var a = this.textureSize.width / n.width,
                        u = this.textureSize.height / n.height;
                    return i.tx /= n.width * a, i.ty /=
                        n.width * a, i.invert(), s.prepend(i), s.scale(1, 1 / o), s.scale(a, u), s.translate(e.anchor.x, e.anchor.y), s
                }, i.prototype.capFilterArea = function(t) {
                    t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0), t.x + t.width > this.textureSize.width && (t.width = this.textureSize.width - t.x), t.y + t.height > this.textureSize.height && (t.height = this.textureSize.height - t.y)
                }, i.prototype.resize = function(t, e) {
                    this.textureSize.width = t, this.textureSize.height = e;
                    for (var r = 0; r < this.texturePool.length; r++) this.texturePool[r].resize(t,
                        e)
                }, i.prototype.destroy = function() {
                    this.filterStack = null, this.offsetY = 0;
                    for (var t = 0; t < this.texturePool.length; t++) this.texturePool[t].destroy();
                    this.texturePool = null
                }
        }, {
            "../../../const": 18,
            "../../../math": 29,
            "../utils/Quad": 60,
            "../utils/RenderTarget": 61,
            "./WebGLManager": 54
        }],
        51: [function(t, e, r) {
            function i(t) {
                n.call(this, t), this.stencilStack = [], this.reverse = !0, this.count = 0, this.alphaMaskPool = []
            }
            var n = t("./WebGLManager"),
                s = t("../filters/SpriteMaskFilter");
            i.prototype = Object.create(n.prototype), i.prototype.constructor =
                i, e.exports = i, i.prototype.pushMask = function(t, e) {
                    e.texture ? this.pushSpriteMask(t, e) : this.pushStencilMask(t, e)
                }, i.prototype.popMask = function(t, e) {
                    e.texture ? this.popSpriteMask(t, e) : this.popStencilMask(t, e)
                }, i.prototype.pushSpriteMask = function(t, e) {
                    var r = this.alphaMaskPool.pop();
                    r || (r = [new s(e)]), r[0].maskSprite = e, this.renderer.filterManager.pushFilter(t, r)
                }, i.prototype.popSpriteMask = function() {
                    var t = this.renderer.filterManager.popFilter();
                    this.alphaMaskPool.push(t)
                }, i.prototype.pushStencilMask = function(t,
                    e) {
                    this.renderer.stencilManager.pushMask(e)
                }, i.prototype.popStencilMask = function(t, e) {
                    this.renderer.stencilManager.popMask(e)
                }
        }, {
            "../filters/SpriteMaskFilter": 48,
            "./WebGLManager": 54
        }],
        52: [function(t, e, r) {
            function i(t) {
                n.call(this, t), this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
                for (var e = 0; e < this.maxAttibs; e++) this.attribState[e] = !1;
                this.stack = [], this._currentId = -1, this.currentShader = null
            }
            var n = t("./WebGLManager"),
                s = t("../shaders/TextureShader"),
                o = t("../shaders/ComplexPrimitiveShader"),
                a = t("../shaders/PrimitiveShader"),
                h = t("../../../utils");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, h.pluginTarget.mixin(i), e.exports = i, i.prototype.onContextChange = function() {
                this.initPlugins();
                var t = this.renderer.gl;
                this.maxAttibs = t.getParameter(t.MAX_VERTEX_ATTRIBS), this.attribState = [];
                for (var e = 0; e < this.maxAttibs; e++) this.attribState[e] = !1;
                this.defaultShader = new s(this), this.primitiveShader = new a(this), this.complexPrimitiveShader = new o(this)
            }, i.prototype.setAttribs = function(t) {
                var e;
                for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
                for (var r in t) this.tempAttribState[t[r]] = !0;
                var i = this.renderer.gl;
                for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.attribState[e] ? i.enableVertexAttribArray(e) : i.disableVertexAttribArray(e))
            }, i.prototype.setShader = function(t) {
                return this._currentId !== t.uuid && (this._currentId = t.uuid, this.currentShader = t, this.renderer.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
            }, i.prototype.destroy = function() {
                n.prototype.destroy.call(this), this.destroyPlugins(), this.attribState = null, this.tempAttribState = null
            }
        }, {
            "../../../utils": 72,
            "../shaders/ComplexPrimitiveShader": 55,
            "../shaders/PrimitiveShader": 56,
            "../shaders/TextureShader": 58,
            "./WebGLManager": 54
        }],
        53: [function(t, e, r) {
            function i(t) {
                n.call(this, t), this.stencilMaskStack = null
            }
            var n = t("./WebGLManager"),
                s = t("../../../utils");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i, i.prototype.setMaskStack =
                function(t) {
                    this.stencilMaskStack = t;
                    var e = this.renderer.gl;
                    0 === t.stencilStack.length ? e.disable(e.STENCIL_TEST) : e.enable(e.STENCIL_TEST)
                }, i.prototype.pushStencil = function(t, e) {
                    this.renderer.currentRenderTarget.attachStencilBuffer();
                    var r = this.renderer.gl,
                        i = this.stencilMaskStack;
                    this.bindGraphics(t, e, this.renderer), 0 === i.stencilStack.length && (r.enable(r.STENCIL_TEST), r.clear(r.STENCIL_BUFFER_BIT), i.reverse = !0, i.count = 0), i.stencilStack.push(e);
                    var n = i.count;
                    r.colorMask(!1, !1, !1, !1), r.stencilFunc(r.ALWAYS,
                        0, 255), r.stencilOp(r.KEEP, r.KEEP, r.INVERT), 1 === e.mode ? (r.drawElements(r.TRIANGLE_FAN, e.indices.length - 4, r.UNSIGNED_SHORT, 0), i.reverse ? (r.stencilFunc(r.EQUAL, 255 - n, 255), r.stencilOp(r.KEEP, r.KEEP, r.DECR)) : (r.stencilFunc(r.EQUAL, n, 255), r.stencilOp(r.KEEP, r.KEEP, r.INCR)), r.drawElements(r.TRIANGLE_FAN, 4, r.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), i.reverse ? r.stencilFunc(r.EQUAL, 255 - (n + 1), 255) : r.stencilFunc(r.EQUAL, n + 1, 255), i.reverse = !i.reverse) : (i.reverse ? (r.stencilFunc(r.EQUAL, n, 255), r.stencilOp(r.KEEP,
                        r.KEEP, r.INCR)) : (r.stencilFunc(r.EQUAL, 255 - n, 255), r.stencilOp(r.KEEP, r.KEEP, r.DECR)), r.drawElements(r.TRIANGLE_STRIP, e.indices.length, r.UNSIGNED_SHORT, 0), i.reverse ? r.stencilFunc(r.EQUAL, n + 1, 255) : r.stencilFunc(r.EQUAL, 255 - (n + 1), 255)), r.colorMask(!0, !0, !0, !0), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), i.count++
                }, i.prototype.bindGraphics = function(t, e) {
                    this._currentGraphics = t;
                    var r, i = this.renderer.gl;
                    1 === e.mode ? (r = this.renderer.shaderManager.complexPrimitiveShader, this.renderer.shaderManager.setShader(r), i.uniformMatrix3fv(r.uniforms.translationMatrix._location, !1, t.worldTransform.toArray(!0)), i.uniformMatrix3fv(r.uniforms.projectionMatrix._location, !1, this.renderer.currentRenderTarget.projectionMatrix.toArray(!0)), i.uniform3fv(r.uniforms.tint._location, s.hex2rgb(t.tint)), i.uniform3fv(r.uniforms.color._location, e.color), i.uniform1f(r.uniforms.alpha._location, t.worldAlpha), i.bindBuffer(i.ARRAY_BUFFER, e.buffer), i.vertexAttribPointer(r.attributes.aVertexPosition, 2, i.FLOAT, !1, 8, 0), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.indexBuffer)) : (r = this.renderer.shaderManager.primitiveShader,
                        this.renderer.shaderManager.setShader(r), i.uniformMatrix3fv(r.uniforms.translationMatrix._location, !1, t.worldTransform.toArray(!0)), i.uniformMatrix3fv(r.uniforms.projectionMatrix._location, !1, this.renderer.currentRenderTarget.projectionMatrix.toArray(!0)), i.uniform3fv(r.uniforms.tint._location, s.hex2rgb(t.tint)), i.uniform1f(r.uniforms.alpha._location, t.worldAlpha), i.bindBuffer(i.ARRAY_BUFFER, e.buffer), i.vertexAttribPointer(r.attributes.aVertexPosition, 2, i.FLOAT, !1, 24, 0), i.vertexAttribPointer(r.attributes.aColor,
                            4, i.FLOAT, !1, 24, 8), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.indexBuffer))
                }, i.prototype.popStencil = function(t, e) {
                    var r = this.renderer.gl,
                        i = this.stencilMaskStack;
                    if (i.stencilStack.pop(), i.count--, 0 === i.stencilStack.length) r.disable(r.STENCIL_TEST);
                    else {
                        var n = i.count;
                        this.bindGraphics(t, e, this.renderer), r.colorMask(!1, !1, !1, !1), 1 === e.mode ? (i.reverse = !i.reverse, i.reverse ? (r.stencilFunc(r.EQUAL, 255 - (n + 1), 255), r.stencilOp(r.KEEP, r.KEEP, r.INCR)) : (r.stencilFunc(r.EQUAL, n + 1, 255), r.stencilOp(r.KEEP, r.KEEP, r.DECR)),
                            r.drawElements(r.TRIANGLE_FAN, 4, r.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), r.stencilFunc(r.ALWAYS, 0, 255), r.stencilOp(r.KEEP, r.KEEP, r.INVERT), r.drawElements(r.TRIANGLE_FAN, e.indices.length - 4, r.UNSIGNED_SHORT, 0), i.reverse ? r.stencilFunc(r.EQUAL, n, 255) : r.stencilFunc(r.EQUAL, 255 - n, 255)) : (i.reverse ? (r.stencilFunc(r.EQUAL, n + 1, 255), r.stencilOp(r.KEEP, r.KEEP, r.DECR)) : (r.stencilFunc(r.EQUAL, 255 - (n + 1), 255), r.stencilOp(r.KEEP, r.KEEP, r.INCR)), r.drawElements(r.TRIANGLE_STRIP, e.indices.length, r.UNSIGNED_SHORT, 0),
                            i.reverse ? r.stencilFunc(r.EQUAL, n, 255) : r.stencilFunc(r.EQUAL, 255 - n, 255)), r.colorMask(!0, !0, !0, !0), r.stencilOp(r.KEEP, r.KEEP, r.KEEP)
                    }
                }, i.prototype.destroy = function() {
                    n.prototype.destroy.call(this), this.stencilMaskStack.stencilStack = null
                }, i.prototype.pushMask = function(t) {
                    this.renderer.setObjectRenderer(this.renderer.plugins.graphics), t.dirty && this.renderer.plugins.graphics.updateGraphics(t, this.renderer.gl), t._webGL[this.renderer.gl.id].data.length && this.pushStencil(t, t._webGL[this.renderer.gl.id].data[0],
                        this.renderer)
                }, i.prototype.popMask = function(t) {
                    this.renderer.setObjectRenderer(this.renderer.plugins.graphics), this.popStencil(t, t._webGL[this.renderer.gl.id].data[0], this.renderer)
                }
        }, {
            "../../../utils": 72,
            "./WebGLManager": 54
        }],
        54: [function(t, e, r) {
            function i(t) {
                this.renderer = t, this.renderer.on("context", this.onContextChange, this)
            }
            i.prototype.constructor = i, e.exports = i, i.prototype.onContextChange = function() {}, i.prototype.destroy = function() {
                this.renderer.off("context", this.onContextChange), this.renderer =
                    null
            }
        }, {}],
        55: [function(t, e, r) {
            function i(t) {
                n.call(this, t, ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform mat3 projectionMatrix;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "varying vec4 vColor;", "void main(void){", "   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"].join("\n"), ["precision mediump float;", "varying vec4 vColor;", "void main(void){",
                    "   gl_FragColor = vColor;", "}"
                ].join("\n"), {
                    tint: {
                        type: "3f",
                        value: [0, 0, 0]
                    },
                    alpha: {
                        type: "1f",
                        value: 0
                    },
                    color: {
                        type: "3f",
                        value: [0, 0, 0]
                    },
                    translationMatrix: {
                        type: "mat3",
                        value: new Float32Array(9)
                    },
                    projectionMatrix: {
                        type: "mat3",
                        value: new Float32Array(9)
                    }
                }, {
                    aVertexPosition: 0
                })
            }
            var n = t("./Shader");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i
        }, {
            "./Shader": 57
        }],
        56: [function(t, e, r) {
            function i(t) {
                n.call(this, t, ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;",
                    "uniform mat3 projectionMatrix;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void){", "   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"
                ].join("\n"), ["precision mediump float;", "varying vec4 vColor;", "void main(void){", "   gl_FragColor = vColor;", "}"].join("\n"), {
                    tint: {
                        type: "3f",
                        value: [0, 0, 0]
                    },
                    alpha: {
                        type: "1f",
                        value: 0
                    },
                    translationMatrix: {
                        type: "mat3",
                        value: new Float32Array(9)
                    },
                    projectionMatrix: {
                        type: "mat3",
                        value: new Float32Array(9)
                    }
                }, {
                    aVertexPosition: 0,
                    aColor: 0
                })
            }
            var n = t("./Shader");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i
        }, {
            "./Shader": 57
        }],
        57: [function(t, e, r) {
            function i(t, e, r, i, s) {
                if (!e || !r) throw new Error("Pixi.js Error. Shader requires vertexSrc and fragmentSrc");
                this.uuid = n.uuid(), this.gl = t.renderer.gl, this.shaderManager = t, this.program = null, this.uniforms = i || {}, this.attributes = s || {}, this.textureCount = 1, this.vertexSrc =
                    e, this.fragmentSrc = r, this.init()
            }
            var n = t("../../../utils");
            i.prototype.constructor = i, e.exports = i, i.prototype.init = function() {
                    this.compile(), this.gl.useProgram(this.program), this.cacheUniformLocations(Object.keys(this.uniforms)), this.cacheAttributeLocations(Object.keys(this.attributes))
                }, i.prototype.cacheUniformLocations = function(t) {
                    for (var e = 0; e < t.length; ++e) this.uniforms[t[e]]._location = this.gl.getUniformLocation(this.program, t[e])
                }, i.prototype.cacheAttributeLocations = function(t) {
                    for (var e = 0; e < t.length; ++e) this.attributes[t[e]] =
                        this.gl.getAttribLocation(this.program, t[e])
                }, i.prototype.compile = function() {
                    var t = this.gl,
                        e = this._glCompile(t.VERTEX_SHADER, this.vertexSrc),
                        r = this._glCompile(t.FRAGMENT_SHADER, this.fragmentSrc),
                        i = t.createProgram();
                    return t.attachShader(i, e), t.attachShader(i, r), t.linkProgram(i), t.getProgramParameter(i, t.LINK_STATUS) || (console.error("Pixi.js Error: Could not initialize shader."), console.error("gl.VALIDATE_STATUS", t.getProgramParameter(i, t.VALIDATE_STATUS)), console.error("gl.getError()", t.getError()),
                        "" !== t.getProgramInfoLog(i) && console.warn("Pixi.js Warning: gl.getProgramInfoLog()", t.getProgramInfoLog(i)), t.deleteProgram(i), i = null), t.deleteShader(e), t.deleteShader(r), this.program = i
                }, i.prototype.syncUniform = function(t) {
                    var e, r, i = t._location,
                        s = t.value,
                        o = this.gl;
                    switch (t.type) {
                        case "i":
                        case "1i":
                            o.uniform1i(i, s);
                            break;
                        case "f":
                        case "1f":
                            o.uniform1f(i, s);
                            break;
                        case "2f":
                            o.uniform2f(i, s[0], s[1]);
                            break;
                        case "3f":
                            o.uniform3f(i, s[0], s[1], s[2]);
                            break;
                        case "4f":
                            o.uniform4f(i, s[0], s[1], s[2], s[3]);
                            break;
                        case "v2":
                            o.uniform2f(i, s.x, s.y);
                            break;
                        case "v3":
                            o.uniform3f(i, s.x, s.y, s.z);
                            break;
                        case "v4":
                            o.uniform4f(i, s.x, s.y, s.z, s.w);
                            break;
                        case "1iv":
                            o.uniform1iv(i, s);
                            break;
                        case "2iv":
                            o.uniform2iv(i, s);
                            break;
                        case "3iv":
                            o.uniform3iv(i, s);
                            break;
                        case "4iv":
                            o.uniform4iv(i, s);
                            break;
                        case "1fv":
                            o.uniform1fv(i, s);
                            break;
                        case "2fv":
                            o.uniform2fv(i, s);
                            break;
                        case "3fv":
                            o.uniform3fv(i, s);
                            break;
                        case "4fv":
                            o.uniform4fv(i, s);
                            break;
                        case "m2":
                        case "mat2":
                        case "Matrix2fv":
                            o.uniformMatrix2fv(i, t.transpose, s);
                            break;
                        case "m3":
                        case "mat3":
                        case "Matrix3fv":
                            o.uniformMatrix3fv(i,
                                t.transpose, s);
                            break;
                        case "m4":
                        case "mat4":
                        case "Matrix4fv":
                            o.uniformMatrix4fv(i, t.transpose, s);
                            break;
                        case "c":
                            "number" == typeof s && (s = n.hex2rgb(s)), o.uniform3f(i, s[0], s[1], s[2]);
                            break;
                        case "iv1":
                            o.uniform1iv(i, s);
                            break;
                        case "iv":
                            o.uniform3iv(i, s);
                            break;
                        case "fv1":
                            o.uniform1fv(i, s);
                            break;
                        case "fv":
                            o.uniform3fv(i, s);
                            break;
                        case "v2v":
                            for (t._array || (t._array = new Float32Array(2 * s.length)), e = 0, r = s.length; e < r; ++e) t._array[2 * e] = s[e].x, t._array[2 * e + 1] = s[e].y;
                            o.uniform2fv(i, t._array);
                            break;
                        case "v3v":
                            for (t._array ||
                                (t._array = new Float32Array(3 * s.length)), e = 0, r = s.length; e < r; ++e) t._array[3 * e] = s[e].x, t._array[3 * e + 1] = s[e].y, t._array[3 * e + 2] = s[e].z;
                            o.uniform3fv(i, t._array);
                            break;
                        case "v4v":
                            for (t._array || (t._array = new Float32Array(4 * s.length)), e = 0, r = s.length; e < r; ++e) t._array[4 * e] = s[e].x, t._array[4 * e + 1] = s[e].y, t._array[4 * e + 2] = s[e].z, t._array[4 * e + 3] = s[e].w;
                            o.uniform4fv(i, t._array);
                            break;
                        case "t":
                        case "sampler2D":
                            if (!t.value || !t.value.baseTexture.hasLoaded) break;
                            o.activeTexture(o["TEXTURE" + this.textureCount]);
                            var a = t.value.baseTexture._glTextures[o.id];
                            a || this.initSampler2D(t), o.bindTexture(o.TEXTURE_2D, a), o.uniform1i(t._location, this.textureCount), this.textureCount++;
                            break;
                        default:
                            console.warn("Pixi.js Shader Warning: Unknown uniform type: " + t.type)
                    }
                }, i.prototype.syncUniforms = function() {
                    this.textureCount = 1;
                    for (var t in this.uniforms) this.syncUniform(this.uniforms[t])
                }, i.prototype.initSampler2D = function(t) {
                    var e = this.gl,
                        r = t.value.baseTexture;
                    if (r.hasLoaded)
                        if (t.textureData) {
                            var i = t.textureData;
                            r._glTextures[e.id] = e.createTexture(), e.bindTexture(e.TEXTURE_2D,
                                r._glTextures[e.id]), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultipliedAlpha), e.texImage2D(e.TEXTURE_2D, 0, i.luminance ? e.LUMINANCE : e.RGBA, e.RGBA, e.UNSIGNED_BYTE, r.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, i.magFilter ? i.magFilter : e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE)
                        } else this.shaderManager.renderer.updateTexture(r)
                },
                i.prototype.destroy = function() {
                    this.gl.deleteProgram(this.program), this.gl = null, this.uniforms = null, this.attributes = null, this.vertexSrc = null, this.fragmentSrc = null
                }, i.prototype._glCompile = function(t, e) {
                    var r = this.gl.createShader(t);
                    return this.gl.shaderSource(r, e), this.gl.compileShader(r), this.gl.getShaderParameter(r, this.gl.COMPILE_STATUS) ? r : (console.log(this.gl.getShaderInfoLog(r)), null)
                }
        }, {
            "../../../utils": 72
        }],
        58: [function(t, e, r) {
            function i(t, e, r, s, o) {
                var a = {
                    uSampler: {
                        type: "sampler2D",
                        value: 0
                    },
                    projectionMatrix: {
                        type: "mat3",
                        value: new Float32Array(1, 0, 0, 0, 1, 0, 0, 0, 1)
                    }
                };
                if (s)
                    for (var h in s) a[h] = s[h];
                var u = {
                    aVertexPosition: 0,
                    aTextureCoord: 0,
                    aColor: 0
                };
                if (o)
                    for (var l in o) u[l] = o[l];
                e = e || i.defaultVertexSrc, r = r || i.defaultFragmentSrc, n.call(this, t, e, r, a, u)
            }
            var n = t("./Shader");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i, i.defaultVertexSrc = ["#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "#else", "precision mediump float;", "#endif", "attribute vec2 aVertexPosition;",
                "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform mat3 projectionMatrix;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "void main(void){", "   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"
            ].join("\n"), i.defaultFragmentSrc = ["#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "#else", "precision mediump float;", "#endif", "varying vec2 vTextureCoord;",
                "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void){", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"
            ].join("\n")
        }, {
            "./Shader": 57
        }],
        59: [function(t, e, r) {
            function i(t) {
                n.call(this, t)
            }
            var n = t("../managers/WebGLManager");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i, i.prototype.start = function() {}, i.prototype.stop = function() {
                this.flush()
            }, i.prototype.flush = function() {}, i.prototype.render = function(t) {}
        }, {
            "../managers/WebGLManager": 54
        }],
        60: [function(t, e, r) {
            function i(t) {
                this.gl = t, this.vertices = new Float32Array([0, 0, 200, 0, 200, 200, 0, 200]), this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), this.colors = new Float32Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]), this.indices = new Uint16Array([0, 1, 2, 0, 3, 2]), this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, 128, t.DYNAMIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER,
                    this.indices, t.STATIC_DRAW), this.upload()
            }
            i.prototype.constructor = i, i.prototype.map = function(t, e) {
                    var r = 0,
                        i = 0;
                    this.uvs[0] = r, this.uvs[1] = i, this.uvs[2] = r + e.width / t.width, this.uvs[3] = i, this.uvs[4] = r + e.width / t.width, this.uvs[5] = i + e.height / t.height, this.uvs[6] = r, this.uvs[7] = i + e.height / t.height, r = e.x, i = e.y, this.vertices[0] = r, this.vertices[1] = i, this.vertices[2] = r + e.width, this.vertices[3] = i, this.vertices[4] = r + e.width, this.vertices[5] = i + e.height, this.vertices[6] = r, this.vertices[7] = i + e.height, this.upload()
                },
                i.prototype.upload = function() {
                    var t = this.gl;
                    t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices), t.bufferSubData(t.ARRAY_BUFFER, 32, this.uvs), t.bufferSubData(t.ARRAY_BUFFER, 64, this.colors)
                }, e.exports = i
        }, {}],
        61: [function(t, e, r) {
            var i = t("../../../math"),
                n = t("../../../utils"),
                s = t("../../../const"),
                o = t("./StencilMaskStack"),
                a = function(t, e, r, a, h, u) {
                    if (this.gl = t, this.frameBuffer = null, this.texture = null, this.size = new i.Rectangle(0, 0, 1, 1), this.resolution = h || s.RESOLUTION,
                        this.projectionMatrix = new i.Matrix, this.transform = null, this.frame = null, this.stencilBuffer = null, this.stencilMaskStack = new o, this.filterStack = [{
                            renderTarget: this,
                            filter: [],
                            bounds: this.size
                        }], this.scaleMode = a || s.SCALE_MODES.DEFAULT, this.root = u, !this.root) {
                        this.frameBuffer = t.createFramebuffer(), this.texture = t.createTexture(), t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, a === s.SCALE_MODES.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER,
                            a === s.SCALE_MODES.LINEAR ? t.LINEAR : t.NEAREST);
                        var l = n.isPowerOfTwo(e, r);
                        l ? (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.REPEAT)) : (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE)), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0)
                    }
                    this.resize(e, r)
                };
            a.prototype.constructor = a, e.exports =
                a, a.prototype.clear = function(t) {
                    var e = this.gl;
                    t && e.bindFramebuffer(e.FRAMEBUFFER, this.frameBuffer), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT)
                }, a.prototype.attachStencilBuffer = function() {
                    if (!this.stencilBuffer && !this.root) {
                        var t = this.gl;
                        this.stencilBuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, this.stencilBuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.stencilBuffer), t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, this.size.width *
                            this.resolution, this.size.height * this.resolution)
                    }
                }, a.prototype.activate = function() {
                    var t = this.gl;
                    t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer);
                    var e = this.frame || this.size;
                    this.calculateProjection(e), this.transform && this.projectionMatrix.append(this.transform), t.viewport(0, 0, e.width * this.resolution, e.height * this.resolution)
                }, a.prototype.calculateProjection = function(t) {
                    var e = this.projectionMatrix;
                    e.identity(), this.root ? (e.a = 1 / t.width * 2, e.d = -1 / t.height * 2, e.tx = -1 - t.x * e.a, e.ty = 1 - t.y * e.d) : (e.a = 1 / t.width *
                        2, e.d = 1 / t.height * 2, e.tx = -1 - t.x * e.a, e.ty = -1 - t.y * e.d)
                }, a.prototype.resize = function(t, e) {
                    if (t = 0 | t, e = 0 | e, this.size.width !== t || this.size.height !== e) {
                        if (this.size.width = t, this.size.height = e, !this.root) {
                            var r = this.gl;
                            r.bindTexture(r.TEXTURE_2D, this.texture), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, t * this.resolution, e * this.resolution, 0, r.RGBA, r.UNSIGNED_BYTE, null), this.stencilBuffer && (r.bindRenderbuffer(r.RENDERBUFFER, this.stencilBuffer), r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t * this.resolution, e *
                                this.resolution))
                        }
                        var i = this.frame || this.size;
                        this.calculateProjection(i)
                    }
                }, a.prototype.destroy = function() {
                    var t = this.gl;
                    t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
                }
        }, {
            "../../../const": 18,
            "../../../math": 29,
            "../../../utils": 72,
            "./StencilMaskStack": 62
        }],
        62: [function(t, e, r) {
            function i() {
                this.stencilStack = [], this.reverse = !0, this.count = 0
            }
            i.prototype.constructor = i, e.exports = i
        }, {}],
        63: [function(t, e, r) {
            function i(t) {
                o.call(this), this.anchor =
                    new n.Point, this._texture = null, this._width = 0, this._height = 0, this.tint = 16777215, this.blendMode = u.BLEND_MODES.NORMAL, this.shader = null, this.cachedTint = 16777215, this.texture = t || s.EMPTY
            }
            var n = t("../math"),
                s = t("../textures/Texture"),
                o = t("../display/Container"),
                a = t("../renderers/canvas/utils/CanvasTinter"),
                h = t("../utils"),
                u = t("../const"),
                l = new n.Point;
            i.prototype = Object.create(o.prototype), i.prototype.constructor = i, e.exports = i, Object.defineProperties(i.prototype, {
                width: {
                    get: function() {
                        return this.scale.x *
                            this.texture._frame.width
                    },
                    set: function(t) {
                        this.scale.x = t / this.texture._frame.width, this._width = t
                    }
                },
                height: {
                    get: function() {
                        return this.scale.y * this.texture._frame.height
                    },
                    set: function(t) {
                        this.scale.y = t / this.texture._frame.height, this._height = t
                    }
                },
                texture: {
                    get: function() {
                        return this._texture
                    },
                    set: function(t) {
                        this._texture !== t && (this._texture = t, this.cachedTint = 16777215, t && (t.baseTexture.hasLoaded ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
                    }
                }
            }), i.prototype._onTextureUpdate = function() {
                this._width &&
                    (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
            }, i.prototype._renderWebGL = function(t) {
                t.setObjectRenderer(t.plugins.sprite), t.plugins.sprite.render(this)
            }, i.prototype.getBounds = function(t) {
                if (!this._currentBounds) {
                    var e, r, i, n, s = this._texture._frame.width,
                        o = this._texture._frame.height,
                        a = s * (1 - this.anchor.x),
                        h = s * -this.anchor.x,
                        u = o * (1 - this.anchor.y),
                        l = o * -this.anchor.y,
                        c = t || this.worldTransform,
                        d = c.a,
                        p = c.b,
                        f = c.c,
                        g = c.d,
                        v = c.tx,
                        y = c.ty;
                    if (0 === p && 0 === f) d < 0 && (d *= -1), g < 0 && (g *= -1), e = d * h + v, r = d * a + v, i = g * l + y, n = g * u + y;
                    else {
                        var m = d * h + f * l + v,
                            x = g * l + p * h + y,
                            _ = d * a + f * l + v,
                            E = g * l + p * a + y,
                            b = d * a + f * u + v,
                            T = g * u + p * a + y,
                            S = d * h + f * u + v,
                            w = g * u + p * h + y;
                        e = m, e = _ < e ? _ : e, e = b < e ? b : e, e = S < e ? S : e, i = x, i = E < i ? E : i, i = T < i ? T : i, i = w < i ? w : i, r = m, r = _ > r ? _ : r, r = b > r ? b : r, r = S > r ? S : r, n = x, n = E > n ? E : n, n = T > n ? T : n, n = w > n ? w : n
                    }
                    if (this.children.length) {
                        var R = this.containerGetBounds();
                        a = R.x, h = R.x + R.width, u = R.y, l = R.y + R.height, e = e < a ? e : a, i = i < u ? i : u, r = r > h ? r : h, n = n > l ? n : l
                    }
                    var A = this._bounds;
                    A.x = e, A.width = r - e, A.y = i, A.height =
                        n - i, this._currentBounds = A
                }
                return this._currentBounds
            }, i.prototype.getLocalBounds = function() {
                return this._bounds.x = -this._texture._frame.width * this.anchor.x, this._bounds.y = -this._texture._frame.height * this.anchor.y, this._bounds.width = this._texture._frame.width, this._bounds.height = this._texture._frame.height, this._bounds
            }, i.prototype.containsPoint = function(t) {
                this.worldTransform.applyInverse(t, l);
                var e, r = this._texture._frame.width,
                    i = this._texture._frame.height,
                    n = -r * this.anchor.x;
                return l.x > n && l.x < n +
                    r && (e = -i * this.anchor.y, l.y > e && l.y < e + i)
            }, i.prototype._renderCanvas = function(t) {
                if (!(this.texture.crop.width <= 0 || this.texture.crop.height <= 0) && (this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = t.blendModes[t.currentBlendMode]), this.texture.valid)) {
                    var e, r, i, n, s = this._texture,
                        o = this.worldTransform,
                        h = s.baseTexture.resolution / t.resolution;
                    if (t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.currentScaleMode !== s.baseTexture.scaleMode && (t.currentScaleMode =
                            s.baseTexture.scaleMode, t.context[t.smoothProperty] = t.currentScaleMode === u.SCALE_MODES.LINEAR), s.rotate) {
                        var l = o.a,
                            c = o.b;
                        o.a = -o.c, o.b = -o.d, o.c = l, o.d = c, i = s.crop.height, n = s.crop.width, e = s.trim ? s.trim.y - this.anchor.y * s.trim.height : this.anchor.y * -s._frame.height, r = s.trim ? s.trim.x - this.anchor.x * s.trim.width : this.anchor.x * -s._frame.width
                    } else i = s.crop.width, n = s.crop.height, e = s.trim ? s.trim.x - this.anchor.x * s.trim.width : this.anchor.x * -s._frame.width, r = s.trim ? s.trim.y - this.anchor.y * s.trim.height : this.anchor.y *
                        -s._frame.height;
                    t.roundPixels ? (t.context.setTransform(o.a, o.b, o.c, o.d, o.tx * t.resolution | 0, o.ty * t.resolution | 0), e = 0 | e, r = 0 | r) : t.context.setTransform(o.a, o.b, o.c, o.d, o.tx * t.resolution, o.ty * t.resolution), 16777215 !== this.tint ? (this.cachedTint !== this.tint && (this.cachedTint = this.tint, this.tintedTexture = a.getTintedTexture(this, this.tint)), t.context.drawImage(this.tintedTexture, 0, 0, i * h * t.resolution, n * h * t.resolution, e, r, i * t.resolution, n * t.resolution)) : t.context.drawImage(s.baseTexture.source, s.crop.x * h, s.crop.y *
                        h, i * h * t.resolution, n * h * t.resolution, e, r, i * t.resolution, n * t.resolution)
                }
            }, i.prototype.destroy = function(t, e) {
                o.prototype.destroy.call(this), this.anchor = null, t && this._texture.destroy(e), this._texture = null, this.shader = null
            }, i.fromFrame = function(t) {
                var e = h.TextureCache[t];
                if (!e) throw new Error('The frameId "' + t + '" does not exist in the texture cache');
                return new i(e)
            }, i.fromImage = function(t, e, r) {
                return new i(s.fromImage(t, e, r))
            }
        }, {
            "../const": 18,
            "../display/Container": 19,
            "../math": 29,
            "../renderers/canvas/utils/CanvasTinter": 44,
            "../textures/Texture": 68,
            "../utils": 72
        }],
        64: [function(t, e, r) {
            function i(t) {
                n.call(this, t), this.vertSize = 5, this.vertByteSize = 4 * this.vertSize, this.size = o.SPRITE_BATCH_SIZE;
                var e = 4 * this.size * this.vertByteSize,
                    r = 6 * this.size;
                this.vertices = new ArrayBuffer(e), this.positions = new Float32Array(this.vertices), this.colors = new Uint32Array(this.vertices), this.indices = new Uint16Array(r), this.lastIndexCount = 0;
                for (var i = 0, s = 0; i < r; i += 6, s += 4) this.indices[i + 0] = s + 0, this.indices[i + 1] = s + 1, this.indices[i + 2] = s + 2, this.indices[i +
                    3] = s + 0, this.indices[i + 4] = s + 2, this.indices[i + 5] = s + 3;
                this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.shader = null
            }
            var n = t("../../renderers/webgl/utils/ObjectRenderer"),
                s = t("../../renderers/webgl/WebGLRenderer"),
                o = t("../../const");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i, s.registerPlugin("sprite", i), i.prototype.onContextChange = function() {
                var t = this.renderer.gl;
                this.shader =
                    this.renderer.shaderManager.defaultShader, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999
            }, i.prototype.render = function(t) {
                var e = t._texture;
                this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = e.baseTexture);
                var r =
                    e._uvs;
                if (r) {
                    var i, n, s, o, a = t.anchor.x,
                        h = t.anchor.y;
                    if (e.trim) {
                        var u = e.trim;
                        n = u.x - a * u.width, i = n + e.crop.width, o = u.y - h * u.height, s = o + e.crop.height
                    } else i = e._frame.width * (1 - a), n = e._frame.width * -a, s = e._frame.height * (1 - h), o = e._frame.height * -h;
                    var l = this.currentBatchSize * this.vertByteSize,
                        c = t.worldTransform,
                        d = c.a,
                        p = c.b,
                        f = c.c,
                        g = c.d,
                        v = c.tx,
                        y = c.ty,
                        m = this.colors,
                        x = this.positions;
                    this.renderer.roundPixels ? (x[l] = d * n + f * o + v | 0, x[l + 1] = g * o + p * n + y | 0, x[l + 5] = d * i + f * o + v | 0, x[l + 6] = g * o + p * i + y | 0, x[l + 10] = d * i + f * s + v | 0, x[l + 11] = g *
                        s + p * i + y | 0, x[l + 15] = d * n + f * s + v | 0, x[l + 16] = g * s + p * n + y | 0) : (x[l] = d * n + f * o + v, x[l + 1] = g * o + p * n + y, x[l + 5] = d * i + f * o + v, x[l + 6] = g * o + p * i + y, x[l + 10] = d * i + f * s + v, x[l + 11] = g * s + p * i + y, x[l + 15] = d * n + f * s + v, x[l + 16] = g * s + p * n + y), x[l + 2] = r.x0, x[l + 3] = r.y0, x[l + 7] = r.x1, x[l + 8] = r.y1, x[l + 12] = r.x2, x[l + 13] = r.y2, x[l + 17] = r.x3, x[l + 18] = r.y3;
                    var _ = t.tint;
                    m[l + 4] = m[l + 9] = m[l + 14] = m[l + 19] = (_ >> 16) + (65280 & _) + ((255 & _) << 16) + (255 * t.worldAlpha << 24), this.sprites[this.currentBatchSize++] = t
                }
            }, i.SRVB = [], i.SRVBidx = -1, i.prototype.flush = function() {
                if (0 !== this.currentBatchSize) {
                    var t,
                        e = this.renderer.gl;
                    if (this.currentBatchSize > .5 * this.size) e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices);
                    else if (i.SRVBidx < 0) {
                        var r = this.positions.subarray(0, this.currentBatchSize * this.vertByteSize);
                        e.bufferSubData(e.ARRAY_BUFFER, 0, r)
                    } else {
                        var n = i.SRVB[i.SRVBidx];
                        void 0 == n && (n = e.createBuffer(), i.SRVB.push(n)), i.SRVBidx++, e.bindBuffer(e.ARRAY_BUFFER, n);
                        var s = this.vertByteSize;
                        e.vertexAttribPointer(this.shader.attributes.aVertexPosition, 2, e.FLOAT, !1, s, 0), e.vertexAttribPointer(this.shader.attributes.aTextureCoord,
                            2, e.FLOAT, !1, s, 8), e.vertexAttribPointer(this.shader.attributes.aColor, 4, e.UNSIGNED_BYTE, !0, s, 16);
                        var r = this.positions.subarray(0, this.currentBatchSize * this.vertByteSize);
                        e.bufferData(e.ARRAY_BUFFER, r, e.STATIC_DRAW)
                    }
                    for (var o, a, h, u, l = 0, c = 0, d = null, p = this.renderer.blendModeManager.currentBlendMode, f = null, g = !1, v = !1, y = 0, m = this.currentBatchSize; y < m; y++) u = this.sprites[y], o = u._texture.baseTexture, a = u.blendMode, h = u.shader || this.shader, g = p !== a, v = f !== h, (d !== o || g || v) && (this.renderBatch(d, l, c), c = y, l = 0, d = o, g &&
                        (p = a, this.renderer.blendModeManager.setBlendMode(p)), v && (f = h, t = f.shaders ? f.shaders[e.id] : f, t || (t = f.getShader(this.renderer)), this.renderer.shaderManager.setShader(t), t.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(!0), t.syncUniforms(), e.activeTexture(e.TEXTURE0))), l++;
                    this.renderBatch(d, l, c), this.currentBatchSize = 0
                }
            }, i.prototype.renderBatch = function(t, e, r) {
                if (0 !== e) {
                    var i = this.renderer.gl;
                    t._glTextures[i.id] ? i.bindTexture(i.TEXTURE_2D, t._glTextures[i.id]) :
                        this.renderer.updateTexture(t), i.drawElements(i.TRIANGLES, 6 * e, i.UNSIGNED_SHORT, 6 * r * 2), this.renderer.drawCount++
                }
            }, i.prototype.start = function() {
                var t = this.renderer.gl;
                t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                var e = this.vertByteSize;
                t.vertexAttribPointer(this.shader.attributes.aVertexPosition, 2, t.FLOAT, !1, e, 0), t.vertexAttribPointer(this.shader.attributes.aTextureCoord, 2, t.FLOAT, !1, e, 8), t.vertexAttribPointer(this.shader.attributes.aColor, 4,
                    t.UNSIGNED_BYTE, !0, e, 16)
            }, i.prototype.destroy = function() {
                this.renderer.gl.deleteBuffer(this.vertexBuffer), this.renderer.gl.deleteBuffer(this.indexBuffer), this.shader.destroy(), this.renderer = null, this.vertices = null, this.positions = null, this.colors = null, this.indices = null, this.vertexBuffer = null, this.indexBuffer = null, this.currentBaseTexture = null, this.drawing = !1, this.textures = null, this.blendModes = null, this.shaders = null, this.sprites = null, this.shader = null
            }
        }, {
            "../../const": 18,
            "../../renderers/webgl/WebGLRenderer": 45,
            "../../renderers/webgl/utils/ObjectRenderer": 59
        }],
        65: [function(t, e, r) {
            function i(t, e, r) {
                this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.resolution = r || a.RESOLUTION, this._text = null, this._style = null;
                var i = s.fromCanvas(this.canvas);
                i.trim = new o.Rectangle, n.call(this, i), this.text = t, this.style = e
            }
            var n = t("../sprites/Sprite"),
                s = t("../textures/Texture"),
                o = t("../math"),
                a = t("../const");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i, i.fontPropertiesCache = {}, i.fontPropertiesCanvas = document.createElement("canvas"), i.fontPropertiesContext = i.fontPropertiesCanvas.getContext("2d"), Object.defineProperties(i.prototype, {
                    width: {
                        get: function() {
                            return this.dirty && this.updateText(), this.scale.x * (this._texture._frame.width - this.extraWidthDueToEffects)
                        },
                        set: function(t) {
                            this.scale.x = t / (this._texture._frame.width - this.extraWidthDueToEffects), this._width = t
                        }
                    },
                    height: {
                        get: function() {
                            return this.dirty && this.updateText(), this.scale.y * (this._texture._frame.height - this._hack_extraOffsetTop -
                                this.extraHeightDueToEffects)
                        },
                        set: function(t) {
                            this.scale.y = t / (this._texture._frame.height - this._hack_extraOffsetTop - this.extraHeightDueToEffects), this._height = t
                        }
                    },
                    style: {
                        get: function() {
                            return this._style
                        },
                        set: function(t) {
                            t = t || {}, t.font = t.font || "bold 20pt Arial", t.fill = t.fill || "black", t.align = t.align || "left", t.stroke = t.stroke || "black", t.strokeThickness = t.strokeThickness || 0, t.wordWrap = t.wordWrap || !1, t.wordWrapWidth = t.wordWrapWidth || 100, t.dropShadow = t.dropShadow || !1, t.dropShadowColor = t.dropShadowColor ||
                                "#000000", t.dropShadowAngle = t.dropShadowAngle || Math.PI / 6, t.dropShadowDistance = t.dropShadowDistance || 5, t.blurShadow = t.blurShadow || !1, t.blurShadowX = t.blurShadowX || 5, t.blurShadowY = t.blurShadowY || 5, t.padding = t.padding || 0, t.textBaseline = t.textBaseline || "alphabetic", t.lineJoin = t.lineJoin || "round", t.miterLimit = t.miterLimit || 10, this._style = t, this.dirty = !0
                        }
                    },
                    text: {
                        get: function() {
                            return this._text
                        },
                        set: function(t) {
                            t = t.toString() || " ", this._text !== t && (this._text = t, this.dirty = !0)
                        }
                    }
                }), i.prototype.updateText = function() {
                    var t =
                        this._style;
                    this.context.font = t.font;
                    for (var e = t.wordWrap ? this.wordWrap(this._text) : this._text, r = e.split(/(?:\r\n|\r|\n)/), i = new Array(r.length), n = 0, s = this.determineFontProperties(t.font), o = 0; o < r.length; o++) {
                        var a = this.context.measureText(r[o]).width;
                        i[o] = a, n = Math.max(n, a)
                    }
                    var h = n;
                    this.extraWidthDueToEffects = t.strokeThickness + (this._hack_NoCutFix ? 0 : s.fontSize), t.dropShadow && (this.extraWidthDueToEffects += t.dropShadowDistance), t.blurShadow && (this.extraWidthDueToEffects += Math.max(2 * t.dropShadowDistance +
                        Math.abs(t.blurShadowX), 0)), h += this.extraWidthDueToEffects, this.canvas.width = h * this.resolution;
                    var u = this.style.lineHeight || s.fontSize,
                        l = this.style.spacingY || 0,
                        c = u * r.length + l * (r.length - 1) + s.extraSizeTop;
                    this.extraHeightDueToEffects = t.strokeThickness, t.dropShadow && (this.extraHeightDueToEffects += t.dropShadowDistance), t.blurShadow && (this.extraHeightDueToEffects += Math.max(2 * t.dropShadowDistance + Math.abs(t.blurShadowY), 0)), c += this.extraHeightDueToEffects, this.canvas.height = (c + 2 * this._style.padding) * this.resolution,
                        this.context.scale(this.resolution, this.resolution), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.context.font = t.font, this.context.strokeStyle = t.stroke, this.context.lineWidth = t.strokeThickness, this.context.textBaseline = t.textBaseline, this.context.lineJoin = t.lineJoin, this.context.miterLimit = t.miterLimit;
                    var d, p;
                    if (1 != this._skipUpdateTexture && t.dropShadow) {
                        this.context.fillStyle = t.dropShadowColor;
                        var f = Math.cos(t.dropShadowAngle) * t.dropShadowDistance,
                            g =
                            Math.sin(t.dropShadowAngle) * t.dropShadowDistance;
                        for (o = 0; o < r.length; o++) d = t.strokeThickness / 2 + (this._hack_NoCutFix ? 0 : s.fontSize / 2), p = t.strokeThickness / 2 + o * (u + l) + s.ascent + s.extraSizeTop, "right" === t.align ? d += n - i[o] : "center" === t.align && (d += (n - i[o]) / 2), t.fill && this.context.fillText(r[o], d + f, p + g + this._style.padding)
                    }
                    if (this.context.fillStyle = t.fill, t.blurShadow) {
                        var v = void 0 != window.safari || document.documentElement.className.indexOf("iOS") >= 0 && document.documentElement.className.indexOf("MobileSafari") >=
                            0;
                        this.context.shadowBlur = t.dropShadowDistance * (v ? .66 : 1), this.context.shadowOffsetX = t.blurShadowX, this.context.shadowOffsetY = t.blurShadowY
                    }
                    if (1 != this._skipUpdateTexture)
                        for (o = 0; o < r.length; o++) {
                            if (d = t.strokeThickness / 2 + (this._hack_NoCutFix ? 0 : s.fontSize / 2), p = t.strokeThickness / 2 + o * (u + l) + s.ascent + s.extraSizeTop, t.blurShadow && (this.context.shadowColor = t.dropShadowColor, d += Math.max(t.dropShadowDistance - t.blurShadowX, 0), p += Math.max(t.dropShadowDistance - t.blurShadowY, 0)), t.mFillUseGradient || t.mOutlineUseGradient) {
                                var y =
                                    .5 * u,
                                    m = d + .5 * i[o],
                                    x = t.strokeThickness / 2 + o * (u + l) + y + this._style.padding;
                                t.blurShadow && (x += Math.max(t.dropShadowDistance - t.blurShadowY, 0));
                                var _ = .5 * Math.max(i[o], u),
                                    E = 0,
                                    b = 0,
                                    T = 0,
                                    S = 0;
                                if (t.mFillUseGradient) {
                                    E = Math.cos(t.mFillGradientAngle + Math.PI) * _, T = Math.sin(t.mFillGradientAngle + Math.PI) * _, T = T >= 0 ? Math.min(T, y) : Math.max(T, -y), b = Math.cos(t.mFillGradientAngle) * _, S = Math.sin(t.mFillGradientAngle) * _, S = S >= 0 ? Math.min(S, y) : Math.max(S, -y);
                                    for (var w = this.context.createLinearGradient(m + E, x + T, m + b, x + S), R = 0; R < t.mFillGradient.colorKeys.length; R++) w.addColorStop(t.mFillGradient.colorKeys[R].time,
                                        t.mFillGradient.colorKeys[R].color.rgbAsString());
                                    this.context.fillStyle = w
                                }
                                if (t.mOutlineUseGradient) {
                                    E = Math.cos(t.mOutlineGradientAngle + Math.PI) * _, T = Math.sin(t.mOutlineGradientAngle + Math.PI) * _, T = T >= 0 ? Math.min(T, y) : Math.max(T, -y), b = Math.cos(t.mOutlineGradientAngle) * _, S = Math.sin(t.mOutlineGradientAngle) * _, S = S >= 0 ? Math.min(S, y) : Math.max(S, -y);
                                    for (var A = this.context.createLinearGradient(m + E, x + T, m + b, x + S), M = 0; M < t.mOutlineGradient.colorKeys.length; M++) A.addColorStop(t.mOutlineGradient.colorKeys[M].time, t.mOutlineGradient.colorKeys[M].color.rgbAsString());
                                    this.context.strokeStyle = A
                                }
                            }
                            "right" === t.align ? d += n - i[o] : "center" === t.align && (d += (n - i[o]) / 2), t.stroke && t.strokeThickness && (t.blurShadow && 0 != t.fillCenter && this.context.fillText(r[o], d, p + this._style.padding), this.context.strokeText(r[o], d, p + this._style.padding), this.context.shadowColor = "RGBA(0, 0, 0, 0)"), t.fill && 0 != t.fillCenter && this.context.fillText(r[o], d, p + this._style.padding)
                        }
                    this._hack_extraOffsetTop = s.extraSizeTop, this._hack_extraOffsetBottom = l, this.updateTexture()
                }, i.prototype.updateTexture =
                function() {
                    var t = this._texture;
                    t.baseTexture.hasLoaded = !0, t.baseTexture.resolution = this.resolution, t.baseTexture.width = this.canvas.width / this.resolution, t.baseTexture.height = this.canvas.height / this.resolution, t.crop.width = t._frame.width = this.canvas.width / this.resolution, t.crop.height = t._frame.height = this.canvas.height / this.resolution, t.trim.x = 0, t.trim.y = -this._style.padding, t.trim.width = t._frame.width, t.trim.height = t._frame.height - 2 * this._style.padding, this._width = this.canvas.width / this.resolution,
                        this._height = this.canvas.height / this.resolution, 1 != this._skipUpdateTexture && t.baseTexture.emit("update", t.baseTexture), this.dirty = !1
                }, i.prototype.renderWebGL = function(t) {
                    this.dirty && this.updateText(), n.prototype.renderWebGL.call(this, t)
                }, i.prototype._renderCanvas = function(t) {
                    this.dirty && this.updateText(), n.prototype._renderCanvas.call(this, t)
                }, i.prototype.determineFontProperties = function(t) {
                    var e = i.fontPropertiesCache[t];
                    if (!e) {
                        var r = t.split(" "),
                            n = r[1],
                            s = 0 | r[0].split("px")[0],
                            o = 50,
                            a = "" + o + "px " + n,
                            h = t;
                        if (e = i.fontPropertiesCache[a], void 0 != e) {
                            var u = {};
                            return u.ascent = Math.round(s * e.ascent / o), u.descent = Math.round(s * e.descent / o), u.fontSize = s, u.extraSizeTop = Math.round(s * e.extraSizeTop / o), i.fontPropertiesCache[t] = u, u
                        }
                        t = a, e = {};
                        var l = i.fontPropertiesCanvas,
                            c = i.fontPropertiesContext;
                        c.font = t;
                        var d = Math.ceil(c.measureText("|Mq").width),
                            p = Math.ceil(c.measureText("M").width),
                            f = 2 * p;
                        p = 1.4 * p | 0, l.width = d, l.height = f, c.fillStyle = "#f00", c.fillRect(0, 0, d, f), c.font = t, c.textBaseline = "alphabetic", c.fillStyle = "#000",
                            c.fillText("|MEq", 0, p);
                        var g, v, y = c.getImageData(0, 0, d, f).data,
                            m = y.length,
                            x = 4 * d,
                            _ = 0,
                            E = !1;
                        for (g = 0; g < p; g++) {
                            for (v = 0; v < x; v += 4)
                                if (y[_ + v] < 253) {
                                    E = !0;
                                    break
                                }
                            if (E) break;
                            _ += x
                        }
                        for (e.ascent = p - g + 1, _ = m - x, E = !1, g = f; g > p; g--) {
                            for (v = 0; v < x; v += 4)
                                if (y[_ + v] < 253) {
                                    E = !0;
                                    break
                                }
                            if (E) break;
                            _ -= x
                        }
                        for (e.descent = g - p, e.fontSize = e.ascent + e.descent, c.fillStyle = "#f00", c.fillRect(0, 0, d, f), c.textBaseline = "alphabetic", c.fillStyle = "#000", c.fillText("|Mq", 0, p), y = c.getImageData(0, 0, d, f).data, m = y.length, _ = 0, E = !1, g = 0; g < p; g++) {
                            for (v = 0; v < x; v +=
                                4)
                                if (y[_ + v] < 253) {
                                    E = !0;
                                    break
                                }
                            if (E) break;
                            _ += x
                        }
                        if (e.extraSizeTop = p - g - e.ascent, i.fontPropertiesCache[t] = e, t != h) return this.determineFontProperties(h)
                    }
                    return e
                }, i.prototype.wordWrap = function(t) {
                    for (var e = "", r = t.split("\n"), i = this._style.wordWrapWidth, n = 0; n < r.length; n++) {
                        for (var s = i, o = r[n].split(" "), a = 0; a < o.length; a++) {
                            var h = this.context.measureText(o[a]).width,
                                u = h + this.context.measureText(" ").width;
                            0 === a || u > s ? (a > 0 && (e += "\n"), e += o[a], s = i - h) : (s -= u, e += " " + o[a])
                        }
                        n < r.length - 1 && (e += "\n")
                    }
                    return e
                }, i.prototype.getBounds =
                function(t) {
                    return this.dirty && this.updateText(), n.prototype.getBounds.call(this, t)
                }, i.prototype.destroy = function(t) {
                    this.context = null, this.canvas = null, this._style = null, this._texture.destroy(void 0 === t || t)
                }
        }, {
            "../const": 18,
            "../math": 29,
            "../sprites/Sprite": 63,
            "../textures/Texture": 68
        }],
        66: [function(t, e, r) {
            function i(t, e, r) {
                o.call(this), this.uuid = n.uuid(), this.resolution = r || 1, this.width = 100, this.height = 100, this.realWidth = 100, this.realHeight = 100, this.scaleMode = e || s.SCALE_MODES.DEFAULT, this.hasLoaded = !1, this.isLoading = !1, this.source = null, this.premultipliedAlpha = !0, this.imageUrl = null, this.isPowerOfTwo = !1, this.mipmap = !1, this._glTextures = [], this.hasAlpha = !0, t && this.loadSource(t)
            }
            var n = t("../utils"),
                s = t("../const"),
                o = t("eventemitter3");
            i.prototype = Object.create(o.prototype), i.prototype.constructor = i, e.exports = i, i.prototype.update = function() {
                this.realWidth = this.source.naturalWidth || this.source.width, this.realHeight = this.source.naturalHeight || this.source.height, this.width = this.realWidth / this.resolution,
                    this.height = this.realHeight / this.resolution, this.isPowerOfTwo = n.isPowerOfTwo(this.realWidth, this.realHeight), this.emit("update", this)
            }, i.prototype.loadSource = function(t) {
                var e = this.isLoading;
                if (this.hasLoaded = !1, this.isLoading = !1, e && this.source && (this.source.onload = null, this.source.onerror = null), this.source = t, (this.source.complete || this.source.getContext) && this.source.width && this.source.height) this._sourceLoaded();
                else if (!t.getContext) {
                    this.isLoading = !0;
                    var r = this;
                    t.onload = function() {
                        t.onload = null,
                            t.onerror = null, r.isLoading && (r.isLoading = !1, r._sourceLoaded(), r.emit("loaded", r))
                    }, t.onerror = function() {
                        t.onload = null, t.onerror = null, r.isLoading && (r.isLoading = !1, r.emit("error", r))
                    }, t.complete && t.src && (this.isLoading = !1, t.onload = null, t.onerror = null, t.width && t.height ? (this._sourceLoaded(), e && this.emit("loaded", this)) : e && this.emit("error", this))
                }
            }, i.prototype._sourceLoaded = function() {
                this.hasLoaded = !0, this.update()
            }, i.prototype.destroy = function() {
                this.imageUrl ? (delete n.BaseTextureCache[this.imageUrl],
                    delete n.TextureCache[this.imageUrl], this.imageUrl = null, navigator.isCocoonJS || (this.source.src = "")) : this.source && this.source._pixiId && delete n.BaseTextureCache[this.source._pixiId], this.source = null, this.dispose()
            }, i.prototype.dispose = function() {
                this.emit("dispose", this), this._glTextures.length = 0
            }, i.prototype.updateSourceImage = function(t) {
                this.source.src = t, this.loadSource(this.source)
            }, b64_keys = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", b64_cached = [];
            for (var a = 0; a < 256; a++) b64_cached.push(b64_keys.indexOf(String.fromCharCode(a)));
            b64toBlob = function(t, e, r) {
                e = e || "";
                var i, n, s, o, a, h, u, l, c = Math.ceil((t.length - r) / 4 * 3),
                    d = 0,
                    p = r,
                    i = null,
                    f = [],
                    g = 196608,
                    v = 0;
                for (d = 0; d < c; d += 3) d % g || (i = new Uint8Array(Math.min(g, c - d)), f.push(i), v = 0), a = b64_cached[t.charCodeAt(p++)], h = b64_cached[t.charCodeAt(p++)], u = b64_cached[t.charCodeAt(p++)], l = b64_cached[t.charCodeAt(p++)], n = a << 2 | h >> 4, s = (15 & h) << 4 | u >> 2, o = (3 & u) << 6 | l, i[v++] = n, i[v++] = s, i[v++] = o;
                return new Blob(f, {
                    type: e
                })
            }, i.fromImage = function(t, e, r) {
                void 0 === e && 0 !== t.indexOf("data:") && (e = !0);
                var n = new Image;
                e && (n.crossOrigin = "");
                var s = new i(n, r),
                    o = void 0 != window.atob && void 0 != window.Blob && void 0 != window.XMLHttpRequest && void 0 != window.URL && 1 != window.UHT_IMAGESLOADER_NOBLOBS && !(navigator.userAgent.indexOf("UCBrowser") > -1);
                if (o)
                    if ("data:image/png" == t.slice(0, 14)) {
                        var a = b64toBlob(t, "image/png", 22),
                            h = URL.createObjectURL(a);
                        n.src = h
                    } else if ("data:image/jpeg" == t.slice(0, 15)) {
                    s.hasAlpha = !1;
                    var u = b64toBlob(t, "image/jpeg", 23),
                        l = URL.createObjectURL(u);
                    n.src = l
                } else {
                    ".jpg" == t.slice(t.length - 4, t.length) && (this.hasAlpha = !1);
                    var c = n;
                    c.downloadSizeLoaded = -1, c.downloadSizeTotal = -1;
                    var d = new XMLHttpRequest;
                    d.open("GET", t, !0), d.responseType = "arraybuffer", d.onload = function(t) {
                        c.downloadSizeLoaded = c.downloadSizeTotal;
                        var e = new Blob([this.response]);
                        c.src = window.URL.createObjectURL(e)
                    }, d.onprogress = function(t) {
                        c.downloadSizeLoaded = t.loaded, c.downloadSizeTotal = t.total
                    }, d.onloadstart = function() {
                        c.downloadSizeLoaded = 0
                    }, d.send()
                } else "data:image/jpeg" == t.slice(0, 15) && (this.hasAlpha = !1), ".jpg" == t.slice(t.length - 4, t.length) && (this.hasAlpha = !1), n.src = t;
                return s.resolution = 1, s
            }, i.fromCanvas = function(t, e) {
                t._pixiId || (t._pixiId = "canvas_" + n.uuid());
                var r = n.BaseTextureCache[t._pixiId];
                return r || (r = new i(t, e), n.BaseTextureCache[t._pixiId] = r), r
            }
        }, {
            "../const": 18,
            "../utils": 72,
            eventemitter3: 6
        }],
        67: [function(t, e, r) {
            function i(t, e, r, i, c) {
                if (!t) throw new Error("Unable to create RenderTexture, you must pass a renderer into the constructor.");
                e = e || 100, r = r || 100, c = c || l.RESOLUTION;
                var d = new n;
                if (d.width = e, d.height = r, d.resolution = c, d.scaleMode = i || l.SCALE_MODES.DEFAULT,
                    d.hasLoaded = !0, s.call(this, d, new u.Rectangle(0, 0, e, r)), this.width = e, this.height = r, this.resolution = c, this.render = null, this.renderer = t, this.renderer.type === l.RENDERER_TYPE.WEBGL) {
                    var p = this.renderer.gl;
                    this.textureBuffer = new o(p, this.width, this.height, d.scaleMode, this.resolution), this.baseTexture._glTextures[p.id] = this.textureBuffer.texture, this.filterManager = new a(this.renderer), this.filterManager.onContextChange(), this.filterManager.resize(e, r), this.render = this.renderWebGL, this.renderer.currentRenderer.start(),
                        this.renderer.currentRenderTarget.activate()
                } else this.render = this.renderCanvas, this.textureBuffer = new h(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
                this.valid = !0, this._updateUvs()
            }
            var n = t("./BaseTexture"),
                s = t("./Texture"),
                o = t("../renderers/webgl/utils/RenderTarget"),
                a = t("../renderers/webgl/managers/FilterManager"),
                h = t("../renderers/canvas/utils/CanvasBuffer"),
                u = t("../math"),
                l = t("../const"),
                c = new u.Matrix;
            i.prototype = Object.create(s.prototype),
                i.prototype.constructor = i, e.exports = i, i.prototype.resize = function(t, e, r) {
                    t === this.width && e === this.height || (this.valid = t > 0 && e > 0, this.width = this._frame.width = this.crop.width = t, this.height = this._frame.height = this.crop.height = e, r && (this.baseTexture.width = this.width, this.baseTexture.height = this.height), this.valid && (this.textureBuffer.resize(this.width * this.resolution, this.height * this.resolution), this.filterManager && this.filterManager.resize(this.width, this.height)))
                }, i.prototype.clear = function() {
                    this.valid &&
                        (this.renderer.type === l.RENDERER_TYPE.WEBGL && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear())
                }, i.prototype.renderWebGL = function(t, e, r, i) {
                    if (this.valid) {
                        if (i = void 0 === i || i, this.textureBuffer.transform = e, this.textureBuffer.activate(), t.worldAlpha = t.alpha, i) {
                            t.worldTransform.identity(), t.currentBounds = null;
                            var n, s, o = t.children;
                            for (n = 0, s = o.length; n < s; ++n) o[n].updateTransform()
                        }
                        var a = this.renderer.filterManager;
                        this.renderer.filterManager =
                            this.filterManager, this.renderer.renderDisplayObject(t, this.textureBuffer, r), this.renderer.filterManager = a
                    }
                }, i.prototype.renderCanvas = function(t, e, r, i) {
                    if (this.valid) {
                        i = !!i;
                        var n = t.worldTransform,
                            s = c;
                        s.identity(), e && s.append(e), t.worldTransform = s, t.worldAlpha = 1;
                        var o, a, h = t.children;
                        for (o = 0, a = h.length; o < a; ++o) h[o].updateTransform();
                        r && this.textureBuffer.clear(), t.worldTransform = n;
                        var u = this.textureBuffer.context,
                            l = this.renderer.resolution;
                        this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t,
                            u), this.renderer.resolution = l
                    }
                }, i.prototype.destroy = function() {
                    s.prototype.destroy.call(this, !0), this.textureBuffer.destroy(), this.filterManager && this.filterManager.destroy(), this.renderer = null
                }, i.prototype.getImage = function() {
                    var t = new Image;
                    return t.src = this.getBase64(), t
                }, i.prototype.getBase64 = function() {
                    return this.getCanvas().toDataURL()
                }, i.prototype.getCanvas = function() {
                    if (this.renderer.type === l.RENDERER_TYPE.WEBGL) {
                        var t = this.renderer.gl,
                            e = this.textureBuffer.size.width,
                            r = this.textureBuffer.size.height,
                            i = new Uint8Array(4 * e * r);
                        t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer), t.readPixels(0, 0, e, r, t.RGBA, t.UNSIGNED_BYTE, i), t.bindFramebuffer(t.FRAMEBUFFER, null);
                        var n = new h(e, r),
                            s = n.context.getImageData(0, 0, e, r);
                        return s.data.set(i), n.context.putImageData(s, 0, 0), n.canvas
                    }
                    return this.textureBuffer.canvas
                }, i.prototype.getPixels = function() {
                    var t, e;
                    if (this.renderer.type === l.RENDERER_TYPE.WEBGL) {
                        var r = this.renderer.gl;
                        t = this.textureBuffer.size.width, e = this.textureBuffer.size.height;
                        var i = new Uint8Array(4 *
                            t * e);
                        return r.bindFramebuffer(r.FRAMEBUFFER, this.textureBuffer.frameBuffer), r.readPixels(0, 0, t, e, r.RGBA, r.UNSIGNED_BYTE, i), r.bindFramebuffer(r.FRAMEBUFFER, null), i
                    }
                    return t = this.textureBuffer.canvas.width, e = this.textureBuffer.canvas.height, this.textureBuffer.canvas.getContext("2d").getImageData(0, 0, t, e).data
                }, i.prototype.getPixel = function(t, e) {
                    if (this.renderer.type === l.RENDERER_TYPE.WEBGL) {
                        var r = this.renderer.gl,
                            i = new Uint8Array(4);
                        return r.bindFramebuffer(r.FRAMEBUFFER, this.textureBuffer.frameBuffer),
                            r.readPixels(t, e, 1, 1, r.RGBA, r.UNSIGNED_BYTE, i), r.bindFramebuffer(r.FRAMEBUFFER, null), i
                    }
                    return this.textureBuffer.canvas.getContext("2d").getImageData(t, e, 1, 1).data
                }, i.prototype.setPixels = function(t) {
                    this.renderer.type !== l.RENDERER_TYPE.WEBGL && this.textureBuffer.canvas.getContext("2d").putImageData(t, 0, 0)
                }
        }, {
            "../const": 18,
            "../math": 29,
            "../renderers/canvas/utils/CanvasBuffer": 41,
            "../renderers/webgl/managers/FilterManager": 50,
            "../renderers/webgl/utils/RenderTarget": 61,
            "./BaseTexture": 66,
            "./Texture": 68
        }],
        68: [function(t, e, r) {
            function i(t, e, r, n, s) {
                if (a.call(this), this.noFrame = !1, e || (this.noFrame = !0, e = new h.Rectangle(0, 0, 1, 1)), t instanceof i && (t = t.baseTexture), this.baseTexture = t, this._frame = e, this.trim = n, this.valid = !1, this.requiresUpdate = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = r || e, this._rotate = +(s || 0), s === !0) this._rotate = 2;
                else if (this._rotate % 2 !== 0) throw "attempt to use diamond-shaped UVs. If you are sure, set rotation manually";
                t.hasLoaded ? (this.noFrame && (e = new h.Rectangle(0, 0, t.width,
                    t.height), t.on("update", this.onBaseTextureUpdated, this)), this.frame = e) : t.once("loaded", this.onBaseTextureLoaded, this)
            }
            var n = t("./BaseTexture"),
                s = t("./VideoBaseTexture"),
                o = t("./TextureUvs"),
                a = t("eventemitter3"),
                h = t("../math"),
                u = t("../utils");
            i.prototype = Object.create(a.prototype), i.prototype.constructor = i, e.exports = i, Object.defineProperties(i.prototype, {
                    frame: {
                        get: function() {
                            return this._frame
                        },
                        set: function(t) {
                            if (this._frame = t, this.noFrame = !1, this.width = t.width, this.height = t.height, !this.trim && !this.rotate &&
                                (t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                            this.valid = t && t.width && t.height && this.baseTexture.hasLoaded, this.trim ? (this.width = this.trim.width, this.height = this.trim.height, this._frame.width = this.trim.width, this._frame.height = this.trim.height) : this.crop = t, this.valid && this._updateUvs()
                        }
                    },
                    rotate: {
                        get: function() {
                            return this._rotate
                        },
                        set: function(t) {
                            this._rotate = t, this.valid && this._updateUvs()
                        }
                    }
                }),
                i.prototype.update = function() {
                    this.baseTexture.update()
                }, i.prototype.onBaseTextureLoaded = function(t) {
                    this.noFrame ? this.frame = new h.Rectangle(0, 0, t.width, t.height) : this.frame = this._frame, this.emit("update", this)
                }, i.prototype.onBaseTextureUpdated = function(t) {
                    this._frame.width = t.width, this._frame.height = t.height, this.emit("update", this)
                }, i.prototype.destroy = function(t) {
                    this.baseTexture && (t && this.baseTexture.destroy(), this.baseTexture.off("update", this.onBaseTextureUpdated), this.baseTexture.off("loaded",
                        this.onBaseTextureLoaded), this.baseTexture = null), this._frame = null, this._uvs = null, this.trim = null, this.crop = null, this.valid = !1
                }, i.prototype.clone = function() {
                    return new i(this.baseTexture, this.frame, this.crop, this.trim, this.rotate)
                }, i.prototype._updateUvs = function() {
                    this._uvs || (this._uvs = new o), this._uvs.set(this.crop, this.baseTexture, this.rotate)
                }, i.fromImage = function(t, e, r, s) {
                    if (void 0 != s) {
                        var o = u.TextureCache[s];
                        if (!o) {
                            var o = new i(n.fromImage(t, e, r));
                            u.TextureCache[s] = o
                        }
                        return o
                    }
                    return new i(n.fromImage(t,
                        e, r))
                }, i.fromFrame = function(t) {
                    var e = u.TextureCache[t];
                    if (!e) throw new Error('The frameId "' + t + '" does not exist in the texture cache');
                    return e
                }, i.fromCanvas = function(t, e) {
                    return new i(n.fromCanvas(t, e))
                }, i.fromVideo = function(t, e) {
                    return "string" == typeof t ? i.fromVideoUrl(t, e) : new i(s.fromVideo(t, e))
                }, i.fromVideoUrl = function(t, e) {
                    return new i(s.fromUrl(t, e))
                }, i.addTextureToCache = function(t, e) {
                    u.TextureCache[e] = t
                }, i.removeTextureFromCache = function(t) {
                    var e = u.TextureCache[t];
                    return delete u.TextureCache[t],
                        delete u.BaseTextureCache[t], e
                }, i.EMPTY = new i(new n)
        }, {
            "../math": 29,
            "../utils": 72,
            "./BaseTexture": 66,
            "./TextureUvs": 69,
            "./VideoBaseTexture": 70,
            eventemitter3: 6
        }],
        69: [function(t, e, r) {
            function i() {
                this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1
            }
            e.exports = i;
            var n = t("../math/GroupD8");
            i.prototype.set = function(t, e, r) {
                var i = e.width,
                    s = e.height;
                if (r) {
                    var o = n.isSwapWidthHeight(r),
                        a = (o ? t.height : t.width) / 2 / i,
                        h = (o ? t.width : t.height) / 2 / s,
                        u = t.x / i + a,
                        l = t.y / s + h;
                    r = n.add(r, n.NW), this.x0 =
                        u + a * n.uX(r), this.y0 = l + h * n.uY(r), r = n.add(r, 2), this.x1 = u + a * n.uX(r), this.y1 = l + h * n.uY(r), r = n.add(r, 2), this.x2 = u + a * n.uX(r), this.y2 = l + h * n.uY(r), r = n.add(r, 2), this.x3 = u + a * n.uX(r), this.y3 = l + h * n.uY(r)
                } else this.x0 = t.x / i, this.y0 = t.y / s, this.x1 = (t.x + t.width) / i, this.y1 = t.y / s, this.x2 = (t.x + t.width) / i, this.y2 = (t.y + t.height) / s, this.x3 = t.x / i, this.y3 = (t.y + t.height) / s
            }
        }, {
            "../math/GroupD8": 26
        }],
        70: [function(t, e, r) {
            function i(t, e) {
                if (!t) throw new Error("No video source element specified.");
                (t.readyState === t.HAVE_ENOUGH_DATA ||
                    t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0), s.call(this, t, e), this.autoUpdate = !1, this._onUpdate = this._onUpdate.bind(this), this._onCanPlay = this._onCanPlay.bind(this), t.complete || (t.addEventListener("canplay", this._onCanPlay), t.addEventListener("canplaythrough", this._onCanPlay), t.addEventListener("play", this._onPlayStart.bind(this)), t.addEventListener("pause", this._onPlayStop.bind(this))), this.__loaded = !1
            }

            function n(t, e) {
                e || (e = "video/" + t.substr(t.lastIndexOf(".") + 1));
                var r =
                    document.createElement("source");
                return r.src = t, r.type = e, r
            }
            var s = t("./BaseTexture"),
                o = t("../utils");
            i.prototype = Object.create(s.prototype), i.prototype.constructor = i, e.exports = i, i.prototype._onUpdate = function() {
                this.autoUpdate && (window.requestAnimationFrame(this._onUpdate), this.update())
            }, i.prototype._onPlayStart = function() {
                this.autoUpdate || (window.requestAnimationFrame(this._onUpdate), this.autoUpdate = !0)
            }, i.prototype._onPlayStop = function() {
                this.autoUpdate = !1
            }, i.prototype._onCanPlay = function() {
                this.hasLoaded = !0, this.source && (this.source.removeEventListener("canplay", this._onCanPlay), this.source.removeEventListener("canplaythrough", this._onCanPlay), this.width = this.source.videoWidth, this.height = this.source.videoHeight, this.source.play(), this.__loaded || (this.__loaded = !0, this.emit("loaded", this)))
            }, i.prototype.destroy = function() {
                this.source && this.source._pixiId && (delete o.BaseTextureCache[this.source._pixiId], delete this.source._pixiId), s.prototype.destroy.call(this)
            }, i.fromVideo = function(t, e) {
                t._pixiId ||
                    (t._pixiId = "video_" + o.uuid());
                var r = o.BaseTextureCache[t._pixiId];
                return r || (r = new i(t, e), o.BaseTextureCache[t._pixiId] = r), r
            }, i.fromUrl = function(t, e) {
                var r = document.createElement("video");
                if (Array.isArray(t))
                    for (var s = 0; s < t.length; ++s) r.appendChild(n(t.src || t, t.mime));
                else r.appendChild(n(t.src || t, t.mime));
                return r.load(), r.play(), i.fromVideo(r, e)
            }, i.fromUrls = i.fromUrl
        }, {
            "../utils": 72,
            "./BaseTexture": 66
        }],
        71: [function(t, e, r) {
            var i = e.exports = {};
            i.Triangulate = function(t) {
                    var e = !0,
                        r = t.length >> 1;
                    if (r <
                        3) return [];
                    for (var n = [], s = [], o = 0; o < r; o++) s.push(o);
                    o = 0;
                    for (var a = r; a > 3;) {
                        var h = s[(o + 0) % a],
                            u = s[(o + 1) % a],
                            l = s[(o + 2) % a],
                            c = t[2 * h],
                            d = t[2 * h + 1],
                            p = t[2 * u],
                            f = t[2 * u + 1],
                            g = t[2 * l],
                            v = t[2 * l + 1],
                            y = !1;
                        if (i._convex(c, d, p, f, g, v, e)) {
                            y = !0;
                            for (var m = 0; m < a; m++) {
                                var x = s[m];
                                if (x !== h && x !== u && x !== l && i._PointInTriangle(t[2 * x], t[2 * x + 1], c, d, p, f, g, v)) {
                                    y = !1;
                                    break
                                }
                            }
                        }
                        if (y) n.push(h, u, l), s.splice((o + 1) % a, 1), a--, o = 0;
                        else if (o++ > 3 * a) {
                            if (!e) return null;
                            for (n = [], s = [], o = 0; o < r; o++) s.push(o);
                            o = 0, a = r, e = !1
                        }
                    }
                    return n.push(s[0], s[1], s[2]), n
                }, i._PointInTriangle =
                function(t, e, r, i, n, s, o, a) {
                    var h = o - r,
                        u = a - i,
                        l = n - r,
                        c = s - i,
                        d = t - r,
                        p = e - i,
                        f = h * h + u * u,
                        g = h * l + u * c,
                        v = h * d + u * p,
                        y = l * l + c * c,
                        m = l * d + c * p,
                        x = 1 / (f * y - g * g),
                        _ = (y * v - g * m) * x,
                        E = (f * m - g * v) * x;
                    return _ >= 0 && E >= 0 && _ + E < 1
                }, i._convex = function(t, e, r, i, n, s, o) {
                    return (e - i) * (n - r) + (r - t) * (s - i) >= 0 === o
                }
        }, {}],
        72: [function(t, e, r) {
            var i = t("../const"),
                n = e.exports = {
                    _uid: 0,
                    _saidHello: !1,
                    pluginTarget: t("./pluginTarget"),
                    PolyK: t("./PolyK"),
                    async: t("async"),
                    uuid: function() {
                        return ++n._uid
                    },
                    hex2rgb: function(t, e) {
                        return e = e || [], e[0] = (t >> 16 & 255) / 255, e[1] = (t >>
                            8 & 255) / 255, e[2] = (255 & t) / 255, e
                    },
                    hex2string: function(t) {
                        return t = t.toString(16), t = "000000".substr(0, 6 - t.length) + t, "#" + t
                    },
                    rgb2hex: function(t) {
                        return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
                    },
                    canUseNewCanvasBlendModes: function() {
                        if ("undefined" == typeof document) return !1;
                        var t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",
                            e = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
                            r = new Image;
                        r.src = t + "AP804Oa6" + e;
                        var i = new Image;
                        i.src = t + "/wCKxvRF" + e;
                        var n = document.createElement("canvas");
                        n.width = 6, n.height = 1;
                        var s = n.getContext("2d");
                        s.globalCompositeOperation = "multiply", s.drawImage(r, 0, 0), s.drawImage(i, 2, 0);
                        var o = s.getImageData(2, 0, 1, 1).data;
                        return 255 === o[0] && 0 === o[1] && 0 === o[2]
                    },
                    getNextPowerOfTwo: function(t) {
                        if (t > 0 && 0 === (t & t - 1)) return t;
                        for (var e = 1; e < t;) e <<= 1;
                        return e
                    },
                    isPowerOfTwo: function(t, e) {
                        return t > 0 && 0 === (t & t - 1) && e > 0 && 0 === (e & e - 1)
                    },
                    getResolutionOfUrl: function(t) {
                        var e = i.RETINA_PREFIX.exec(t);
                        return e ? parseFloat(e[1]) : 1
                    },
                    sayHello: function(t) {
                        if (!n._saidHello) {
                            if (navigator.userAgent.toLowerCase().indexOf("chrome") >
                                -1) {
                                var e = ["\n %c %c %c Pixi.js " + i.VERSION + " -  " + t + "   %c  %c  http://www.pixijs.com/  %c %c %c%c \n\n", "background: #ff66a5; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff66a5; background: #030307; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "background: #ffc3dc; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;"];
                                window.console.log.apply(console, e)
                            } else window.console && window.console.log("Pixi.js " + i.VERSION + " - " + t + " - http://www.pixijs.com/");
                            n._saidHello = !0
                        }
                    },
                    isWebGLSupported: function() {
                        var t = {
                            stencil: !0
                        };
                        try {
                            if (!window.WebGLRenderingContext) return !1;
                            var e = document.createElement("canvas"),
                                r = e.getContext("webgl", t) || e.getContext("experimental-webgl", t);
                            return !(!r || !r.getContextAttributes().stencil)
                        } catch (i) {
                            return !1
                        }
                    },
                    TextureCache: {},
                    BaseTextureCache: {}
                }
        }, {
            "../const": 18,
            "./PolyK": 71,
            "./pluginTarget": 73,
            async: 2
        }],
        73: [function(t, e, r) {
            function i(t) {
                t.__plugins = {}, t.registerPlugin = function(e, r) {
                    t.__plugins[e] = r
                }, t.prototype.initPlugins = function() {
                    this.plugins = this.plugins || {};
                    for (var e in t.__plugins) this.plugins[e] = new t.__plugins[e](this)
                }, t.prototype.destroyPlugins = function() {
                    for (var t in this.plugins) this.plugins[t].destroy(), this.plugins[t] = null;
                    this.plugins = null
                }
            }
            e.exports = {
                mixin: function(t) {
                    i(t)
                }
            }
        }, {}],
        74: [function(t, e, r) {
            var i = t("./core"),
                n = t("./mesh"),
                s = t("./extras"),
                o = t("./core/utils");
            i.SpriteBatch =
                function() {
                    throw new ReferenceError("SpriteBatch does not exist any more, please use the new ParticleContainer instead.");
                }, i.AssetLoader = function() {
                    throw new ReferenceError("The loader system was overhauled in pixi v3, please see the new PIXI.loaders.Loader class.");
                }, Object.defineProperties(i, {
                    Stage: {
                        get: function() {
                            return console.warn("You do not need to use a PIXI Stage any more, you can simply render any container."), i.Container
                        }
                    },
                    DisplayObjectContainer: {
                        get: function() {
                            return console.warn("DisplayObjectContainer has been shortened to Container, please use Container from now on."),
                                i.Container
                        }
                    },
                    Strip: {
                        get: function() {
                            return console.warn("The Strip class has been renamed to Mesh and moved to mesh.Mesh, please use mesh.Mesh from now on."), n.Mesh
                        }
                    },
                    Rope: {
                        get: function() {
                            return console.warn("The Rope class has been moved to mesh.Rope, please use mesh.Rope from now on."), n.Rope
                        }
                    },
                    MovieClip: {
                        get: function() {
                            return console.warn("The MovieClip class has been moved to extras.MovieClip, please use extras.MovieClip from now on."), s.MovieClip
                        }
                    },
                    TilingSprite: {
                        get: function() {
                            return console.warn("The TilingSprite class has been moved to extras.TilingSprite, please use extras.TilingSprite from now on."),
                                s.TilingSprite
                        }
                    },
                    BitmapText: {
                        get: function() {
                            return console.warn("The BitmapText class has been moved to extras.BitmapText, please use extras.BitmapText from now on."), s.BitmapText
                        }
                    },
                    blendModes: {
                        get: function() {
                            return console.warn("The blendModes has been moved to BLEND_MODES, please use BLEND_MODES from now on."), i.BLEND_MODES
                        }
                    },
                    scaleModes: {
                        get: function() {
                            return console.warn("The scaleModes has been moved to SCALE_MODES, please use SCALE_MODES from now on."), i.SCALE_MODES
                        }
                    },
                    BaseTextureCache: {
                        get: function() {
                            return console.warn("The BaseTextureCache class has been moved to utils.BaseTextureCache, please use utils.BaseTextureCache from now on."),
                                o.BaseTextureCache
                        }
                    },
                    TextureCache: {
                        get: function() {
                            return console.warn("The TextureCache class has been moved to utils.TextureCache, please use utils.TextureCache from now on."), o.TextureCache
                        }
                    }
                }), i.Sprite.prototype.setTexture = function(t) {
                    this.texture = t, console.warn("setTexture is now deprecated, please use the texture property, e.g : sprite.texture = texture;")
                }, s.BitmapText.prototype.setText = function(t) {
                    this.text = t, console.warn("setText is now deprecated, please use the text property, e.g : myBitmapText.text = 'my text';")
                },
                i.Text.prototype.setText = function(t) {
                    this.text = t, console.warn("setText is now deprecated, please use the text property, e.g : myText.text = 'my text';")
                }, i.Text.prototype.setStyle = function(t) {
                    this.style = t, console.warn("setStyle is now deprecated, please use the style property, e.g : myText.style = style;")
                }, i.Texture.prototype.setFrame = function(t) {
                    this.frame = t, console.warn("setFrame is now deprecated, please use the frame property, e.g : myTexture.frame = frame;")
                }
        }, {
            "./core": 25,
            "./core/utils": 72,
            "./extras": 81,
            "./mesh": 93
        }],
        75: [function(t, e, r) {
            function i(t, e) {
                n.Container.call(this), e = e || {}, this.textWidth = 0, this.textHeight = 0, this._glyphs = [], this._font = {
                    tint: void 0 !== e.tint ? e.tint : 16777215,
                    align: e.align || "left",
                    name: null,
                    size: 0
                }, this.font = e.font, this._text = t, this.maxWidth = 0, this.dirty = !1, this.updateText()
            }
            var n = t("../core");
            i.prototype = Object.create(n.Container.prototype), i.prototype.constructor = i, e.exports = i, Object.defineProperties(i.prototype, {
                tint: {
                    get: function() {
                        return this._font.tint
                    },
                    set: function(t) {
                        this._font.tint = "number" == typeof t && t >= 0 ? t : 16777215, this.dirty = !0
                    }
                },
                align: {
                    get: function() {
                        return this._font.align
                    },
                    set: function(t) {
                        this._font.align = t || "left", this.dirty = !0
                    }
                },
                font: {
                    get: function() {
                        return this._font
                    },
                    set: function(t) {
                        t && ("string" == typeof t ? (t = t.split(" "), this._font.name = 1 === t.length ? t[0] : t.slice(1).join(" "), this._font.size = t.length >= 2 ? parseInt(t[0], 10) : i.fonts[this._font.name].size) : (this._font.name = t.name, this._font.size = "number" == typeof t.size ? t.size : parseInt(t.size,
                            10)), this.dirty = !0)
                    }
                },
                text: {
                    get: function() {
                        return this._text
                    },
                    set: function(t) {
                        t = t.toString() || " ", this._text !== t && (this._text = t, this.dirty = !0)
                    }
                }
            }), i.parse = function(t, e) {
                var r = {},
                    s = t.getElementsByTagName("info")[0],
                    o = t.getElementsByTagName("common")[0];
                r.font = s.getAttribute("face"), r.size = parseInt(s.getAttribute("size"), 10), r.lineHeight = parseInt(o.getAttribute("lineHeight"), 10), r.chars = {};
                for (var a = t.getElementsByTagName("char"), h = 0; h < a.length; h++) {
                    var u = parseInt(a[h].getAttribute("id"), 10),
                        l = new n.math.Rectangle(parseInt(a[h].getAttribute("x"),
                            10) + e.frame.x, parseInt(a[h].getAttribute("y"), 10) + e.frame.y, parseInt(a[h].getAttribute("width"), 10), parseInt(a[h].getAttribute("height"), 10));
                    r.chars[u] = {
                        xOffset: parseInt(a[h].getAttribute("xoffset"), 10),
                        yOffset: parseInt(a[h].getAttribute("yoffset"), 10),
                        xAdvance: parseInt(a[h].getAttribute("xadvance"), 10),
                        kerning: {},
                        texture: new n.Texture(e.baseTexture, l)
                    }
                }
                var c = t.getElementsByTagName("kerning");
                for (h = 0; h < c.length; h++) {
                    var d = parseInt(c[h].getAttribute("first"), 10),
                        p = parseInt(c[h].getAttribute("second"),
                            10),
                        f = parseInt(c[h].getAttribute("amount"), 10);
                    r.chars[p].kerning[d] = f
                }
                i.fonts[r.font] = r
            }, i.prototype.updateText = function() {
                for (var t = i.fonts[this._font.name], e = new n.math.Point, r = null, s = [], o = 0, a = 0, h = [], u = 0, l = this._font.size / t.size, c = -1, d = 0; d < this.text.length; d++) {
                    var p = this.text.charCodeAt(d);
                    if (c = /(\s)/.test(this.text.charAt(d)) ? d : c, /(?:\r\n|\r|\n)/.test(this.text.charAt(d))) h.push(o), a = Math.max(a, o), u++, e.x = 0, e.y += t.lineHeight, r = null;
                    else if (c !== -1 && this.maxWidth > 0 && e.x * l > this.maxWidth) s.splice(c,
                        d - c), d = c, c = -1, h.push(o), a = Math.max(a, o), u++, e.x = 0, e.y += t.lineHeight, r = null;
                    else {
                        var f = t.chars[p];
                        f && (r && f.kerning[r] && (e.x += f.kerning[r]), s.push({
                            texture: f.texture,
                            line: u,
                            charCode: p,
                            position: new n.math.Point(e.x + f.xOffset, e.y + f.yOffset)
                        }), o = e.x + f.xAdvance, e.x += f.xAdvance, r = p)
                    }
                }
                h.push(o), a = Math.max(a, o);
                var g = [];
                for (d = 0; d <= u; d++) {
                    var v = 0;
                    "right" === this._font.align ? v = a - h[d] : "center" === this._font.align && (v = (a - h[d]) / 2), g.push(v)
                }
                var y = s.length,
                    m = this.tint;
                for (d = 0; d < y; d++) {
                    var x = this._glyphs[d];
                    x ? x.texture =
                        s[d].texture : (x = new n.Sprite(s[d].texture), this._glyphs.push(x)), x.position.x = (s[d].position.x + g[s[d].line]) * l, x.position.y = s[d].position.y * l, x.scale.x = x.scale.y = l, x.tint = m, x.parent || this.addChild(x)
                }
                for (d = y; d < this._glyphs.length; ++d) this.removeChild(this._glyphs[d]);
                this.textWidth = a * l, this.textHeight = (e.y + t.lineHeight) * l
            }, i.prototype.updateTransform = function() {
                this.dirty && (this.updateText(), this.dirty = !1), this.containerUpdateTransform()
            }, i.fonts = {}
        }, {
            "../core": 25
        }],
        76: [function(t, e, r) {
            function i(t) {
                n.Sprite.call(this,
                    t[0]), this._textures = t, this.animationSpeed = 1, this.loop = !0, this.onComplete = null, this._currentTime = 0, this.playing = !1
            }
            var n = t("../core"),
                s = t("../ticker");
            i.prototype = Object.create(n.Sprite.prototype), i.prototype.constructor = i, e.exports = i, Object.defineProperties(i.prototype, {
                totalFrames: {
                    get: function() {
                        return this._textures.length
                    }
                },
                textures: {
                    get: function() {
                        return this._textures
                    },
                    set: function(t) {
                        this._textures = t, this.texture = this._textures[Math.floor(this._currentTime) % this._textures.length]
                    }
                },
                currentFrame: {
                    get: function() {
                        return Math.floor(this._currentTime) %
                            this._textures.length
                    }
                }
            }), i.prototype.stop = function() {
                this.playing && (this.playing = !1, s.shared.remove(this.update, this))
            }, i.prototype.play = function() {
                this.playing || (this.playing = !0, s.shared.add(this.update, this))
            }, i.prototype.gotoAndStop = function(t) {
                this.stop(), this._currentTime = t;
                var e = Math.floor(this._currentTime);
                this._texture = this._textures[e % this._textures.length]
            }, i.prototype.gotoAndPlay = function(t) {
                this._currentTime = t, this.play()
            }, i.prototype.update = function(t) {
                this._currentTime += this.animationSpeed *
                    t;
                var e = Math.floor(this._currentTime);
                e < 0 ? this.loop ? (this._currentTime += this._textures.length, this._texture = this._textures[this._currentTime]) : (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this.loop || e < this._textures.length ? this._texture = this._textures[e % this._textures.length] : e >= this._textures.length && (this.gotoAndStop(this.textures.length - 1), this.onComplete && this.onComplete())
            }, i.prototype.destroy = function() {
                this.stop(), n.Sprite.prototype.destroy.call(this)
            }, i.fromFrames = function(t) {
                for (var e = [], r = 0; r < t.length; ++r) e.push(new n.Texture.fromFrame(t[r]));
                return new i(e)
            }, i.fromImages = function(t) {
                for (var e = [], r = 0; r < t.length; ++r) e.push(new n.Texture.fromImage(t[r]));
                return new i(e)
            }
        }, {
            "../core": 25,
            "../ticker": 100
        }],
        77: [function(t, e, r) {
            function i(t, e, r) {
                n.Sprite.call(this, t), this.tileScale = new n.math.Point(1, 1), this.tilePosition = new n.math.Point(0, 0), this._width = e || 100, this._height = r || 100, this._uvs = new n.TextureUvs, this._canvasPattern = null, this.shader = new n.AbstractFilter(["precision lowp float;",
                    "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform mat3 projectionMatrix;", "uniform vec4 uFrame;", "uniform vec4 uTransform;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "void main(void){", "   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);", "   vec2 coord = aTextureCoord;", "   coord -= uTransform.xy;", "   coord /= uTransform.zw;", "   coord /= uFrame.zw;", "   vTextureCoord = coord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);",
                    "}"
                ].join("\n"), ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "uniform vec4 uFrame;", "void main(void){", "   vec2 coord = fract(vTextureCoord);", "   coord *= uFrame.zw;", "   coord += uFrame.xy;", "   gl_FragColor =  texture2D(uSampler, coord) * vColor ;", "}"].join("\n"), {
                    uFrame: {
                        type: "4fv",
                        value: [0, 0, 1, 1]
                    },
                    uTransform: {
                        type: "4fv",
                        value: [0, 0, 1, 1]
                    }
                })
            }
            var n = t("../core"),
                s = new n.Point;
            i.prototype = Object.create(n.Sprite.prototype), i.prototype.constructor =
                i, e.exports = i, Object.defineProperties(i.prototype, {
                    width: {
                        get: function() {
                            return this._width
                        },
                        set: function(t) {
                            this._width = t
                        }
                    },
                    height: {
                        get: function() {
                            return this._height
                        },
                        set: function(t) {
                            this._height = t
                        }
                    }
                }), i.prototype._onTextureUpdate = function() {}, i.prototype._renderWebGL = function(t) {
                    var e = this._texture;
                    if (e && e._uvs) {
                        var r = e._uvs,
                            i = e._frame.width,
                            n = e._frame.height,
                            s = e.baseTexture.width,
                            o = e.baseTexture.height;
                        e._uvs = this._uvs, e._frame.width = this.width, e._frame.height = this.height, this.shader.uniforms.uFrame.value[0] =
                            r.x0 + .5 / s, this.shader.uniforms.uFrame.value[1] = r.y0 + .5 / o, this.shader.uniforms.uFrame.value[2] = r.x1 - r.x0 + -1 / s, this.shader.uniforms.uFrame.value[3] = r.y2 - r.y0 + -1 / o, this.shader.uniforms.uTransform.value[0] = this.tilePosition.x % s / this._width, this.shader.uniforms.uTransform.value[1] = this.tilePosition.y % o / this._height, this.shader.uniforms.uTransform.value[2] = s / this._width * this.tileScale.x, this.shader.uniforms.uTransform.value[3] = o / this._height * this.tileScale.y, t.setObjectRenderer(t.plugins.sprite), t.plugins.sprite.render(this),
                            e._uvs = r, e._frame.width = i, e._frame.height = n
                    }
                }, i.prototype._renderCanvas = function(t) {
                    var e = this._texture;
                    if (e.baseTexture.hasLoaded) {
                        var r = t.context,
                            i = this.worldTransform,
                            s = t.resolution,
                            o = e.baseTexture,
                            a = this.tilePosition.x % o.width,
                            h = this.tilePosition.y % o.height;
                        if (!this._canvasPattern) {
                            var u = new n.CanvasBuffer(e._frame.width, e._frame.height);
                            u.context.drawImage(o.source, -e._frame.x, -e._frame.y), this._canvasPattern = u.context.createPattern(u.canvas, "repeat")
                        }
                        r.globalAlpha = this.worldAlpha, r.setTransform(i.a *
                            s, i.b * s, i.c * s, i.d * s, i.tx * s, i.ty * s), r.scale(this.tileScale.x, this.tileScale.y), r.translate(a + this.anchor.x * -this._width, h + this.anchor.y * -this._height), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, r.globalCompositeOperation = t.blendModes[t.currentBlendMode]), r.fillStyle = this._canvasPattern, r.fillRect(-a, -h, this._width / this.tileScale.x, this._height / this.tileScale.y)
                    }
                }, i.prototype.getBounds = function() {
                    var t, e, r, i, n = this._width,
                        s = this._height,
                        o = n * (1 - this.anchor.x),
                        a = n * -this.anchor.x,
                        h = s * (1 - this.anchor.y),
                        u = s * -this.anchor.y,
                        l = this.worldTransform,
                        c = l.a,
                        d = l.b,
                        p = l.c,
                        f = l.d,
                        g = l.tx,
                        v = l.ty,
                        y = c * a + p * u + g,
                        m = f * u + d * a + v,
                        x = c * o + p * u + g,
                        _ = f * u + d * o + v,
                        E = c * o + p * h + g,
                        b = f * h + d * o + v,
                        T = c * a + p * h + g,
                        S = f * h + d * a + v;
                    t = y, t = x < t ? x : t, t = E < t ? E : t, t = T < t ? T : t, r = m, r = _ < r ? _ : r, r = b < r ? b : r, r = S < r ? S : r, e = y, e = x > e ? x : e, e = E > e ? E : e, e = T > e ? T : e, i = m, i = _ > i ? _ : i, i = b > i ? b : i, i = S > i ? S : i;
                    var w = this._bounds;
                    return w.x = t, w.width = e - t, w.y = r, w.height = i - r, this._currentBounds = w, w
                }, i.prototype.containsPoint = function(t) {
                    this.worldTransform.applyInverse(t, s);
                    var e,
                        r = this._width,
                        i = this._height,
                        n = -r * this.anchor.x;
                    return s.x > n && s.x < n + r && (e = -i * this.anchor.y, s.y > e && s.y < e + i)
                }, i.prototype.destroy = function() {
                    n.Sprite.prototype.destroy.call(this), this.tileScale = null, this._tileScaleOffset = null, this.tilePosition = null, this._uvs = null
                }, i.fromFrame = function(t, e, r) {
                    var s = n.utils.TextureCache[t];
                    if (!s) throw new Error('The frameId "' + t + '" does not exist in the texture cache ' + this);
                    return new i(s, e, r)
                }, i.fromImage = function(t, e, r, s, o) {
                    return new i(n.Texture.fromImage(t, s, o),
                        e, r)
                }
        }, {
            "../core": 25
        }],
        78: [function(t, e, r) {
            var i = t("../core"),
                n = i.DisplayObject,
                s = new i.Matrix;
            n.prototype._cacheAsBitmap = !1, n.prototype._originalRenderWebGL = null, n.prototype._originalRenderCanvas = null, n.prototype._originalUpdateTransform = null, n.prototype._originalHitTest = null, n.prototype._originalDestroy = null, n.prototype._cachedSprite = null, Object.defineProperties(n.prototype, {
                cacheAsBitmap: {
                    get: function() {
                        return this._cacheAsBitmap
                    },
                    set: function(t) {
                        this._cacheAsBitmap !== t && (this._cacheAsBitmap = t,
                            t ? (this._originalRenderWebGL = this.renderWebGL, this._originalRenderCanvas = this.renderCanvas, this._originalUpdateTransform = this.updateTransform, this._originalGetBounds = this.getBounds, this._originalDestroy = this.destroy, this._originalContainesPoint = this.containsPoint, this.renderWebGL = this._renderCachedWebGL, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (this._cachedSprite && this._destroyCachedDisplayObject(), this.renderWebGL = this._originalRenderWebGL, this.renderCanvas =
                                this._originalRenderCanvas, this.getBounds = this._originalGetBounds, this.destroy = this._originalDestroy, this.updateTransform = this._originalUpdateTransform, this.containsPoint = this._originalContainsPoint))
                    }
                }
            }), n.prototype._renderCachedWebGL = function(t) {
                this._initCachedDisplayObject(t), this._cachedSprite.worldAlpha = this.worldAlpha, t.setObjectRenderer(t.plugins.sprite), t.plugins.sprite.render(this._cachedSprite)
            }, n.prototype._initCachedDisplayObject = function(t) {
                if (!this._cachedSprite) {
                    t.currentRenderer.flush();
                    var e = this.getLocalBounds().clone();
                    if (this._filters) {
                        var r = this._filters[0].padding;
                        e.x -= r, e.y -= r, e.width += 2 * r, e.height += 2 * r
                    }
                    var n = t.currentRenderTarget,
                        o = t.filterManager.filterStack,
                        a = new i.RenderTexture(t, 0 | e.width, 0 | e.height),
                        h = s;
                    h.tx = -e.x, h.ty = -e.y, this.renderWebGL = this._originalRenderWebGL, a.render(this, h, !0, !0), t.setRenderTarget(n), t.filterManager.filterStack = o, this.renderWebGL = this._renderCachedWebGL, this.updateTransform = this.displayObjectUpdateTransform, this.getBounds = this._getCachedBounds,
                        this._cachedSprite = new i.Sprite(a), this._cachedSprite.worldTransform = this.worldTransform, this._cachedSprite.anchor.x = -(e.x / e.width), this._cachedSprite.anchor.y = -(e.y / e.height), this.updateTransform(), this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite)
                }
            }, n.prototype._renderCachedCanvas = function(t) {
                this._initCachedDisplayObjectCanvas(t), this._cachedSprite.worldAlpha = this.worldAlpha, this._cachedSprite.renderCanvas(t)
            }, n.prototype._initCachedDisplayObjectCanvas = function(t) {
                if (!this._cachedSprite) {
                    var e =
                        this.getLocalBounds(),
                        r = t.context,
                        n = new i.RenderTexture(t, 0 | e.width, 0 | e.height),
                        o = s;
                    o.tx = -e.x, o.ty = -e.y, this.renderCanvas = this._originalRenderCanvas, n.render(this, o, !0), t.context = r, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.getBounds = this._getCachedBounds, this._cachedSprite = new i.Sprite(n), this._cachedSprite.worldTransform = this.worldTransform, this._cachedSprite.anchor.x = -(e.x / e.width), this._cachedSprite.anchor.y = -(e.y / e.height), this.updateTransform(),
                        this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite)
                }
            }, n.prototype._getCachedBounds = function() {
                return this._cachedSprite._currentBounds = null, this._cachedSprite.getBounds()
            }, n.prototype._destroyCachedDisplayObject = function() {
                this._cachedSprite._texture.destroy(), this._cachedSprite = null
            }, n.prototype._cacheAsBitmapDestroy = function() {
                this.cacheAsBitmap = !1, this._originalDestroy()
            }
        }, {
            "../core": 25
        }],
        79: [function(t, e, r) {
            var i = t("../core");
            i.DisplayObject.prototype.name = null, i.Container.prototype.getChildByName =
                function(t) {
                    for (var e = 0; e < this.children.length; e++)
                        if (this.children[e].name === t) return this.children[e];
                    return null
                }
        }, {
            "../core": 25
        }],
        80: [function(t, e, r) {
            var i = t("../core");
            i.DisplayObject.prototype.getGlobalPosition = function(t) {
                return t = t || new i.Point, this.parent ? (this.displayObjectUpdateTransform(), t.x = this.worldTransform.tx, t.y = this.worldTransform.ty) : (t.x = this.position.x, t.y = this.position.y), t
            }
        }, {
            "../core": 25
        }],
        81: [function(t, e, r) {
            t("./cacheAsBitmap"), t("./getChildByName"), t("./getGlobalPosition"),
                e.exports = {
                    MovieClip: t("./MovieClip"),
                    TilingSprite: t("./TilingSprite"),
                    BitmapText: t("./BitmapText")
                }
        }, {
            "./BitmapText": 75,
            "./MovieClip": 76,
            "./TilingSprite": 77,
            "./cacheAsBitmap": 78,
            "./getChildByName": 79,
            "./getGlobalPosition": 80
        }],
        82: [function(t, e, r) {
            function i() {
                this.global = new n.Point, this.target = null, this.originalEvent = null
            }
            var n = t("../core");
            i.prototype.constructor = i, e.exports = i, i.prototype.getLocalPosition = function(t, e, r) {
                var i = t.worldTransform,
                    s = r ? r : this.global,
                    o = i.a,
                    a = i.c,
                    h = i.tx,
                    u = i.b,
                    l = i.d,
                    c =
                    i.ty,
                    d = 1 / (o * l + a * -u);
                return e = e || new n.math.Point, e.x = l * d * s.x + -a * d * s.y + (c * a - h * l) * d, e.y = o * d * s.y + -u * d * s.x + (-c * o + h * u) * d, e
            }
        }, {
            "../core": 25
        }],
        83: [function(t, e, r) {
            function i(t, e) {
                e = e || {}, this.renderer = t, this.autoPreventDefault = void 0 === e.autoPreventDefault || e.autoPreventDefault, this.interactionFrequency = e.interactionFrequency || 10, this.mouse = new s, this.eventData = {
                        stopped: !1,
                        target: null,
                        type: null,
                        data: this.mouse,
                        stopPropagation: function() {
                            this.stopped = !0
                        }
                    }, this.interactiveDataPool = [], this.interactionDOMElement =
                    null, this.eventsAdded = !1, this.onMouseUp = this.onMouseUp.bind(this), this.processMouseUp = this.processMouseUp.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.processMouseDown = this.processMouseDown.bind(this), this.onMouseMove = this.onMouseMove.bind(this), this.processMouseMove = this.processMouseMove.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.processMouseOverOut = this.processMouseOverOut.bind(this), this.onTouchStart = this.onTouchStart.bind(this), this.processTouchStart = this.processTouchStart.bind(this),
                    this.onTouchEnd = this.onTouchEnd.bind(this), this.processTouchEnd = this.processTouchEnd.bind(this), this.onTouchMove = this.onTouchMove.bind(this), this.processTouchMove = this.processTouchMove.bind(this), this.last = 0, this.currentCursorStyle = "inherit", this._tempPoint = new n.Point, this.resolution = 1, this.setTargetElement(this.renderer.view, this.renderer.resolution)
            }
            var n = t("../core"),
                s = t("./InteractionData");
            Object.assign(n.DisplayObject.prototype, t("./interactiveTarget")), i.prototype.constructor = i, e.exports =
                i, i.prototype.setTargetElement = function(t, e) {
                    this.removeEvents(), this.interactionDOMElement = t, this.resolution = e || 1, this.addEvents()
                }, i.prototype.addEvents = function() {
                    this.interactionDOMElement && (n.ticker.shared.add(this.update, this), window.navigator.msPointerEnabled && (this.interactionDOMElement.style["-ms-content-zooming"] = "none", this.interactionDOMElement.style["-ms-touch-action"] = "none"), window.document.addEventListener("mousemove", this.onMouseMove, !0), this.interactionDOMElement.addEventListener("mousedown",
                        this.onMouseDown, !0), this.interactionDOMElement.addEventListener("mouseout", this.onMouseOut, !0), this.interactionDOMElement.addEventListener("touchstart", this.onTouchStart, !0), this.interactionDOMElement.addEventListener("touchend", this.onTouchEnd, !0), this.interactionDOMElement.addEventListener("touchmove", this.onTouchMove, !0), window.addEventListener("mouseup", this.onMouseUp, !0), this.eventsAdded = !0)
                }, i.prototype.removeEvents = function() {
                    this.interactionDOMElement && (n.ticker.shared.remove(this.update),
                        window.navigator.msPointerEnabled && (this.interactionDOMElement.style["-ms-content-zooming"] = "", this.interactionDOMElement.style["-ms-touch-action"] = ""), window.document.removeEventListener("mousemove", this.onMouseMove, !0), this.interactionDOMElement.removeEventListener("mousedown", this.onMouseDown, !0), this.interactionDOMElement.removeEventListener("mouseout", this.onMouseOut, !0), this.interactionDOMElement.removeEventListener("touchstart", this.onTouchStart, !0), this.interactionDOMElement.removeEventListener("touchend",
                            this.onTouchEnd, !0), this.interactionDOMElement.removeEventListener("touchmove", this.onTouchMove, !0), this.interactionDOMElement = null, window.removeEventListener("mouseup", this.onMouseUp, !0), this.eventsAdded = !1)
                }, i.prototype.update = function(t) {
                    if (this._deltaTime += t, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.interactionDOMElement)) {
                        if (this.didMove) return void(this.didMove = !1);
                        this.cursor = "inherit", this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, !0), this.currentCursorStyle !== this.cursor && (this.currentCursorStyle = this.cursor, this.interactionDOMElement.style.cursor = this.cursor)
                    }
                }, i.prototype.dispatchEvent = function(t, e, r) {
                    r.stopped || (r.target = t, r.type = e, t.emit(e, r), t[e] && t[e](r))
                }, i.prototype.mapPositionToPoint = function(t, e, r) {
                    var i = this.interactionDOMElement.getBoundingClientRect();
                    t.x = (e - i.left) * (this.interactionDOMElement.width / i.width) / this.resolution, t.y = (r - i.top) * (this.interactionDOMElement.height / i.height) / this.resolution
                }, i.prototype.processInteractive =
                function(t, e, r, i, n) {
                    if (!e.visible) return !1;
                    var s = e.children,
                        o = !1;
                    if (n = n || e.interactive, e.interactiveChildren)
                        for (var a = s.length - 1; a >= 0; a--) !o && i ? o = this.processInteractive(t, s[a], r, !0, n) : this.processInteractive(t, s[a], r, !1, !1);
                    return n && (i && (e.hitArea ? (e.worldTransform.applyInverse(t, this._tempPoint), o = e.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) : e.containsPoint && (o = e.containsPoint(t))), e.interactive && r(e, o)), o
                }, i.prototype.onMouseDown = function(t) {
                    this.mouse.originalEvent = t, this.eventData.data =
                        this.mouse, this.eventData.stopped = !1, this.mapPositionToPoint(this.mouse.global, t.clientX, t.clientY), this.autoPreventDefault && this.mouse.originalEvent.preventDefault(), this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseDown, !0)
                }, i.prototype.processMouseDown = function(t, e) {
                    var r = this.mouse.originalEvent,
                        i = 2 === r.button || 3 === r.which;
                    e && (t[i ? "_isRightDown" : "_isLeftDown"] = !0, this.dispatchEvent(t, i ? "rightdown" : "mousedown", this.eventData))
                }, i.prototype.onMouseUp = function(t) {
                    this.mouse.originalEvent =
                        t, this.eventData.data = this.mouse, this.eventData.stopped = !1, this.mapPositionToPoint(this.mouse.global, t.clientX, t.clientY), this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseUp, !0)
                }, i.prototype.processMouseUp = function(t, e) {
                    var r = this.mouse.originalEvent,
                        i = 2 === r.button || 3 === r.which,
                        n = i ? "_isRightDown" : "_isLeftDown";
                    e ? (this.dispatchEvent(t, i ? "rightup" : "mouseup", this.eventData), t[n] && (t[n] = !1, this.dispatchEvent(t, i ? "rightclick" : "click", this.eventData))) : t[n] &&
                        (t[n] = !1, this.dispatchEvent(t, i ? "rightupoutside" : "mouseupoutside", this.eventData))
                }, i.prototype.onMouseMove = function(t) {
                    this.mouse.originalEvent = t, this.eventData.data = this.mouse, this.eventData.stopped = !1, this.mapPositionToPoint(this.mouse.global, t.clientX, t.clientY), this.didMove = !0, this.cursor = "inherit", this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseMove, !0), this.currentCursorStyle !== this.cursor && (this.currentCursorStyle = this.cursor, this.interactionDOMElement.style.cursor =
                        this.cursor)
                }, i.prototype.processMouseMove = function(t, e) {
                    this.dispatchEvent(t, "mousemove", this.eventData), this.processMouseOverOut(t, e)
                }, i.prototype.onMouseOut = function(t) {
                    this.mouse.originalEvent = t, this.eventData.stopped = !1, this.mapPositionToPoint(this.mouse.global, t.clientX, t.clientY), this.interactionDOMElement.style.cursor = "inherit", this.mapPositionToPoint(this.mouse.global, t.clientX, t.clientY), this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, !1)
                }, i.prototype.processMouseOverOut = function(t, e) {
                    e ? (t._over || (t._over = !0, this.dispatchEvent(t, "mouseover", this.eventData)), t.buttonMode && (this.cursor = t.defaultCursor)) : t._over && (t._over = !1, this.dispatchEvent(t, "mouseout", this.eventData))
                }, i.prototype.onTouchStart = function(t) {
                    this.autoPreventDefault && t.preventDefault();
                    for (var e = t.changedTouches, r = e.length, i = 0; i < r; i++) {
                        var n = e[i],
                            s = this.getTouchData(n);
                        s.originalEvent = t, this.eventData.data = s, this.eventData.stopped = !1, this.processInteractive(s.global,
                            this.renderer._lastObjectRendered, this.processTouchStart, !0), this.returnTouchData(s)
                    }
                }, i.prototype.processTouchStart = function(t, e) {
                    e && (t._touchDown = !0, this.dispatchEvent(t, "touchstart", this.eventData))
                }, i.prototype.onTouchEnd = function(t) {
                    this.autoPreventDefault && t.preventDefault();
                    for (var e = t.changedTouches, r = e.length, i = 0; i < r; i++) {
                        var n = e[i],
                            s = this.getTouchData(n);
                        s.originalEvent = t, this.eventData.data = s, this.eventData.stopped = !1, this.processInteractive(s.global, this.renderer._lastObjectRendered, this.processTouchEnd, !0), this.returnTouchData(s)
                    }
                }, i.prototype.processTouchEnd = function(t, e) {
                    e ? (this.dispatchEvent(t, "touchend", this.eventData), t._touchDown && (t._touchDown = !1, this.dispatchEvent(t, "tap", this.eventData))) : t._touchDown && (t._touchDown = !1, this.dispatchEvent(t, "touchendoutside", this.eventData))
                }, i.prototype.onTouchMove = function(t) {
                    this.autoPreventDefault && t.preventDefault();
                    for (var e = t.changedTouches, r = e.length, i = 0; i < r; i++) {
                        var n = e[i],
                            s = this.getTouchData(n);
                        s.originalEvent = t, this.eventData.data = s, this.eventData.stopped = !1, this.processInteractive(s.global, this.renderer._lastObjectRendered, this.processTouchMove, !1), this.returnTouchData(s)
                    }
                }, i.prototype.processTouchMove = function(t, e) {
                    e = e, this.dispatchEvent(t, "touchmove", this.eventData)
                }, i.prototype.getTouchData = function(t) {
                    var e = this.interactiveDataPool.pop();
                    return e || (e = new s), e.identifier = t.identifier, this.mapPositionToPoint(e.global, t.clientX, t.clientY), t.globalX = e.global.x, t.globalY = e.global.y, e
                }, i.prototype.returnTouchData = function(t) {
                    this.interactiveDataPool.push(t)
                },
                i.prototype.destroy = function() {
                    this.removeEvents(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactiveDataPool = null, this.interactionDOMElement = null, this.onMouseUp = null, this.processMouseUp = null, this.onMouseDown = null, this.processMouseDown = null, this.onMouseMove = null, this.processMouseMove = null, this.onMouseOut = null, this.processMouseOverOut = null, this.onTouchStart = null, this.processTouchStart = null, this.onTouchEnd = null, this.processTouchEnd = null, this.onTouchMove = null, this.processTouchMove =
                        null, this._tempPoint = null
                }, n.WebGLRenderer.registerPlugin("interaction", i), n.CanvasRenderer.registerPlugin("interaction", i)
        }, {
            "../core": 25,
            "./InteractionData": 82,
            "./interactiveTarget": 85
        }],
        84: [function(t, e, r) {
            e.exports = {
                InteractionData: t("./InteractionData"),
                InteractionManager: t("./InteractionManager"),
                interactiveTarget: t("./interactiveTarget")
            }
        }, {
            "./InteractionData": 82,
            "./InteractionManager": 83,
            "./interactiveTarget": 85
        }],
        85: [function(t, e, r) {
            e.exports = {
                interactive: !1,
                buttonMode: !1,
                interactiveChildren: !0,
                defaultCursor: "pointer",
                _over: !1,
                _touchDown: !1
            }
        }, {}],
        86: [function(t, e, r) {
            function i(t, e) {
                var r = {},
                    i = t.data.getElementsByTagName("info")[0],
                    n = t.data.getElementsByTagName("common")[0];
                r.font = i.getAttribute("face"), r.size = parseInt(i.getAttribute("size"), 10), r.lineHeight = parseInt(n.getAttribute("lineHeight"), 10), r.chars = {};
                for (var o = t.data.getElementsByTagName("char"), h = 0; h < o.length; h++) {
                    var u = parseInt(o[h].getAttribute("id"), 10),
                        l = new s.math.Rectangle(parseInt(o[h].getAttribute("x"), 10) + e.frame.x, parseInt(o[h].getAttribute("y"),
                            10) + e.frame.y, parseInt(o[h].getAttribute("width"), 10), parseInt(o[h].getAttribute("height"), 10));
                    r.chars[u] = {
                        xOffset: parseInt(o[h].getAttribute("xoffset"), 10),
                        yOffset: parseInt(o[h].getAttribute("yoffset"), 10),
                        xAdvance: parseInt(o[h].getAttribute("xadvance"), 10),
                        kerning: {},
                        texture: new s.Texture(e.baseTexture, l)
                    }
                }
                var c = t.data.getElementsByTagName("kerning");
                for (h = 0; h < c.length; h++) {
                    var d = parseInt(c[h].getAttribute("first"), 10),
                        p = parseInt(c[h].getAttribute("second"), 10),
                        f = parseInt(c[h].getAttribute("amount"),
                            10);
                    r.chars[p].kerning[d] = f
                }
                t.bitmapFont = r, a.BitmapText.fonts[r.font] = r
            }
            var n = t("resource-loader").Resource,
                s = t("../core"),
                o = t("../core/utils"),
                a = t("../extras"),
                h = t("path");
            e.exports = function() {
                return function(t, e) {
                    if (!t.data || !t.isXml) return e();
                    if (0 === t.data.getElementsByTagName("page").length || 0 === t.data.getElementsByTagName("info").length || null === t.data.getElementsByTagName("info")[0].getAttribute("face")) return e();
                    var r = h.dirname(t.url);
                    "." === r && (r = ""), this.baseUrl && r && ("/" === this.baseUrl.charAt(this.baseUrl.length -
                        1) && (r += "/"), r = r.replace(this.baseUrl, "")), r && "/" !== r.charAt(r.length - 1) && (r += "/");
                    var s = t.data.getElementsByTagName("page")[0].getAttribute("file");
                    if (o.TextureCache[s]) i(t, o.TextureCache[s]), e();
                    else {
                        var a = {
                            crossOrigin: t.crossOrigin,
                            loadType: n.LOAD_TYPE.IMAGE
                        };
                        this.add(t.name + "_image", s, a, function(r) {
                            i(t, r.texture), e()
                        })
                    }
                }
            }
        }, {
            "../core": 25,
            "../core/utils": 72,
            "../extras": 81,
            path: 4,
            "resource-loader": 14
        }],
        87: [function(t, e, r) {
            e.exports = {
                Loader: t("./loader"),
                bitmapFontParser: t("./bitmapFontParser"),
                spritesheetParser: t("./spritesheetParser"),
                textureParser: t("./textureParser"),
                Resource: t("resource-loader").Resource
            }
        }, {
            "./bitmapFontParser": 86,
            "./loader": 88,
            "./spritesheetParser": 89,
            "./textureParser": 90,
            "resource-loader": 14
        }],
        88: [function(t, e, r) {
            function i(t, e) {
                n.call(this, t, e);
                for (var r = 0; r < i._pixiMiddleware.length; ++r) this.use(i._pixiMiddleware[r]())
            }
            var n = t("resource-loader"),
                s = t("./textureParser"),
                o = t("./spritesheetParser"),
                a = t("./bitmapFontParser");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i, i._pixiMiddleware = [n.middleware.parsing.blob, s, o, a], i.addPixiMiddleware = function(t) {
                i._pixiMiddleware.push(t)
            };
            var h = n.Resource;
            h.setExtensionXhrType("fnt", h.XHR_RESPONSE_TYPE.DOCUMENT)
        }, {
            "./bitmapFontParser": 86,
            "./spritesheetParser": 89,
            "./textureParser": 90,
            "resource-loader": 14
        }],
        89: [function(t, e, r) {
            var i = t("resource-loader").Resource,
                n = t("path"),
                s = t("../core");
            e.exports = function() {
                return function(t, e) {
                    if (!t.data || !t.isJson || !t.data.frames) return e();
                    var r = {
                            crossOrigin: t.crossOrigin,
                            loadType: i.LOAD_TYPE.IMAGE
                        },
                        o = n.dirname(t.url.replace(this.baseUrl,
                            "")),
                        a = s.utils.getResolutionOfUrl(t.url);
                    this.add(t.name + "_image", o + "/" + t.data.meta.image, r, function(r) {
                        t.textures = {};
                        var i = t.data.frames;
                        for (var n in i) {
                            var o = i[n].frame;
                            if (o) {
                                var h = null,
                                    u = null;
                                if (h = i[n].rotated ? new s.math.Rectangle(o.x, o.y, o.h, o.w) : new s.math.Rectangle(o.x, o.y, o.w, o.h), i[n].trimmed && (u = new s.math.Rectangle(i[n].spriteSourceSize.x / a, i[n].spriteSourceSize.y / a, i[n].sourceSize.w / a, i[n].sourceSize.h / a)), i[n].rotated) {
                                    var l = h.width;
                                    h.width = h.height, h.height = l
                                }
                                h.x /= a, h.y /= a, h.width /= a,
                                    h.height /= a, t.textures[n] = new s.Texture(r.texture.baseTexture, h, h.clone(), u, i[n].rotated), s.utils.TextureCache[n] = t.textures[n]
                            }
                        }
                        e()
                    })
                }
            }
        }, {
            "../core": 25,
            path: 4,
            "resource-loader": 14
        }],
        90: [function(t, e, r) {
            var i = t("../core");
            e.exports = function() {
                return function(t, e) {
                    t.data && t.isImage && (t.texture = new i.Texture(new i.BaseTexture(t.data, null, i.utils.getResolutionOfUrl(t.url))), i.utils.TextureCache[t.url] = t.texture), e()
                }
            }
        }, {
            "../core": 25
        }],
        91: [function(t, e, r) {
            function i(t, e, r, s, o) {
                n.Container.call(this), this.texture =
                    t, this.uvs = r || new Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.vertices = e || new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.indices = s || new Uint16Array([0, 1, 2, 3]), this.dirty = !0, this.blendMode = n.BLEND_MODES.NORMAL, this.canvasPadding = 0, this.drawMode = o || i.DRAW_MODES.TRIANGLE_MESH
            }
            var n = t("../core");
            i.prototype = Object.create(n.Container.prototype), i.prototype.constructor = i, e.exports = i, i.prototype._renderWebGL = function(t) {
                    t.setObjectRenderer(t.plugins.mesh), t.plugins.mesh.render(this)
                }, i.prototype._renderCanvas =
                function(t) {
                    var e = t.context,
                        r = this.worldTransform;
                    t.roundPixels ? e.setTransform(r.a, r.b, r.c, r.d, 0 | r.tx, 0 | r.ty) : e.setTransform(r.a, r.b, r.c, r.d, r.tx, r.ty), this.drawMode === i.DRAW_MODES.TRIANGLE_MESH ? this._renderCanvasTriangleMesh(e) : this._renderCanvasTriangles(e)
                }, i.prototype._renderCanvasTriangleMesh = function(t) {
                    for (var e = this.vertices, r = this.uvs, i = e.length / 2, n = 0; n < i - 2; n++) {
                        var s = 2 * n;
                        this._renderCanvasDrawTriangle(t, e, r, s, s + 2, s + 4)
                    }
                }, i.prototype._renderCanvasTriangles = function(t) {
                    for (var e = this.vertices,
                            r = this.uvs, i = this.indices, n = i.length, s = 0; s < n; s += 3) {
                        var o = 2 * i[s],
                            a = 2 * i[s + 1],
                            h = 2 * i[s + 2];
                        this._renderCanvasDrawTriangle(t, e, r, o, a, h)
                    }
                }, i.prototype._renderCanvasDrawTriangle = function(t, e, r, i, n, s) {
                    var o = this.texture.baseTexture.source,
                        a = this.texture.width,
                        h = this.texture.height,
                        u = e[i],
                        l = e[n],
                        c = e[s],
                        d = e[i + 1],
                        p = e[n + 1],
                        f = e[s + 1],
                        g = r[i] * a,
                        v = r[n] * a,
                        y = r[s] * a,
                        m = r[i + 1] * h,
                        x = r[n + 1] * h,
                        _ = r[s + 1] * h;
                    if (this.canvasPadding > 0) {
                        var E = this.canvasPadding / this.worldTransform.a,
                            b = this.canvasPadding / this.worldTransform.d,
                            T = (u +
                                l + c) / 3,
                            S = (d + p + f) / 3,
                            w = u - T,
                            R = d - S,
                            A = Math.sqrt(w * w + R * R);
                        u = T + w / A * (A + E), d = S + R / A * (A + b), w = l - T, R = p - S, A = Math.sqrt(w * w + R * R), l = T + w / A * (A + E), p = S + R / A * (A + b), w = c - T, R = f - S, A = Math.sqrt(w * w + R * R), c = T + w / A * (A + E), f = S + R / A * (A + b)
                    }
                    t.save(), t.beginPath(), t.moveTo(u, d), t.lineTo(l, p), t.lineTo(c, f), t.closePath(), t.clip();
                    var M = g * x + m * y + v * _ - x * y - m * v - g * _,
                        C = u * x + m * c + l * _ - x * c - m * l - u * _,
                        O = g * l + u * y + v * c - l * y - u * v - g * c,
                        P = g * x * c + m * l * y + u * v * _ - u * x * y - m * v * c - g * l * _,
                        D = d * x + m * f + p * _ - x * f - m * p - d * _,
                        L = g * p + d * y + v * f - p * y - d * v - g * f,
                        B = g * x * f + m * p * y + d * v * _ - d * x * y - m * v * f - g * p * _;
                    t.transform(C /
                        M, D / M, O / M, L / M, P / M, B / M), t.drawImage(o, 0, 0), t.restore()
                }, i.prototype.renderMeshFlat = function(t) {
                    var e = this.context,
                        r = t.vertices,
                        i = r.length / 2;
                    e.beginPath();
                    for (var n = 1; n < i - 2; n++) {
                        var s = 2 * n,
                            o = r[s],
                            a = r[s + 2],
                            h = r[s + 4],
                            u = r[s + 1],
                            l = r[s + 3],
                            c = r[s + 5];
                        e.moveTo(o, u), e.lineTo(a, l), e.lineTo(h, c)
                    }
                    e.fillStyle = "#FF0000", e.fill(), e.closePath()
                }, i.prototype.onTextureUpdate = function() {
                    this.updateFrame = !0
                }, i.prototype.getBounds = function(t) {
                    for (var e = t || this.worldTransform, r = e.a, i = e.b, s = e.c, o = e.d, a = e.tx, h = e.ty, u = -(1 / 0), l = -(1 / 0), c = 1 / 0, d = 1 / 0, p = this.vertices, f = 0, g = p.length; f < g; f += 2) {
                        var v = p[f],
                            y = p[f + 1],
                            m = r * v + s * y + a,
                            x = o * y + i * v + h;
                        c = m < c ? m : c, d = x < d ? x : d, u = m > u ? m : u, l = x > l ? x : l
                    }
                    if (c === -(1 / 0) || l === 1 / 0) return n.math.Rectangle.EMPTY;
                    var _ = this._bounds;
                    return _.x = c, _.width = u - c, _.y = d, _.height = l - d, this._currentBounds = _, _
                }, i.DRAW_MODES = {
                    TRIANGLE_MESH: 0,
                    TRIANGLES: 1
                }
        }, {
            "../core": 25
        }],
        92: [function(t, e, r) {
            function i(t, e) {
                n.call(this, t), this.points = e, this.vertices = new Float32Array(4 * e.length), this.uvs = new Float32Array(4 * e.length), this.colors =
                    new Float32Array(2 * e.length), this.indices = new Uint16Array(2 * e.length), this.refresh()
            }
            var n = t("./Mesh");
            i.prototype = Object.create(n.prototype), i.prototype.constructor = i, e.exports = i, i.prototype.refresh = function() {
                var t = this.points;
                if (!(t.length < 1)) {
                    var e = this.uvs,
                        r = this.indices,
                        i = this.colors;
                    e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, i[0] = 1, i[1] = 1, r[0] = 0, r[1] = 1;
                    for (var n, s, o, a = t.length, h = 1; h < a; h++) n = t[h], s = 4 * h, o = h / (a - 1), h % 2 ? (e[s] = o, e[s + 1] = 0, e[s + 2] = o, e[s + 3] = 1) : (e[s] = o, e[s + 1] = 0, e[s + 2] = o, e[s + 3] = 1), s = 2 * h, i[s] = 1, i[s + 1] =
                        1, s = 2 * h, r[s] = s, r[s + 1] = s + 1
                }
            }, i.prototype.updateTransform = function() {
                var t = this.points;
                if (!(t.length < 1)) {
                    for (var e, r, i, n, s, o, a = t[0], h = 0, u = 0, l = this.vertices, c = t.length, d = 0; d < c; d++) r = t[d], i = 4 * d, e = d < t.length - 1 ? t[d + 1] : r, u = -(e.x - a.x), h = e.y - a.y, n = 10 * (1 - d / (c - 1)), n > 1 && (n = 1), s = Math.sqrt(h * h + u * u), o = this.texture.height / 2, h /= s, u /= s, h *= o, u *= o, l[i] = r.x + h, l[i + 1] = r.y + u, l[i + 2] = r.x - h, l[i + 3] = r.y - u, a = r;
                    this.containerUpdateTransform()
                }
            }
        }, {
            "./Mesh": 91
        }],
        93: [function(t, e, r) {
            e.exports = {
                Mesh: t("./Mesh"),
                Rope: t("./Rope"),
                MeshRenderer: t("./webgl/MeshRenderer"),
                MeshShader: t("./webgl/MeshShader")
            }
        }, {
            "./Mesh": 91,
            "./Rope": 92,
            "./webgl/MeshRenderer": 94,
            "./webgl/MeshShader": 95
        }],
        94: [function(t, e, r) {
            function i(t) {
                n.call(this, t), this.indices = new Uint16Array(15E3);
                for (var e = 0, r = 0; e < 15E3; e += 6, r += 4) this.indices[e + 0] = r + 0, this.indices[e + 1] = r + 1, this.indices[e + 2] = r + 2, this.indices[e + 3] = r + 0, this.indices[e + 4] = r + 2, this.indices[e + 5] = r + 3
            }
            var n = t("../../core/renderers/webgl/utils/ObjectRenderer"),
                s = t("../../core/renderers/webgl/WebGLRenderer");
            i.prototype = Object.create(n.prototype),
                i.prototype.constructor = i, e.exports = i, s.registerPlugin("mesh", i), i.prototype.onContextChange = function() {}, i.prototype.render = function(t) {
                    t._vertexBuffer || this._initWebGL(t);
                    var e = this.renderer,
                        r = e.gl,
                        i = t.texture.baseTexture,
                        n = e.shaderManager.plugins.meshShader,
                        s = {
                            TRIANGLE_MESH: 0,
                            TRIANGLES: 1
                        },
                        o = t.drawMode === s.TRIANGLE_STRIP ? r.TRIANGLE_STRIP : r.TRIANGLES;
                    e.blendModeManager.setBlendMode(t.blendMode), r.uniformMatrix3fv(n.uniforms.translationMatrix._location, !1, t.worldTransform.toArray(!0)), r.uniformMatrix3fv(n.uniforms.projectionMatrix._location, !1, e.currentRenderTarget.projectionMatrix.toArray(!0));
                    var a = t.worldAlpha;
                    if (t.darkColor) {
                        var h = t.lightColor;
                        h.a *= a;
                        var u = t.darkColor;
                        r.uniform4fv(n.uniforms.light._location, [h.r * h.a, h.g * h.a, h.b * h.a, h.a]), r.uniform4fv(n.uniforms.dark._location, [u.r * u.a, u.g * u.a, u.b * u.a, u.a])
                    } else r.uniform4fv(n.uniforms.light._location, [a, a, a, a]), r.uniform4fv(n.uniforms.dark._location, [0, 0, 0, 0]);
                    t.dirty ? (t.dirty = !1, r.bindBuffer(r.ARRAY_BUFFER, t._vertexBuffer), r.bufferData(r.ARRAY_BUFFER, t.vertices, r.STATIC_DRAW), r.vertexAttribPointer(n.attributes.aVertexPosition,
                        2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, t._uvBuffer), r.bufferData(r.ARRAY_BUFFER, t.uvs, r.STATIC_DRAW), r.vertexAttribPointer(n.attributes.aTextureCoord, 2, r.FLOAT, !1, 0, 0), r.activeTexture(r.TEXTURE0), i._glTextures[r.id] ? r.bindTexture(r.TEXTURE_2D, i._glTextures[r.id]) : this.renderer.updateTexture(i), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t._indexBuffer), r.bufferData(r.ELEMENT_ARRAY_BUFFER, t.indices, r.STATIC_DRAW)) : (r.bindBuffer(r.ARRAY_BUFFER, t._vertexBuffer), r.bufferSubData(r.ARRAY_BUFFER, 0, t.vertices),
                        r.vertexAttribPointer(n.attributes.aVertexPosition, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, t._uvBuffer), r.vertexAttribPointer(n.attributes.aTextureCoord, 2, r.FLOAT, !1, 0, 0), r.activeTexture(r.TEXTURE0), i._glTextures[r.id] ? r.bindTexture(r.TEXTURE_2D, i._glTextures[r.id]) : this.renderer.updateTexture(i), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t._indexBuffer)), r.drawElements(o, t.indices.length, r.UNSIGNED_SHORT, 0)
                }, i.prototype._initWebGL = function(t) {
                    var e = this.renderer.gl;
                    t._vertexBuffer = e.createBuffer(),
                        t._indexBuffer = e.createBuffer(), t._uvBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, t._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, t.vertices, e.DYNAMIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, t._uvBuffer), e.bufferData(e.ARRAY_BUFFER, t.uvs, e.STATIC_DRAW), t.colors && (t._colorBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, t._colorBuffer), e.bufferData(e.ARRAY_BUFFER, t.colors, e.STATIC_DRAW)), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, t.indices, e.STATIC_DRAW)
                },
                i.prototype.flush = function() {}, i.prototype.start = function() {
                    var t = this.renderer.shaderManager.plugins.meshShader;
                    this.renderer.shaderManager.setShader(t)
                }, i.prototype.destroy = function() {}
        }, {
            "../../core/renderers/webgl/WebGLRenderer": 45,
            "../../core/renderers/webgl/utils/ObjectRenderer": 59
        }],
        95: [function(t, e, r) {
            function i(t) {
                n.Shader.call(this, t, ["precision lowp float;", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform mat3 projectionMatrix;",
                    "varying vec2 vTextureCoord;", "void main(void){", "   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"
                ].join("\n"), ["precision lowp float;", "varying vec2 vTextureCoord;", "uniform sampler2D uSampler;", "uniform vec4 light;", "uniform vec4 dark;", "void main(void){", "vec4 texColor = texture2D(uSampler, vTextureCoord);", "gl_FragColor.a = texColor.a * light.a;", "gl_FragColor.rgb = ((texColor.a - 1.0) * dark.a + 1.0 - texColor.rgb) * dark.rgb + texColor.rgb * light.rgb;",
                    "}"
                ].join("\n"), {
                    light: {
                        type: "4fv",
                        value: [1, 1, 1, 1]
                    },
                    dark: {
                        type: "4fv",
                        value: [0, 0, 0, 1]
                    },
                    translationMatrix: {
                        type: "mat3",
                        value: new Float32Array(9)
                    },
                    projectionMatrix: {
                        type: "mat3",
                        value: new Float32Array(9)
                    }
                }, {
                    aVertexPosition: 0,
                    aTextureCoord: 0
                })
            }
            var n = t("../../core");
            i.prototype = Object.create(n.Shader.prototype), i.prototype.constructor = i, e.exports = i, n.ShaderManager.registerPlugin("meshShader", i)
        }, {
            "../../core": 25
        }],
        96: [function(t, e, r) {
            Object.assign || (Object.assign = t("object-assign"))
        }, {
            "object-assign": 7
        }],
        97: [function(t, e, r) {
            t("./Object.assign"), t("./requestAnimationFrame")
        }, {
            "./Object.assign": 96,
            "./requestAnimationFrame": 98
        }],
        98: [function(t, e, r) {
            (function(t) {
                if (Date.now && Date.prototype.getTime || (Date.now = function() {
                        return (new Date).getTime()
                    }), !t.performance || !t.performance.now) {
                    var e = Date.now();
                    t.performance || (t.performance = {}), t.performance.now = function() {
                        return Date.now() - e
                    }
                }
                for (var r = Date.now(), i = ["ms", "moz", "webkit", "o"], n = 0; n < i.length && !t.requestAnimationFrame; ++n) t.requestAnimationFrame = t[i[n] +
                    "RequestAnimationFrame"], t.cancelAnimationFrame = t[i[n] + "CancelAnimationFrame"] || t[i[n] + "CancelRequestAnimationFrame"];
                t.requestAnimationFrame || (t.requestAnimationFrame = function(t) {
                    if ("function" != typeof t) throw new TypeError(t + "is not a function");
                    var e = Date.now(),
                        i = 16 + r - e;
                    return i < 0 && (i = 0), r = e, setTimeout(function() {
                        r = Date.now(), t(performance.now())
                    }, i)
                }), t.cancelAnimationFrame || (t.cancelAnimationFrame = function(t) {
                    clearTimeout(t)
                })
            }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ?
                self : "undefined" != typeof window ? window : {})
        }, {}],
        99: [function(t, e, r) {
            function i() {
                var t = this;
                this._tick = function(e) {
                    t._requestId = null, t.started && (t.update(e), t.started && null === t._requestId && t._emitter.listeners(o, !0))
                }, this._emitter = new s, this._requestId = null, this._maxElapsedMS = 100, this.autoStart = !1, this.deltaTime = 1, this.elapsedMS = 1 / n.TARGET_FPMS, this.lastTime = 0, this.speed = 1, this.started = !1
            }
            var n = t("../core"),
                s = t("eventemitter3"),
                o = "tick";
            Object.defineProperties(i.prototype, {
                FPS: {
                    get: function() {
                        return 1E3 /
                            this.elapsedMS
                    }
                },
                minFPS: {
                    get: function() {
                        return 1E3 / this._maxElapsedMS
                    },
                    set: function(t) {
                        var e = Math.min(Math.max(0, t) / 1E3, n.TARGET_FPMS);
                        this._maxElapsedMS = 1 / e
                    }
                }
            }), i.prototype._requestIfNeeded = function() {
                null === this._requestId && this._emitter.listeners(o, !0) && (this.lastTime = performance.now(), this._requestId = requestAnimationFrame(this._tick))
            }, i.prototype._cancelIfNeeded = function() {
                null !== this._requestId && (cancelAnimationFrame(this._requestId), this._requestId = null)
            }, i.prototype._startIfPossible = function() {
                this.started ?
                    this._requestIfNeeded() : this.autoStart && this.start()
            }, i.prototype.add = function(t, e) {
                return this._emitter.on(o, t, e), this._startIfPossible(), this
            }, i.prototype.addOnce = function(t, e) {
                return this._emitter.once(o, t, e), this._startIfPossible(), this
            }, i.prototype.remove = function(t, e) {
                return this._emitter.off(o, t, e), this._emitter.listeners(o, !0) || this._cancelIfNeeded(), this
            }, i.prototype.start = function() {
                this.started || (this.started = !0, this._requestIfNeeded())
            }, i.prototype.stop = function() {
                this.started && (this.started = !1, this._cancelIfNeeded())
            }, i.prototype.update = function(t) {
                var e;
                t = t || performance.now(), e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), this.deltaTime = e * n.TARGET_FPMS * this.speed, this._emitter.emit(o, this.deltaTime), this.lastTime = t
            }, e.exports = i
        }, {
            "../core": 25,
            eventemitter3: 6
        }],
        100: [function(t, e, r) {
            var i = t("./Ticker"),
                n = new i;
            n.autoStart = !0, e.exports = {
                shared: n,
                Ticker: i
            }
        }, {
            "./Ticker": 99
        }]
    }, {}, [1])(1)
});
var __extends = this && this.__extends || function() {
    var extendStatics = Object.setPrototypeOf || {
        __proto__: []
    }
    instanceof Array && function(d, b) {
        d.__proto__ = b
    } || function(d, b) {
        for (var p in b)
            if (b.hasOwnProperty(p)) d[p] = b[p]
    };
    return function(d, b) {
        extendStatics(d, b);

        function __() {
            this.constructor = d
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
    }
}();
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var Animation = function() {
            function Animation(name, timelines, duration) {
                if (name == null) throw new Error("name cannot be null.");
                if (timelines == null) throw new Error("timelines cannot be null.");
                this.name = name;
                this.timelines = timelines;
                this.duration = duration
            }
            Animation.prototype.apply = function(skeleton, lastTime, time, loop, events, alpha, pose, direction) {
                if (skeleton == null) throw new Error("skeleton cannot be null.");
                if (loop && this.duration != 0) {
                    time %= this.duration;
                    if (lastTime >
                        0) lastTime %= this.duration
                }
                var timelines = this.timelines;
                for (var i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, pose, direction)
            };
            Animation.binarySearch = function(values, target, step) {
                if (step === void 0) step = 1;
                var low = 0;
                var high = values.length / step - 2;
                if (high == 0) return step;
                var current = high >>> 1;
                while (true) {
                    if (values[(current + 1) * step] <= target) low = current + 1;
                    else high = current;
                    if (low == high) return (low + 1) * step;
                    current = low + high >>> 1
                }
            };
            Animation.linearSearch = function(values, target,
                step) {
                for (var i = 0, last = values.length - step; i <= last; i += step)
                    if (values[i] > target) return i;
                return -1
            };
            return Animation
        }();
        core.Animation = Animation;
        var MixPose;
        (function(MixPose) {
            MixPose[MixPose["setup"] = 0] = "setup";
            MixPose[MixPose["current"] = 1] = "current";
            MixPose[MixPose["currentLayered"] = 2] = "currentLayered"
        })(MixPose = core.MixPose || (core.MixPose = {}));
        var MixDirection;
        (function(MixDirection) {
            MixDirection[MixDirection["in"] = 0] = "in";
            MixDirection[MixDirection["out"] = 1] = "out"
        })(MixDirection = core.MixDirection ||
            (core.MixDirection = {}));
        var TimelineType;
        (function(TimelineType) {
            TimelineType[TimelineType["rotate"] = 0] = "rotate";
            TimelineType[TimelineType["translate"] = 1] = "translate";
            TimelineType[TimelineType["scale"] = 2] = "scale";
            TimelineType[TimelineType["shear"] = 3] = "shear";
            TimelineType[TimelineType["attachment"] = 4] = "attachment";
            TimelineType[TimelineType["color"] = 5] = "color";
            TimelineType[TimelineType["deform"] = 6] = "deform";
            TimelineType[TimelineType["event"] = 7] = "event";
            TimelineType[TimelineType["drawOrder"] = 8] = "drawOrder";
            TimelineType[TimelineType["ikConstraint"] = 9] = "ikConstraint";
            TimelineType[TimelineType["transformConstraint"] = 10] = "transformConstraint";
            TimelineType[TimelineType["pathConstraintPosition"] = 11] = "pathConstraintPosition";
            TimelineType[TimelineType["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
            TimelineType[TimelineType["pathConstraintMix"] = 13] = "pathConstraintMix";
            TimelineType[TimelineType["twoColor"] = 14] = "twoColor"
        })(TimelineType = core.TimelineType || (core.TimelineType = {}));
        var CurveTimeline = function() {
            function CurveTimeline(frameCount) {
                if (frameCount <=
                    0) throw new Error("frameCount must be > 0: " + frameCount);
                this.curves = core.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE)
            }
            CurveTimeline.prototype.getFrameCount = function() {
                return this.curves.length / CurveTimeline.BEZIER_SIZE + 1
            };
            CurveTimeline.prototype.setLinear = function(frameIndex) {
                this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR
            };
            CurveTimeline.prototype.setStepped = function(frameIndex) {
                this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED
            };
            CurveTimeline.prototype.getCurveType =
                function(frameIndex) {
                    var index = frameIndex * CurveTimeline.BEZIER_SIZE;
                    if (index == this.curves.length) return CurveTimeline.LINEAR;
                    var type = this.curves[index];
                    if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;
                    if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;
                    return CurveTimeline.BEZIER
                };
            CurveTimeline.prototype.setCurve = function(frameIndex, cx1, cy1, cx2, cy2) {
                var tmpx = (-cx1 * 2 + cx2) * .03,
                    tmpy = (-cy1 * 2 + cy2) * .03;
                var dddfx = ((cx1 - cx2) * 3 + 1) * .006,
                    dddfy = ((cy1 - cy2) * 3 + 1) * .006;
                var ddfx = tmpx * 2 + dddfx,
                    ddfy =
                    tmpy * 2 + dddfy;
                var dfx = cx1 * .3 + tmpx + dddfx * .16666667,
                    dfy = cy1 * .3 + tmpy + dddfy * .16666667;
                var i = frameIndex * CurveTimeline.BEZIER_SIZE;
                var curves = this.curves;
                curves[i++] = CurveTimeline.BEZIER;
                var x = dfx,
                    y = dfy;
                for (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
                    curves[i] = x;
                    curves[i + 1] = y;
                    dfx += ddfx;
                    dfy += ddfy;
                    ddfx += dddfx;
                    ddfy += dddfy;
                    x += dfx;
                    y += dfy
                }
            };
            CurveTimeline.prototype.getCurvePercent = function(frameIndex, percent) {
                percent = core.MathUtils.clamp(percent, 0, 1);
                var curves = this.curves;
                var i = frameIndex * CurveTimeline.BEZIER_SIZE;
                var type = curves[i];
                if (type == CurveTimeline.LINEAR) return percent;
                if (type == CurveTimeline.STEPPED) return 0;
                i++;
                var x = 0;
                for (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
                    x = curves[i];
                    if (x >= percent) {
                        var prevX = void 0,
                            prevY = void 0;
                        if (i == start) {
                            prevX = 0;
                            prevY = 0
                        } else {
                            prevX = curves[i - 2];
                            prevY = curves[i - 1]
                        }
                        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX)
                    }
                }
                var y = curves[i - 1];
                return y + (1 - y) * (percent - x) / (1 - x)
            };
            CurveTimeline.LINEAR = 0;
            CurveTimeline.STEPPED = 1;
            CurveTimeline.BEZIER = 2;
            CurveTimeline.BEZIER_SIZE =
                10 * 2 - 1;
            return CurveTimeline
        }();
        core.CurveTimeline = CurveTimeline;
        var RotateTimeline = function(_super) {
            __extends(RotateTimeline, _super);

            function RotateTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount << 1);
                return _this
            }
            RotateTimeline.prototype.getPropertyId = function() {
                return (TimelineType.rotate << 24) + this.boneIndex
            };
            RotateTimeline.prototype.setFrame = function(frameIndex, time, degrees) {
                frameIndex <<= 1;
                this.frames[frameIndex] = time;
                this.frames[frameIndex +
                    RotateTimeline.ROTATION] = degrees
            };
            RotateTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, pose, direction) {
                var frames = this.frames;
                var bone = skeleton.bones[this.boneIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            bone.rotation = bone.data.rotation;
                            return;
                        case MixPose.current:
                            var r_1 = bone.data.rotation - bone.rotation;
                            r_1 -= (16384 - (16384.499999999996 - r_1 / 360 | 0)) * 360;
                            bone.rotation += r_1 * alpha
                    }
                    return
                }
                if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {
                    if (pose == MixPose.setup) bone.rotation =
                        bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] * alpha;
                    else {
                        var r_2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;
                        r_2 -= (16384 - (16384.499999999996 - r_2 / 360 | 0)) * 360;
                        bone.rotation += r_2 * alpha
                    }
                    return
                }
                var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);
                var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];
                var frameTime = frames[frame];
                var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] -
                    frameTime));
                var r = frames[frame + RotateTimeline.ROTATION] - prevRotation;
                r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
                r = prevRotation + r * percent;
                if (pose == MixPose.setup) {
                    r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
                    bone.rotation = bone.data.rotation + r * alpha
                } else {
                    r = bone.data.rotation + r - bone.rotation;
                    r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
                    bone.rotation += r * alpha
                }
            };
            RotateTimeline.ENTRIES = 2;
            RotateTimeline.PREV_TIME = -2;
            RotateTimeline.PREV_ROTATION = -1;
            RotateTimeline.ROTATION = 1;
            return RotateTimeline
        }(CurveTimeline);
        core.RotateTimeline = RotateTimeline;
        var TranslateTimeline = function(_super) {
            __extends(TranslateTimeline, _super);

            function TranslateTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);
                return _this
            }
            TranslateTimeline.prototype.getPropertyId = function() {
                return (TimelineType.translate << 24) + this.boneIndex
            };
            TranslateTimeline.prototype.setFrame = function(frameIndex, time, x, y) {
                frameIndex *= TranslateTimeline.ENTRIES;
                this.frames[frameIndex] =
                    time;
                this.frames[frameIndex + TranslateTimeline.X] = x;
                this.frames[frameIndex + TranslateTimeline.Y] = y
            };
            TranslateTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, pose, direction) {
                var frames = this.frames;
                var bone = skeleton.bones[this.boneIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            bone.x = bone.data.x;
                            bone.y = bone.data.y;
                            return;
                        case MixPose.current:
                            bone.x += (bone.data.x - bone.x) * alpha;
                            bone.y += (bone.data.y - bone.y) * alpha
                    }
                    return
                }
                var x = 0,
                    y = 0;
                if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {
                    x =
                        frames[frames.length + TranslateTimeline.PREV_X];
                    y = frames[frames.length + TranslateTimeline.PREV_Y]
                } else {
                    var frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);
                    x = frames[frame + TranslateTimeline.PREV_X];
                    y = frames[frame + TranslateTimeline.PREV_Y];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));
                    x += (frames[frame + TranslateTimeline.X] - x) * percent;
                    y += (frames[frame + TranslateTimeline.Y] -
                        y) * percent
                }
                if (pose == MixPose.setup) {
                    bone.x = bone.data.x + x * alpha;
                    bone.y = bone.data.y + y * alpha
                } else {
                    bone.x += (bone.data.x + x - bone.x) * alpha;
                    bone.y += (bone.data.y + y - bone.y) * alpha
                }
            };
            TranslateTimeline.ENTRIES = 3;
            TranslateTimeline.PREV_TIME = -3;
            TranslateTimeline.PREV_X = -2;
            TranslateTimeline.PREV_Y = -1;
            TranslateTimeline.X = 1;
            TranslateTimeline.Y = 2;
            return TranslateTimeline
        }(CurveTimeline);
        core.TranslateTimeline = TranslateTimeline;
        var ScaleTimeline = function(_super) {
            __extends(ScaleTimeline, _super);

            function ScaleTimeline(frameCount) {
                return _super.call(this,
                    frameCount) || this
            }
            ScaleTimeline.prototype.getPropertyId = function() {
                return (TimelineType.scale << 24) + this.boneIndex
            };
            ScaleTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, pose, direction) {
                var frames = this.frames;
                var bone = skeleton.bones[this.boneIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            bone.scaleX = bone.data.scaleX;
                            bone.scaleY = bone.data.scaleY;
                            return;
                        case MixPose.current:
                            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
                            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha
                    }
                    return
                }
                var x =
                    0,
                    y = 0;
                if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {
                    x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;
                    y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY
                } else {
                    var frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);
                    x = frames[frame + ScaleTimeline.PREV_X];
                    y = frames[frame + ScaleTimeline.PREV_Y];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));
                    x = (x + (frames[frame +
                        ScaleTimeline.X] - x) * percent) * bone.data.scaleX;
                    y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY
                }
                if (alpha == 1) {
                    bone.scaleX = x;
                    bone.scaleY = y
                } else {
                    var bx = 0,
                        by = 0;
                    if (pose == MixPose.setup) {
                        bx = bone.data.scaleX;
                        by = bone.data.scaleY
                    } else {
                        bx = bone.scaleX;
                        by = bone.scaleY
                    }
                    if (direction == MixDirection.out) {
                        x = Math.abs(x) * core.MathUtils.signum(bx);
                        y = Math.abs(y) * core.MathUtils.signum(by)
                    } else {
                        bx = Math.abs(bx) * core.MathUtils.signum(x);
                        by = Math.abs(by) * core.MathUtils.signum(y)
                    }
                    bone.scaleX = bx + (x - bx) * alpha;
                    bone.scaleY =
                        by + (y - by) * alpha
                }
            };
            return ScaleTimeline
        }(TranslateTimeline);
        core.ScaleTimeline = ScaleTimeline;
        var ShearTimeline = function(_super) {
            __extends(ShearTimeline, _super);

            function ShearTimeline(frameCount) {
                return _super.call(this, frameCount) || this
            }
            ShearTimeline.prototype.getPropertyId = function() {
                return (TimelineType.shear << 24) + this.boneIndex
            };
            ShearTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, pose, direction) {
                var frames = this.frames;
                var bone = skeleton.bones[this.boneIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            bone.shearX =
                                bone.data.shearX;
                            bone.shearY = bone.data.shearY;
                            return;
                        case MixPose.current:
                            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
                            bone.shearY += (bone.data.shearY - bone.shearY) * alpha
                    }
                    return
                }
                var x = 0,
                    y = 0;
                if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {
                    x = frames[frames.length + ShearTimeline.PREV_X];
                    y = frames[frames.length + ShearTimeline.PREV_Y]
                } else {
                    var frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);
                    x = frames[frame + ShearTimeline.PREV_X];
                    y = frames[frame + ShearTimeline.PREV_Y];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));
                    x = x + (frames[frame + ShearTimeline.X] - x) * percent;
                    y = y + (frames[frame + ShearTimeline.Y] - y) * percent
                }
                if (pose == MixPose.setup) {
                    bone.shearX = bone.data.shearX + x * alpha;
                    bone.shearY = bone.data.shearY + y * alpha
                } else {
                    bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
                    bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha
                }
            };
            return ShearTimeline
        }(TranslateTimeline);
        core.ShearTimeline = ShearTimeline;
        var ColorTimeline = function(_super) {
            __extends(ColorTimeline, _super);

            function ColorTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);
                return _this
            }
            ColorTimeline.prototype.getPropertyId = function() {
                return (TimelineType.color << 24) + this.slotIndex
            };
            ColorTimeline.prototype.setFrame = function(frameIndex, time, r, g, b, a) {
                frameIndex *= ColorTimeline.ENTRIES;
                this.frames[frameIndex] = time;
                this.frames[frameIndex + ColorTimeline.R] = r;
                this.frames[frameIndex +
                    ColorTimeline.G] = g;
                this.frames[frameIndex + ColorTimeline.B] = b;
                this.frames[frameIndex + ColorTimeline.A] = a
            };
            ColorTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, pose, direction) {
                var slot = skeleton.slots[this.slotIndex];
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            slot.color.setFromColor(slot.data.color);
                            return;
                        case MixPose.current:
                            var color = slot.color,
                                setup = slot.data.color;
                            color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha,
                                (setup.a - color.a) * alpha)
                    }
                    return
                }
                var r = 0,
                    g = 0,
                    b = 0,
                    a = 0;
                if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {
                    var i = frames.length;
                    r = frames[i + ColorTimeline.PREV_R];
                    g = frames[i + ColorTimeline.PREV_G];
                    b = frames[i + ColorTimeline.PREV_B];
                    a = frames[i + ColorTimeline.PREV_A]
                } else {
                    var frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);
                    r = frames[frame + ColorTimeline.PREV_R];
                    g = frames[frame + ColorTimeline.PREV_G];
                    b = frames[frame + ColorTimeline.PREV_B];
                    a = frames[frame + ColorTimeline.PREV_A];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));
                    r += (frames[frame + ColorTimeline.R] - r) * percent;
                    g += (frames[frame + ColorTimeline.G] - g) * percent;
                    b += (frames[frame + ColorTimeline.B] - b) * percent;
                    a += (frames[frame + ColorTimeline.A] - a) * percent
                }
                if (alpha == 1) slot.color.set(r, g, b, a);
                else {
                    var color = slot.color;
                    if (pose == MixPose.setup) color.setFromColor(slot.data.color);
                    color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a -
                        color.a) * alpha)
                }
            };
            ColorTimeline.ENTRIES = 5;
            ColorTimeline.PREV_TIME = -5;
            ColorTimeline.PREV_R = -4;
            ColorTimeline.PREV_G = -3;
            ColorTimeline.PREV_B = -2;
            ColorTimeline.PREV_A = -1;
            ColorTimeline.R = 1;
            ColorTimeline.G = 2;
            ColorTimeline.B = 3;
            ColorTimeline.A = 4;
            return ColorTimeline
        }(CurveTimeline);
        core.ColorTimeline = ColorTimeline;
        var TwoColorTimeline = function(_super) {
            __extends(TwoColorTimeline, _super);

            function TwoColorTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount *
                    TwoColorTimeline.ENTRIES);
                return _this
            }
            TwoColorTimeline.prototype.getPropertyId = function() {
                return (TimelineType.twoColor << 24) + this.slotIndex
            };
            TwoColorTimeline.prototype.setFrame = function(frameIndex, time, r, g, b, a, r2, g2, b2) {
                frameIndex *= TwoColorTimeline.ENTRIES;
                this.frames[frameIndex] = time;
                this.frames[frameIndex + TwoColorTimeline.R] = r;
                this.frames[frameIndex + TwoColorTimeline.G] = g;
                this.frames[frameIndex + TwoColorTimeline.B] = b;
                this.frames[frameIndex + TwoColorTimeline.A] = a;
                this.frames[frameIndex + TwoColorTimeline.R2] =
                    r2;
                this.frames[frameIndex + TwoColorTimeline.G2] = g2;
                this.frames[frameIndex + TwoColorTimeline.B2] = b2
            };
            TwoColorTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, pose, direction) {
                var slot = skeleton.slots[this.slotIndex];
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            slot.color.setFromColor(slot.data.color);
                            slot.darkColor.setFromColor(slot.data.darkColor);
                            return;
                        case MixPose.current:
                            var light = slot.color,
                                dark = slot.darkColor,
                                setupLight = slot.data.color,
                                setupDark =
                                slot.data.darkColor;
                            light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
                            dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0)
                    }
                    return
                }
                var r = 0,
                    g = 0,
                    b = 0,
                    a = 0,
                    r2 = 0,
                    g2 = 0,
                    b2 = 0;
                if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {
                    var i = frames.length;
                    r = frames[i + TwoColorTimeline.PREV_R];
                    g = frames[i + TwoColorTimeline.PREV_G];
                    b = frames[i + TwoColorTimeline.PREV_B];
                    a = frames[i + TwoColorTimeline.PREV_A];
                    r2 = frames[i + TwoColorTimeline.PREV_R2];
                    g2 = frames[i + TwoColorTimeline.PREV_G2];
                    b2 = frames[i + TwoColorTimeline.PREV_B2]
                } else {
                    var frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);
                    r = frames[frame + TwoColorTimeline.PREV_R];
                    g = frames[frame + TwoColorTimeline.PREV_G];
                    b = frames[frame + TwoColorTimeline.PREV_B];
                    a = frames[frame + TwoColorTimeline.PREV_A];
                    r2 = frames[frame + TwoColorTimeline.PREV_R2];
                    g2 = frames[frame + TwoColorTimeline.PREV_G2];
                    b2 = frames[frame + TwoColorTimeline.PREV_B2];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));
                    r += (frames[frame + TwoColorTimeline.R] - r) * percent;
                    g += (frames[frame + TwoColorTimeline.G] - g) * percent;
                    b += (frames[frame + TwoColorTimeline.B] - b) * percent;
                    a += (frames[frame + TwoColorTimeline.A] - a) * percent;
                    r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;
                    g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;
                    b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent
                }
                if (alpha == 1) {
                    slot.color.set(r,
                        g, b, a);
                    slot.darkColor.set(r2, g2, b2, 1)
                } else {
                    var light = slot.color,
                        dark = slot.darkColor;
                    if (pose == MixPose.setup) {
                        light.setFromColor(slot.data.color);
                        dark.setFromColor(slot.data.darkColor)
                    }
                    light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
                    dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0)
                }
            };
            TwoColorTimeline.ENTRIES = 8;
            TwoColorTimeline.PREV_TIME = -8;
            TwoColorTimeline.PREV_R = -7;
            TwoColorTimeline.PREV_G = -6;
            TwoColorTimeline.PREV_B = -5;
            TwoColorTimeline.PREV_A = -4;
            TwoColorTimeline.PREV_R2 = -3;
            TwoColorTimeline.PREV_G2 = -2;
            TwoColorTimeline.PREV_B2 = -1;
            TwoColorTimeline.R = 1;
            TwoColorTimeline.G = 2;
            TwoColorTimeline.B = 3;
            TwoColorTimeline.A = 4;
            TwoColorTimeline.R2 = 5;
            TwoColorTimeline.G2 = 6;
            TwoColorTimeline.B2 = 7;
            return TwoColorTimeline
        }(CurveTimeline);
        core.TwoColorTimeline = TwoColorTimeline;
        var AttachmentTimeline = function() {
            function AttachmentTimeline(frameCount) {
                this.frames = core.Utils.newFloatArray(frameCount);
                this.attachmentNames = new Array(frameCount)
            }
            AttachmentTimeline.prototype.getPropertyId = function() {
                return (TimelineType.attachment <<
                    24) + this.slotIndex
            };
            AttachmentTimeline.prototype.getFrameCount = function() {
                return this.frames.length
            };
            AttachmentTimeline.prototype.setFrame = function(frameIndex, time, attachmentName) {
                this.frames[frameIndex] = time;
                this.attachmentNames[frameIndex] = attachmentName
            };
            AttachmentTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, pose, direction) {
                var slot = skeleton.slots[this.slotIndex];
                if (direction == MixDirection.out && pose == MixPose.setup) {
                    var attachmentName_1 = slot.data.attachmentName;
                    slot.setAttachment(attachmentName_1 ==
                        null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));
                    return
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    if (pose == MixPose.setup) {
                        var attachmentName_2 = slot.data.attachmentName;
                        slot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2))
                    }
                    return
                }
                var frameIndex = 0;
                if (time >= frames[frames.length - 1]) frameIndex = frames.length - 1;
                else frameIndex = Animation.binarySearch(frames, time, 1) - 1;
                var attachmentName = this.attachmentNames[frameIndex];
                skeleton.slots[this.slotIndex].setAttachment(attachmentName ==
                    null ? null : skeleton.getAttachment(this.slotIndex, attachmentName))
            };
            return AttachmentTimeline
        }();
        core.AttachmentTimeline = AttachmentTimeline;
        var zeros = null;
        var DeformTimeline = function(_super) {
            __extends(DeformTimeline, _super);

            function DeformTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount);
                _this.frameVertices = new Array(frameCount);
                if (zeros == null) zeros = core.Utils.newFloatArray(64);
                return _this
            }
            DeformTimeline.prototype.getPropertyId = function() {
                return (TimelineType.deform <<
                    27) + +this.attachment.id + this.slotIndex
            };
            DeformTimeline.prototype.setFrame = function(frameIndex, time, vertices) {
                this.frames[frameIndex] = time;
                this.frameVertices[frameIndex] = vertices
            };
            DeformTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                var slot = skeleton.slots[this.slotIndex];
                var slotAttachment = slot.getAttachment();
                if (!(slotAttachment instanceof core.VertexAttachment) || !slotAttachment.applyDeform(this.attachment)) return;
                var verticesArray = slot.attachmentVertices;
                if (verticesArray.length == 0) alpha = 1;
                var frameVertices = this.frameVertices;
                var vertexCount = frameVertices[0].length;
                var frames = this.frames;
                if (time < frames[0]) {
                    var vertexAttachment = slotAttachment;
                    switch (pose) {
                        case MixPose.setup:
                            verticesArray.length = 0;
                            return;
                        case MixPose.current:
                            if (alpha == 1) {
                                verticesArray.length = 0;
                                break
                            }
                            var vertices_1 = core.Utils.setArraySize(verticesArray, vertexCount);
                            if (vertexAttachment.bones == null) {
                                var setupVertices = vertexAttachment.vertices;
                                for (var i = 0; i < vertexCount; i++) vertices_1[i] +=
                                    (setupVertices[i] - vertices_1[i]) * alpha
                            } else {
                                alpha = 1 - alpha;
                                for (var i = 0; i < vertexCount; i++) vertices_1[i] *= alpha
                            }
                    }
                    return
                }
                var vertices = core.Utils.setArraySize(verticesArray, vertexCount);
                if (time >= frames[frames.length - 1]) {
                    var lastVertices = frameVertices[frames.length - 1];
                    if (alpha == 1) core.Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);
                    else if (pose == MixPose.setup) {
                        var vertexAttachment = slotAttachment;
                        if (vertexAttachment.bones == null) {
                            var setupVertices = vertexAttachment.vertices;
                            for (var i = 0; i < vertexCount; i++) {
                                var setup =
                                    setupVertices[i];
                                vertices[i] = setup + (lastVertices[i] - setup) * alpha
                            }
                        } else
                            for (var i = 0; i < vertexCount; i++) vertices[i] = lastVertices[i] * alpha
                    } else
                        for (var i = 0; i < vertexCount; i++) vertices[i] += (lastVertices[i] - vertices[i]) * alpha;
                    return
                }
                var frame = Animation.binarySearch(frames, time);
                var prevVertices = frameVertices[frame - 1];
                var nextVertices = frameVertices[frame];
                var frameTime = frames[frame];
                var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));
                if (alpha == 1)
                    for (var i = 0; i < vertexCount; i++) {
                        var prev =
                            prevVertices[i];
                        vertices[i] = prev + (nextVertices[i] - prev) * percent
                    } else if (pose == MixPose.setup) {
                        var vertexAttachment = slotAttachment;
                        if (vertexAttachment.bones == null) {
                            var setupVertices = vertexAttachment.vertices;
                            for (var i = 0; i < vertexCount; i++) {
                                var prev = prevVertices[i],
                                    setup = setupVertices[i];
                                vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha
                            }
                        } else
                            for (var i = 0; i < vertexCount; i++) {
                                var prev = prevVertices[i];
                                vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha
                            }
                    } else
                        for (var i = 0; i < vertexCount; i++) {
                            var prev =
                                prevVertices[i];
                            vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha
                        }
            };
            return DeformTimeline
        }(CurveTimeline);
        core.DeformTimeline = DeformTimeline;
        var EventTimeline = function() {
            function EventTimeline(frameCount) {
                this.frames = core.Utils.newFloatArray(frameCount);
                this.events = new Array(frameCount)
            }
            EventTimeline.prototype.getPropertyId = function() {
                return TimelineType.event << 24
            };
            EventTimeline.prototype.getFrameCount = function() {
                return this.frames.length
            };
            EventTimeline.prototype.setFrame = function(frameIndex,
                event) {
                this.frames[frameIndex] = event.time;
                this.events[frameIndex] = event
            };
            EventTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                if (firedEvents == null) return;
                var frames = this.frames;
                var frameCount = this.frames.length;
                if (lastTime > time) {
                    this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, pose, direction);
                    lastTime = -1
                } else if (lastTime >= frames[frameCount - 1]) return;
                if (time < frames[0]) return;
                var frame = 0;
                if (lastTime < frames[0]) frame = 0;
                else {
                    frame = Animation.binarySearch(frames,
                        lastTime);
                    var frameTime = frames[frame];
                    while (frame > 0) {
                        if (frames[frame - 1] != frameTime) break;
                        frame--
                    }
                }
                for (; frame < frameCount && time >= frames[frame]; frame++) firedEvents.push(this.events[frame])
            };
            return EventTimeline
        }();
        core.EventTimeline = EventTimeline;
        var DrawOrderTimeline = function() {
            function DrawOrderTimeline(frameCount) {
                this.frames = core.Utils.newFloatArray(frameCount);
                this.drawOrders = new Array(frameCount)
            }
            DrawOrderTimeline.prototype.getPropertyId = function() {
                return TimelineType.drawOrder << 24
            };
            DrawOrderTimeline.prototype.getFrameCount =
                function() {
                    return this.frames.length
                };
            DrawOrderTimeline.prototype.setFrame = function(frameIndex, time, drawOrder) {
                this.frames[frameIndex] = time;
                this.drawOrders[frameIndex] = drawOrder
            };
            DrawOrderTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                var drawOrder = skeleton.drawOrder;
                var slots = skeleton.slots;
                if (direction == MixDirection.out && pose == MixPose.setup) {
                    core.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
                    return
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    if (pose == MixPose.setup) core.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
                    return
                }
                var frame = 0;
                if (time >= frames[frames.length - 1]) frame = frames.length - 1;
                else frame = Animation.binarySearch(frames, time) - 1;
                var drawOrderToSetupIndex = this.drawOrders[frame];
                if (drawOrderToSetupIndex == null) core.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
                else
                    for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]]
            };
            return DrawOrderTimeline
        }();
        core.DrawOrderTimeline = DrawOrderTimeline;
        var IkConstraintTimeline = function(_super) {
            __extends(IkConstraintTimeline, _super);

            function IkConstraintTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);
                return _this
            }
            IkConstraintTimeline.prototype.getPropertyId = function() {
                return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex
            };
            IkConstraintTimeline.prototype.setFrame = function(frameIndex, time, mix, bendDirection) {
                frameIndex *=
                    IkConstraintTimeline.ENTRIES;
                this.frames[frameIndex] = time;
                this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;
                this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection
            };
            IkConstraintTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                var frames = this.frames;
                var constraint = skeleton.ikConstraints[this.ikConstraintIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            constraint.mix = constraint.data.mix;
                            constraint.bendDirection = constraint.data.bendDirection;
                            return;
                        case MixPose.current:
                            constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
                            constraint.bendDirection = constraint.data.bendDirection
                    }
                    return
                }
                if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {
                    if (pose == MixPose.setup) {
                        constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;
                        constraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection : frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION]
                    } else {
                        constraint.mix +=
                            (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;
                        if (direction == MixDirection["in"]) constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION]
                    }
                    return
                }
                var frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);
                var mix = frames[frame + IkConstraintTimeline.PREV_MIX];
                var frameTime = frames[frame];
                var percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));
                if (pose == MixPose.setup) {
                    constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;
                    constraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection : frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION]
                } else {
                    constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;
                    if (direction == MixDirection["in"]) constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION]
                }
            };
            IkConstraintTimeline.ENTRIES =
                3;
            IkConstraintTimeline.PREV_TIME = -3;
            IkConstraintTimeline.PREV_MIX = -2;
            IkConstraintTimeline.PREV_BEND_DIRECTION = -1;
            IkConstraintTimeline.MIX = 1;
            IkConstraintTimeline.BEND_DIRECTION = 2;
            return IkConstraintTimeline
        }(CurveTimeline);
        core.IkConstraintTimeline = IkConstraintTimeline;
        var TransformConstraintTimeline = function(_super) {
            __extends(TransformConstraintTimeline, _super);

            function TransformConstraintTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount *
                    TransformConstraintTimeline.ENTRIES);
                return _this
            }
            TransformConstraintTimeline.prototype.getPropertyId = function() {
                return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex
            };
            TransformConstraintTimeline.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
                frameIndex *= TransformConstraintTimeline.ENTRIES;
                this.frames[frameIndex] = time;
                this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;
                this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] =
                    translateMix;
                this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;
                this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix
            };
            TransformConstraintTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                var frames = this.frames;
                var constraint = skeleton.transformConstraints[this.transformConstraintIndex];
                if (time < frames[0]) {
                    var data = constraint.data;
                    switch (pose) {
                        case MixPose.setup:
                            constraint.rotateMix = data.rotateMix;
                            constraint.translateMix = data.translateMix;
                            constraint.scaleMix = data.scaleMix;
                            constraint.shearMix = data.shearMix;
                            return;
                        case MixPose.current:
                            constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
                            constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
                            constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
                            constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha
                    }
                    return
                }
                var rotate = 0,
                    translate = 0,
                    scale = 0,
                    shear = 0;
                if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {
                    var i = frames.length;
                    rotate =
                        frames[i + TransformConstraintTimeline.PREV_ROTATE];
                    translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];
                    scale = frames[i + TransformConstraintTimeline.PREV_SCALE];
                    shear = frames[i + TransformConstraintTimeline.PREV_SHEAR]
                } else {
                    var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);
                    rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];
                    translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];
                    scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];
                    shear =
                        frames[frame + TransformConstraintTimeline.PREV_SHEAR];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));
                    rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;
                    translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;
                    scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;
                    shear += (frames[frame + TransformConstraintTimeline.SHEAR] -
                        shear) * percent
                }
                if (pose == MixPose.setup) {
                    var data = constraint.data;
                    constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
                    constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
                    constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
                    constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha
                } else {
                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
                    constraint.translateMix += (translate - constraint.translateMix) * alpha;
                    constraint.scaleMix += (scale - constraint.scaleMix) *
                        alpha;
                    constraint.shearMix += (shear - constraint.shearMix) * alpha
                }
            };
            TransformConstraintTimeline.ENTRIES = 5;
            TransformConstraintTimeline.PREV_TIME = -5;
            TransformConstraintTimeline.PREV_ROTATE = -4;
            TransformConstraintTimeline.PREV_TRANSLATE = -3;
            TransformConstraintTimeline.PREV_SCALE = -2;
            TransformConstraintTimeline.PREV_SHEAR = -1;
            TransformConstraintTimeline.ROTATE = 1;
            TransformConstraintTimeline.TRANSLATE = 2;
            TransformConstraintTimeline.SCALE = 3;
            TransformConstraintTimeline.SHEAR = 4;
            return TransformConstraintTimeline
        }(CurveTimeline);
        core.TransformConstraintTimeline = TransformConstraintTimeline;
        var PathConstraintPositionTimeline = function(_super) {
            __extends(PathConstraintPositionTimeline, _super);

            function PathConstraintPositionTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);
                return _this
            }
            PathConstraintPositionTimeline.prototype.getPropertyId = function() {
                return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex
            };
            PathConstraintPositionTimeline.prototype.setFrame = function(frameIndex, time, value) {
                frameIndex *= PathConstraintPositionTimeline.ENTRIES;
                this.frames[frameIndex] = time;
                this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value
            };
            PathConstraintPositionTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                var frames = this.frames;
                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            constraint.position =
                                constraint.data.position;
                            return;
                        case MixPose.current:
                            constraint.position += (constraint.data.position - constraint.position) * alpha
                    }
                    return
                }
                var position = 0;
                if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];
                else {
                    var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);
                    position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame /
                        PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));
                    position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent
                }
                if (pose == MixPose.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
                else constraint.position += (position - constraint.position) * alpha
            };
            PathConstraintPositionTimeline.ENTRIES = 2;
            PathConstraintPositionTimeline.PREV_TIME = -2;
            PathConstraintPositionTimeline.PREV_VALUE = -1;
            PathConstraintPositionTimeline.VALUE = 1;
            return PathConstraintPositionTimeline
        }(CurveTimeline);
        core.PathConstraintPositionTimeline = PathConstraintPositionTimeline;
        var PathConstraintSpacingTimeline = function(_super) {
            __extends(PathConstraintSpacingTimeline, _super);

            function PathConstraintSpacingTimeline(frameCount) {
                return _super.call(this, frameCount) || this
            }
            PathConstraintSpacingTimeline.prototype.getPropertyId = function() {
                return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex
            };
            PathConstraintSpacingTimeline.prototype.apply =
                function(skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                    var frames = this.frames;
                    var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
                    if (time < frames[0]) {
                        switch (pose) {
                            case MixPose.setup:
                                constraint.spacing = constraint.data.spacing;
                                return;
                            case MixPose.current:
                                constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha
                        }
                        return
                    }
                    var spacing = 0;
                    if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];
                    else {
                        var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);
                        spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];
                        var frameTime = frames[frame];
                        var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));
                        spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent
                    }
                    if (pose == MixPose.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) *
                        alpha;
                    else constraint.spacing += (spacing - constraint.spacing) * alpha
                };
            return PathConstraintSpacingTimeline
        }(PathConstraintPositionTimeline);
        core.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;
        var PathConstraintMixTimeline = function(_super) {
            __extends(PathConstraintMixTimeline, _super);

            function PathConstraintMixTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);
                return _this
            }
            PathConstraintMixTimeline.prototype.getPropertyId =
                function() {
                    return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex
                };
            PathConstraintMixTimeline.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix) {
                frameIndex *= PathConstraintMixTimeline.ENTRIES;
                this.frames[frameIndex] = time;
                this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;
                this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix
            };
            PathConstraintMixTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                var frames =
                    this.frames;
                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            constraint.rotateMix = constraint.data.rotateMix;
                            constraint.translateMix = constraint.data.translateMix;
                            return;
                        case MixPose.current:
                            constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
                            constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha
                    }
                    return
                }
                var rotate = 0,
                    translate = 0;
                if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {
                    rotate =
                        frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];
                    translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE]
                } else {
                    var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);
                    rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];
                    translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] -
                        frameTime));
                    rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;
                    translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent
                }
                if (pose == MixPose.setup) {
                    constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
                    constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha
                } else {
                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
                    constraint.translateMix += (translate - constraint.translateMix) *
                        alpha
                }
            };
            PathConstraintMixTimeline.ENTRIES = 3;
            PathConstraintMixTimeline.PREV_TIME = -3;
            PathConstraintMixTimeline.PREV_ROTATE = -2;
            PathConstraintMixTimeline.PREV_TRANSLATE = -1;
            PathConstraintMixTimeline.ROTATE = 1;
            PathConstraintMixTimeline.TRANSLATE = 2;
            return PathConstraintMixTimeline
        }(CurveTimeline);
        core.PathConstraintMixTimeline = PathConstraintMixTimeline
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var AnimationState = function() {
            function AnimationState(data) {
                this.tracks = new Array;
                this.events = new Array;
                this.listeners = new Array;
                this.queue = new EventQueue(this);
                this.propertyIDs = new core.IntSet;
                this.mixingTo = new Array;
                this.animationsChanged = false;
                this.timeScale = 1;
                this.trackEntryPool = new core.Pool(function() {
                    return new TrackEntry
                });
                this.data = data
            }
            AnimationState.prototype.update = function(delta) {
                delta *= this.timeScale;
                var tracks = this.tracks;
                for (var i = 0, n =
                        tracks.length; i < n; i++) {
                    var current = tracks[i];
                    if (current == null) continue;
                    current.animationLast = current.nextAnimationLast;
                    current.trackLast = current.nextTrackLast;
                    var currentDelta = delta * current.timeScale;
                    if (current.delay > 0) {
                        current.delay -= currentDelta;
                        if (current.delay > 0) continue;
                        currentDelta = -current.delay;
                        current.delay = 0
                    }
                    var next = current.next;
                    if (next != null) {
                        var nextTime = current.trackLast - next.delay;
                        if (nextTime >= 0) {
                            next.delay = 0;
                            next.trackTime = nextTime + delta * next.timeScale;
                            current.trackTime += currentDelta;
                            this.setCurrent(i, next, true);
                            while (next.mixingFrom != null) {
                                next.mixTime += currentDelta;
                                next = next.mixingFrom
                            }
                            continue
                        }
                    } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
                        tracks[i] = null;
                        this.queue.end(current);
                        this.disposeNext(current);
                        continue
                    }
                    if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
                        var from = current.mixingFrom;
                        current.mixingFrom = null;
                        while (from != null) {
                            this.queue.end(from);
                            from = from.mixingFrom
                        }
                    }
                    current.trackTime += currentDelta
                }
                this.queue.drain()
            };
            AnimationState.prototype.updateMixingFrom =
                function(to, delta) {
                    var from = to.mixingFrom;
                    if (from == null) return true;
                    var finished = this.updateMixingFrom(from, delta);
                    if (to.mixTime > 0 && (to.mixTime >= to.mixDuration || to.timeScale == 0)) {
                        if (from.totalAlpha == 0) {
                            to.mixingFrom = from.mixingFrom;
                            to.interruptAlpha = from.interruptAlpha;
                            this.queue.end(from)
                        }
                        return finished
                    }
                    from.animationLast = from.nextAnimationLast;
                    from.trackLast = from.nextTrackLast;
                    from.trackTime += delta * from.timeScale;
                    to.mixTime += delta * to.timeScale;
                    return false
                };
            AnimationState.prototype.apply = function(skeleton) {
                if (skeleton ==
                    null) throw new Error("skeleton cannot be null.");
                if (this.animationsChanged) this._animationsChanged();
                var events = this.events;
                var tracks = this.tracks;
                var applied = false;
                for (var i = 0, n = tracks.length; i < n; i++) {
                    var current = tracks[i];
                    if (current == null || current.delay > 0) continue;
                    applied = true;
                    var currentPose = i == 0 ? core.MixPose.current : core.MixPose.currentLayered;
                    var mix = current.alpha;
                    if (current.mixingFrom != null) mix *= this.applyMixingFrom(current, skeleton, currentPose);
                    else if (current.trackTime >= current.trackEnd &&
                        current.next == null) mix = 0;
                    var animationLast = current.animationLast,
                        animationTime = current.getAnimationTime();
                    var timelineCount = current.animation.timelines.length;
                    var timelines = current.animation.timelines;
                    if (mix == 1)
                        for (var ii = 0; ii < timelineCount; ii++) timelines[ii].apply(skeleton, animationLast, animationTime, events, 1, core.MixPose.setup, core.MixDirection["in"]);
                    else {
                        var timelineData = current.timelineData;
                        var firstFrame = current.timelinesRotation.length == 0;
                        if (firstFrame) core.Utils.setArraySize(current.timelinesRotation,
                            timelineCount << 1, null);
                        var timelinesRotation = current.timelinesRotation;
                        for (var ii = 0; ii < timelineCount; ii++) {
                            var timeline = timelines[ii];
                            var pose = timelineData[ii] >= AnimationState.FIRST ? core.MixPose.setup : currentPose;
                            if (timeline instanceof core.RotateTimeline) this.applyRotateTimeline(timeline, skeleton, animationTime, mix, pose, timelinesRotation, ii << 1, firstFrame);
                            else {
                                core.Utils.webkit602BugfixHelper(mix, pose);
                                timeline.apply(skeleton, animationLast, animationTime, events, mix, pose, core.MixDirection["in"])
                            }
                        }
                    }
                    this.queueEvents(current,
                        animationTime);
                    events.length = 0;
                    current.nextAnimationLast = animationTime;
                    current.nextTrackLast = current.trackTime
                }
                this.queue.drain();
                return applied
            };
            AnimationState.prototype.applyMixingFrom = function(to, skeleton, currentPose) {
                var from = to.mixingFrom;
                if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, currentPose);
                var mix = 0;
                if (to.mixDuration == 0) {
                    mix = 1;
                    currentPose = core.MixPose.setup
                } else {
                    mix = to.mixTime / to.mixDuration;
                    if (mix > 1) mix = 1
                }
                var events = mix < from.eventThreshold ? this.events : null;
                var attachments =
                    mix < from.attachmentThreshold,
                    drawOrder = mix < from.drawOrderThreshold;
                var animationLast = from.animationLast,
                    animationTime = from.getAnimationTime();
                var timelineCount = from.animation.timelines.length;
                var timelines = from.animation.timelines;
                var timelineData = from.timelineData;
                var timelineDipMix = from.timelineDipMix;
                var firstFrame = from.timelinesRotation.length == 0;
                if (firstFrame) core.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
                var timelinesRotation = from.timelinesRotation;
                var pose;
                var alphaDip =
                    from.alpha * to.interruptAlpha,
                    alphaMix = alphaDip * (1 - mix),
                    alpha = 0;
                from.totalAlpha = 0;
                for (var i = 0; i < timelineCount; i++) {
                    var timeline = timelines[i];
                    switch (timelineData[i]) {
                        case AnimationState.SUBSEQUENT:
                            if (!attachments && timeline instanceof core.AttachmentTimeline) continue;
                            if (!drawOrder && timeline instanceof core.DrawOrderTimeline) continue;
                            pose = currentPose;
                            alpha = alphaMix;
                            break;
                        case AnimationState.FIRST:
                            pose = core.MixPose.setup;
                            alpha = alphaMix;
                            break;
                        case AnimationState.DIP:
                            pose = core.MixPose.setup;
                            alpha = alphaDip;
                            break;
                        default:
                            pose = core.MixPose.setup;
                            alpha = alphaDip;
                            var dipMix = timelineDipMix[i];
                            alpha *= Math.max(0, 1 - dipMix.mixTime / dipMix.mixDuration);
                            break
                    }
                    from.totalAlpha += alpha;
                    if (timeline instanceof core.RotateTimeline) this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, pose, timelinesRotation, i << 1, firstFrame);
                    else timeline.apply(skeleton, animationLast, animationTime, events, alpha, pose, core.MixDirection.out)
                }
                if (to.mixDuration > 0) this.queueEvents(from, animationTime);
                this.events.length = 0;
                from.nextAnimationLast =
                    animationTime;
                from.nextTrackLast = from.trackTime;
                return mix
            };
            AnimationState.prototype.applyRotateTimeline = function(timeline, skeleton, time, alpha, pose, timelinesRotation, i, firstFrame) {
                if (firstFrame) timelinesRotation[i] = 0;
                if (alpha == 1) {
                    timeline.apply(skeleton, 0, time, null, 1, pose, core.MixDirection["in"]);
                    return
                }
                var rotateTimeline = timeline;
                var frames = rotateTimeline.frames;
                var bone = skeleton.bones[rotateTimeline.boneIndex];
                if (time < frames[0]) {
                    if (pose == core.MixPose.setup) bone.rotation = bone.data.rotation;
                    return
                }
                var r2 =
                    0;
                if (time >= frames[frames.length - core.RotateTimeline.ENTRIES]) r2 = bone.data.rotation + frames[frames.length + core.RotateTimeline.PREV_ROTATION];
                else {
                    var frame = core.Animation.binarySearch(frames, time, core.RotateTimeline.ENTRIES);
                    var prevRotation = frames[frame + core.RotateTimeline.PREV_ROTATION];
                    var frameTime = frames[frame];
                    var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + core.RotateTimeline.PREV_TIME] - frameTime));
                    r2 = frames[frame + core.RotateTimeline.ROTATION] - prevRotation;
                    r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
                    r2 = prevRotation + r2 * percent + bone.data.rotation;
                    r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360
                }
                var r1 = pose == core.MixPose.setup ? bone.data.rotation : bone.rotation;
                var total = 0,
                    diff = r2 - r1;
                if (diff == 0) total = timelinesRotation[i];
                else {
                    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
                    var lastTotal = 0,
                        lastDiff = 0;
                    if (firstFrame) {
                        lastTotal = 0;
                        lastDiff = diff
                    } else {
                        lastTotal = timelinesRotation[i];
                        lastDiff = timelinesRotation[i + 1]
                    }
                    var current = diff > 0,
                        dir = lastTotal >= 0;
                    if (core.MathUtils.signum(lastDiff) !=
                        core.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
                        if (Math.abs(lastTotal) > 180) lastTotal += 360 * core.MathUtils.signum(lastTotal);
                        dir = current
                    }
                    total = diff + lastTotal - lastTotal % 360;
                    if (dir != current) total += 360 * core.MathUtils.signum(lastTotal);
                    timelinesRotation[i] = total
                }
                timelinesRotation[i + 1] = diff;
                r1 += total * alpha;
                bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360
            };
            AnimationState.prototype.queueEvents = function(entry, animationTime) {
                var animationStart = entry.animationStart,
                    animationEnd = entry.animationEnd;
                var duration = animationEnd - animationStart;
                var trackLastWrapped = entry.trackLast % duration;
                var events = this.events;
                var i = 0,
                    n = events.length;
                for (; i < n; i++) {
                    var event_1 = events[i];
                    if (event_1.time < trackLastWrapped) break;
                    if (event_1.time > animationEnd) continue;
                    this.queue.event(entry, event_1)
                }
                if (entry.loop ? trackLastWrapped > entry.trackTime % duration : animationTime >= animationEnd && entry.animationLast < animationEnd) this.queue.complete(entry);
                for (; i < n; i++) {
                    var event_2 = events[i];
                    if (event_2.time < animationStart) continue;
                    this.queue.event(entry,
                        events[i])
                }
            };
            AnimationState.prototype.clearTracks = function() {
                var oldDrainDisabled = this.queue.drainDisabled;
                this.queue.drainDisabled = true;
                for (var i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);
                this.tracks.length = 0;
                this.queue.drainDisabled = oldDrainDisabled;
                this.queue.drain()
            };
            AnimationState.prototype.clearTrack = function(trackIndex) {
                if (trackIndex >= this.tracks.length) return;
                var current = this.tracks[trackIndex];
                if (current == null) return;
                this.queue.end(current);
                this.disposeNext(current);
                var entry = current;
                while (true) {
                    var from = entry.mixingFrom;
                    if (from == null) break;
                    this.queue.end(from);
                    entry.mixingFrom = null;
                    entry = from
                }
                this.tracks[current.trackIndex] = null;
                this.queue.drain()
            };
            AnimationState.prototype.setCurrent = function(index, current, interrupt) {
                var from = this.expandToIndex(index);
                this.tracks[index] = current;
                if (from != null) {
                    if (interrupt) this.queue.interrupt(from);
                    current.mixingFrom = from;
                    current.mixTime = 0;
                    if (from.mixingFrom != null && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
                    from.timelinesRotation.length = 0
                }
                this.queue.start(current)
            };
            AnimationState.prototype.setAnimation = function(trackIndex, animationName, loop) {
                var animation = this.data.skeletonData.findAnimation(animationName);
                if (animation == null) throw new Error("Animation not found: " + animationName);
                return this.setAnimationWith(trackIndex, animation, loop)
            };
            AnimationState.prototype.setAnimationWith = function(trackIndex, animation, loop) {
                if (animation == null) throw new Error("animation cannot be null.");
                var interrupt = true;
                var current =
                    this.expandToIndex(trackIndex);
                if (current != null)
                    if (current.nextTrackLast == -1) {
                        this.tracks[trackIndex] = current.mixingFrom;
                        this.queue.interrupt(current);
                        this.queue.end(current);
                        this.disposeNext(current);
                        current = current.mixingFrom;
                        interrupt = false
                    } else this.disposeNext(current);
                var entry = this.trackEntry(trackIndex, animation, loop, current);
                this.setCurrent(trackIndex, entry, interrupt);
                this.queue.drain();
                return entry
            };
            AnimationState.prototype.addAnimation = function(trackIndex, animationName, loop, delay) {
                var animation =
                    this.data.skeletonData.findAnimation(animationName);
                if (animation == null) throw new Error("Animation not found: " + animationName);
                return this.addAnimationWith(trackIndex, animation, loop, delay)
            };
            AnimationState.prototype.addAnimationWith = function(trackIndex, animation, loop, delay) {
                if (animation == null) throw new Error("animation cannot be null.");
                var last = this.expandToIndex(trackIndex);
                if (last != null)
                    while (last.next != null) last = last.next;
                var entry = this.trackEntry(trackIndex, animation, loop, last);
                if (last == null) {
                    this.setCurrent(trackIndex,
                        entry, true);
                    this.queue.drain()
                } else {
                    last.next = entry;
                    if (delay <= 0) {
                        var duration = last.animationEnd - last.animationStart;
                        if (duration != 0) {
                            if (last.loop) delay += duration * (1 + (last.trackTime / duration | 0));
                            else delay += duration;
                            delay -= this.data.getMix(last.animation, animation)
                        } else delay = 0
                    }
                }
                entry.delay = delay;
                return entry
            };
            AnimationState.prototype.setEmptyAnimation = function(trackIndex, mixDuration) {
                var entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);
                entry.mixDuration = mixDuration;
                entry.trackEnd =
                    mixDuration;
                return entry
            };
            AnimationState.prototype.addEmptyAnimation = function(trackIndex, mixDuration, delay) {
                if (delay <= 0) delay -= mixDuration;
                var entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);
                entry.mixDuration = mixDuration;
                entry.trackEnd = mixDuration;
                return entry
            };
            AnimationState.prototype.setEmptyAnimations = function(mixDuration) {
                var oldDrainDisabled = this.queue.drainDisabled;
                this.queue.drainDisabled = true;
                for (var i = 0, n = this.tracks.length; i < n; i++) {
                    var current = this.tracks[i];
                    if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration)
                }
                this.queue.drainDisabled = oldDrainDisabled;
                this.queue.drain()
            };
            AnimationState.prototype.expandToIndex = function(index) {
                if (index < this.tracks.length) return this.tracks[index];
                core.Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);
                this.tracks.length = index + 1;
                return null
            };
            AnimationState.prototype.trackEntry = function(trackIndex, animation, loop, last) {
                var entry = this.trackEntryPool.obtain();
                entry.trackIndex = trackIndex;
                entry.animation = animation;
                entry.loop = loop;
                entry.eventThreshold = 0;
                entry.attachmentThreshold = 0;
                entry.drawOrderThreshold = 0;
                entry.animationStart = 0;
                entry.animationEnd = animation.duration;
                entry.animationLast = -1;
                entry.nextAnimationLast = -1;
                entry.delay = 0;
                entry.trackTime = 0;
                entry.trackLast = -1;
                entry.nextTrackLast = -1;
                entry.trackEnd = Number.MAX_VALUE;
                entry.timeScale = 1;
                entry.alpha = 1;
                entry.interruptAlpha = 1;
                entry.mixTime = 0;
                entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);
                return entry
            };
            AnimationState.prototype.disposeNext =
                function(entry) {
                    var next = entry.next;
                    while (next != null) {
                        this.queue.dispose(next);
                        next = next.next
                    }
                    entry.next = null
                };
            AnimationState.prototype._animationsChanged = function() {
                this.animationsChanged = false;
                var propertyIDs = this.propertyIDs;
                propertyIDs.clear();
                var mixingTo = this.mixingTo;
                var lastEntry = null;
                for (var i = 0, n = this.tracks.length; i < n; i++) {
                    var entry = this.tracks[i];
                    if (entry != null) entry.setTimelineData(null, mixingTo, propertyIDs)
                }
            };
            AnimationState.prototype.getCurrent = function(trackIndex) {
                if (trackIndex >= this.tracks.length) return null;
                return this.tracks[trackIndex]
            };
            AnimationState.prototype.addListener = function(listener) {
                if (listener == null) throw new Error("listener cannot be null.");
                this.listeners.push(listener)
            };
            AnimationState.prototype.removeListener = function(listener) {
                var index = this.listeners.indexOf(listener);
                if (index >= 0) this.listeners.splice(index, 1)
            };
            AnimationState.prototype.clearListeners = function() {
                this.listeners.length = 0
            };
            AnimationState.prototype.clearListenerNotifications = function() {
                this.queue.clear()
            };
            AnimationState.prototype.setAnimationByName =
                function(trackIndex, animationName, loop) {
                    if (!AnimationState.deprecatedWarning1) {
                        AnimationState.deprecatedWarning1 = true;
                        console.warn("Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")
                    }
                    this.setAnimation(trackIndex, animationName, loop)
                };
            AnimationState.prototype.addAnimationByName = function(trackIndex, animationName, loop, delay) {
                if (!AnimationState.deprecatedWarning2) {
                    AnimationState.deprecatedWarning2 = true;
                    console.warn("Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")
                }
                this.addAnimation(trackIndex,
                    animationName, loop, delay)
            };
            AnimationState.prototype.hasAnimation = function(animationName) {
                var animation = this.data.skeletonData.findAnimation(animationName);
                return animation !== null
            };
            AnimationState.prototype.hasAnimationByName = function(animationName) {
                if (!AnimationState.deprecatedWarning3) {
                    AnimationState.deprecatedWarning3 = true;
                    console.warn("Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")
                }
                return this.hasAnimation(animationName)
            };
            AnimationState.emptyAnimation =
                new core.Animation("<empty>", [], 0);
            AnimationState.SUBSEQUENT = 0;
            AnimationState.FIRST = 1;
            AnimationState.DIP = 2;
            AnimationState.DIP_MIX = 3;
            AnimationState.deprecatedWarning1 = false;
            AnimationState.deprecatedWarning2 = false;
            AnimationState.deprecatedWarning3 = false;
            return AnimationState
        }();
        core.AnimationState = AnimationState;
        var TrackEntry = function() {
            function TrackEntry() {
                this.timelineData = new Array;
                this.timelineDipMix = new Array;
                this.timelinesRotation = new Array
            }
            TrackEntry.prototype.reset = function() {
                this.next = null;
                this.mixingFrom = null;
                this.animation = null;
                this.listener = null;
                this.timelineData.length = 0;
                this.timelineDipMix.length = 0;
                this.timelinesRotation.length = 0
            };
            TrackEntry.prototype.setTimelineData = function(to, mixingToArray, propertyIDs) {
                if (to != null) mixingToArray.push(to);
                var lastEntry = this.mixingFrom != null ? this.mixingFrom.setTimelineData(this, mixingToArray, propertyIDs) : this;
                if (to != null) mixingToArray.pop();
                var mixingTo = mixingToArray;
                var mixingToLast = mixingToArray.length - 1;
                var timelines = this.animation.timelines;
                var timelinesCount = this.animation.timelines.length;
                var timelineData = core.Utils.setArraySize(this.timelineData, timelinesCount);
                this.timelineDipMix.length = 0;
                var timelineDipMix = core.Utils.setArraySize(this.timelineDipMix, timelinesCount);
                outer: for (var i = 0; i < timelinesCount; i++) {
                    var id = timelines[i].getPropertyId();
                    if (!propertyIDs.add(id)) timelineData[i] = AnimationState.SUBSEQUENT;
                    else if (to == null || !to.hasTimeline(id)) timelineData[i] = AnimationState.FIRST;
                    else {
                        for (var ii = mixingToLast; ii >= 0; ii--) {
                            var entry =
                                mixingTo[ii];
                            if (!entry.hasTimeline(id))
                                if (entry.mixDuration > 0) {
                                    timelineData[i] = AnimationState.DIP_MIX;
                                    timelineDipMix[i] = entry;
                                    continue outer
                                }
                        }
                        timelineData[i] = AnimationState.DIP
                    }
                }
                return lastEntry
            };
            TrackEntry.prototype.hasTimeline = function(id) {
                var timelines = this.animation.timelines;
                for (var i = 0, n = timelines.length; i < n; i++)
                    if (timelines[i].getPropertyId() == id) return true;
                return false
            };
            TrackEntry.prototype.getAnimationTime = function() {
                if (this.loop) {
                    var duration = this.animationEnd - this.animationStart;
                    if (duration ==
                        0) return this.animationStart;
                    return this.trackTime % duration + this.animationStart
                }
                return Math.min(this.trackTime + this.animationStart, this.animationEnd)
            };
            TrackEntry.prototype.setAnimationLast = function(animationLast) {
                this.animationLast = animationLast;
                this.nextAnimationLast = animationLast
            };
            TrackEntry.prototype.isComplete = function() {
                return this.trackTime >= this.animationEnd - this.animationStart
            };
            TrackEntry.prototype.resetRotationDirections = function() {
                this.timelinesRotation.length = 0
            };
            Object.defineProperty(TrackEntry.prototype,
                "time", {
                    get: function() {
                        if (!TrackEntry.deprecatedWarning1) {
                            TrackEntry.deprecatedWarning1 = true;
                            console.warn("Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")
                        }
                        return this.trackTime
                    },
                    set: function(value) {
                        if (!TrackEntry.deprecatedWarning1) {
                            TrackEntry.deprecatedWarning1 = true;
                            console.warn("Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")
                        }
                        this.trackTime = value
                    },
                    enumerable: true,
                    configurable: true
                });
            Object.defineProperty(TrackEntry.prototype,
                "endTime", {
                    get: function() {
                        if (!TrackEntry.deprecatedWarning2) {
                            TrackEntry.deprecatedWarning2 = true;
                            console.warn("Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")
                        }
                        return this.trackTime
                    },
                    set: function(value) {
                        if (!TrackEntry.deprecatedWarning2) {
                            TrackEntry.deprecatedWarning2 = true;
                            console.warn("Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")
                        }
                        this.trackTime = value
                    },
                    enumerable: true,
                    configurable: true
                });
            TrackEntry.prototype.loopsCount =
                function() {
                    return Math.floor(this.trackTime / this.trackEnd)
                };
            TrackEntry.deprecatedWarning1 = false;
            TrackEntry.deprecatedWarning2 = false;
            return TrackEntry
        }();
        core.TrackEntry = TrackEntry;
        var EventQueue = function() {
            function EventQueue(animState) {
                this.objects = [];
                this.drainDisabled = false;
                this.animState = animState
            }
            EventQueue.prototype.start = function(entry) {
                this.objects.push(EventType.start);
                this.objects.push(entry);
                this.animState.animationsChanged = true
            };
            EventQueue.prototype.interrupt = function(entry) {
                this.objects.push(EventType.interrupt);
                this.objects.push(entry)
            };
            EventQueue.prototype.end = function(entry) {
                this.objects.push(EventType.end);
                this.objects.push(entry);
                this.animState.animationsChanged = true
            };
            EventQueue.prototype.dispose = function(entry) {
                this.objects.push(EventType.dispose);
                this.objects.push(entry)
            };
            EventQueue.prototype.complete = function(entry) {
                this.objects.push(EventType.complete);
                this.objects.push(entry)
            };
            EventQueue.prototype.event = function(entry, event) {
                this.objects.push(EventType.event);
                this.objects.push(entry);
                this.objects.push(event)
            };
            EventQueue.prototype.deprecateStuff = function() {
                if (!EventQueue.deprecatedWarning1) {
                    EventQueue.deprecatedWarning1 = true;
                    console.warn("Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")
                }
                return true
            };
            EventQueue.prototype.drain = function() {
                if (this.drainDisabled) return;
                this.drainDisabled = true;
                var objects = this.objects;
                var listeners = this.animState.listeners;
                for (var i = 0; i < objects.length; i +=
                    2) {
                    var type = objects[i];
                    var entry = objects[i + 1];
                    switch (type) {
                        case EventType.start:
                            if (entry.listener != null && entry.listener.start) entry.listener.start(entry);
                            for (var ii = 0; ii < listeners.length; ii++)
                                if (listeners[ii].start) listeners[ii].start(entry);
                            entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);
                            this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);
                            break;
                        case EventType.interrupt:
                            if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);
                            for (var ii = 0; ii < listeners.length; ii++)
                                if (listeners[ii].interrupt) listeners[ii].interrupt(entry);
                            break;
                        case EventType.end:
                            if (entry.listener != null && entry.listener.end) entry.listener.end(entry);
                            for (var ii = 0; ii < listeners.length; ii++)
                                if (listeners[ii].end) listeners[ii].end(entry);
                            entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);
                            this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);
                        case EventType.dispose:
                            if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);
                            for (var ii = 0; ii < listeners.length; ii++)
                                if (listeners[ii].dispose) listeners[ii].dispose(entry);
                            this.animState.trackEntryPool.free(entry);
                            break;
                        case EventType.complete:
                            if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);
                            for (var ii = 0; ii < listeners.length; ii++)
                                if (listeners[ii].complete) listeners[ii].complete(entry);
                            var count = core.MathUtils.toInt(entry.loopsCount());
                            entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);
                            this.animState.onComplete && this.deprecateStuff() &&
                                this.animState.onComplete(entry.trackIndex, count);
                            break;
                        case EventType.event:
                            var event_3 = objects[i++ + 2];
                            if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event_3);
                            for (var ii = 0; ii < listeners.length; ii++)
                                if (listeners[ii].event) listeners[ii].event(entry, event_3);
                            entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event_3);
                            this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event_3);
                            break
                    }
                }
                this.clear();
                this.drainDisabled = false
            };
            EventQueue.prototype.clear = function() {
                this.objects.length = 0
            };
            EventQueue.deprecatedWarning1 = false;
            return EventQueue
        }();
        core.EventQueue = EventQueue;
        var EventType;
        (function(EventType) {
            EventType[EventType["start"] = 0] = "start";
            EventType[EventType["interrupt"] = 1] = "interrupt";
            EventType[EventType["end"] = 2] = "end";
            EventType[EventType["dispose"] = 3] = "dispose";
            EventType[EventType["complete"] = 4] = "complete";
            EventType[EventType["event"] = 5] = "event"
        })(EventType = core.EventType || (core.EventType = {}));
        var AnimationStateAdapter2 =
            function() {
                function AnimationStateAdapter2() {}
                AnimationStateAdapter2.prototype.start = function(entry) {};
                AnimationStateAdapter2.prototype.interrupt = function(entry) {};
                AnimationStateAdapter2.prototype.end = function(entry) {};
                AnimationStateAdapter2.prototype.dispose = function(entry) {};
                AnimationStateAdapter2.prototype.complete = function(entry) {};
                AnimationStateAdapter2.prototype.event = function(entry, event) {};
                return AnimationStateAdapter2
            }();
        core.AnimationStateAdapter2 = AnimationStateAdapter2
    })(core = pixi_spine.core ||
        (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var AnimationStateData = function() {
            function AnimationStateData(skeletonData) {
                this.animationToMixTime = {};
                this.defaultMix = 0;
                if (skeletonData == null) throw new Error("skeletonData cannot be null.");
                this.skeletonData = skeletonData
            }
            AnimationStateData.prototype.setMix = function(fromName, toName, duration) {
                var from = this.skeletonData.findAnimation(fromName);
                if (from == null) throw new Error("Animation not found: " + fromName);
                var to = this.skeletonData.findAnimation(toName);
                if (to == null) throw new Error("Animation not found: " + toName);
                this.setMixWith(from, to, duration)
            };
            AnimationStateData.prototype.setMixByName = function(fromName, toName, duration) {
                if (!AnimationStateData.deprecatedWarning1) {
                    AnimationStateData.deprecatedWarning1 = true;
                    console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")
                }
                this.setMix(fromName, toName, duration)
            };
            AnimationStateData.prototype.setMixWith = function(from, to, duration) {
                if (from == null) throw new Error("from cannot be null.");
                if (to == null) throw new Error("to cannot be null.");
                var key = from.name + "." + to.name;
                this.animationToMixTime[key] = duration
            };
            AnimationStateData.prototype.getMix = function(from, to) {
                var key = from.name + "." + to.name;
                var value = this.animationToMixTime[key];
                return value === undefined ? this.defaultMix : value
            };
            AnimationStateData.deprecatedWarning1 = false;
            return AnimationStateData
        }();
        core.AnimationStateData = AnimationStateData
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var AtlasAttachmentLoader = function() {
            function AtlasAttachmentLoader(atlas) {
                this.atlas = atlas
            }
            AtlasAttachmentLoader.prototype.newRegionAttachment = function(skin, name, path) {
                var region = this.atlas.findRegion(path);
                if (region == null) throw new Error("Region not found in atlas: " + path + " (region attachment: " + name + ")");
                var attachment = new core.RegionAttachment(name);
                attachment.region = region;
                return attachment
            };
            AtlasAttachmentLoader.prototype.newMeshAttachment = function(skin,
                name, path) {
                var region = this.atlas.findRegion(path);
                if (region == null) throw new Error("Region not found in atlas: " + path + " (mesh attachment: " + name + ")");
                var attachment = new core.MeshAttachment(name);
                attachment.region = region;
                return attachment
            };
            AtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function(skin, name) {
                return new core.BoundingBoxAttachment(name)
            };
            AtlasAttachmentLoader.prototype.newPathAttachment = function(skin, name) {
                return new core.PathAttachment(name)
            };
            AtlasAttachmentLoader.prototype.newPointAttachment =
                function(skin, name) {
                    return new core.PointAttachment(name)
                };
            AtlasAttachmentLoader.prototype.newClippingAttachment = function(skin, name) {
                return new core.ClippingAttachment(name)
            };
            return AtlasAttachmentLoader
        }();
        core.AtlasAttachmentLoader = AtlasAttachmentLoader
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var BlendMode;
        (function(BlendMode) {
            BlendMode[BlendMode["Normal"] = 0] = "Normal";
            BlendMode[BlendMode["Additive"] = 1] = "Additive";
            BlendMode[BlendMode["Multiply"] = 2] = "Multiply";
            BlendMode[BlendMode["Screen"] = 3] = "Screen"
        })(BlendMode = core.BlendMode || (core.BlendMode = {}))
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var Bone = function() {
            function Bone(data, skeleton, parent) {
                this.matrix = new PIXI.Matrix;
                this.children = new Array;
                this.x = 0;
                this.y = 0;
                this.rotation = 0;
                this.scaleX = 0;
                this.scaleY = 0;
                this.shearX = 0;
                this.shearY = 0;
                this.ax = 0;
                this.ay = 0;
                this.arotation = 0;
                this.ascaleX = 0;
                this.ascaleY = 0;
                this.ashearX = 0;
                this.ashearY = 0;
                this.appliedValid = false;
                this.sorted = false;
                if (data == null) throw new Error("data cannot be null.");
                if (skeleton == null) throw new Error("skeleton cannot be null.");
                this.data =
                    data;
                this.skeleton = skeleton;
                this.parent = parent;
                this.setToSetupPose()
            }
            Object.defineProperty(Bone.prototype, "worldX", {
                get: function() {
                    return this.matrix.tx
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Bone.prototype, "worldY", {
                get: function() {
                    return this.matrix.ty
                },
                enumerable: true,
                configurable: true
            });
            Bone.prototype.update = function() {
                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
            };
            Bone.prototype.updateWorldTransform = function() {
                this.updateWorldTransformWith(this.x,
                    this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
            };
            Bone.prototype.updateWorldTransformWith = function(x, y, rotation, scaleX, scaleY, shearX, shearY) {
                this.ax = x;
                this.ay = y;
                this.arotation = rotation;
                this.ascaleX = scaleX;
                this.ascaleY = scaleY;
                this.ashearX = shearX;
                this.ashearY = shearY;
                this.appliedValid = true;
                var parent = this.parent;
                var m = this.matrix;
                if (parent == null) {
                    var rotationY = rotation + 90 + shearY;
                    var la = core.MathUtils.cosDeg(rotation + shearX) * scaleX;
                    var lb = core.MathUtils.cosDeg(rotationY) * scaleY;
                    var lc =
                        core.MathUtils.sinDeg(rotation + shearX) * scaleX;
                    var ld = core.MathUtils.sinDeg(rotationY) * scaleY;
                    var skeleton = this.skeleton;
                    if (skeleton.flipX) {
                        x = -x;
                        la = -la;
                        lb = -lb
                    }
                    if (skeleton.flipY !== Bone.yDown) {
                        y = -y;
                        lc = -lc;
                        ld = -ld
                    }
                    m.a = la;
                    m.c = lb;
                    m.b = lc;
                    m.d = ld;
                    m.tx = x + skeleton.x;
                    m.ty = y + skeleton.y;
                    return
                }
                var pa = parent.matrix.a,
                    pb = parent.matrix.c,
                    pc = parent.matrix.b,
                    pd = parent.matrix.d;
                m.tx = pa * x + pb * y + parent.matrix.tx;
                m.ty = pc * x + pd * y + parent.matrix.ty;
                switch (this.data.transformMode) {
                    case core.TransformMode.Normal:
                        var rotationY =
                            rotation + 90 + shearY;
                        var la = core.MathUtils.cosDeg(rotation + shearX) * scaleX;
                        var lb = core.MathUtils.cosDeg(rotationY) * scaleY;
                        var lc = core.MathUtils.sinDeg(rotation + shearX) * scaleX;
                        var ld = core.MathUtils.sinDeg(rotationY) * scaleY;
                        m.a = pa * la + pb * lc;
                        m.c = pa * lb + pb * ld;
                        m.b = pc * la + pd * lc;
                        m.d = pc * lb + pd * ld;
                        return;
                    case core.TransformMode.OnlyTranslation:
                        var rotationY = rotation + 90 + shearY;
                        m.a = core.MathUtils.cosDeg(rotation + shearX) * scaleX;
                        m.c = core.MathUtils.cosDeg(rotationY) * scaleY;
                        m.b = core.MathUtils.sinDeg(rotation + shearX) * scaleX;
                        m.d = core.MathUtils.sinDeg(rotationY) * scaleY;
                        break;
                    case core.TransformMode.NoRotationOrReflection:
                        var s = pa * pa + pc * pc;
                        var prx = 0;
                        if (s > 1E-4) {
                            s = Math.abs(pa * pd - pb * pc) / s;
                            pb = pc * s;
                            pd = pa * s;
                            prx = Math.atan2(pc, pa) * core.MathUtils.radDeg
                        } else {
                            pa = 0;
                            pc = 0;
                            prx = 90 - Math.atan2(pd, pb) * core.MathUtils.radDeg
                        }
                        var rx = rotation + shearX - prx;
                        var ry = rotation + shearY - prx + 90;
                        var la = core.MathUtils.cosDeg(rx) * scaleX;
                        var lb = core.MathUtils.cosDeg(ry) * scaleY;
                        var lc = core.MathUtils.sinDeg(rx) * scaleX;
                        var ld = core.MathUtils.sinDeg(ry) * scaleY;
                        m.a = pa * la - pb * lc;
                        m.c = pa * lb - pb * ld;
                        m.b = pc * la + pd * lc;
                        m.d = pc * lb + pd * ld;
                        break;
                    case core.TransformMode.NoScale:
                    case core.TransformMode.NoScaleOrReflection:
                        var cos = core.MathUtils.cosDeg(rotation);
                        var sin = core.MathUtils.sinDeg(rotation);
                        var za = pa * cos + pb * sin;
                        var zc = pc * cos + pd * sin;
                        var s = Math.sqrt(za * za + zc * zc);
                        if (s > 1E-5) s = 1 / s;
                        za *= s;
                        zc *= s;
                        s = Math.sqrt(za * za + zc * zc);
                        var r = Math.PI / 2 + Math.atan2(zc, za);
                        var zb = Math.cos(r) * s;
                        var zd = Math.sin(r) * s;
                        var la = core.MathUtils.cosDeg(shearX) * scaleX;
                        var lb = core.MathUtils.cosDeg(90 +
                            shearY) * scaleY;
                        var lc = core.MathUtils.sinDeg(shearX) * scaleX;
                        var ld = core.MathUtils.sinDeg(90 + shearY) * scaleY;
                        m.a = za * la + zb * lc;
                        m.c = za * lb + zb * ld;
                        m.b = zc * la + zd * lc;
                        m.d = zc * lb + zd * ld;
                        if (this.data.transformMode != core.TransformMode.NoScaleOrReflection ? pa * pd - pb * pc < 0 : this.skeleton.flipX != this.skeleton.flipY != Bone.yDown) {
                            m.c = -m.c;
                            m.d = -m.d
                        }
                        return
                }
                if (this.skeleton.flipX) {
                    m.a = -m.a;
                    m.c = -m.c
                }
                if (this.skeleton.flipY != Bone.yDown) {
                    m.b = -m.b;
                    m.d = -m.d
                }
            };
            Bone.prototype.setToSetupPose = function() {
                var data = this.data;
                this.x = data.x;
                this.y = data.y;
                this.rotation = data.rotation;
                this.scaleX = data.scaleX;
                this.scaleY = data.scaleY;
                this.shearX = data.shearX;
                this.shearY = data.shearY
            };
            Bone.prototype.getWorldRotationX = function() {
                return Math.atan2(this.matrix.b, this.matrix.a) * core.MathUtils.radDeg
            };
            Bone.prototype.getWorldRotationY = function() {
                return Math.atan2(this.matrix.d, this.matrix.c) * core.MathUtils.radDeg
            };
            Bone.prototype.getWorldScaleX = function() {
                var m = this.matrix;
                return Math.sqrt(m.a * m.a + m.c * m.c)
            };
            Bone.prototype.getWorldScaleY = function() {
                var m =
                    this.matrix;
                return Math.sqrt(m.b * m.b + m.d * m.d)
            };
            Bone.prototype.updateAppliedTransform = function() {
                this.appliedValid = true;
                var parent = this.parent;
                var m = this.matrix;
                if (parent == null) {
                    this.ax = m.tx;
                    this.ay = m.ty;
                    this.arotation = Math.atan2(m.b, m.a) * core.MathUtils.radDeg;
                    this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
                    this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
                    this.ashearX = 0;
                    this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * core.MathUtils.radDeg;
                    return
                }
                var pm = parent.matrix;
                var pid = 1 / (pm.a * pm.d - pm.b * pm.c);
                var dx =
                    m.tx - pm.tx,
                    dy = m.ty - pm.ty;
                this.ax = dx * pm.d * pid - dy * pm.c * pid;
                this.ay = dy * pm.a * pid - dx * pm.b * pid;
                var ia = pid * pm.d;
                var id = pid * pm.a;
                var ib = pid * pm.c;
                var ic = pid * pm.b;
                var ra = ia * m.a - ib * m.b;
                var rb = ia * m.c - ib * m.d;
                var rc = id * m.b - ic * m.a;
                var rd = id * m.d - ic * m.c;
                this.ashearX = 0;
                this.ascaleX = Math.sqrt(ra * ra + rc * rc);
                if (this.ascaleX > 1E-4) {
                    var det = ra * rd - rb * rc;
                    this.ascaleY = det / this.ascaleX;
                    this.ashearY = Math.atan2(ra * rb + rc * rd, det) * core.MathUtils.radDeg;
                    this.arotation = Math.atan2(rc, ra) * core.MathUtils.radDeg
                } else {
                    this.ascaleX = 0;
                    this.ascaleY =
                        Math.sqrt(rb * rb + rd * rd);
                    this.ashearY = 0;
                    this.arotation = 90 - Math.atan2(rd, rb) * core.MathUtils.radDeg
                }
            };
            Bone.prototype.worldToLocal = function(world) {
                var m = this.matrix;
                var a = m.a,
                    b = m.c,
                    c = m.b,
                    d = m.d;
                var invDet = 1 / (a * d - b * c);
                var x = world.x - m.tx,
                    y = world.y - m.ty;
                world.x = x * d * invDet - y * b * invDet;
                world.y = y * a * invDet - x * c * invDet;
                return world
            };
            Bone.prototype.localToWorld = function(local) {
                var m = this.matrix;
                var x = local.x,
                    y = local.y;
                local.x = x * m.a + y * m.c + m.tx;
                local.y = x * m.b + y * m.d + m.ty;
                return local
            };
            Bone.prototype.worldToLocalRotation =
                function(worldRotation) {
                    var sin = core.MathUtils.sinDeg(worldRotation),
                        cos = core.MathUtils.cosDeg(worldRotation);
                    var mat = this.matrix;
                    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * core.MathUtils.radDeg
                };
            Bone.prototype.localToWorldRotation = function(localRotation) {
                var sin = core.MathUtils.sinDeg(localRotation),
                    cos = core.MathUtils.cosDeg(localRotation);
                var mat = this.matrix;
                return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * core.MathUtils.radDeg
            };
            Bone.prototype.rotateWorld = function(degrees) {
                var mat =
                    this.matrix;
                var a = mat.a,
                    b = mat.c,
                    c = mat.b,
                    d = mat.d;
                var cos = core.MathUtils.cosDeg(degrees),
                    sin = core.MathUtils.sinDeg(degrees);
                mat.a = cos * a - sin * c;
                mat.c = cos * b - sin * d;
                mat.b = sin * a + cos * c;
                mat.d = sin * b + cos * d;
                this.appliedValid = false
            };
            Bone.yDown = false;
            return Bone
        }();
        core.Bone = Bone
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var BoneData = function() {
            function BoneData(index, name, parent) {
                this.x = 0;
                this.y = 0;
                this.rotation = 0;
                this.scaleX = 1;
                this.scaleY = 1;
                this.shearX = 0;
                this.shearY = 0;
                this.transformMode = TransformMode.Normal;
                if (index < 0) throw new Error("index must be >= 0.");
                if (name == null) throw new Error("name cannot be null.");
                this.index = index;
                this.name = name;
                this.parent = parent
            }
            return BoneData
        }();
        core.BoneData = BoneData;
        var TransformMode;
        (function(TransformMode) {
            TransformMode[TransformMode["Normal"] =
                0] = "Normal";
            TransformMode[TransformMode["OnlyTranslation"] = 1] = "OnlyTranslation";
            TransformMode[TransformMode["NoRotationOrReflection"] = 2] = "NoRotationOrReflection";
            TransformMode[TransformMode["NoScale"] = 3] = "NoScale";
            TransformMode[TransformMode["NoScaleOrReflection"] = 4] = "NoScaleOrReflection"
        })(TransformMode = core.TransformMode || (core.TransformMode = {}))
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var Event = function() {
            function Event(time, data) {
                if (data == null) throw new Error("data cannot be null.");
                this.time = time;
                this.data = data
            }
            return Event
        }();
        core.Event = Event
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var EventData = function() {
            function EventData(name) {
                this.name = name
            }
            return EventData
        }();
        core.EventData = EventData
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var IkConstraint = function() {
            function IkConstraint(data, skeleton) {
                this.mix = 1;
                this.bendDirection = 0;
                if (data == null) throw new Error("data cannot be null.");
                if (skeleton == null) throw new Error("skeleton cannot be null.");
                this.data = data;
                this.mix = data.mix;
                this.bendDirection = data.bendDirection;
                this.bones = new Array;
                for (var i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));
                this.target = skeleton.findBone(data.target.name)
            }
            IkConstraint.prototype.getOrder =
                function() {
                    return this.data.order
                };
            IkConstraint.prototype.apply = function() {
                this.update()
            };
            IkConstraint.prototype.update = function() {
                var target = this.target;
                var bones = this.bones;
                switch (bones.length) {
                    case 1:
                        this.apply1(bones[0], target.worldX, target.worldY, this.mix);
                        break;
                    case 2:
                        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);
                        break
                }
            };
            IkConstraint.prototype.apply1 = function(bone, targetX, targetY, alpha) {
                if (!bone.appliedValid) bone.updateAppliedTransform();
                var p = bone.parent.matrix;
                var id = 1 / (p.a * p.d - p.b * p.c);
                var x = targetX - p.tx,
                    y = targetY - p.ty;
                var tx = (x * p.d - y * p.c) * id - bone.ax,
                    ty = (y * p.a - x * p.b) * id - bone.ay;
                var rotationIK = Math.atan2(ty, tx) * core.MathUtils.radDeg - bone.ashearX - bone.arotation;
                if (bone.ascaleX < 0) rotationIK += 180;
                if (rotationIK > 180) rotationIK -= 360;
                else if (rotationIK < -180) rotationIK += 360;
                bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, bone.ascaleX, bone.ascaleY, bone.ashearX, bone.ashearY)
            };
            IkConstraint.prototype.apply2 = function(parent, child, targetX,
                targetY, bendDir, alpha) {
                if (alpha == 0) {
                    child.updateWorldTransform();
                    return
                }
                if (!parent.appliedValid) parent.updateAppliedTransform();
                if (!child.appliedValid) child.updateAppliedTransform();
                var px = parent.ax,
                    py = parent.ay,
                    psx = parent.ascaleX,
                    psy = parent.ascaleY,
                    csx = child.ascaleX;
                var pmat = parent.matrix;
                var os1 = 0,
                    os2 = 0,
                    s2 = 0;
                if (psx < 0) {
                    psx = -psx;
                    os1 = 180;
                    s2 = -1
                } else {
                    os1 = 0;
                    s2 = 1
                }
                if (psy < 0) {
                    psy = -psy;
                    s2 = -s2
                }
                if (csx < 0) {
                    csx = -csx;
                    os2 = 180
                } else os2 = 0;
                var cx = child.ax,
                    cy = 0,
                    cwx = 0,
                    cwy = 0,
                    a = pmat.a,
                    b = pmat.c,
                    c = pmat.b,
                    d = pmat.d;
                var u = Math.abs(psx -
                    psy) <= 1E-4;
                if (!u) {
                    cy = 0;
                    cwx = a * cx + pmat.tx;
                    cwy = c * cx + pmat.ty
                } else {
                    cy = child.ay;
                    cwx = a * cx + b * cy + pmat.tx;
                    cwy = c * cx + d * cy + pmat.ty
                }
                var pp = parent.parent.matrix;
                a = pp.a;
                b = pp.c;
                c = pp.b;
                d = pp.d;
                var id = 1 / (a * d - b * c),
                    x = targetX - pp.tx,
                    y = targetY - pp.ty;
                var tx = (x * d - y * b) * id - px,
                    ty = (y * a - x * c) * id - py;
                x = cwx - pp.tx;
                y = cwy - pp.ty;
                var dx = (x * d - y * b) * id - px,
                    dy = (y * a - x * c) * id - py;
                var l1 = Math.sqrt(dx * dx + dy * dy),
                    l2 = child.data.length * csx,
                    a1 = 0,
                    a2 = 0;
                outer: if (u) {
                    l2 *= psx;
                    var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);
                    if (cos < -1) cos = -1;
                    else if (cos > 1) cos = 1;
                    a2 =
                        Math.acos(cos) * bendDir;
                    a = l1 + l2 * cos;
                    b = l2 * Math.sin(a2);
                    a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b)
                } else {
                    a = psx * l2;
                    b = psy * l2;
                    var aa = a * a,
                        bb = b * b,
                        dd = tx * tx + ty * ty,
                        ta = Math.atan2(ty, tx);
                    c = bb * l1 * l1 + aa * dd - aa * bb;
                    var c1 = -2 * bb * l1,
                        c2 = bb - aa;
                    d = c1 * c1 - 4 * c2 * c;
                    if (d >= 0) {
                        var q = Math.sqrt(d);
                        if (c1 < 0) q = -q;
                        q = -(c1 + q) / 2;
                        var r0 = q / c2,
                            r1 = c / q;
                        var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
                        if (r * r <= dd) {
                            y = Math.sqrt(dd - r * r) * bendDir;
                            a1 = ta - Math.atan2(y, r);
                            a2 = Math.atan2(y / psy, (r - l1) / psx);
                            break outer
                        }
                    }
                    var minAngle = core.MathUtils.PI,
                        minX = l1 - a,
                        minDist = minX * minX,
                        minY = 0;
                    var maxAngle = 0,
                        maxX = l1 + a,
                        maxDist = maxX * maxX,
                        maxY = 0;
                    c = -a * l1 / (aa - bb);
                    if (c >= -1 && c <= 1) {
                        c = Math.acos(c);
                        x = a * Math.cos(c) + l1;
                        y = b * Math.sin(c);
                        d = x * x + y * y;
                        if (d < minDist) {
                            minAngle = c;
                            minDist = d;
                            minX = x;
                            minY = y
                        }
                        if (d > maxDist) {
                            maxAngle = c;
                            maxDist = d;
                            maxX = x;
                            maxY = y
                        }
                    }
                    if (dd <= (minDist + maxDist) / 2) {
                        a1 = ta - Math.atan2(minY * bendDir, minX);
                        a2 = minAngle * bendDir
                    } else {
                        a1 = ta - Math.atan2(maxY * bendDir, maxX);
                        a2 = maxAngle * bendDir
                    }
                }
                var os = Math.atan2(cy, cx) * s2;
                var rotation = parent.arotation;
                a1 = (a1 - os) * core.MathUtils.radDeg + os1 - rotation;
                if (a1 >
                    180) a1 -= 360;
                else if (a1 < -180) a1 += 360;
                parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.ascaleX, parent.ascaleY, 0, 0);
                rotation = child.arotation;
                a2 = ((a2 + os) * core.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
                if (a2 > 180) a2 -= 360;
                else if (a2 < -180) a2 += 360;
                child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY)
            };
            return IkConstraint
        }();
        core.IkConstraint = IkConstraint
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var IkConstraintData = function() {
            function IkConstraintData(name) {
                this.order = 0;
                this.bones = new Array;
                this.bendDirection = 1;
                this.mix = 1;
                this.name = name
            }
            return IkConstraintData
        }();
        core.IkConstraintData = IkConstraintData
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var PathConstraint = function() {
            function PathConstraint(data, skeleton) {
                this.position = 0;
                this.spacing = 0;
                this.rotateMix = 0;
                this.translateMix = 0;
                this.spaces = new Array;
                this.positions = new Array;
                this.world = new Array;
                this.curves = new Array;
                this.lengths = new Array;
                this.segments = new Array;
                if (data == null) throw new Error("data cannot be null.");
                if (skeleton == null) throw new Error("skeleton cannot be null.");
                this.data = data;
                this.bones = new Array;
                for (var i = 0, n = data.bones.length; i <
                    n; i++) this.bones.push(skeleton.findBone(data.bones[i].name));
                this.target = skeleton.findSlot(data.target.name);
                this.position = data.position;
                this.spacing = data.spacing;
                this.rotateMix = data.rotateMix;
                this.translateMix = data.translateMix
            }
            PathConstraint.prototype.apply = function() {
                this.update()
            };
            PathConstraint.prototype.update = function() {
                var attachment = this.target.getAttachment();
                if (!(attachment instanceof core.PathAttachment)) return;
                var rotateMix = this.rotateMix,
                    translateMix = this.translateMix;
                var translate =
                    translateMix > 0,
                    rotate = rotateMix > 0;
                if (!translate && !rotate) return;
                var data = this.data;
                var spacingMode = data.spacingMode;
                var lengthSpacing = spacingMode == core.SpacingMode.Length;
                var rotateMode = data.rotateMode;
                var tangents = rotateMode == core.RotateMode.Tangent,
                    scale = rotateMode == core.RotateMode.ChainScale;
                var boneCount = this.bones.length,
                    spacesCount = tangents ? boneCount : boneCount + 1;
                var bones = this.bones;
                var spaces = core.Utils.setArraySize(this.spaces, spacesCount),
                    lengths = null;
                var spacing = this.spacing;
                if (scale || lengthSpacing) {
                    if (scale) lengths =
                        core.Utils.setArraySize(this.lengths, boneCount);
                    for (var i = 0, n = spacesCount - 1; i < n;) {
                        var bone = bones[i];
                        var setupLength = bone.data.length;
                        if (setupLength < PathConstraint.epsilon) {
                            if (scale) lengths[i] = 0;
                            spaces[++i] = 0
                        } else {
                            var x = setupLength * bone.matrix.a,
                                y = setupLength * bone.matrix.b;
                            var length_1 = Math.sqrt(x * x + y * y);
                            if (scale) lengths[i] = length_1;
                            spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_1 / setupLength
                        }
                    }
                } else
                    for (var i = 1; i < spacesCount; i++) spaces[i] = spacing;
                var positions = this.computeWorldPositions(attachment,
                    spacesCount, tangents, data.positionMode == core.PositionMode.Percent, spacingMode == core.SpacingMode.Percent);
                var boneX = positions[0],
                    boneY = positions[1],
                    offsetRotation = data.offsetRotation;
                var tip = false;
                if (offsetRotation == 0) tip = rotateMode == core.RotateMode.Chain;
                else {
                    tip = false;
                    var p = this.target.bone.matrix;
                    offsetRotation *= p.a * p.d - p.b * p.c > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad
                }
                for (var i = 0, p = 3; i < boneCount; i++, p += 3) {
                    var bone = bones[i];
                    var mat = bone.matrix;
                    mat.tx += (boneX - mat.tx) * translateMix;
                    mat.ty += (boneY -
                        mat.ty) * translateMix;
                    var x = positions[p],
                        y = positions[p + 1],
                        dx = x - boneX,
                        dy = y - boneY;
                    if (scale) {
                        var length_2 = lengths[i];
                        if (length_2 != 0) {
                            var s = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;
                            mat.a *= s;
                            mat.b *= s
                        }
                    }
                    boneX = x;
                    boneY = y;
                    if (rotate) {
                        var a = mat.a,
                            b = mat.c,
                            c = mat.b,
                            d = mat.d,
                            r = 0,
                            cos = 0,
                            sin = 0;
                        if (tangents) r = positions[p - 1];
                        else if (spaces[i + 1] == 0) r = positions[p + 2];
                        else r = Math.atan2(dy, dx);
                        r -= Math.atan2(c, a);
                        if (tip) {
                            cos = Math.cos(r);
                            sin = Math.sin(r);
                            var length_3 = bone.data.length;
                            boneX += (length_3 * (cos * a - sin * c) - dx) * rotateMix;
                            boneY += (length_3 * (sin * a + cos * c) - dy) * rotateMix
                        } else r += offsetRotation;
                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;
                        else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;
                        r *= rotateMix;
                        cos = Math.cos(r);
                        sin = Math.sin(r);
                        mat.a = cos * a - sin * c;
                        mat.c = cos * b - sin * d;
                        mat.b = sin * a + cos * c;
                        mat.d = sin * b + cos * d
                    }
                    bone.appliedValid = false
                }
            };
            PathConstraint.prototype.computeWorldPositions = function(path, spacesCount, tangents, percentPosition, percentSpacing) {
                var target = this.target;
                var position = this.position;
                var spaces = this.spaces,
                    out = core.Utils.setArraySize(this.positions,
                        spacesCount * 3 + 2),
                    world = null;
                var closed = path.closed;
                var verticesLength = path.worldVerticesLength,
                    curveCount = verticesLength / 6,
                    prevCurve = PathConstraint.NONE;
                if (!path.constantSpeed) {
                    var lengths = path.lengths;
                    curveCount -= closed ? 1 : 2;
                    var pathLength_1 = lengths[curveCount];
                    if (percentPosition) position *= pathLength_1;
                    if (percentSpacing)
                        for (var i = 0; i < spacesCount; i++) spaces[i] *= pathLength_1;
                    world = core.Utils.setArraySize(this.world, 8);
                    for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
                        var space = spaces[i];
                        position += space;
                        var p = position;
                        if (closed) {
                            p %= pathLength_1;
                            if (p < 0) p += pathLength_1;
                            curve = 0
                        } else if (p < 0) {
                            if (prevCurve != PathConstraint.BEFORE) {
                                prevCurve = PathConstraint.BEFORE;
                                path.computeWorldVertices(target, 2, 4, world, 0, 2)
                            }
                            this.addBeforePosition(p, world, 0, out, o);
                            continue
                        } else if (p > pathLength_1) {
                            if (prevCurve != PathConstraint.AFTER) {
                                prevCurve = PathConstraint.AFTER;
                                path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2)
                            }
                            this.addAfterPosition(p - pathLength_1, world, 0, out, o);
                            continue
                        }
                        for (;; curve++) {
                            var length_4 = lengths[curve];
                            if (p > length_4) continue;
                            if (curve == 0) p /= length_4;
                            else {
                                var prev = lengths[curve - 1];
                                p = (p - prev) / (length_4 - prev)
                            }
                            break
                        }
                        if (curve != prevCurve) {
                            prevCurve = curve;
                            if (closed && curve == curveCount) {
                                path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
                                path.computeWorldVertices(target, 0, 4, world, 4, 2)
                            } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2)
                        }
                        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0)
                    }
                    return out
                }
                if (closed) {
                    verticesLength +=
                        2;
                    world = core.Utils.setArraySize(this.world, verticesLength);
                    path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
                    path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
                    world[verticesLength - 2] = world[0];
                    world[verticesLength - 1] = world[1]
                } else {
                    curveCount--;
                    verticesLength -= 4;
                    world = core.Utils.setArraySize(this.world, verticesLength);
                    path.computeWorldVertices(target, 2, verticesLength, world, 0, 2)
                }
                var curves = core.Utils.setArraySize(this.curves, curveCount);
                var pathLength = 0;
                var x1 = world[0],
                    y1 = world[1],
                    cx1 = 0,
                    cy1 = 0,
                    cx2 = 0,
                    cy2 = 0,
                    x2 = 0,
                    y2 = 0;
                var tmpx = 0,
                    tmpy = 0,
                    dddfx = 0,
                    dddfy = 0,
                    ddfx = 0,
                    ddfy = 0,
                    dfx = 0,
                    dfy = 0;
                for (var i = 0, w = 2; i < curveCount; i++, w += 6) {
                    cx1 = world[w];
                    cy1 = world[w + 1];
                    cx2 = world[w + 2];
                    cy2 = world[w + 3];
                    x2 = world[w + 4];
                    y2 = world[w + 5];
                    tmpx = (x1 - cx1 * 2 + cx2) * .1875;
                    tmpy = (y1 - cy1 * 2 + cy2) * .1875;
                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * .09375;
                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * .09375;
                    ddfx = tmpx * 2 + dddfx;
                    ddfy = tmpy * 2 + dddfy;
                    dfx = (cx1 - x1) * .75 + tmpx + dddfx * .16666667;
                    dfy = (cy1 - y1) * .75 + tmpy + dddfy * .16666667;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx;
                    dfy +=
                        ddfy;
                    ddfx += dddfx;
                    ddfy += dddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx;
                    dfy += ddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx + dddfx;
                    dfy += ddfy + dddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    curves[i] = pathLength;
                    x1 = x2;
                    y1 = y2
                }
                if (percentPosition) position *= pathLength;
                if (percentSpacing)
                    for (var i = 0; i < spacesCount; i++) spaces[i] *= pathLength;
                var segments = this.segments;
                var curveLength = 0;
                for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
                    var space = spaces[i];
                    position += space;
                    var p = position;
                    if (closed) {
                        p %=
                            pathLength;
                        if (p < 0) p += pathLength;
                        curve = 0
                    } else if (p < 0) {
                        this.addBeforePosition(p, world, 0, out, o);
                        continue
                    } else if (p > pathLength) {
                        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
                        continue
                    }
                    for (;; curve++) {
                        var length_5 = curves[curve];
                        if (p > length_5) continue;
                        if (curve == 0) p /= length_5;
                        else {
                            var prev = curves[curve - 1];
                            p = (p - prev) / (length_5 - prev)
                        }
                        break
                    }
                    if (curve != prevCurve) {
                        prevCurve = curve;
                        var ii = curve * 6;
                        x1 = world[ii];
                        y1 = world[ii + 1];
                        cx1 = world[ii + 2];
                        cy1 = world[ii + 3];
                        cx2 = world[ii + 4];
                        cy2 = world[ii + 5];
                        x2 = world[ii +
                            6];
                        y2 = world[ii + 7];
                        tmpx = (x1 - cx1 * 2 + cx2) * .03;
                        tmpy = (y1 - cy1 * 2 + cy2) * .03;
                        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * .006;
                        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * .006;
                        ddfx = tmpx * 2 + dddfx;
                        ddfy = tmpy * 2 + dddfy;
                        dfx = (cx1 - x1) * .3 + tmpx + dddfx * .16666667;
                        dfy = (cy1 - y1) * .3 + tmpy + dddfy * .16666667;
                        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[0] = curveLength;
                        for (ii = 1; ii < 8; ii++) {
                            dfx += ddfx;
                            dfy += ddfy;
                            ddfx += dddfx;
                            ddfy += dddfy;
                            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                            segments[ii] = curveLength
                        }
                        dfx += ddfx;
                        dfy += ddfy;
                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[8] =
                            curveLength;
                        dfx += ddfx + dddfx;
                        dfy += ddfy + dddfy;
                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[9] = curveLength;
                        segment = 0
                    }
                    p *= curveLength;
                    for (;; segment++) {
                        var length_6 = segments[segment];
                        if (p > length_6) continue;
                        if (segment == 0) p /= length_6;
                        else {
                            var prev = segments[segment - 1];
                            p = segment + (p - prev) / (length_6 - prev)
                        }
                        break
                    }
                    this.addCurvePosition(p * .1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0)
                }
                return out
            };
            PathConstraint.prototype.addBeforePosition = function(p, temp, i, out, o) {
                var x1 = temp[i],
                    y1 = temp[i + 1],
                    dx =
                    temp[i + 2] - x1,
                    dy = temp[i + 3] - y1,
                    r = Math.atan2(dy, dx);
                out[o] = x1 + p * Math.cos(r);
                out[o + 1] = y1 + p * Math.sin(r);
                out[o + 2] = r
            };
            PathConstraint.prototype.addAfterPosition = function(p, temp, i, out, o) {
                var x1 = temp[i + 2],
                    y1 = temp[i + 3],
                    dx = x1 - temp[i],
                    dy = y1 - temp[i + 1],
                    r = Math.atan2(dy, dx);
                out[o] = x1 + p * Math.cos(r);
                out[o + 1] = y1 + p * Math.sin(r);
                out[o + 2] = r
            };
            PathConstraint.prototype.addCurvePosition = function(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
                if (p == 0 || isNaN(p)) p = 1E-4;
                var tt = p * p,
                    ttt = tt * p,
                    u = 1 - p,
                    uu = u * u,
                    uuu = uu * u;
                var ut = u * p,
                    ut3 = ut *
                    3,
                    uut3 = u * ut3,
                    utt3 = ut3 * p;
                var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt,
                    y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
                out[o] = x;
                out[o + 1] = y;
                if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt))
            };
            PathConstraint.prototype.getOrder = function() {
                return this.data.order
            };
            PathConstraint.NONE = -1;
            PathConstraint.BEFORE = -2;
            PathConstraint.AFTER = -3;
            PathConstraint.epsilon = 1E-5;
            return PathConstraint
        }();
        core.PathConstraint = PathConstraint
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var PathConstraintData = function() {
            function PathConstraintData(name) {
                this.order = 0;
                this.bones = new Array;
                this.name = name
            }
            return PathConstraintData
        }();
        core.PathConstraintData = PathConstraintData;
        var PositionMode;
        (function(PositionMode) {
            PositionMode[PositionMode["Fixed"] = 0] = "Fixed";
            PositionMode[PositionMode["Percent"] = 1] = "Percent"
        })(PositionMode = core.PositionMode || (core.PositionMode = {}));
        var SpacingMode;
        (function(SpacingMode) {
            SpacingMode[SpacingMode["Length"] = 0] =
                "Length";
            SpacingMode[SpacingMode["Fixed"] = 1] = "Fixed";
            SpacingMode[SpacingMode["Percent"] = 2] = "Percent"
        })(SpacingMode = core.SpacingMode || (core.SpacingMode = {}));
        var RotateMode;
        (function(RotateMode) {
            RotateMode[RotateMode["Tangent"] = 0] = "Tangent";
            RotateMode[RotateMode["Chain"] = 1] = "Chain";
            RotateMode[RotateMode["ChainScale"] = 2] = "ChainScale"
        })(RotateMode = core.RotateMode || (core.RotateMode = {}))
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var Skeleton = function() {
            function Skeleton(data) {
                this._updateCache = new Array;
                this.updateCacheReset = new Array;
                this.time = 0;
                this.flipX = false;
                this.flipY = false;
                this.x = 0;
                this.y = 0;
                if (data == null) throw new Error("data cannot be null.");
                this.data = data;
                this.bones = new Array;
                for (var i = 0; i < data.bones.length; i++) {
                    var boneData = data.bones[i];
                    var bone = void 0;
                    if (boneData.parent == null) bone = new core.Bone(boneData, this, null);
                    else {
                        var parent_1 = this.bones[boneData.parent.index];
                        bone = new core.Bone(boneData, this, parent_1);
                        parent_1.children.push(bone)
                    }
                    this.bones.push(bone)
                }
                this.slots = new Array;
                this.drawOrder = new Array;
                for (var i = 0; i < data.slots.length; i++) {
                    var slotData = data.slots[i];
                    var bone = this.bones[slotData.boneData.index];
                    var slot = new core.Slot(slotData, bone);
                    this.slots.push(slot);
                    this.drawOrder.push(slot)
                }
                this.ikConstraints = new Array;
                for (var i = 0; i < data.ikConstraints.length; i++) {
                    var ikConstraintData = data.ikConstraints[i];
                    this.ikConstraints.push(new core.IkConstraint(ikConstraintData,
                        this))
                }
                this.transformConstraints = new Array;
                for (var i = 0; i < data.transformConstraints.length; i++) {
                    var transformConstraintData = data.transformConstraints[i];
                    this.transformConstraints.push(new core.TransformConstraint(transformConstraintData, this))
                }
                this.pathConstraints = new Array;
                for (var i = 0; i < data.pathConstraints.length; i++) {
                    var pathConstraintData = data.pathConstraints[i];
                    this.pathConstraints.push(new core.PathConstraint(pathConstraintData, this))
                }
                this.color = new core.Color(1, 1, 1, 1);
                this.updateCache()
            }
            Skeleton.prototype.updateCache =
                function() {
                    var updateCache = this._updateCache;
                    updateCache.length = 0;
                    this.updateCacheReset.length = 0;
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) bones[i].sorted = false;
                    var ikConstraints = this.ikConstraints;
                    var transformConstraints = this.transformConstraints;
                    var pathConstraints = this.pathConstraints;
                    var ikCount = ikConstraints.length,
                        transformCount = transformConstraints.length,
                        pathCount = pathConstraints.length;
                    var constraintCount = ikCount + transformCount + pathCount;
                    outer: for (var i = 0; i < constraintCount; i++) {
                        for (var ii =
                                0; ii < ikCount; ii++) {
                            var constraint = ikConstraints[ii];
                            if (constraint.data.order == i) {
                                this.sortIkConstraint(constraint);
                                continue outer
                            }
                        }
                        for (var ii = 0; ii < transformCount; ii++) {
                            var constraint = transformConstraints[ii];
                            if (constraint.data.order == i) {
                                this.sortTransformConstraint(constraint);
                                continue outer
                            }
                        }
                        for (var ii = 0; ii < pathCount; ii++) {
                            var constraint = pathConstraints[ii];
                            if (constraint.data.order == i) {
                                this.sortPathConstraint(constraint);
                                continue outer
                            }
                        }
                    }
                    for (var i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i])
                };
            Skeleton.prototype.sortIkConstraint = function(constraint) {
                var target = constraint.target;
                this.sortBone(target);
                var constrained = constraint.bones;
                var parent = constrained[0];
                this.sortBone(parent);
                if (constrained.length > 1) {
                    var child = constrained[constrained.length - 1];
                    if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child)
                }
                this._updateCache.push(constraint);
                this.sortReset(parent.children);
                constrained[constrained.length - 1].sorted = true
            };
            Skeleton.prototype.sortPathConstraint = function(constraint) {
                var slot =
                    constraint.target;
                var slotIndex = slot.data.index;
                var slotBone = slot.bone;
                if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
                if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
                for (var i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
                var attachment = slot.getAttachment();
                if (attachment instanceof core.PathAttachment) this.sortPathConstraintAttachmentWith(attachment,
                    slotBone);
                var constrained = constraint.bones;
                var boneCount = constrained.length;
                for (var i = 0; i < boneCount; i++) this.sortBone(constrained[i]);
                this._updateCache.push(constraint);
                for (var i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);
                for (var i = 0; i < boneCount; i++) constrained[i].sorted = true
            };
            Skeleton.prototype.sortTransformConstraint = function(constraint) {
                this.sortBone(constraint.target);
                var constrained = constraint.bones;
                var boneCount = constrained.length;
                if (constraint.data.local)
                    for (var i = 0; i < boneCount; i++) {
                        var child =
                            constrained[i];
                        this.sortBone(child.parent);
                        if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child)
                    } else
                        for (var i = 0; i < boneCount; i++) this.sortBone(constrained[i]);
                this._updateCache.push(constraint);
                for (var ii = 0; ii < boneCount; ii++) this.sortReset(constrained[ii].children);
                for (var ii = 0; ii < boneCount; ii++) constrained[ii].sorted = true
            };
            Skeleton.prototype.sortPathConstraintAttachment = function(skin, slotIndex, slotBone) {
                var attachments = skin.attachments[slotIndex];
                if (!attachments) return;
                for (var key in attachments) this.sortPathConstraintAttachmentWith(attachments[key],
                    slotBone)
            };
            Skeleton.prototype.sortPathConstraintAttachmentWith = function(attachment, slotBone) {
                if (!(attachment instanceof core.PathAttachment)) return;
                var pathBones = attachment.bones;
                if (pathBones == null) this.sortBone(slotBone);
                else {
                    var bones = this.bones;
                    var i = 0;
                    while (i < pathBones.length) {
                        var boneCount = pathBones[i++];
                        for (var n = i + boneCount; i < n; i++) {
                            var boneIndex = pathBones[i];
                            this.sortBone(bones[boneIndex])
                        }
                    }
                }
            };
            Skeleton.prototype.sortBone = function(bone) {
                if (bone.sorted) return;
                var parent = bone.parent;
                if (parent !=
                    null) this.sortBone(parent);
                bone.sorted = true;
                this._updateCache.push(bone)
            };
            Skeleton.prototype.sortReset = function(bones) {
                for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    if (bone.sorted) this.sortReset(bone.children);
                    bone.sorted = false
                }
            };
            Skeleton.prototype.updateWorldTransform = function() {
                var updateCacheReset = this.updateCacheReset;
                for (var i = 0, n = updateCacheReset.length; i < n; i++) {
                    var bone = updateCacheReset[i];
                    bone.ax = bone.x;
                    bone.ay = bone.y;
                    bone.arotation = bone.rotation;
                    bone.ascaleX = bone.scaleX;
                    bone.ascaleY =
                        bone.scaleY;
                    bone.ashearX = bone.shearX;
                    bone.ashearY = bone.shearY;
                    bone.appliedValid = true
                }
                var updateCache = this._updateCache;
                for (var i = 0, n = updateCache.length; i < n; i++) updateCache[i].update()
            };
            Skeleton.prototype.setToSetupPose = function() {
                this.setBonesToSetupPose();
                this.setSlotsToSetupPose()
            };
            Skeleton.prototype.setBonesToSetupPose = function() {
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();
                var ikConstraints = this.ikConstraints;
                for (var i = 0, n = ikConstraints.length; i < n; i++) {
                    var constraint =
                        ikConstraints[i];
                    constraint.bendDirection = constraint.data.bendDirection;
                    constraint.mix = constraint.data.mix
                }
                var transformConstraints = this.transformConstraints;
                for (var i = 0, n = transformConstraints.length; i < n; i++) {
                    var constraint = transformConstraints[i];
                    var data = constraint.data;
                    constraint.rotateMix = data.rotateMix;
                    constraint.translateMix = data.translateMix;
                    constraint.scaleMix = data.scaleMix;
                    constraint.shearMix = data.shearMix
                }
                var pathConstraints = this.pathConstraints;
                for (var i = 0, n = pathConstraints.length; i < n; i++) {
                    var constraint =
                        pathConstraints[i];
                    var data = constraint.data;
                    constraint.position = data.position;
                    constraint.spacing = data.spacing;
                    constraint.rotateMix = data.rotateMix;
                    constraint.translateMix = data.translateMix
                }
            };
            Skeleton.prototype.setSlotsToSetupPose = function() {
                var slots = this.slots;
                core.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
                for (var i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose()
            };
            Skeleton.prototype.getRootBone = function() {
                if (this.bones.length == 0) return null;
                return this.bones[0]
            };
            Skeleton.prototype.findBone =
                function(boneName) {
                    if (boneName == null) throw new Error("boneName cannot be null.");
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        var bone = bones[i];
                        if (bone.data.name == boneName) return bone
                    }
                    return null
                };
            Skeleton.prototype.findBoneIndex = function(boneName) {
                if (boneName == null) throw new Error("boneName cannot be null.");
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++)
                    if (bones[i].data.name == boneName) return i;
                return -1
            };
            Skeleton.prototype.findSlot = function(slotName) {
                if (slotName == null) throw new Error("slotName cannot be null.");
                var slots = this.slots;
                for (var i = 0, n = slots.length; i < n; i++) {
                    var slot = slots[i];
                    if (slot.data.name == slotName) return slot
                }
                return null
            };
            Skeleton.prototype.findSlotIndex = function(slotName) {
                if (slotName == null) throw new Error("slotName cannot be null.");
                var slots = this.slots;
                for (var i = 0, n = slots.length; i < n; i++)
                    if (slots[i].data.name == slotName) return i;
                return -1
            };
            Skeleton.prototype.setSkinByName = function(skinName) {
                var skin = this.data.findSkin(skinName);
                if (skin == null) throw new Error("Skin not found: " + skinName);
                this.setSkin(skin)
            };
            Skeleton.prototype.setSkin = function(newSkin) {
                if (newSkin != null)
                    if (this.skin != null) newSkin.attachAll(this, this.skin);
                    else {
                        var slots = this.slots;
                        for (var i = 0, n = slots.length; i < n; i++) {
                            var slot = slots[i];
                            var name_1 = slot.data.attachmentName;
                            if (name_1 != null) {
                                var attachment = newSkin.getAttachment(i, name_1);
                                if (attachment != null) slot.setAttachment(attachment)
                            }
                        }
                    }
                this.skin = newSkin
            };
            Skeleton.prototype.getAttachmentByName = function(slotName, attachmentName) {
                return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName)
            };
            Skeleton.prototype.getAttachment = function(slotIndex, attachmentName) {
                if (attachmentName == null) throw new Error("attachmentName cannot be null.");
                if (this.skin != null) {
                    var attachment = this.skin.getAttachment(slotIndex, attachmentName);
                    if (attachment != null) return attachment
                }
                if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
                return null
            };
            Skeleton.prototype.setAttachment = function(slotName, attachmentName) {
                if (slotName == null) throw new Error("slotName cannot be null.");
                var slots = this.slots;
                for (var i = 0, n = slots.length; i < n; i++) {
                    var slot = slots[i];
                    if (slot.data.name == slotName) {
                        var attachment = null;
                        if (attachmentName != null) {
                            attachment = this.getAttachment(i, attachmentName);
                            if (attachment == null) throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
                        }
                        slot.setAttachment(attachment);
                        return
                    }
                }
                throw new Error("Slot not found: " + slotName);
            };
            Skeleton.prototype.findIkConstraint = function(constraintName) {
                if (constraintName == null) throw new Error("constraintName cannot be null.");
                var ikConstraints = this.ikConstraints;
                for (var i = 0, n = ikConstraints.length; i < n; i++) {
                    var ikConstraint = ikConstraints[i];
                    if (ikConstraint.data.name == constraintName) return ikConstraint
                }
                return null
            };
            Skeleton.prototype.findTransformConstraint = function(constraintName) {
                if (constraintName == null) throw new Error("constraintName cannot be null.");
                var transformConstraints = this.transformConstraints;
                for (var i = 0, n = transformConstraints.length; i < n; i++) {
                    var constraint = transformConstraints[i];
                    if (constraint.data.name == constraintName) return constraint
                }
                return null
            };
            Skeleton.prototype.findPathConstraint = function(constraintName) {
                if (constraintName == null) throw new Error("constraintName cannot be null.");
                var pathConstraints = this.pathConstraints;
                for (var i = 0, n = pathConstraints.length; i < n; i++) {
                    var constraint = pathConstraints[i];
                    if (constraint.data.name == constraintName) return constraint
                }
                return null
            };
            Skeleton.prototype.getBounds = function(offset, size, temp) {
                if (offset == null) throw new Error("offset cannot be null.");
                if (size == null) throw new Error("size cannot be null.");
                var drawOrder =
                    this.drawOrder;
                var minX = Number.POSITIVE_INFINITY,
                    minY = Number.POSITIVE_INFINITY,
                    maxX = Number.NEGATIVE_INFINITY,
                    maxY = Number.NEGATIVE_INFINITY;
                for (var i = 0, n = drawOrder.length; i < n; i++) {
                    var slot = drawOrder[i];
                    var verticesLength = 0;
                    var vertices = null;
                    var attachment = slot.getAttachment();
                    if (attachment instanceof core.RegionAttachment) {
                        verticesLength = 8;
                        vertices = core.Utils.setArraySize(temp, verticesLength, 0);
                        attachment.computeWorldVertices(slot.bone, vertices, 0, 2)
                    } else if (attachment instanceof core.MeshAttachment) {
                        var mesh =
                            attachment;
                        verticesLength = mesh.worldVerticesLength;
                        vertices = core.Utils.setArraySize(temp, verticesLength, 0);
                        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2)
                    }
                    if (vertices != null)
                        for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {
                            var x = vertices[ii],
                                y = vertices[ii + 1];
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y)
                        }
                }
                offset.set(minX, minY);
                size.set(maxX - minX, maxY - minY)
            };
            Skeleton.prototype.update = function(delta) {
                this.time += delta
            };
            return Skeleton
        }();
        core.Skeleton =
            Skeleton
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var SkeletonBounds = function() {
            function SkeletonBounds() {
                this.minX = 0;
                this.minY = 0;
                this.maxX = 0;
                this.maxY = 0;
                this.boundingBoxes = new Array;
                this.polygons = new Array;
                this.polygonPool = new core.Pool(function() {
                    return core.Utils.newFloatArray(16)
                })
            }
            SkeletonBounds.prototype.update = function(skeleton, updateAabb) {
                if (skeleton == null) throw new Error("skeleton cannot be null.");
                var boundingBoxes = this.boundingBoxes;
                var polygons = this.polygons;
                var polygonPool = this.polygonPool;
                var slots = skeleton.slots;
                var slotCount = slots.length;
                boundingBoxes.length = 0;
                polygonPool.freeAll(polygons);
                polygons.length = 0;
                for (var i = 0; i < slotCount; i++) {
                    var slot = slots[i];
                    var attachment = slot.getAttachment();
                    if (attachment instanceof core.BoundingBoxAttachment) {
                        var boundingBox = attachment;
                        boundingBoxes.push(boundingBox);
                        var polygon = polygonPool.obtain();
                        if (polygon.length != boundingBox.worldVerticesLength) polygon = core.Utils.newFloatArray(boundingBox.worldVerticesLength);
                        polygons.push(polygon);
                        boundingBox.computeWorldVertices(slot,
                            0, boundingBox.worldVerticesLength, polygon, 0, 2)
                    }
                }
                if (updateAabb) this.aabbCompute();
                else {
                    this.minX = Number.POSITIVE_INFINITY;
                    this.minY = Number.POSITIVE_INFINITY;
                    this.maxX = Number.NEGATIVE_INFINITY;
                    this.maxY = Number.NEGATIVE_INFINITY
                }
            };
            SkeletonBounds.prototype.aabbCompute = function() {
                var minX = Number.POSITIVE_INFINITY,
                    minY = Number.POSITIVE_INFINITY,
                    maxX = Number.NEGATIVE_INFINITY,
                    maxY = Number.NEGATIVE_INFINITY;
                var polygons = this.polygons;
                for (var i = 0, n = polygons.length; i < n; i++) {
                    var polygon = polygons[i];
                    var vertices =
                        polygon;
                    for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {
                        var x = vertices[ii];
                        var y = vertices[ii + 1];
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y)
                    }
                }
                this.minX = minX;
                this.minY = minY;
                this.maxX = maxX;
                this.maxY = maxY
            };
            SkeletonBounds.prototype.aabbContainsPoint = function(x, y) {
                return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY
            };
            SkeletonBounds.prototype.aabbIntersectsSegment = function(x1, y1, x2, y2) {
                var minX = this.minX;
                var minY = this.minY;
                var maxX = this.maxX;
                var maxY = this.maxY;
                if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) return false;
                var m = (y2 - y1) / (x2 - x1);
                var y = m * (minX - x1) + y1;
                if (y > minY && y < maxY) return true;
                y = m * (maxX - x1) + y1;
                if (y > minY && y < maxY) return true;
                var x = (minY - y1) / m + x1;
                if (x > minX && x < maxX) return true;
                x = (maxY - y1) / m + x1;
                if (x > minX && x < maxX) return true;
                return false
            };
            SkeletonBounds.prototype.aabbIntersectsSkeleton = function(bounds) {
                return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY
            };
            SkeletonBounds.prototype.containsPoint =
                function(x, y) {
                    var polygons = this.polygons;
                    for (var i = 0, n = polygons.length; i < n; i++)
                        if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];
                    return null
                };
            SkeletonBounds.prototype.containsPointPolygon = function(polygon, x, y) {
                var vertices = polygon;
                var nn = polygon.length;
                var prevIndex = nn - 2;
                var inside = false;
                for (var ii = 0; ii < nn; ii += 2) {
                    var vertexY = vertices[ii + 1];
                    var prevY = vertices[prevIndex + 1];
                    if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {
                        var vertexX = vertices[ii];
                        if (vertexX + (y - vertexY) / (prevY - vertexY) *
                            (vertices[prevIndex] - vertexX) < x) inside = !inside
                    }
                    prevIndex = ii
                }
                return inside
            };
            SkeletonBounds.prototype.intersectsSegment = function(x1, y1, x2, y2) {
                var polygons = this.polygons;
                for (var i = 0, n = polygons.length; i < n; i++)
                    if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];
                return null
            };
            SkeletonBounds.prototype.intersectsSegmentPolygon = function(polygon, x1, y1, x2, y2) {
                var vertices = polygon;
                var nn = polygon.length;
                var width12 = x1 - x2,
                    height12 = y1 - y2;
                var det1 = x1 * y2 - y1 * x2;
                var x3 = vertices[nn -
                        2],
                    y3 = vertices[nn - 1];
                for (var ii = 0; ii < nn; ii += 2) {
                    var x4 = vertices[ii],
                        y4 = vertices[ii + 1];
                    var det2 = x3 * y4 - y3 * x4;
                    var width34 = x3 - x4,
                        height34 = y3 - y4;
                    var det3 = width12 * height34 - height12 * width34;
                    var x = (det1 * width34 - width12 * det2) / det3;
                    if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {
                        var y = (det1 * height34 - height12 * det2) / det3;
                        if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1)) return true
                    }
                    x3 = x4;
                    y3 = y4
                }
                return false
            };
            SkeletonBounds.prototype.getPolygon = function(boundingBox) {
                if (boundingBox == null) throw new Error("boundingBox cannot be null.");
                var index = this.boundingBoxes.indexOf(boundingBox);
                return index == -1 ? null : this.polygons[index]
            };
            SkeletonBounds.prototype.getWidth = function() {
                return this.maxX - this.minX
            };
            SkeletonBounds.prototype.getHeight = function() {
                return this.maxY - this.minY
            };
            return SkeletonBounds
        }();
        core.SkeletonBounds = SkeletonBounds
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var SkeletonClipping = function() {
            function SkeletonClipping() {
                this.triangulator = new core.Triangulator;
                this.clippingPolygon = new Array;
                this.clipOutput = new Array;
                this.clippedVertices = new Array;
                this.clippedTriangles = new Array;
                this.scratch = new Array
            }
            SkeletonClipping.prototype.clipStart = function(slot, clip) {
                if (this.clipAttachment != null) return 0;
                this.clipAttachment = clip;
                var n = clip.worldVerticesLength;
                var vertices = core.Utils.setArraySize(this.clippingPolygon, n);
                clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);
                var clippingPolygon = this.clippingPolygon;
                SkeletonClipping.makeClockwise(clippingPolygon);
                var clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));
                for (var i = 0, n_1 = clippingPolygons.length; i < n_1; i++) {
                    var polygon = clippingPolygons[i];
                    SkeletonClipping.makeClockwise(polygon);
                    polygon.push(polygon[0]);
                    polygon.push(polygon[1])
                }
                return clippingPolygons.length
            };
            SkeletonClipping.prototype.clipEndWithSlot =
                function(slot) {
                    if (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data) this.clipEnd()
                };
            SkeletonClipping.prototype.clipEnd = function() {
                if (this.clipAttachment == null) return;
                this.clipAttachment = null;
                this.clippingPolygons = null;
                this.clippedVertices.length = 0;
                this.clippedTriangles.length = 0;
                this.clippingPolygon.length = 0
            };
            SkeletonClipping.prototype.isClipping = function() {
                return this.clipAttachment != null
            };
            SkeletonClipping.prototype.clipTriangles = function(vertices, verticesLength, triangles, trianglesLength,
                uvs, light, dark, twoColor) {
                var clipOutput = this.clipOutput,
                    clippedVertices = this.clippedVertices;
                var clippedTriangles = this.clippedTriangles;
                var polygons = this.clippingPolygons;
                var polygonsCount = this.clippingPolygons.length;
                var vertexSize = twoColor ? 12 : 8;
                var index = 0;
                clippedVertices.length = 0;
                clippedTriangles.length = 0;
                outer: for (var i = 0; i < trianglesLength; i += 3) {
                    var vertexOffset = triangles[i] << 1;
                    var x1 = vertices[vertexOffset],
                        y1 = vertices[vertexOffset + 1];
                    var u1 = uvs[vertexOffset],
                        v1 = uvs[vertexOffset + 1];
                    vertexOffset =
                        triangles[i + 1] << 1;
                    var x2 = vertices[vertexOffset],
                        y2 = vertices[vertexOffset + 1];
                    var u2 = uvs[vertexOffset],
                        v2 = uvs[vertexOffset + 1];
                    vertexOffset = triangles[i + 2] << 1;
                    var x3 = vertices[vertexOffset],
                        y3 = vertices[vertexOffset + 1];
                    var u3 = uvs[vertexOffset],
                        v3 = uvs[vertexOffset + 1];
                    for (var p = 0; p < polygonsCount; p++) {
                        var s = clippedVertices.length;
                        if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {
                            var clipOutputLength = clipOutput.length;
                            if (clipOutputLength == 0) continue;
                            var d0 = y2 - y3,
                                d1 = x3 - x2,
                                d2 = x1 - x3,
                                d4 = y3 - y1;
                            var d = 1 / (d0 *
                                d2 + d1 * (y1 - y3));
                            var clipOutputCount = clipOutputLength >> 1;
                            var clipOutputItems = this.clipOutput;
                            var clippedVerticesItems = core.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);
                            for (var ii = 0; ii < clipOutputLength; ii += 2) {
                                var x = clipOutputItems[ii],
                                    y = clipOutputItems[ii + 1];
                                clippedVerticesItems[s] = x;
                                clippedVerticesItems[s + 1] = y;
                                clippedVerticesItems[s + 2] = light.r;
                                clippedVerticesItems[s + 3] = light.g;
                                clippedVerticesItems[s + 4] = light.b;
                                clippedVerticesItems[s + 5] = light.a;
                                var c0 = x - x3,
                                    c1 = y - y3;
                                var a = (d0 * c0 + d1 *
                                    c1) * d;
                                var b = (d4 * c0 + d2 * c1) * d;
                                var c = 1 - a - b;
                                clippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;
                                clippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;
                                if (twoColor) {
                                    clippedVerticesItems[s + 8] = dark.r;
                                    clippedVerticesItems[s + 9] = dark.g;
                                    clippedVerticesItems[s + 10] = dark.b;
                                    clippedVerticesItems[s + 11] = dark.a
                                }
                                s += vertexSize
                            }
                            s = clippedTriangles.length;
                            var clippedTrianglesItems = core.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));
                            clipOutputCount--;
                            for (var ii = 1; ii < clipOutputCount; ii++) {
                                clippedTrianglesItems[s] = index;
                                clippedTrianglesItems[s +
                                    1] = index + ii;
                                clippedTrianglesItems[s + 2] = index + ii + 1;
                                s += 3
                            }
                            index += clipOutputCount + 1
                        } else {
                            var clippedVerticesItems = core.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);
                            clippedVerticesItems[s] = x1;
                            clippedVerticesItems[s + 1] = y1;
                            clippedVerticesItems[s + 2] = light.r;
                            clippedVerticesItems[s + 3] = light.g;
                            clippedVerticesItems[s + 4] = light.b;
                            clippedVerticesItems[s + 5] = light.a;
                            if (!twoColor) {
                                clippedVerticesItems[s + 6] = u1;
                                clippedVerticesItems[s + 7] = v1;
                                clippedVerticesItems[s + 8] = x2;
                                clippedVerticesItems[s + 9] = y2;
                                clippedVerticesItems[s +
                                    10] = light.r;
                                clippedVerticesItems[s + 11] = light.g;
                                clippedVerticesItems[s + 12] = light.b;
                                clippedVerticesItems[s + 13] = light.a;
                                clippedVerticesItems[s + 14] = u2;
                                clippedVerticesItems[s + 15] = v2;
                                clippedVerticesItems[s + 16] = x3;
                                clippedVerticesItems[s + 17] = y3;
                                clippedVerticesItems[s + 18] = light.r;
                                clippedVerticesItems[s + 19] = light.g;
                                clippedVerticesItems[s + 20] = light.b;
                                clippedVerticesItems[s + 21] = light.a;
                                clippedVerticesItems[s + 22] = u3;
                                clippedVerticesItems[s + 23] = v3
                            } else {
                                clippedVerticesItems[s + 6] = u1;
                                clippedVerticesItems[s + 7] = v1;
                                clippedVerticesItems[s +
                                    8] = dark.r;
                                clippedVerticesItems[s + 9] = dark.g;
                                clippedVerticesItems[s + 10] = dark.b;
                                clippedVerticesItems[s + 11] = dark.a;
                                clippedVerticesItems[s + 12] = x2;
                                clippedVerticesItems[s + 13] = y2;
                                clippedVerticesItems[s + 14] = light.r;
                                clippedVerticesItems[s + 15] = light.g;
                                clippedVerticesItems[s + 16] = light.b;
                                clippedVerticesItems[s + 17] = light.a;
                                clippedVerticesItems[s + 18] = u2;
                                clippedVerticesItems[s + 19] = v2;
                                clippedVerticesItems[s + 20] = dark.r;
                                clippedVerticesItems[s + 21] = dark.g;
                                clippedVerticesItems[s + 22] = dark.b;
                                clippedVerticesItems[s + 23] = dark.a;
                                clippedVerticesItems[s + 24] = x3;
                                clippedVerticesItems[s + 25] = y3;
                                clippedVerticesItems[s + 26] = light.r;
                                clippedVerticesItems[s + 27] = light.g;
                                clippedVerticesItems[s + 28] = light.b;
                                clippedVerticesItems[s + 29] = light.a;
                                clippedVerticesItems[s + 30] = u3;
                                clippedVerticesItems[s + 31] = v3;
                                clippedVerticesItems[s + 32] = dark.r;
                                clippedVerticesItems[s + 33] = dark.g;
                                clippedVerticesItems[s + 34] = dark.b;
                                clippedVerticesItems[s + 35] = dark.a
                            }
                            s = clippedTriangles.length;
                            var clippedTrianglesItems = core.Utils.setArraySize(clippedTriangles, s + 3);
                            clippedTrianglesItems[s] =
                                index;
                            clippedTrianglesItems[s + 1] = index + 1;
                            clippedTrianglesItems[s + 2] = index + 2;
                            index += 3;
                            continue outer
                        }
                    }
                }
            };
            SkeletonClipping.prototype.clip = function(x1, y1, x2, y2, x3, y3, clippingArea, output) {
                var originalOutput = output;
                var clipped = false;
                var input = null;
                if (clippingArea.length % 4 >= 2) {
                    input = output;
                    output = this.scratch
                } else input = this.scratch;
                input.length = 0;
                input.push(x1);
                input.push(y1);
                input.push(x2);
                input.push(y2);
                input.push(x3);
                input.push(y3);
                input.push(x1);
                input.push(y1);
                output.length = 0;
                var clippingVertices =
                    clippingArea;
                var clippingVerticesLast = clippingArea.length - 4;
                for (var i = 0;; i += 2) {
                    var edgeX = clippingVertices[i],
                        edgeY = clippingVertices[i + 1];
                    var edgeX2 = clippingVertices[i + 2],
                        edgeY2 = clippingVertices[i + 3];
                    var deltaX = edgeX - edgeX2,
                        deltaY = edgeY - edgeY2;
                    var inputVertices = input;
                    var inputVerticesLength = input.length - 2,
                        outputStart = output.length;
                    for (var ii = 0; ii < inputVerticesLength; ii += 2) {
                        var inputX = inputVertices[ii],
                            inputY = inputVertices[ii + 1];
                        var inputX2 = inputVertices[ii + 2],
                            inputY2 = inputVertices[ii + 3];
                        var side2 =
                            deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;
                        if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {
                            if (side2) {
                                output.push(inputX2);
                                output.push(inputY2);
                                continue
                            }
                            var c0 = inputY2 - inputY,
                                c2 = inputX2 - inputX;
                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));
                            output.push(edgeX + (edgeX2 - edgeX) * ua);
                            output.push(edgeY + (edgeY2 - edgeY) * ua)
                        } else if (side2) {
                            var c0 = inputY2 - inputY,
                                c2 = inputX2 - inputX;
                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));
                            output.push(edgeX +
                                (edgeX2 - edgeX) * ua);
                            output.push(edgeY + (edgeY2 - edgeY) * ua);
                            output.push(inputX2);
                            output.push(inputY2)
                        }
                        clipped = true
                    }
                    if (outputStart == output.length) {
                        originalOutput.length = 0;
                        return true
                    }
                    output.push(output[0]);
                    output.push(output[1]);
                    if (i == clippingVerticesLast) break;
                    var temp = output;
                    output = input;
                    output.length = 0;
                    input = temp
                }
                if (originalOutput != output) {
                    originalOutput.length = 0;
                    for (var i = 0, n = output.length - 2; i < n; i++) originalOutput[i] = output[i]
                } else originalOutput.length = originalOutput.length - 2;
                return clipped
            };
            SkeletonClipping.makeClockwise =
                function(polygon) {
                    var vertices = polygon;
                    var verticeslength = polygon.length;
                    var area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1],
                        p1x = 0,
                        p1y = 0,
                        p2x = 0,
                        p2y = 0;
                    for (var i = 0, n = verticeslength - 3; i < n; i += 2) {
                        p1x = vertices[i];
                        p1y = vertices[i + 1];
                        p2x = vertices[i + 2];
                        p2y = vertices[i + 3];
                        area += p1x * p2y - p2x * p1y
                    }
                    if (area < 0) return;
                    for (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {
                        var x = vertices[i],
                            y = vertices[i + 1];
                        var other = lastX - i;
                        vertices[i] = vertices[other];
                        vertices[i + 1] = vertices[other +
                            1];
                        vertices[other] = x;
                        vertices[other + 1] = y
                    }
                };
            return SkeletonClipping
        }();
        core.SkeletonClipping = SkeletonClipping
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var SkeletonData = function() {
            function SkeletonData() {
                this.bones = new Array;
                this.slots = new Array;
                this.skins = new Array;
                this.events = new Array;
                this.animations = new Array;
                this.ikConstraints = new Array;
                this.transformConstraints = new Array;
                this.pathConstraints = new Array;
                this.fps = 0
            }
            SkeletonData.prototype.findBone = function(boneName) {
                if (boneName == null) throw new Error("boneName cannot be null.");
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    if (bone.name == boneName) return bone
                }
                return null
            };
            SkeletonData.prototype.findBoneIndex = function(boneName) {
                if (boneName == null) throw new Error("boneName cannot be null.");
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++)
                    if (bones[i].name == boneName) return i;
                return -1
            };
            SkeletonData.prototype.findSlot = function(slotName) {
                if (slotName == null) throw new Error("slotName cannot be null.");
                var slots = this.slots;
                for (var i = 0, n = slots.length; i < n; i++) {
                    var slot = slots[i];
                    if (slot.name == slotName) return slot
                }
                return null
            };
            SkeletonData.prototype.findSlotIndex = function(slotName) {
                if (slotName == null) throw new Error("slotName cannot be null.");
                var slots = this.slots;
                for (var i = 0, n = slots.length; i < n; i++)
                    if (slots[i].name == slotName) return i;
                return -1
            };
            SkeletonData.prototype.findSkin = function(skinName) {
                if (skinName == null) throw new Error("skinName cannot be null.");
                var skins = this.skins;
                for (var i = 0, n = skins.length; i < n; i++) {
                    var skin = skins[i];
                    if (skin.name == skinName) return skin
                }
                return null
            };
            SkeletonData.prototype.findEvent = function(eventDataName) {
                if (eventDataName ==
                    null) throw new Error("eventDataName cannot be null.");
                var events = this.events;
                for (var i = 0, n = events.length; i < n; i++) {
                    var event_4 = events[i];
                    if (event_4.name == eventDataName) return event_4
                }
                return null
            };
            SkeletonData.prototype.findAnimation = function(animationName) {
                if (animationName == null) throw new Error("animationName cannot be null.");
                var animations = this.animations;
                for (var i = 0, n = animations.length; i < n; i++) {
                    var animation = animations[i];
                    if (animation.name == animationName) return animation
                }
                return null
            };
            SkeletonData.prototype.findIkConstraint =
                function(constraintName) {
                    if (constraintName == null) throw new Error("constraintName cannot be null.");
                    var ikConstraints = this.ikConstraints;
                    for (var i = 0, n = ikConstraints.length; i < n; i++) {
                        var constraint = ikConstraints[i];
                        if (constraint.name == constraintName) return constraint
                    }
                    return null
                };
            SkeletonData.prototype.findTransformConstraint = function(constraintName) {
                if (constraintName == null) throw new Error("constraintName cannot be null.");
                var transformConstraints = this.transformConstraints;
                for (var i = 0, n = transformConstraints.length; i <
                    n; i++) {
                    var constraint = transformConstraints[i];
                    if (constraint.name == constraintName) return constraint
                }
                return null
            };
            SkeletonData.prototype.findPathConstraint = function(constraintName) {
                if (constraintName == null) throw new Error("constraintName cannot be null.");
                var pathConstraints = this.pathConstraints;
                for (var i = 0, n = pathConstraints.length; i < n; i++) {
                    var constraint = pathConstraints[i];
                    if (constraint.name == constraintName) return constraint
                }
                return null
            };
            SkeletonData.prototype.findPathConstraintIndex = function(pathConstraintName) {
                if (pathConstraintName ==
                    null) throw new Error("pathConstraintName cannot be null.");
                var pathConstraints = this.pathConstraints;
                for (var i = 0, n = pathConstraints.length; i < n; i++)
                    if (pathConstraints[i].name == pathConstraintName) return i;
                return -1
            };
            return SkeletonData
        }();
        core.SkeletonData = SkeletonData
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var SkeletonJson = function() {
            function SkeletonJson(attachmentLoader) {
                this.scale = 1;
                this.linkedMeshes = new Array;
                this.attachmentLoader = attachmentLoader
            }
            SkeletonJson.prototype.readSkeletonData = function(json) {
                var scale = this.scale;
                var skeletonData = new core.SkeletonData;
                var root = typeof json === "string" ? JSON.parse(json) : json;
                var skeletonMap = root.skeleton;
                if (skeletonMap != null) {
                    skeletonData.hash = skeletonMap.hash;
                    skeletonData.version = skeletonMap.spine;
                    skeletonData.width =
                        skeletonMap.width;
                    skeletonData.height = skeletonMap.height;
                    skeletonData.fps = skeletonMap.fps;
                    skeletonData.imagesPath = skeletonMap.images
                }
                if (root.bones)
                    for (var i = 0; i < root.bones.length; i++) {
                        var boneMap = root.bones[i];
                        var parent_2 = null;
                        var parentName = this.getValue(boneMap, "parent", null);
                        if (parentName != null) {
                            parent_2 = skeletonData.findBone(parentName);
                            if (parent_2 == null) throw new Error("Parent bone not found: " + parentName);
                        }
                        var data = new core.BoneData(skeletonData.bones.length, boneMap.name, parent_2);
                        data.length =
                            this.getValue(boneMap, "length", 0) * scale;
                        data.x = this.getValue(boneMap, "x", 0) * scale;
                        data.y = this.getValue(boneMap, "y", 0) * scale;
                        data.rotation = this.getValue(boneMap, "rotation", 0);
                        data.scaleX = this.getValue(boneMap, "scaleX", 1);
                        data.scaleY = this.getValue(boneMap, "scaleY", 1);
                        data.shearX = this.getValue(boneMap, "shearX", 0);
                        data.shearY = this.getValue(boneMap, "shearY", 0);
                        data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
                        skeletonData.bones.push(data)
                    }
                if (root.slots)
                    for (var i =
                            0; i < root.slots.length; i++) {
                        var slotMap = root.slots[i];
                        var slotName = slotMap.name;
                        var boneName = slotMap.bone;
                        var boneData = skeletonData.findBone(boneName);
                        if (boneData == null) throw new Error("Slot bone not found: " + boneName);
                        var data = new core.SlotData(skeletonData.slots.length, slotName, boneData);
                        var color = this.getValue(slotMap, "color", null);
                        if (color != null) data.color.setFromString(color);
                        var dark = this.getValue(slotMap, "dark", null);
                        if (dark != null) {
                            data.darkColor = new core.Color(1, 1, 1, 1);
                            data.darkColor.setFromString(dark)
                        }
                        data.attachmentName =
                            this.getValue(slotMap, "attachment", null);
                        data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
                        skeletonData.slots.push(data)
                    }
                if (root.ik)
                    for (var i = 0; i < root.ik.length; i++) {
                        var constraintMap = root.ik[i];
                        var data = new core.IkConstraintData(constraintMap.name);
                        data.order = this.getValue(constraintMap, "order", 0);
                        for (var j = 0; j < constraintMap.bones.length; j++) {
                            var boneName = constraintMap.bones[j];
                            var bone = skeletonData.findBone(boneName);
                            if (bone == null) throw new Error("IK bone not found: " +
                                boneName);
                            data.bones.push(bone)
                        }
                        var targetName = constraintMap.target;
                        data.target = skeletonData.findBone(targetName);
                        if (data.target == null) throw new Error("IK target bone not found: " + targetName);
                        data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
                        data.mix = this.getValue(constraintMap, "mix", 1);
                        skeletonData.ikConstraints.push(data)
                    }
                if (root.transform)
                    for (var i = 0; i < root.transform.length; i++) {
                        var constraintMap = root.transform[i];
                        var data = new core.TransformConstraintData(constraintMap.name);
                        data.order = this.getValue(constraintMap, "order", 0);
                        for (var j = 0; j < constraintMap.bones.length; j++) {
                            var boneName = constraintMap.bones[j];
                            var bone = skeletonData.findBone(boneName);
                            if (bone == null) throw new Error("Transform constraint bone not found: " + boneName);
                            data.bones.push(bone)
                        }
                        var targetName = constraintMap.target;
                        data.target = skeletonData.findBone(targetName);
                        if (data.target == null) throw new Error("Transform constraint target bone not found: " + targetName);
                        data.local = this.getValue(constraintMap, "local", false);
                        data.relative = this.getValue(constraintMap, "relative", false);
                        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
                        data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
                        data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
                        data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
                        data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
                        data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
                        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
                        data.translateMix = this.getValue(constraintMap,
                            "translateMix", 1);
                        data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
                        data.shearMix = this.getValue(constraintMap, "shearMix", 1);
                        skeletonData.transformConstraints.push(data)
                    }
                if (root.path)
                    for (var i = 0; i < root.path.length; i++) {
                        var constraintMap = root.path[i];
                        var data = new core.PathConstraintData(constraintMap.name);
                        data.order = this.getValue(constraintMap, "order", 0);
                        for (var j = 0; j < constraintMap.bones.length; j++) {
                            var boneName = constraintMap.bones[j];
                            var bone = skeletonData.findBone(boneName);
                            if (bone == null) throw new Error("Transform constraint bone not found: " +
                                boneName);
                            data.bones.push(bone)
                        }
                        var targetName = constraintMap.target;
                        data.target = skeletonData.findSlot(targetName);
                        if (data.target == null) throw new Error("Path target slot not found: " + targetName);
                        data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
                        data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
                        data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
                        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
                        data.position = this.getValue(constraintMap, "position", 0);
                        if (data.positionMode == core.PositionMode.Fixed) data.position *= scale;
                        data.spacing = this.getValue(constraintMap, "spacing", 0);
                        if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed) data.spacing *= scale;
                        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
                        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
                        skeletonData.pathConstraints.push(data)
                    }
                if (root.skins)
                    for (var skinName in root.skins) {
                        var skinMap =
                            root.skins[skinName];
                        var skin = new core.Skin(skinName);
                        for (var slotName in skinMap) {
                            var slotIndex = skeletonData.findSlotIndex(slotName);
                            if (slotIndex == -1) throw new Error("Slot not found: " + slotName);
                            var slotMap = skinMap[slotName];
                            for (var entryName in slotMap) {
                                var attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);
                                if (attachment != null) skin.addAttachment(slotIndex, entryName, attachment)
                            }
                        }
                        skeletonData.skins.push(skin);
                        if (skin.name == "default") skeletonData.defaultSkin = skin
                    }
                for (var i =
                        0, n = this.linkedMeshes.length; i < n; i++) {
                    var linkedMesh = this.linkedMeshes[i];
                    var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
                    if (skin == null) throw new Error("Skin not found: " + linkedMesh.skin);
                    var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
                    if (parent_3 == null) throw new Error("Parent mesh not found: " + linkedMesh.parent);
                    linkedMesh.mesh.setParentMesh(parent_3)
                }
                this.linkedMeshes.length = 0;
                if (root.events)
                    for (var eventName in root.events) {
                        var eventMap =
                            root.events[eventName];
                        var data = new core.EventData(eventName);
                        data.intValue = this.getValue(eventMap, "int", 0);
                        data.floatValue = this.getValue(eventMap, "float", 0);
                        data.stringValue = this.getValue(eventMap, "string", "");
                        data.audio = this.getValue(eventMap, "audio", null);
                        skeletonData.events.push(data)
                    }
                if (root.animations)
                    for (var animationName in root.animations) {
                        var animationMap = root.animations[animationName];
                        this.readAnimation(animationMap, animationName, skeletonData)
                    }
                return skeletonData
            };
            SkeletonJson.prototype.readAttachment =
                function(map, skin, slotIndex, name, skeletonData) {
                    var scale = this.scale;
                    name = this.getValue(map, "name", name);
                    var type = this.getValue(map, "type", "region");
                    switch (type) {
                        case "region":
                            var path = this.getValue(map, "path", name);
                            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
                            if (region == null) return null;
                            region.path = path;
                            region.x = this.getValue(map, "x", 0) * scale;
                            region.y = this.getValue(map, "y", 0) * scale;
                            region.scaleX = this.getValue(map, "scaleX", 1);
                            region.scaleY = this.getValue(map, "scaleY", 1);
                            region.rotation =
                                this.getValue(map, "rotation", 0);
                            region.width = map.width * scale;
                            region.height = map.height * scale;
                            var color = this.getValue(map, "color", null);
                            if (color != null) region.color.setFromString(color);
                            return region;
                        case "boundingbox":
                            var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
                            if (box == null) return null;
                            this.readVertices(map, box, map.vertexCount << 1);
                            var color = this.getValue(map, "color", null);
                            if (color != null) box.color.setFromString(color);
                            return box;
                        case "mesh":
                        case "linkedmesh":
                            var path = this.getValue(map,
                                "path", name);
                            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
                            if (mesh == null) return null;
                            mesh.path = path;
                            var color = this.getValue(map, "color", null);
                            if (color != null) mesh.color.setFromString(color);
                            var parent_4 = this.getValue(map, "parent", null);
                            if (parent_4 != null) {
                                mesh.inheritDeform = this.getValue(map, "deform", true);
                                this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, "skin", null), slotIndex, parent_4));
                                return mesh
                            }
                            var uvs = map.uvs;
                            this.readVertices(map, mesh, uvs.length);
                            mesh.triangles =
                                map.triangles;
                            mesh.regionUVs = uvs;
                            mesh.hullLength = this.getValue(map, "hull", 0) * 2;
                            return mesh;
                        case "path":
                            var path = this.attachmentLoader.newPathAttachment(skin, name);
                            if (path == null) return null;
                            path.closed = this.getValue(map, "closed", false);
                            path.constantSpeed = this.getValue(map, "constantSpeed", true);
                            var vertexCount = map.vertexCount;
                            this.readVertices(map, path, vertexCount << 1);
                            var lengths = core.Utils.newArray(vertexCount / 3, 0);
                            for (var i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;
                            path.lengths = lengths;
                            var color = this.getValue(map, "color", null);
                            if (color != null) path.color.setFromString(color);
                            return path;
                        case "point":
                            var point = this.attachmentLoader.newPointAttachment(skin, name);
                            if (point == null) return null;
                            point.x = this.getValue(map, "x", 0) * scale;
                            point.y = this.getValue(map, "y", 0) * scale;
                            point.rotation = this.getValue(map, "rotation", 0);
                            var color = this.getValue(map, "color", null);
                            if (color != null) point.color.setFromString(color);
                            return point;
                        case "clipping":
                            var clip = this.attachmentLoader.newClippingAttachment(skin,
                                name);
                            if (clip == null) return null;
                            var end = this.getValue(map, "end", null);
                            if (end != null) {
                                var slot = skeletonData.findSlot(end);
                                if (slot == null) throw new Error("Clipping end slot not found: " + end);
                                clip.endSlot = slot
                            }
                            var vertexCount = map.vertexCount;
                            this.readVertices(map, clip, vertexCount << 1);
                            var color = this.getValue(map, "color", null);
                            if (color != null) clip.color.setFromString(color);
                            return clip
                    }
                    return null
                };
            SkeletonJson.prototype.readVertices = function(map, attachment, verticesLength) {
                var scale = this.scale;
                attachment.worldVerticesLength =
                    verticesLength;
                var vertices = map.vertices;
                if (verticesLength == vertices.length) {
                    var scaledVertices = core.Utils.toFloatArray(vertices);
                    if (scale != 1)
                        for (var i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;
                    attachment.vertices = scaledVertices;
                    return
                }
                var weights = new Array;
                var bones = new Array;
                for (var i = 0, n = vertices.length; i < n;) {
                    var boneCount = vertices[i++];
                    bones.push(boneCount);
                    for (var nn = i + boneCount * 4; i < nn; i += 4) {
                        bones.push(vertices[i]);
                        weights.push(vertices[i + 1] * scale);
                        weights.push(vertices[i + 2] * scale);
                        weights.push(vertices[i + 3])
                    }
                }
                attachment.bones = bones;
                attachment.vertices = core.Utils.toFloatArray(weights)
            };
            SkeletonJson.prototype.readAnimation = function(map, name, skeletonData) {
                var scale = this.scale;
                var timelines = new Array;
                var duration = 0;
                if (map.slots)
                    for (var slotName in map.slots) {
                        var slotMap = map.slots[slotName];
                        var slotIndex = skeletonData.findSlotIndex(slotName);
                        if (slotIndex == -1) throw new Error("Slot not found: " + slotName);
                        for (var timelineName in slotMap) {
                            var timelineMap = slotMap[timelineName];
                            if (timelineName ==
                                "attachment") {
                                var timeline = new core.AttachmentTimeline(timelineMap.length);
                                timeline.slotIndex = slotIndex;
                                var frameIndex = 0;
                                for (var i = 0; i < timelineMap.length; i++) {
                                    var valueMap = timelineMap[i];
                                    timeline.setFrame(frameIndex++, valueMap.time, valueMap.name)
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1])
                            } else if (timelineName == "color") {
                                var timeline = new core.ColorTimeline(timelineMap.length);
                                timeline.slotIndex = slotIndex;
                                var frameIndex = 0;
                                for (var i = 0; i < timelineMap.length; i++) {
                                    var valueMap =
                                        timelineMap[i];
                                    var color = new core.Color;
                                    color.setFromString(valueMap.color || "ffffffff");
                                    timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);
                                    this.readCurve(valueMap, timeline, frameIndex);
                                    frameIndex++
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.ColorTimeline.ENTRIES])
                            } else if (timelineName == "twoColor") {
                                var timeline = new core.TwoColorTimeline(timelineMap.length);
                                timeline.slotIndex = slotIndex;
                                var frameIndex = 0;
                                for (var i = 0; i <
                                    timelineMap.length; i++) {
                                    var valueMap = timelineMap[i];
                                    var light = new core.Color;
                                    var dark = new core.Color;
                                    light.setFromString(valueMap.light);
                                    dark.setFromString(valueMap.dark);
                                    timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
                                    this.readCurve(valueMap, timeline, frameIndex);
                                    frameIndex++
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TwoColorTimeline.ENTRIES])
                            } else throw new Error("Invalid timeline type for a slot: " +
                                timelineName + " (" + slotName + ")");
                        }
                    }
                if (map.bones)
                    for (var boneName in map.bones) {
                        var boneMap = map.bones[boneName];
                        var boneIndex = skeletonData.findBoneIndex(boneName);
                        if (boneIndex == -1) throw new Error("Bone not found: " + boneName);
                        for (var timelineName in boneMap) {
                            var timelineMap = boneMap[timelineName];
                            if (timelineName === "rotate") {
                                var timeline = new core.RotateTimeline(timelineMap.length);
                                timeline.boneIndex = boneIndex;
                                var frameIndex = 0;
                                for (var i = 0; i < timelineMap.length; i++) {
                                    var valueMap = timelineMap[i];
                                    timeline.setFrame(frameIndex,
                                        valueMap.time, valueMap.angle);
                                    this.readCurve(valueMap, timeline, frameIndex);
                                    frameIndex++
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.RotateTimeline.ENTRIES])
                            } else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
                                var timeline = null;
                                var timelineScale = 1;
                                if (timelineName === "scale") timeline = new core.ScaleTimeline(timelineMap.length);
                                else if (timelineName === "shear") timeline = new core.ShearTimeline(timelineMap.length);
                                else {
                                    timeline =
                                        new core.TranslateTimeline(timelineMap.length);
                                    timelineScale = scale
                                }
                                timeline.boneIndex = boneIndex;
                                var frameIndex = 0;
                                for (var i = 0; i < timelineMap.length; i++) {
                                    var valueMap = timelineMap[i];
                                    var x = this.getValue(valueMap, "x", 0),
                                        y = this.getValue(valueMap, "y", 0);
                                    timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);
                                    this.readCurve(valueMap, timeline, frameIndex);
                                    frameIndex++
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TranslateTimeline.ENTRIES])
                            } else throw new Error("Invalid timeline type for a bone: " +
                                timelineName + " (" + boneName + ")");
                        }
                    }
                if (map.ik)
                    for (var constraintName in map.ik) {
                        var constraintMap = map.ik[constraintName];
                        var constraint = skeletonData.findIkConstraint(constraintName);
                        var timeline = new core.IkConstraintTimeline(constraintMap.length);
                        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
                        var frameIndex = 0;
                        for (var i = 0; i < constraintMap.length; i++) {
                            var valueMap = constraintMap[i];
                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "mix", 1), this.getValue(valueMap,
                                "bendPositive", true) ? 1 : -1);
                            this.readCurve(valueMap, timeline, frameIndex);
                            frameIndex++
                        }
                        timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.IkConstraintTimeline.ENTRIES])
                    }
                if (map.transform)
                    for (var constraintName in map.transform) {
                        var constraintMap = map.transform[constraintName];
                        var constraint = skeletonData.findTransformConstraint(constraintName);
                        var timeline = new core.TransformConstraintTimeline(constraintMap.length);
                        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
                        var frameIndex = 0;
                        for (var i = 0; i < constraintMap.length; i++) {
                            var valueMap = constraintMap[i];
                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1), this.getValue(valueMap, "scaleMix", 1), this.getValue(valueMap, "shearMix", 1));
                            this.readCurve(valueMap, timeline, frameIndex);
                            frameIndex++
                        }
                        timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TransformConstraintTimeline.ENTRIES])
                    }
                if (map.paths)
                    for (var constraintName in map.paths) {
                        var constraintMap =
                            map.paths[constraintName];
                        var index = skeletonData.findPathConstraintIndex(constraintName);
                        if (index == -1) throw new Error("Path constraint not found: " + constraintName);
                        var data = skeletonData.pathConstraints[index];
                        for (var timelineName in constraintMap) {
                            var timelineMap = constraintMap[timelineName];
                            if (timelineName === "position" || timelineName === "spacing") {
                                var timeline = null;
                                var timelineScale = 1;
                                if (timelineName === "spacing") {
                                    timeline = new core.PathConstraintSpacingTimeline(timelineMap.length);
                                    if (data.spacingMode ==
                                        core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed) timelineScale = scale
                                } else {
                                    timeline = new core.PathConstraintPositionTimeline(timelineMap.length);
                                    if (data.positionMode == core.PositionMode.Fixed) timelineScale = scale
                                }
                                timeline.pathConstraintIndex = index;
                                var frameIndex = 0;
                                for (var i = 0; i < timelineMap.length; i++) {
                                    var valueMap = timelineMap[i];
                                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);
                                    this.readCurve(valueMap, timeline, frameIndex);
                                    frameIndex++
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.PathConstraintPositionTimeline.ENTRIES])
                            } else if (timelineName === "mix") {
                                var timeline = new core.PathConstraintMixTimeline(timelineMap.length);
                                timeline.pathConstraintIndex = index;
                                var frameIndex = 0;
                                for (var i = 0; i < timelineMap.length; i++) {
                                    var valueMap = timelineMap[i];
                                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
                                    this.readCurve(valueMap, timeline, frameIndex);
                                    frameIndex++
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.PathConstraintMixTimeline.ENTRIES])
                            }
                        }
                    }
                if (map.deform)
                    for (var deformName in map.deform) {
                        var deformMap = map.deform[deformName];
                        var skin = skeletonData.findSkin(deformName);
                        if (skin == null) throw new Error("Skin not found: " + deformName);
                        for (var slotName in deformMap) {
                            var slotMap = deformMap[slotName];
                            var slotIndex = skeletonData.findSlotIndex(slotName);
                            if (slotIndex == -1) throw new Error("Slot not found: " +
                                slotMap.name);
                            for (var timelineName in slotMap) {
                                var timelineMap = slotMap[timelineName];
                                var attachment = skin.getAttachment(slotIndex, timelineName);
                                if (attachment == null) throw new Error("Deform attachment not found: " + timelineMap.name);
                                var weighted = attachment.bones != null;
                                var vertices = attachment.vertices;
                                var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                                var timeline = new core.DeformTimeline(timelineMap.length);
                                timeline.slotIndex = slotIndex;
                                timeline.attachment = attachment;
                                var frameIndex = 0;
                                for (var j =
                                        0; j < timelineMap.length; j++) {
                                    var valueMap = timelineMap[j];
                                    var deform = void 0;
                                    var verticesValue = this.getValue(valueMap, "vertices", null);
                                    if (verticesValue == null) deform = weighted ? core.Utils.newFloatArray(deformLength) : vertices;
                                    else {
                                        deform = core.Utils.newFloatArray(deformLength);
                                        var start = this.getValue(valueMap, "offset", 0);
                                        core.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                                        if (scale != 1)
                                            for (var i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;
                                        if (!weighted)
                                            for (var i = 0; i < deformLength; i++) deform[i] +=
                                                vertices[i]
                                    }
                                    timeline.setFrame(frameIndex, valueMap.time, deform);
                                    this.readCurve(valueMap, timeline, frameIndex);
                                    frameIndex++
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1])
                            }
                        }
                    }
                var drawOrderNode = map.drawOrder;
                if (drawOrderNode == null) drawOrderNode = map.draworder;
                if (drawOrderNode != null) {
                    var timeline = new core.DrawOrderTimeline(drawOrderNode.length);
                    var slotCount = skeletonData.slots.length;
                    var frameIndex = 0;
                    for (var j = 0; j < drawOrderNode.length; j++) {
                        var drawOrderMap =
                            drawOrderNode[j];
                        var drawOrder = null;
                        var offsets = this.getValue(drawOrderMap, "offsets", null);
                        if (offsets != null) {
                            drawOrder = core.Utils.newArray(slotCount, -1);
                            var unchanged = core.Utils.newArray(slotCount - offsets.length, 0);
                            var originalIndex = 0,
                                unchangedIndex = 0;
                            for (var i = 0; i < offsets.length; i++) {
                                var offsetMap = offsets[i];
                                var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
                                if (slotIndex == -1) throw new Error("Slot not found: " + offsetMap.slot);
                                while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;
                                drawOrder[originalIndex + offsetMap.offset] = originalIndex++
                            }
                            while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;
                            for (var i = slotCount - 1; i >= 0; i--)
                                if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex]
                        }
                        timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder)
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1])
                }
                if (map.events) {
                    var timeline = new core.EventTimeline(map.events.length);
                    var frameIndex = 0;
                    for (var i = 0; i < map.events.length; i++) {
                        var eventMap =
                            map.events[i];
                        var eventData = skeletonData.findEvent(eventMap.name);
                        if (eventData == null) throw new Error("Event not found: " + eventMap.name);
                        var event_5 = new core.Event(core.Utils.toSinglePrecision(eventMap.time), eventData);
                        event_5.intValue = this.getValue(eventMap, "int", eventData.intValue);
                        event_5.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
                        event_5.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
                        timeline.setFrame(frameIndex++, event_5)
                    }
                    timelines.push(timeline);
                    duration =
                        Math.max(duration, timeline.frames[timeline.getFrameCount() - 1])
                }
                if (isNaN(duration)) throw new Error("Error while parsing animation, duration is NaN");
                skeletonData.animations.push(new core.Animation(name, timelines, duration))
            };
            SkeletonJson.prototype.readCurve = function(map, timeline, frameIndex) {
                if (!map.curve) return;
                if (map.curve === "stepped") timeline.setStepped(frameIndex);
                else if (Object.prototype.toString.call(map.curve) === "[object Array]") {
                    var curve = map.curve;
                    timeline.setCurve(frameIndex, curve[0], curve[1],
                        curve[2], curve[3])
                }
            };
            SkeletonJson.prototype.getValue = function(map, prop, defaultValue) {
                return map[prop] !== undefined ? map[prop] : defaultValue
            };
            SkeletonJson.blendModeFromString = function(str) {
                str = str.toLowerCase();
                if (str == "normal") return core.BlendMode.Normal;
                if (str == "additive") return core.BlendMode.Additive;
                if (str == "multiply") return core.BlendMode.Multiply;
                if (str == "screen") return core.BlendMode.Screen;
                throw new Error("Unknown blend mode: " + str);
            };
            SkeletonJson.positionModeFromString = function(str) {
                str = str.toLowerCase();
                if (str == "fixed") return core.PositionMode.Fixed;
                if (str == "percent") return core.PositionMode.Percent;
                throw new Error("Unknown position mode: " + str);
            };
            SkeletonJson.spacingModeFromString = function(str) {
                str = str.toLowerCase();
                if (str == "length") return core.SpacingMode.Length;
                if (str == "fixed") return core.SpacingMode.Fixed;
                if (str == "percent") return core.SpacingMode.Percent;
                throw new Error("Unknown position mode: " + str);
            };
            SkeletonJson.rotateModeFromString = function(str) {
                str = str.toLowerCase();
                if (str == "tangent") return core.RotateMode.Tangent;
                if (str == "chain") return core.RotateMode.Chain;
                if (str == "chainscale") return core.RotateMode.ChainScale;
                throw new Error("Unknown rotate mode: " + str);
            };
            SkeletonJson.transformModeFromString = function(str) {
                str = str.toLowerCase();
                if (str == "normal") return core.TransformMode.Normal;
                if (str == "onlytranslation") return core.TransformMode.OnlyTranslation;
                if (str == "norotationorreflection") return core.TransformMode.NoRotationOrReflection;
                if (str == "noscale") return core.TransformMode.NoScale;
                if (str == "noscaleorreflection") return core.TransformMode.NoScaleOrReflection;
                throw new Error("Unknown transform mode: " + str);
            };
            return SkeletonJson
        }();
        core.SkeletonJson = SkeletonJson;
        var LinkedMesh = function() {
            function LinkedMesh(mesh, skin, slotIndex, parent) {
                this.mesh = mesh;
                this.skin = skin;
                this.slotIndex = slotIndex;
                this.parent = parent
            }
            return LinkedMesh
        }()
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var Skin = function() {
            function Skin(name) {
                this.attachments = new Array;
                if (name == null) throw new Error("name cannot be null.");
                this.name = name
            }
            Skin.prototype.addAttachment = function(slotIndex, name, attachment) {
                if (attachment == null) throw new Error("attachment cannot be null.");
                var attachments = this.attachments;
                if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;
                if (!attachments[slotIndex]) attachments[slotIndex] = {};
                attachments[slotIndex][name] = attachment
            };
            Skin.prototype.getAttachment = function(slotIndex, name) {
                var dictionary = this.attachments[slotIndex];
                return dictionary ? dictionary[name] : null
            };
            Skin.prototype.attachAll = function(skeleton, oldSkin) {
                var slotIndex = 0;
                for (var i = 0; i < skeleton.slots.length; i++) {
                    var slot = skeleton.slots[i];
                    var slotAttachment = slot.getAttachment();
                    if (slotAttachment && slotIndex < oldSkin.attachments.length) {
                        var dictionary = oldSkin.attachments[slotIndex];
                        for (var key in dictionary) {
                            var skinAttachment = dictionary[key];
                            if (slotAttachment == skinAttachment) {
                                var attachment =
                                    this.getAttachment(slotIndex, key);
                                if (attachment != null) slot.setAttachment(attachment);
                                break
                            }
                        }
                    }
                    slotIndex++
                }
            };
            return Skin
        }();
        core.Skin = Skin
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var Slot = function() {
            function Slot(data, bone) {
                this.attachmentVertices = new Array;
                if (data == null) throw new Error("data cannot be null.");
                if (bone == null) throw new Error("bone cannot be null.");
                this.data = data;
                this.bone = bone;
                this.color = new core.Color;
                this.darkColor = data.darkColor == null ? null : new core.Color;
                this.setToSetupPose();
                this.blendMode = this.data.blendMode
            }
            Slot.prototype.getAttachment = function() {
                return this.attachment
            };
            Slot.prototype.setAttachment = function(attachment) {
                if (this.attachment ==
                    attachment) return;
                this.attachment = attachment;
                this.attachmentTime = this.bone.skeleton.time;
                this.attachmentVertices.length = 0
            };
            Slot.prototype.setAttachmentTime = function(time) {
                this.attachmentTime = this.bone.skeleton.time - time
            };
            Slot.prototype.getAttachmentTime = function() {
                return this.bone.skeleton.time - this.attachmentTime
            };
            Slot.prototype.setToSetupPose = function() {
                this.color.setFromColor(this.data.color);
                if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);
                if (this.data.attachmentName ==
                    null) this.attachment = null;
                else {
                    this.attachment = null;
                    this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName))
                }
            };
            return Slot
        }();
        core.Slot = Slot
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var SlotData = function() {
            function SlotData(index, name, boneData) {
                this.color = new core.Color(1, 1, 1, 1);
                if (index < 0) throw new Error("index must be >= 0.");
                if (name == null) throw new Error("name cannot be null.");
                if (boneData == null) throw new Error("boneData cannot be null.");
                this.index = index;
                this.name = name;
                this.boneData = boneData
            }
            return SlotData
        }();
        core.SlotData = SlotData
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var Texture = function() {
            function Texture(image) {
                this._image = image
            }
            Texture.prototype.getImage = function() {
                return this._image
            };
            Texture.filterFromString = function(text) {
                switch (text.toLowerCase()) {
                    case "nearest":
                        return TextureFilter.Nearest;
                    case "linear":
                        return TextureFilter.Linear;
                    case "mipmap":
                        return TextureFilter.MipMap;
                    case "mipmapnearestnearest":
                        return TextureFilter.MipMapNearestNearest;
                    case "mipmaplinearnearest":
                        return TextureFilter.MipMapLinearNearest;
                    case "mipmapnearestlinear":
                        return TextureFilter.MipMapNearestLinear;
                    case "mipmaplinearlinear":
                        return TextureFilter.MipMapLinearLinear;
                    default:
                        throw new Error("Unknown texture filter " + text);
                }
            };
            Texture.wrapFromString = function(text) {
                switch (text.toLowerCase()) {
                    case "mirroredtepeat":
                        return TextureWrap.MirroredRepeat;
                    case "clamptoedge":
                        return TextureWrap.ClampToEdge;
                    case "repeat":
                        return TextureWrap.Repeat;
                    default:
                        throw new Error("Unknown texture wrap " + text);
                }
            };
            return Texture
        }();
        core.Texture = Texture;
        var TextureFilter;
        (function(TextureFilter) {
            TextureFilter[TextureFilter["Nearest"] = 9728] = "Nearest";
            TextureFilter[TextureFilter["Linear"] = 9729] = "Linear";
            TextureFilter[TextureFilter["MipMap"] = 9987] = "MipMap";
            TextureFilter[TextureFilter["MipMapNearestNearest"] = 9984] = "MipMapNearestNearest";
            TextureFilter[TextureFilter["MipMapLinearNearest"] = 9985] = "MipMapLinearNearest";
            TextureFilter[TextureFilter["MipMapNearestLinear"] = 9986] = "MipMapNearestLinear";
            TextureFilter[TextureFilter["MipMapLinearLinear"] = 9987] = "MipMapLinearLinear"
        })(TextureFilter =
            core.TextureFilter || (core.TextureFilter = {}));
        var TextureWrap;
        (function(TextureWrap) {
            TextureWrap[TextureWrap["MirroredRepeat"] = 33648] = "MirroredRepeat";
            TextureWrap[TextureWrap["ClampToEdge"] = 33071] = "ClampToEdge";
            TextureWrap[TextureWrap["Repeat"] = 10497] = "Repeat"
        })(TextureWrap = core.TextureWrap || (core.TextureWrap = {}));
        var TextureRegion = function() {
            function TextureRegion() {
                this.size = null
            }
            Object.defineProperty(TextureRegion.prototype, "width", {
                get: function() {
                    var tex = this.texture;
                    if (PIXI.VERSION[0] == "3") return tex.crop.width;
                    if (tex.trim) return tex.trim.width;
                    return tex.orig.width
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "height", {
                get: function() {
                    var tex = this.texture;
                    if (PIXI.VERSION[0] == "3") return tex.crop.height;
                    if (tex.trim) return tex.trim.height;
                    return tex.orig.height
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "u", {
                get: function() {
                    return this.texture._uvs.x0
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype,
                "v", {
                    get: function() {
                        return this.texture._uvs.y0
                    },
                    enumerable: true,
                    configurable: true
                });
            Object.defineProperty(TextureRegion.prototype, "u2", {
                get: function() {
                    return this.texture._uvs.x2
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "v2", {
                get: function() {
                    return this.texture._uvs.y2
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "offsetX", {
                get: function() {
                    var tex = this.texture;
                    return tex.trim ? tex.trim.x : 0
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "offsetY", {
                get: function() {
                    console.warn("Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.");
                    return this.spineOffsetY
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "pixiOffsetY", {
                get: function() {
                    var tex = this.texture;
                    return tex.trim ? tex.trim.y : 0
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype,
                "spineOffsetY", {
                    get: function() {
                        var tex = this.texture;
                        return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0)
                    },
                    enumerable: true,
                    configurable: true
                });
            Object.defineProperty(TextureRegion.prototype, "originalWidth", {
                get: function() {
                    var tex = this.texture;
                    if (PIXI.VERSION[0] == "3") {
                        if (tex.trim) return tex.trim.width;
                        return tex.crop.width
                    }
                    return tex.orig.width
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "originalHeight", {
                get: function() {
                    var tex = this.texture;
                    if (PIXI.VERSION[0] ==
                        "3") {
                        if (tex.trim) return tex.trim.height;
                        return tex.crop.height
                    }
                    return tex.orig.height
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "x", {
                get: function() {
                    return this.texture.frame.x
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "y", {
                get: function() {
                    return this.texture.frame.y
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "rotate", {
                get: function() {
                    return this.texture.rotate !== 0
                },
                enumerable: true,
                configurable: true
            });
            return TextureRegion
        }();
        core.TextureRegion = TextureRegion
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var TextureAtlas = function() {
            function TextureAtlas(atlasText, textureLoader, callback) {
                this.pages = new Array;
                this.regions = new Array;
                if (atlasText) this.addSpineAtlas(atlasText, textureLoader, callback)
            }
            TextureAtlas.prototype.addTexture = function(name, texture) {
                var pages = this.pages;
                var page = null;
                for (var i = 0; i < pages.length; i++)
                    if (pages[i].baseTexture === texture.baseTexture) {
                        page = pages[i];
                        break
                    }
                if (page === null) {
                    page = new TextureAtlasPage;
                    page.name = "texturePage";
                    var baseTexture =
                        texture.baseTexture;
                    page.width = baseTexture.realWidth;
                    page.height = baseTexture.realHeight;
                    page.baseTexture = baseTexture;
                    page.minFilter = page.magFilter = core.TextureFilter.Nearest;
                    page.uWrap = core.TextureWrap.ClampToEdge;
                    page.vWrap = core.TextureWrap.ClampToEdge;
                    pages.push(page)
                }
                var region = new TextureAtlasRegion;
                region.name = name;
                region.page = page;
                region.texture = texture;
                region.index = -1;
                this.regions.push(region);
                return region
            };
            TextureAtlas.prototype.addTextureHash = function(textures, stripExtension) {
                for (var key in textures)
                    if (textures.hasOwnProperty(key)) this.addTexture(stripExtension &&
                        key.indexOf(".") !== -1 ? key.substr(0, key.lastIndexOf(".")) : key, textures[key])
            };
            TextureAtlas.prototype.addSpineAtlas = function(atlasText, textureLoader, callback) {
                return this.load(atlasText, textureLoader, callback)
            };
            TextureAtlas.prototype.load = function(atlasText, textureLoader, callback) {
                var _this = this;
                if (textureLoader == null) throw new Error("textureLoader cannot be null.");
                var reader = new TextureAtlasReader(atlasText);
                var tuple = new Array(4);
                var page = null;
                var iterateParser = function() {
                    while (true) {
                        var line = reader.readLine();
                        if (line == null) return callback && callback(_this);
                        line = line.trim();
                        if (line.length == 0) page = null;
                        else if (!page) {
                            page = new TextureAtlasPage;
                            page.name = line;
                            if (reader.readTuple(tuple) == 2) {
                                page.width = parseInt(tuple[0]);
                                page.height = parseInt(tuple[1]);
                                reader.readTuple(tuple)
                            }
                            reader.readTuple(tuple);
                            page.minFilter = core.Texture.filterFromString(tuple[0]);
                            page.magFilter = core.Texture.filterFromString(tuple[1]);
                            var direction = reader.readValue();
                            page.uWrap = core.TextureWrap.ClampToEdge;
                            page.vWrap = core.TextureWrap.ClampToEdge;
                            if (direction == "x") page.uWrap = core.TextureWrap.Repeat;
                            else if (direction == "y") page.vWrap = core.TextureWrap.Repeat;
                            else if (direction == "xy") page.uWrap = page.vWrap = core.TextureWrap.Repeat;
                            textureLoader(line, function(texture) {
                                page.baseTexture = texture;
                                if (!texture.hasLoaded) {
                                    texture.width = page.width;
                                    texture.height = page.height
                                }
                                _this.pages.push(page);
                                page.setFilters();
                                if (!page.width || !page.height) {
                                    page.width = texture.realWidth;
                                    page.height = texture.realHeight;
                                    if (!page.width || !page.height) console.log("ERROR spine atlas page " +
                                        page.name + ": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)")
                                }
                                iterateParser()
                            });
                            _this.pages.push(page);
                            break
                        } else {
                            var region = new TextureAtlasRegion;
                            region.name = line;
                            region.page = page;
                            var rotate = reader.readValue() == "true" ? 6 : 0;
                            reader.readTuple(tuple);
                            var x = parseInt(tuple[0]);
                            var y = parseInt(tuple[1]);
                            reader.readTuple(tuple);
                            var width = parseInt(tuple[0]);
                            var height = parseInt(tuple[1]);
                            var resolution = page.baseTexture.resolution;
                            x /= resolution;
                            y /= resolution;
                            width /= resolution;
                            height /= resolution;
                            var frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);
                            if (reader.readTuple(tuple) == 4)
                                if (reader.readTuple(tuple) == 4) reader.readTuple(tuple);
                            var originalWidth = parseInt(tuple[0]) / resolution;
                            var originalHeight = parseInt(tuple[1]) / resolution;
                            reader.readTuple(tuple);
                            var offsetX = parseInt(tuple[0]) / resolution;
                            var offsetY = parseInt(tuple[1]) / resolution;
                            var orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);
                            var trim = new PIXI.Rectangle(offsetX,
                                originalHeight - height - offsetY, width, height);
                            if (PIXI.VERSION[0] != "3") region.texture = new PIXI.Texture(region.page.baseTexture, frame, orig, trim, rotate);
                            else {
                                var frame2 = new PIXI.Rectangle(x, y, width, height);
                                var crop = frame2.clone();
                                trim.width = originalWidth;
                                trim.height = originalHeight;
                                region.texture = new PIXI.Texture(region.page.baseTexture, frame2, crop, trim, rotate)
                            }
                            region.index = parseInt(reader.readValue());
                            region.texture._updateUvs();
                            _this.regions.push(region)
                        }
                    }
                };
                iterateParser()
            };
            TextureAtlas.prototype.findRegion =
                function(name) {
                    for (var i = 0; i < this.regions.length; i++)
                        if (this.regions[i].name == name) return this.regions[i];
                    return null
                };
            TextureAtlas.prototype.dispose = function() {
                for (var i = 0; i < this.pages.length; i++) this.pages[i].baseTexture.dispose()
            };
            return TextureAtlas
        }();
        core.TextureAtlas = TextureAtlas;
        var TextureAtlasReader = function() {
            function TextureAtlasReader(text) {
                this.index = 0;
                this.lines = text.split(/\r\n|\r|\n/)
            }
            TextureAtlasReader.prototype.readLine = function() {
                if (this.index >= this.lines.length) return null;
                return this.lines[this.index++]
            };
            TextureAtlasReader.prototype.readValue = function() {
                var line = this.readLine();
                var colon = line.indexOf(":");
                if (colon == -1) throw new Error("Invalid line: " + line);
                return line.substring(colon + 1).trim()
            };
            TextureAtlasReader.prototype.readTuple = function(tuple) {
                var line = this.readLine();
                var colon = line.indexOf(":");
                if (colon == -1) throw new Error("Invalid line: " + line);
                var i = 0,
                    lastMatch = colon + 1;
                for (; i < 3; i++) {
                    var comma = line.indexOf(",", lastMatch);
                    if (comma == -1) break;
                    tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();
                    lastMatch = comma + 1
                }
                tuple[i] = line.substring(lastMatch).trim();
                return i + 1
            };
            return TextureAtlasReader
        }();
        var TextureAtlasPage = function() {
            function TextureAtlasPage() {}
            TextureAtlasPage.prototype.setFilters = function() {
                var tex = this.baseTexture;
                tex.premultipliedAlpha = false;
                var filter = this.minFilter;
                if (filter == core.TextureFilter.Linear) tex.scaleMode = PIXI.SCALE_MODES.LINEAR;
                else if (this.minFilter == core.TextureFilter.Nearest) tex.scaleMode = PIXI.SCALE_MODES.NEAREST;
                else {
                    tex.mipmap = true;
                    if (filter == core.TextureFilter.MipMapNearestNearest) tex.scaleMode =
                        PIXI.SCALE_MODES.NEAREST;
                    else tex.scaleMode = PIXI.SCALE_MODES.LINEAR
                }
            };
            return TextureAtlasPage
        }();
        core.TextureAtlasPage = TextureAtlasPage;
        var TextureAtlasRegion = function(_super) {
            __extends(TextureAtlasRegion, _super);

            function TextureAtlasRegion() {
                return _super !== null && _super.apply(this, arguments) || this
            }
            return TextureAtlasRegion
        }(core.TextureRegion);
        core.TextureAtlasRegion = TextureAtlasRegion
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var TransformConstraint = function() {
            function TransformConstraint(data, skeleton) {
                this.rotateMix = 0;
                this.translateMix = 0;
                this.scaleMix = 0;
                this.shearMix = 0;
                this.temp = new core.Vector2;
                if (data == null) throw new Error("data cannot be null.");
                if (skeleton == null) throw new Error("skeleton cannot be null.");
                this.data = data;
                this.rotateMix = data.rotateMix;
                this.translateMix = data.translateMix;
                this.scaleMix = data.scaleMix;
                this.shearMix = data.shearMix;
                this.bones = new Array;
                for (var i =
                        0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));
                this.target = skeleton.findBone(data.target.name)
            }
            TransformConstraint.prototype.apply = function() {
                this.update()
            };
            TransformConstraint.prototype.update = function() {
                if (this.data.local)
                    if (this.data.relative) this.applyRelativeLocal();
                    else this.applyAbsoluteLocal();
                else if (this.data.relative) this.applyRelativeWorld();
                else this.applyAbsoluteWorld()
            };
            TransformConstraint.prototype.applyAbsoluteWorld = function() {
                var rotateMix = this.rotateMix,
                    translateMix = this.translateMix,
                    scaleMix = this.scaleMix,
                    shearMix = this.shearMix;
                var target = this.target;
                var targetMat = target.matrix;
                var ta = targetMat.a,
                    tb = targetMat.c,
                    tc = targetMat.b,
                    td = targetMat.d;
                var degRadReflect = ta * td - tb * tc > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;
                var offsetRotation = this.data.offsetRotation * degRadReflect;
                var offsetShearY = this.data.offsetShearY * degRadReflect;
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    var modified = false;
                    var mat = bone.matrix;
                    if (rotateMix !=
                        0) {
                        var a = mat.a,
                            b = mat.c,
                            c = mat.b,
                            d = mat.d;
                        var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;
                        else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;
                        r *= rotateMix;
                        var cos = Math.cos(r),
                            sin = Math.sin(r);
                        mat.a = cos * a - sin * c;
                        mat.c = cos * b - sin * d;
                        mat.b = sin * a + cos * c;
                        mat.d = sin * b + cos * d;
                        modified = true
                    }
                    if (translateMix != 0) {
                        var temp = this.temp;
                        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
                        mat.tx += (temp.x - mat.tx) * translateMix;
                        mat.ty += (temp.y - mat.ty) * translateMix;
                        modified = true
                    }
                    if (scaleMix > 0) {
                        var s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
                        var ts = Math.sqrt(ta * ta + tc * tc);
                        if (s > 1E-5) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;
                        mat.a *= s;
                        mat.b *= s;
                        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
                        ts = Math.sqrt(tb * tb + td * td);
                        if (s > 1E-5) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;
                        mat.c *= s;
                        mat.d *= s;
                        modified = true
                    }
                    if (shearMix > 0) {
                        var b = mat.c,
                            d = mat.d;
                        var by = Math.atan2(d, b);
                        var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;
                        else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;
                        r = by + (r + offsetShearY) * shearMix;
                        var s = Math.sqrt(b * b + d * d);
                        mat.c = Math.cos(r) * s;
                        mat.d = Math.sin(r) * s;
                        modified = true
                    }
                    if (modified) bone.appliedValid = false
                }
            };
            TransformConstraint.prototype.applyRelativeWorld = function() {
                var rotateMix = this.rotateMix,
                    translateMix = this.translateMix,
                    scaleMix = this.scaleMix,
                    shearMix = this.shearMix;
                var target = this.target;
                var targetMat = target.matrix;
                var ta = targetMat.a,
                    tb = targetMat.c,
                    tc = targetMat.b,
                    td = targetMat.d;
                var degRadReflect = ta *
                    td - tb * tc > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;
                var offsetRotation = this.data.offsetRotation * degRadReflect,
                    offsetShearY = this.data.offsetShearY * degRadReflect;
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    var modified = false;
                    var mat = bone.matrix;
                    if (rotateMix != 0) {
                        var a = mat.a,
                            b = mat.c,
                            c = mat.b,
                            d = mat.d;
                        var r = Math.atan2(tc, ta) + offsetRotation;
                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;
                        else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;
                        r *= rotateMix;
                        var cos = Math.cos(r),
                            sin =
                            Math.sin(r);
                        mat.a = cos * a - sin * c;
                        mat.c = cos * b - sin * d;
                        mat.b = sin * a + cos * c;
                        mat.d = sin * b + cos * d;
                        modified = true
                    }
                    if (translateMix != 0) {
                        var temp = this.temp;
                        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
                        mat.tx += temp.x * translateMix;
                        mat.ty += temp.y * translateMix;
                        modified = true
                    }
                    if (scaleMix > 0) {
                        var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
                        mat.a *= s;
                        mat.b *= s;
                        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
                        mat.c *= s;
                        mat.d *= s;
                        modified = true
                    }
                    if (shearMix > 0) {
                        var r = Math.atan2(td,
                            tb) - Math.atan2(tc, ta);
                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;
                        else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;
                        var b = mat.c,
                            d = mat.d;
                        r = Math.atan2(d, b) + (r - core.MathUtils.PI / 2 + offsetShearY) * shearMix;
                        var s = Math.sqrt(b * b + d * d);
                        mat.c = Math.cos(r) * s;
                        mat.d = Math.sin(r) * s;
                        modified = true
                    }
                    if (modified) bone.appliedValid = false
                }
            };
            TransformConstraint.prototype.applyAbsoluteLocal = function() {
                var rotateMix = this.rotateMix,
                    translateMix = this.translateMix,
                    scaleMix = this.scaleMix,
                    shearMix = this.shearMix;
                var target = this.target;
                if (!target.appliedValid) target.updateAppliedTransform();
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    if (!bone.appliedValid) bone.updateAppliedTransform();
                    var rotation = bone.arotation;
                    if (rotateMix != 0) {
                        var r = target.arotation - rotation + this.data.offsetRotation;
                        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
                        rotation += r * rotateMix
                    }
                    var x = bone.ax,
                        y = bone.ay;
                    if (translateMix != 0) {
                        x += (target.ax - x + this.data.offsetX) * translateMix;
                        y += (target.ay - y + this.data.offsetY) * translateMix
                    }
                    var scaleX =
                        bone.ascaleX,
                        scaleY = bone.ascaleY;
                    if (scaleMix > 0) {
                        if (scaleX > 1E-5) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
                        if (scaleY > 1E-5) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY
                    }
                    var shearY = bone.ashearY;
                    if (shearMix > 0) {
                        var r = target.ashearY - shearY + this.data.offsetShearY;
                        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
                        bone.shearY += r * shearMix
                    }
                    bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY)
                }
            };
            TransformConstraint.prototype.applyRelativeLocal =
                function() {
                    var rotateMix = this.rotateMix,
                        translateMix = this.translateMix,
                        scaleMix = this.scaleMix,
                        shearMix = this.shearMix;
                    var target = this.target;
                    if (!target.appliedValid) target.updateAppliedTransform();
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        var bone = bones[i];
                        if (!bone.appliedValid) bone.updateAppliedTransform();
                        var rotation = bone.arotation;
                        if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
                        var x = bone.ax,
                            y = bone.ay;
                        if (translateMix != 0) {
                            x += (target.ax + this.data.offsetX) *
                                translateMix;
                            y += (target.ay + this.data.offsetY) * translateMix
                        }
                        var scaleX = bone.ascaleX,
                            scaleY = bone.ascaleY;
                        if (scaleMix > 0) {
                            if (scaleX > 1E-5) scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;
                            if (scaleY > 1E-5) scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1
                        }
                        var shearY = bone.ashearY;
                        if (shearMix > 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
                        bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY)
                    }
                };
            TransformConstraint.prototype.getOrder = function() {
                return this.data.order
            };
            return TransformConstraint
        }();
        core.TransformConstraint = TransformConstraint
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var TransformConstraintData = function() {
            function TransformConstraintData(name) {
                this.order = 0;
                this.bones = new Array;
                this.rotateMix = 0;
                this.translateMix = 0;
                this.scaleMix = 0;
                this.shearMix = 0;
                this.offsetRotation = 0;
                this.offsetX = 0;
                this.offsetY = 0;
                this.offsetScaleX = 0;
                this.offsetScaleY = 0;
                this.offsetShearY = 0;
                this.relative = false;
                this.local = false;
                if (name == null) throw new Error("name cannot be null.");
                this.name = name
            }
            return TransformConstraintData
        }();
        core.TransformConstraintData =
            TransformConstraintData
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var Triangulator = function() {
            function Triangulator() {
                this.convexPolygons = new Array;
                this.convexPolygonsIndices = new Array;
                this.indicesArray = new Array;
                this.isConcaveArray = new Array;
                this.triangles = new Array;
                this.polygonPool = new core.Pool(function() {
                    return new Array
                });
                this.polygonIndicesPool = new core.Pool(function() {
                    return new Array
                })
            }
            Triangulator.prototype.triangulate = function(verticesArray) {
                var vertices = verticesArray;
                var vertexCount = verticesArray.length >>
                    1;
                var indices = this.indicesArray;
                indices.length = 0;
                for (var i = 0; i < vertexCount; i++) indices[i] = i;
                var isConcave = this.isConcaveArray;
                isConcave.length = 0;
                for (var i = 0, n = vertexCount; i < n; ++i) isConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);
                var triangles = this.triangles;
                triangles.length = 0;
                while (vertexCount > 3) {
                    var previous = vertexCount - 1,
                        i = 0,
                        next = 1;
                    while (true) {
                        outer: if (!isConcave[i]) {
                            var p1 = indices[previous] << 1,
                                p2 = indices[i] << 1,
                                p3 = indices[next] << 1;
                            var p1x = vertices[p1],
                                p1y = vertices[p1 + 1];
                            var p2x =
                                vertices[p2],
                                p2y = vertices[p2 + 1];
                            var p3x = vertices[p3],
                                p3y = vertices[p3 + 1];
                            for (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {
                                if (!isConcave[ii]) continue;
                                var v = indices[ii] << 1;
                                var vx = vertices[v],
                                    vy = vertices[v + 1];
                                if (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy))
                                    if (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy))
                                        if (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy)) break outer
                            }
                            break
                        }if (next == 0) {
                            do {
                                if (!isConcave[i]) break;
                                i--
                            } while (i > 0);
                            break
                        }
                        previous = i;i = next;next = (next + 1) % vertexCount
                    }
                    triangles.push(indices[(vertexCount +
                        i - 1) % vertexCount]);
                    triangles.push(indices[i]);
                    triangles.push(indices[(i + 1) % vertexCount]);
                    indices.splice(i, 1);
                    isConcave.splice(i, 1);
                    vertexCount--;
                    var previousIndex = (vertexCount + i - 1) % vertexCount;
                    var nextIndex = i == vertexCount ? 0 : i;
                    isConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);
                    isConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices)
                }
                if (vertexCount == 3) {
                    triangles.push(indices[2]);
                    triangles.push(indices[0]);
                    triangles.push(indices[1])
                }
                return triangles
            };
            Triangulator.prototype.decompose = function(verticesArray, triangles) {
                var vertices = verticesArray;
                var convexPolygons = this.convexPolygons;
                this.polygonPool.freeAll(convexPolygons);
                convexPolygons.length = 0;
                var convexPolygonsIndices = this.convexPolygonsIndices;
                this.polygonIndicesPool.freeAll(convexPolygonsIndices);
                convexPolygonsIndices.length = 0;
                var polygonIndices = this.polygonIndicesPool.obtain();
                polygonIndices.length = 0;
                var polygon = this.polygonPool.obtain();
                polygon.length = 0;
                var fanBaseIndex = -1,
                    lastWinding = 0;
                for (var i = 0, n = triangles.length; i < n; i += 3) {
                    var t1 = triangles[i] << 1,
                        t2 = triangles[i + 1] << 1,
                        t3 = triangles[i + 2] << 1;
                    var x1 = vertices[t1],
                        y1 = vertices[t1 + 1];
                    var x2 = vertices[t2],
                        y2 = vertices[t2 + 1];
                    var x3 = vertices[t3],
                        y3 = vertices[t3 + 1];
                    var merged = false;
                    if (fanBaseIndex == t1) {
                        var o = polygon.length - 4;
                        var winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);
                        var winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);
                        if (winding1 == lastWinding && winding2 == lastWinding) {
                            polygon.push(x3);
                            polygon.push(y3);
                            polygonIndices.push(t3);
                            merged = true
                        }
                    }
                    if (!merged) {
                        if (polygon.length > 0) {
                            convexPolygons.push(polygon);
                            convexPolygonsIndices.push(polygonIndices)
                        } else {
                            this.polygonPool.free(polygon);
                            this.polygonIndicesPool.free(polygonIndices)
                        }
                        polygon = this.polygonPool.obtain();
                        polygon.length = 0;
                        polygon.push(x1);
                        polygon.push(y1);
                        polygon.push(x2);
                        polygon.push(y2);
                        polygon.push(x3);
                        polygon.push(y3);
                        polygonIndices = this.polygonIndicesPool.obtain();
                        polygonIndices.length = 0;
                        polygonIndices.push(t1);
                        polygonIndices.push(t2);
                        polygonIndices.push(t3);
                        lastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);
                        fanBaseIndex = t1
                    }
                }
                if (polygon.length > 0) {
                    convexPolygons.push(polygon);
                    convexPolygonsIndices.push(polygonIndices)
                }
                for (var i = 0, n = convexPolygons.length; i < n; i++) {
                    polygonIndices = convexPolygonsIndices[i];
                    if (polygonIndices.length == 0) continue;
                    var firstIndex = polygonIndices[0];
                    var lastIndex = polygonIndices[polygonIndices.length - 1];
                    polygon = convexPolygons[i];
                    var o = polygon.length - 4;
                    var prevPrevX = polygon[o],
                        prevPrevY = polygon[o + 1];
                    var prevX =
                        polygon[o + 2],
                        prevY = polygon[o + 3];
                    var firstX = polygon[0],
                        firstY = polygon[1];
                    var secondX = polygon[2],
                        secondY = polygon[3];
                    var winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);
                    for (var ii = 0; ii < n; ii++) {
                        if (ii == i) continue;
                        var otherIndices = convexPolygonsIndices[ii];
                        if (otherIndices.length != 3) continue;
                        var otherFirstIndex = otherIndices[0];
                        var otherSecondIndex = otherIndices[1];
                        var otherLastIndex = otherIndices[2];
                        var otherPoly = convexPolygons[ii];
                        var x3 = otherPoly[otherPoly.length - 2],
                            y3 = otherPoly[otherPoly.length -
                                1];
                        if (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex) continue;
                        var winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);
                        var winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);
                        if (winding1 == winding && winding2 == winding) {
                            otherPoly.length = 0;
                            otherIndices.length = 0;
                            polygon.push(x3);
                            polygon.push(y3);
                            polygonIndices.push(otherLastIndex);
                            prevPrevX = prevX;
                            prevPrevY = prevY;
                            prevX = x3;
                            prevY = y3;
                            ii = 0
                        }
                    }
                }
                for (var i = convexPolygons.length - 1; i >= 0; i--) {
                    polygon = convexPolygons[i];
                    if (polygon.length ==
                        0) {
                        convexPolygons.splice(i, 1);
                        this.polygonPool.free(polygon);
                        polygonIndices = convexPolygonsIndices[i];
                        convexPolygonsIndices.splice(i, 1);
                        this.polygonIndicesPool.free(polygonIndices)
                    }
                }
                return convexPolygons
            };
            Triangulator.isConcave = function(index, vertexCount, vertices, indices) {
                var previous = indices[(vertexCount + index - 1) % vertexCount] << 1;
                var current = indices[index] << 1;
                var next = indices[(index + 1) % vertexCount] << 1;
                return !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current +
                    1], vertices[next], vertices[next + 1])
            };
            Triangulator.positiveArea = function(p1x, p1y, p2x, p2y, p3x, p3y) {
                return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0
            };
            Triangulator.winding = function(p1x, p1y, p2x, p2y, p3x, p3y) {
                var px = p2x - p1x,
                    py = p2y - p1y;
                return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1
            };
            return Triangulator
        }();
        core.Triangulator = Triangulator
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var IntSet = function() {
            function IntSet() {
                this.array = new Array
            }
            IntSet.prototype.add = function(value) {
                var contains = this.contains(value);
                this.array[value | 0] = value | 0;
                return !contains
            };
            IntSet.prototype.contains = function(value) {
                return this.array[value | 0] != undefined
            };
            IntSet.prototype.remove = function(value) {
                this.array[value | 0] = undefined
            };
            IntSet.prototype.clear = function() {
                this.array.length = 0
            };
            return IntSet
        }();
        core.IntSet = IntSet;
        var Color = function() {
            function Color(r,
                g, b, a) {
                if (r === void 0) r = 0;
                if (g === void 0) g = 0;
                if (b === void 0) b = 0;
                if (a === void 0) a = 0;
                this.r = r;
                this.g = g;
                this.b = b;
                this.a = a
            }
            Color.prototype.set = function(r, g, b, a) {
                this.r = r;
                this.g = g;
                this.b = b;
                this.a = a;
                this.clamp();
                return this
            };
            Color.prototype.setFromColor = function(c) {
                this.r = c.r;
                this.g = c.g;
                this.b = c.b;
                this.a = c.a;
                return this
            };
            Color.prototype.setFromString = function(hex) {
                hex = hex.charAt(0) == "#" ? hex.substr(1) : hex;
                this.r = parseInt(hex.substr(0, 2), 16) / 255;
                this.g = parseInt(hex.substr(2, 2), 16) / 255;
                this.b = parseInt(hex.substr(4,
                    2), 16) / 255;
                this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255;
                return this
            };
            Color.prototype.add = function(r, g, b, a) {
                this.r += r;
                this.g += g;
                this.b += b;
                this.a += a;
                this.clamp();
                return this
            };
            Color.prototype.clamp = function() {
                if (this.r < 0) this.r = 0;
                else if (this.r > 1) this.r = 1;
                if (this.g < 0) this.g = 0;
                else if (this.g > 1) this.g = 1;
                if (this.b < 0) this.b = 0;
                else if (this.b > 1) this.b = 1;
                if (this.a < 0) this.a = 0;
                else if (this.a > 1) this.a = 1;
                return this
            };
            Color.WHITE = new Color(1, 1, 1, 1);
            Color.RED = new Color(1, 0, 0, 1);
            Color.GREEN = new Color(0,
                1, 0, 1);
            Color.BLUE = new Color(0, 0, 1, 1);
            Color.MAGENTA = new Color(1, 0, 1, 1);
            return Color
        }();
        core.Color = Color;
        var MathUtils = function() {
            function MathUtils() {}
            MathUtils.clamp = function(value, min, max) {
                if (value < min) return min;
                if (value > max) return max;
                return value
            };
            MathUtils.cosDeg = function(degrees) {
                return Math.cos(degrees * MathUtils.degRad)
            };
            MathUtils.sinDeg = function(degrees) {
                return Math.sin(degrees * MathUtils.degRad)
            };
            MathUtils.signum = function(value) {
                return value > 0 ? 1 : value < 0 ? -1 : 0
            };
            MathUtils.toInt = function(x) {
                return x >
                    0 ? Math.floor(x) : Math.ceil(x)
            };
            MathUtils.cbrt = function(x) {
                var y = Math.pow(Math.abs(x), 1 / 3);
                return x < 0 ? -y : y
            };
            MathUtils.randomTriangular = function(min, max) {
                return MathUtils.randomTriangularWith(min, max, (min + max) * .5)
            };
            MathUtils.randomTriangularWith = function(min, max, mode) {
                var u = Math.random();
                var d = max - min;
                if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));
                return max - Math.sqrt((1 - u) * d * (max - mode))
            };
            MathUtils.PI = 3.1415927;
            MathUtils.PI2 = MathUtils.PI * 2;
            MathUtils.radiansToDegrees = 180 / MathUtils.PI;
            MathUtils.radDeg =
                MathUtils.radiansToDegrees;
            MathUtils.degreesToRadians = MathUtils.PI / 180;
            MathUtils.degRad = MathUtils.degreesToRadians;
            return MathUtils
        }();
        core.MathUtils = MathUtils;
        var Interpolation = function() {
            function Interpolation() {}
            Interpolation.prototype.apply = function(start, end, a) {
                return start + (end - start) * this.applyInternal(a)
            };
            return Interpolation
        }();
        core.Interpolation = Interpolation;
        var Pow = function(_super) {
            __extends(Pow, _super);

            function Pow(power) {
                var _this = _super.call(this) || this;
                _this.power = 2;
                _this.power = power;
                return _this
            }
            Pow.prototype.applyInternal = function(a) {
                if (a <= .5) return Math.pow(a * 2, this.power) / 2;
                return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1
            };
            return Pow
        }(Interpolation);
        core.Pow = Pow;
        var PowOut = function(_super) {
            __extends(PowOut, _super);

            function PowOut(power) {
                return _super.call(this, power) || this
            }
            PowOut.prototype.applyInternal = function(a) {
                return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1
            };
            return PowOut
        }(Pow);
        core.PowOut = PowOut;
        var Utils = function() {
            function Utils() {}
            Utils.arrayCopy =
                function(source, sourceStart, dest, destStart, numElements) {
                    for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) dest[j] = source[i]
                };
            Utils.setArraySize = function(array, size, value) {
                if (value === void 0) value = 0;
                var oldSize = array.length;
                if (oldSize == size) return array;
                array.length = size;
                if (oldSize < size)
                    for (var i = oldSize; i < size; i++) array[i] = value;
                return array
            };
            Utils.ensureArrayCapacity = function(array, size, value) {
                if (value === void 0) value = 0;
                if (array.length >= size) return array;
                return Utils.setArraySize(array,
                    size, value)
            };
            Utils.newArray = function(size, defaultValue) {
                var array = new Array(size);
                for (var i = 0; i < size; i++) array[i] = defaultValue;
                return array
            };
            Utils.newFloatArray = function(size) {
                if (Utils.SUPPORTS_TYPED_ARRAYS) return new Float32Array(size);
                else {
                    var array = new Array(size);
                    for (var i = 0; i < array.length; i++) array[i] = 0;
                    return array
                }
            };
            Utils.newShortArray = function(size) {
                if (Utils.SUPPORTS_TYPED_ARRAYS) return new Int16Array(size);
                else {
                    var array = new Array(size);
                    for (var i = 0; i < array.length; i++) array[i] = 0;
                    return array
                }
            };
            Utils.toFloatArray = function(array) {
                return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array
            };
            Utils.toSinglePrecision = function(value) {
                return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value
            };
            Utils.webkit602BugfixHelper = function(alpha, pose) {};
            Utils.SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== "undefined";
            return Utils
        }();
        core.Utils = Utils;
        var DebugUtils = function() {
            function DebugUtils() {}
            DebugUtils.logBones = function(skeleton) {
                for (var i = 0; i < skeleton.bones.length; i++) {
                    var bone = skeleton.bones[i];
                    var mat = bone.matrix;
                    console.log(bone.data.name + ", " + mat.a + ", " + mat.b + ", " + mat.c + ", " + mat.d + ", " + mat.tx + ", " + mat.ty)
                }
            };
            return DebugUtils
        }();
        core.DebugUtils = DebugUtils;
        var Pool = function() {
            function Pool(instantiator) {
                this.items = new Array;
                this.instantiator = instantiator
            }
            Pool.prototype.obtain = function() {
                return this.items.length > 0 ? this.items.pop() : this.instantiator()
            };
            Pool.prototype.free = function(item) {
                if (item.reset) item.reset();
                this.items.push(item)
            };
            Pool.prototype.freeAll = function(items) {
                for (var i = 0; i <
                    items.length; i++) {
                    if (items[i].reset) items[i].reset();
                    this.items[i] = items[i]
                }
            };
            Pool.prototype.clear = function() {
                this.items.length = 0
            };
            return Pool
        }();
        core.Pool = Pool;
        var Vector2 = function() {
            function Vector2(x, y) {
                if (x === void 0) x = 0;
                if (y === void 0) y = 0;
                this.x = x;
                this.y = y
            }
            Vector2.prototype.set = function(x, y) {
                this.x = x;
                this.y = y;
                return this
            };
            Vector2.prototype.length = function() {
                var x = this.x;
                var y = this.y;
                return Math.sqrt(x * x + y * y)
            };
            Vector2.prototype.normalize = function() {
                var len = this.length();
                if (len != 0) {
                    this.x /= len;
                    this.y /=
                        len
                }
                return this
            };
            return Vector2
        }();
        core.Vector2 = Vector2;
        var TimeKeeper = function() {
            function TimeKeeper() {
                this.maxDelta = .064;
                this.framesPerSecond = 0;
                this.delta = 0;
                this.totalTime = 0;
                this.lastTime = Date.now() / 1E3;
                this.frameCount = 0;
                this.frameTime = 0
            }
            TimeKeeper.prototype.update = function() {
                var now = Date.now() / 1E3;
                this.delta = now - this.lastTime;
                this.frameTime += this.delta;
                this.totalTime += this.delta;
                if (this.delta > this.maxDelta) this.delta = this.maxDelta;
                this.lastTime = now;
                this.frameCount++;
                if (this.frameTime > 1) {
                    this.framesPerSecond =
                        this.frameCount / this.frameTime;
                    this.frameTime = 0;
                    this.frameCount = 0
                }
            };
            return TimeKeeper
        }();
        core.TimeKeeper = TimeKeeper;
        var WindowedMean = function() {
            function WindowedMean(windowSize) {
                if (windowSize === void 0) windowSize = 32;
                this.addedValues = 0;
                this.lastValue = 0;
                this.mean = 0;
                this.dirty = true;
                this.values = new Array(windowSize)
            }
            WindowedMean.prototype.hasEnoughData = function() {
                return this.addedValues >= this.values.length
            };
            WindowedMean.prototype.addValue = function(value) {
                if (this.addedValues < this.values.length) this.addedValues++;
                this.values[this.lastValue++] = value;
                if (this.lastValue > this.values.length - 1) this.lastValue = 0;
                this.dirty = true
            };
            WindowedMean.prototype.getMean = function() {
                if (this.hasEnoughData()) {
                    if (this.dirty) {
                        var mean = 0;
                        for (var i = 0; i < this.values.length; i++) mean += this.values[i];
                        this.mean = mean / this.values.length;
                        this.dirty = false
                    }
                    return this.mean
                } else return 0
            };
            return WindowedMean
        }();
        core.WindowedMean = WindowedMean
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var Attachment = function() {
            function Attachment(name) {
                if (name == null) throw new Error("name cannot be null.");
                this.name = name
            }
            return Attachment
        }();
        core.Attachment = Attachment;
        var VertexAttachment = function(_super) {
            __extends(VertexAttachment, _super);

            function VertexAttachment(name) {
                var _this = _super.call(this, name) || this;
                _this.id = (VertexAttachment.nextID++ & 65535) << 11;
                _this.worldVerticesLength = 0;
                return _this
            }
            VertexAttachment.prototype.computeWorldVerticesOld = function(slot,
                worldVertices) {
                this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2)
            };
            VertexAttachment.prototype.computeWorldVertices = function(slot, start, count, worldVertices, offset, stride) {
                count = offset + (count >> 1) * stride;
                var skeleton = slot.bone.skeleton;
                var deformArray = slot.attachmentVertices;
                var vertices = this.vertices;
                var bones = this.bones;
                if (bones == null) {
                    if (deformArray.length > 0) vertices = deformArray;
                    var mat = slot.bone.matrix;
                    var x = mat.tx;
                    var y = mat.ty;
                    var a = mat.a,
                        b = mat.c,
                        c = mat.b,
                        d = mat.d;
                    for (var v_1 =
                            start, w = offset; w < count; v_1 += 2, w += stride) {
                        var vx = vertices[v_1],
                            vy = vertices[v_1 + 1];
                        worldVertices[w] = vx * a + vy * b + x;
                        worldVertices[w + 1] = vx * c + vy * d + y
                    }
                    return
                }
                var v = 0,
                    skip = 0;
                for (var i = 0; i < start; i += 2) {
                    var n = bones[v];
                    v += n + 1;
                    skip += n
                }
                var skeletonBones = skeleton.bones;
                if (deformArray.length == 0)
                    for (var w = offset, b = skip * 3; w < count; w += stride) {
                        var wx = 0,
                            wy = 0;
                        var n = bones[v++];
                        n += v;
                        for (; v < n; v++, b += 3) {
                            var mat = skeletonBones[bones[v]].matrix;
                            var vx = vertices[b],
                                vy = vertices[b + 1],
                                weight = vertices[b + 2];
                            wx += (vx * mat.a + vy * mat.c + mat.tx) *
                                weight;
                            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight
                        }
                        worldVertices[w] = wx;
                        worldVertices[w + 1] = wy
                    } else {
                        var deform = deformArray;
                        for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
                            var wx = 0,
                                wy = 0;
                            var n = bones[v++];
                            n += v;
                            for (; v < n; v++, b += 3, f += 2) {
                                var mat = skeletonBones[bones[v]].matrix;
                                var vx = vertices[b] + deform[f],
                                    vy = vertices[b + 1] + deform[f + 1],
                                    weight = vertices[b + 2];
                                wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
                                wy += (vx * mat.b + vy * mat.d + mat.ty) * weight
                            }
                            worldVertices[w] = wx;
                            worldVertices[w + 1] = wy
                        }
                    }
            };
            VertexAttachment.prototype.applyDeform =
                function(sourceAttachment) {
                    return this == sourceAttachment
                };
            VertexAttachment.nextID = 0;
            return VertexAttachment
        }(Attachment);
        core.VertexAttachment = VertexAttachment
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var AttachmentType;
        (function(AttachmentType) {
            AttachmentType[AttachmentType["Region"] = 0] = "Region";
            AttachmentType[AttachmentType["BoundingBox"] = 1] = "BoundingBox";
            AttachmentType[AttachmentType["Mesh"] = 2] = "Mesh";
            AttachmentType[AttachmentType["LinkedMesh"] = 3] = "LinkedMesh";
            AttachmentType[AttachmentType["Path"] = 4] = "Path";
            AttachmentType[AttachmentType["Point"] = 5] = "Point"
        })(AttachmentType = core.AttachmentType || (core.AttachmentType = {}))
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var BoundingBoxAttachment = function(_super) {
            __extends(BoundingBoxAttachment, _super);

            function BoundingBoxAttachment(name) {
                var _this = _super.call(this, name) || this;
                _this.color = new core.Color(1, 1, 1, 1);
                return _this
            }
            return BoundingBoxAttachment
        }(core.VertexAttachment);
        core.BoundingBoxAttachment = BoundingBoxAttachment
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var ClippingAttachment = function(_super) {
            __extends(ClippingAttachment, _super);

            function ClippingAttachment(name) {
                var _this = _super.call(this, name) || this;
                _this.color = new core.Color(.2275, .2275, .8078, 1);
                return _this
            }
            return ClippingAttachment
        }(core.VertexAttachment);
        core.ClippingAttachment = ClippingAttachment
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var MeshAttachment = function(_super) {
            __extends(MeshAttachment, _super);

            function MeshAttachment(name) {
                var _this = _super.call(this, name) || this;
                _this.color = new core.Color(1, 1, 1, 1);
                _this.inheritDeform = false;
                _this.tempColor = new core.Color(0, 0, 0, 0);
                return _this
            }
            MeshAttachment.prototype.updateUVs = function(region, uvs) {
                var regionUVs = this.regionUVs;
                var n = regionUVs.length;
                if (!uvs || uvs.length != n) uvs = core.Utils.newFloatArray(n);
                if (region == null) return;
                var texture = region.texture;
                var r = texture._uvs;
                var w1 = region.width,
                    h1 = region.height,
                    w2 = region.originalWidth,
                    h2 = region.originalHeight;
                var x = region.offsetX,
                    y = region.pixiOffsetY;
                for (var i = 0; i < n; i += 2) {
                    var u = this.regionUVs[i],
                        v = this.regionUVs[i + 1];
                    u = (u * w2 - x) / w1;
                    v = (v * h2 - y) / h1;
                    uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1 - v) + (r.x3 * (1 - u) + r.x2 * u) * v;
                    uvs[i + 1] = (r.y0 * (1 - u) + r.y1 * u) * (1 - v) + (r.y3 * (1 - u) + r.y2 * u) * v
                }
                return uvs
            };
            MeshAttachment.prototype.applyDeform = function(sourceAttachment) {
                return this == sourceAttachment || this.inheritDeform && this.parentMesh == sourceAttachment
            };
            MeshAttachment.prototype.getParentMesh = function() {
                return this.parentMesh
            };
            MeshAttachment.prototype.setParentMesh = function(parentMesh) {
                this.parentMesh = parentMesh;
                if (parentMesh != null) {
                    this.bones = parentMesh.bones;
                    this.vertices = parentMesh.vertices;
                    this.worldVerticesLength = parentMesh.worldVerticesLength;
                    this.regionUVs = parentMesh.regionUVs;
                    this.triangles = parentMesh.triangles;
                    this.hullLength = parentMesh.hullLength;
                    this.worldVerticesLength = parentMesh.worldVerticesLength
                }
            };
            return MeshAttachment
        }(core.VertexAttachment);
        core.MeshAttachment = MeshAttachment
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var PathAttachment = function(_super) {
            __extends(PathAttachment, _super);

            function PathAttachment(name) {
                var _this = _super.call(this, name) || this;
                _this.closed = false;
                _this.constantSpeed = false;
                _this.color = new core.Color(1, 1, 1, 1);
                return _this
            }
            return PathAttachment
        }(core.VertexAttachment);
        core.PathAttachment = PathAttachment
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var PointAttachment = function(_super) {
            __extends(PointAttachment, _super);

            function PointAttachment(name) {
                var _this = _super.call(this, name) || this;
                _this.color = new core.Color(.38, .94, 0, 1);
                return _this
            }
            PointAttachment.prototype.computeWorldPosition = function(bone, point) {
                var mat = bone.matrix;
                point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
                point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
                return point
            };
            PointAttachment.prototype.computeWorldRotation = function(bone) {
                var mat =
                    bone.matrix;
                var cos = core.MathUtils.cosDeg(this.rotation),
                    sin = core.MathUtils.sinDeg(this.rotation);
                var x = cos * mat.a + sin * mat.c;
                var y = cos * mat.b + sin * mat.d;
                return Math.atan2(y, x) * core.MathUtils.radDeg
            };
            return PointAttachment
        }(core.VertexAttachment);
        core.PointAttachment = PointAttachment
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var RegionAttachment = function(_super) {
            __extends(RegionAttachment, _super);

            function RegionAttachment(name) {
                var _this = _super.call(this, name) || this;
                _this.x = 0;
                _this.y = 0;
                _this.scaleX = 1;
                _this.scaleY = 1;
                _this.rotation = 0;
                _this.width = 0;
                _this.height = 0;
                _this.color = new core.Color(1, 1, 1, 1);
                _this.offset = core.Utils.newFloatArray(8);
                _this.uvs = core.Utils.newFloatArray(8);
                _this.tempColor = new core.Color(1, 1, 1, 1);
                return _this
            }
            RegionAttachment.prototype.updateOffset = function() {
                var regionScaleX =
                    this.width / this.region.originalWidth * this.scaleX;
                var regionScaleY = this.height / this.region.originalHeight * this.scaleY;
                var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
                var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
                var localX2 = localX + this.region.width * regionScaleX;
                var localY2 = localY + this.region.height * regionScaleY;
                var radians = this.rotation * Math.PI / 180;
                var cos = Math.cos(radians);
                var sin = Math.sin(radians);
                var localXCos = localX * cos + this.x;
                var localXSin = localX *
                    sin;
                var localYCos = localY * cos + this.y;
                var localYSin = localY * sin;
                var localX2Cos = localX2 * cos + this.x;
                var localX2Sin = localX2 * sin;
                var localY2Cos = localY2 * cos + this.y;
                var localY2Sin = localY2 * sin;
                var offset = this.offset;
                offset[RegionAttachment.OX1] = localXCos - localYSin;
                offset[RegionAttachment.OY1] = localYCos + localXSin;
                offset[RegionAttachment.OX2] = localXCos - localY2Sin;
                offset[RegionAttachment.OY2] = localY2Cos + localXSin;
                offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;
                offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;
                offset[RegionAttachment.OX4] = localX2Cos - localYSin;
                offset[RegionAttachment.OY4] = localYCos + localX2Sin
            };
            RegionAttachment.prototype.setRegion = function(region) {
                this.region = region;
                var uvs = this.uvs;
                if (region.rotate) {
                    uvs[2] = region.u;
                    uvs[3] = region.v2;
                    uvs[4] = region.u;
                    uvs[5] = region.v;
                    uvs[6] = region.u2;
                    uvs[7] = region.v;
                    uvs[0] = region.u2;
                    uvs[1] = region.v2
                } else {
                    uvs[0] = region.u;
                    uvs[1] = region.v2;
                    uvs[2] = region.u;
                    uvs[3] = region.v;
                    uvs[4] = region.u2;
                    uvs[5] = region.v;
                    uvs[6] = region.u2;
                    uvs[7] = region.v2
                }
            };
            RegionAttachment.prototype.computeWorldVertices =
                function(bone, worldVertices, offset, stride) {
                    var vertexOffset = this.offset;
                    var mat = bone.matrix;
                    var x = mat.tx,
                        y = mat.ty;
                    var a = mat.a,
                        b = mat.c,
                        c = mat.b,
                        d = mat.d;
                    var offsetX = 0,
                        offsetY = 0;
                    offsetX = vertexOffset[RegionAttachment.OX1];
                    offsetY = vertexOffset[RegionAttachment.OY1];
                    worldVertices[offset] = offsetX * a + offsetY * b + x;
                    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
                    offset += stride;
                    offsetX = vertexOffset[RegionAttachment.OX2];
                    offsetY = vertexOffset[RegionAttachment.OY2];
                    worldVertices[offset] = offsetX * a + offsetY * b + x;
                    worldVertices[offset +
                        1] = offsetX * c + offsetY * d + y;
                    offset += stride;
                    offsetX = vertexOffset[RegionAttachment.OX3];
                    offsetY = vertexOffset[RegionAttachment.OY3];
                    worldVertices[offset] = offsetX * a + offsetY * b + x;
                    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
                    offset += stride;
                    offsetX = vertexOffset[RegionAttachment.OX4];
                    offsetY = vertexOffset[RegionAttachment.OY4];
                    worldVertices[offset] = offsetX * a + offsetY * b + x;
                    worldVertices[offset + 1] = offsetX * c + offsetY * d + y
                };
            RegionAttachment.OX1 = 0;
            RegionAttachment.OY1 = 1;
            RegionAttachment.OX2 = 2;
            RegionAttachment.OY2 = 3;
            RegionAttachment.OX3 =
                4;
            RegionAttachment.OY3 = 5;
            RegionAttachment.OX4 = 6;
            RegionAttachment.OY4 = 7;
            RegionAttachment.X1 = 0;
            RegionAttachment.Y1 = 1;
            RegionAttachment.C1R = 2;
            RegionAttachment.C1G = 3;
            RegionAttachment.C1B = 4;
            RegionAttachment.C1A = 5;
            RegionAttachment.U1 = 6;
            RegionAttachment.V1 = 7;
            RegionAttachment.X2 = 8;
            RegionAttachment.Y2 = 9;
            RegionAttachment.C2R = 10;
            RegionAttachment.C2G = 11;
            RegionAttachment.C2B = 12;
            RegionAttachment.C2A = 13;
            RegionAttachment.U2 = 14;
            RegionAttachment.V2 = 15;
            RegionAttachment.X3 = 16;
            RegionAttachment.Y3 = 17;
            RegionAttachment.C3R =
                18;
            RegionAttachment.C3G = 19;
            RegionAttachment.C3B = 20;
            RegionAttachment.C3A = 21;
            RegionAttachment.U3 = 22;
            RegionAttachment.V3 = 23;
            RegionAttachment.X4 = 24;
            RegionAttachment.Y4 = 25;
            RegionAttachment.C4R = 26;
            RegionAttachment.C4G = 27;
            RegionAttachment.C4B = 28;
            RegionAttachment.C4A = 29;
            RegionAttachment.U4 = 30;
            RegionAttachment.V4 = 31;
            return RegionAttachment
        }(core.Attachment);
        core.RegionAttachment = RegionAttachment
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var JitterEffect = function() {
            function JitterEffect(jitterX, jitterY) {
                this.jitterX = 0;
                this.jitterY = 0;
                this.jitterX = jitterX;
                this.jitterY = jitterY
            }
            JitterEffect.prototype.begin = function(skeleton) {};
            JitterEffect.prototype.transform = function(position, uv, light, dark) {
                position.x += core.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
                position.y += core.MathUtils.randomTriangular(-this.jitterX, this.jitterY)
            };
            JitterEffect.prototype.end = function() {};
            return JitterEffect
        }();
        core.JitterEffect = JitterEffect
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    var core;
    (function(core) {
        var SwirlEffect = function() {
            function SwirlEffect(radius) {
                this.centerX = 0;
                this.centerY = 0;
                this.radius = 0;
                this.angle = 0;
                this.worldX = 0;
                this.worldY = 0;
                this.radius = radius
            }
            SwirlEffect.prototype.begin = function(skeleton) {
                this.worldX = skeleton.x + this.centerX;
                this.worldY = skeleton.y + this.centerY
            };
            SwirlEffect.prototype.transform = function(position, uv, light, dark) {
                var radAngle = this.angle * core.MathUtils.degreesToRadians;
                var x = position.x - this.worldX;
                var y = position.y - this.worldY;
                var dist = Math.sqrt(x * x + y * y);
                if (dist < this.radius) {
                    var theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);
                    var cos = Math.cos(theta);
                    var sin = Math.sin(theta);
                    position.x = cos * x - sin * y + this.worldX;
                    position.y = sin * x + cos * y + this.worldY
                }
            };
            SwirlEffect.prototype.end = function() {};
            SwirlEffect.interpolation = new core.PowOut(2);
            return SwirlEffect
        }();
        core.SwirlEffect = SwirlEffect
    })(core = pixi_spine.core || (pixi_spine.core = {}))
})(pixi_spine || (pixi_spine = {}));
(function() {
    if (!Math.fround) Math.fround = Math.fround = function(array) {
        return function(x) {
            return array[0] = x, array[0]
        }
    }(new Float32Array(1))
})();
var pixi_spine;
(function(pixi_spine) {
    pixi_spine.core.Bone.yDown = true;
    var tempRgb = [0, 0, 0];
    var SpineSprite = function(_super) {
        __extends(SpineSprite, _super);

        function SpineSprite() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.region = null;
            return _this
        }
        return SpineSprite
    }(PIXI.Sprite);
    pixi_spine.SpineSprite = SpineSprite;
    var SpineMesh = function(_super) {
        __extends(SpineMesh, _super);

        function SpineMesh(texture, vertices, uvs, indices, drawMode) {
            return _super.call(this, texture, vertices, uvs, indices, drawMode) || this
        }
        return SpineMesh
    }(PIXI.mesh.Mesh);
    pixi_spine.SpineMesh = SpineMesh;
    var Spine = function(_super) {
        __extends(Spine, _super);

        function Spine(spineData) {
            var _this = _super.call(this) || this;
            if (!spineData) throw new Error("The spineData param is required.");
            if (typeof spineData === "string") throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');
            _this.spineData = spineData;
            _this.skeleton = new pixi_spine.core.Skeleton(spineData);
            _this.skeleton.updateWorldTransform();
            _this.stateData = new pixi_spine.core.AnimationStateData(spineData);
            _this.state = new pixi_spine.core.AnimationState(_this.stateData);
            _this.slotContainers = [];
            _this.tempClipContainers = [];
            for (var i = 0, n = _this.skeleton.slots.length; i < n; i++) {
                var slot = _this.skeleton.slots[i];
                var attachment = slot.attachment;
                var slotContainer = _this.newContainer();
                _this.slotContainers.push(slotContainer);
                _this.addChild(slotContainer);
                _this.tempClipContainers.push(null);
                if (attachment instanceof pixi_spine.core.RegionAttachment) {
                    var spriteName =
                        attachment.region.name;
                    var sprite = _this.createSprite(slot, attachment, spriteName);
                    slot.currentSprite = sprite;
                    slot.currentSpriteName = spriteName;
                    slotContainer.addChild(sprite)
                } else if (attachment instanceof pixi_spine.core.MeshAttachment) {
                    var mesh = _this.createMesh(slot, attachment);
                    slot.currentMesh = mesh;
                    slot.currentMeshName = attachment.name;
                    slotContainer.addChild(mesh)
                } else if (attachment instanceof pixi_spine.core.ClippingAttachment) {
                    _this.createGraphics(slot, attachment);
                    slotContainer.addChild(slot.clippingContainer);
                    slotContainer.addChild(slot.currentGraphics)
                } else continue
            }
            _this.autoUpdate = true;
            _this.tintRgb = new Float32Array([1, 1, 1]);
            return _this
        }
        Object.defineProperty(Spine.prototype, "autoUpdate", {
            get: function() {
                return this.updateTransform === Spine.prototype.autoUpdateTransform
            },
            set: function(value) {
                this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Spine.prototype, "tint", {
            get: function() {
                return PIXI.utils.rgb2hex(this.tintRgb)
            },
            set: function(value) {
                this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb)
            },
            enumerable: true,
            configurable: true
        });
        Spine.prototype.update = function(dt) {
            this.state.update(dt);
            this.state.apply(this.skeleton);
            this.skeleton.updateWorldTransform();
            var slots = this.skeleton.slots;
            var globalClr = this.color;
            var light = null,
                dark = null;
            if (globalClr) {
                light = globalClr.light;
                dark = globalClr.dark
            } else light = this.tintRgb;
            var thack = PIXI.TransformBase && this.transformHack() == 1;
            for (var i = 0, n = slots.length; i < n; i++) {
                var slot = slots[i];
                var attachment = slot.attachment;
                var slotContainer = this.slotContainers[i];
                if (!attachment) {
                    slotContainer.visible = false;
                    continue
                }
                var spriteColor = null;
                var attColor = attachment.color;
                if (attachment instanceof pixi_spine.core.RegionAttachment) {
                    var region = attachment.region;
                    if (region) {
                        if (slot.currentMesh) {
                            slot.currentMesh.visible = false;
                            slot.currentMesh = null;
                            slot.currentMeshName = undefined
                        }
                        var ar = region;
                        if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {
                            var spriteName = ar.name;
                            if (slot.currentSprite) slot.currentSprite.visible =
                                false;
                            slot.sprites = slot.sprites || {};
                            if (slot.sprites[spriteName] !== undefined) slot.sprites[spriteName].visible = true;
                            else {
                                var sprite = this.createSprite(slot, attachment, spriteName);
                                slotContainer.addChild(sprite)
                            }
                            slot.currentSprite = slot.sprites[spriteName];
                            slot.currentSpriteName = spriteName
                        }
                    }
                    if (slotContainer.transform) {
                        var transform = slotContainer.transform;
                        var transAny = transform;
                        var lt = null;
                        if (transAny.matrix2d) {
                            lt = transAny.matrix2d;
                            transAny._dirtyVersion++;
                            transAny.version = transAny._dirtyVersion;
                            transAny.isStatic =
                                true;
                            transAny.operMode = 0
                        } else if (thack) {
                            if (transAny.position) {
                                transform = new PIXI.TransformBase;
                                transform._parentID = -1;
                                transform._worldID = slotContainer.transform._worldID;
                                slotContainer.transform = transform
                            }
                            lt = transform.localTransform
                        } else transAny.setFromMatrix(slot.bone.matrix);
                        if (lt) slot.bone.matrix.copy(lt)
                    } else {
                        var lt = slotContainer.localTransform || new PIXI.Matrix;
                        slot.bone.matrix.copy(lt);
                        slotContainer.localTransform = lt;
                        slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3
                    }
                    if (slot.currentSprite.color) spriteColor =
                        slot.currentSprite.color;
                    else {
                        tempRgb[0] = light[0] * slot.color.r * attColor.r;
                        tempRgb[1] = light[1] * slot.color.g * attColor.g;
                        tempRgb[2] = light[2] * slot.color.b * attColor.b;
                        slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb)
                    }
                    slot.currentSprite.blendMode = slot.blendMode
                } else if (attachment instanceof pixi_spine.core.MeshAttachment) {
                    if (slot.currentSprite) {
                        slot.currentSprite.visible = false;
                        slot.currentSprite = null;
                        slot.currentSpriteName = undefined;
                        if (slotContainer.transform) {
                            var transform = new PIXI.TransformStatic;
                            transform._parentID = -1;
                            transform._worldID = slotContainer.transform._worldID;
                            slotContainer.transform = transform
                        } else {
                            slotContainer.localTransform = new PIXI.Matrix;
                            slotContainer.displayObjectUpdateTransform = PIXI.DisplayObject.prototype.updateTransform
                        }
                    }
                    if (!slot.currentMeshName || slot.currentMeshName !== attachment.name) {
                        var meshName = attachment.name;
                        if (slot.currentMesh) slot.currentMesh.visible = false;
                        slot.meshes = slot.meshes || {};
                        if (slot.meshes[meshName] !== undefined) slot.meshes[meshName].visible = true;
                        else {
                            var mesh = this.createMesh(slot,
                                attachment);
                            slotContainer.addChild(mesh)
                        }
                        slot.currentMesh = slot.meshes[meshName];
                        slot.currentMeshName = meshName
                    }
                    attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);
                    slot.currentMesh.lightColor = slot.color;
                    slot.currentMesh.darkColor = slot.darkColor;
                    if (slot.currentMesh.color) spriteColor = slot.currentMesh.color;
                    else if (PIXI.VERSION[0] !== "3") {
                        var tintRgb = slot.currentMesh.tintRgb;
                        tintRgb[0] = light[0] * slot.color.r * attColor.r;
                        tintRgb[1] = light[1] * slot.color.g * attColor.g;
                        tintRgb[2] = light[2] * slot.color.b *
                            attColor.b
                    }
                    slot.currentMesh.blendMode = slot.blendMode
                } else if (attachment instanceof pixi_spine.core.ClippingAttachment) {
                    if (!slot.currentGraphics) {
                        this.createGraphics(slot, attachment);
                        slotContainer.addChild(slot.clippingContainer);
                        slotContainer.addChild(slot.currentGraphics)
                    }
                    this.updateGraphics(slot, attachment)
                } else {
                    slotContainer.visible = false;
                    continue
                }
                slotContainer.visible = true;
                if (spriteColor) {
                    var r0 = slot.color.r * attColor.r;
                    var g0 = slot.color.g * attColor.g;
                    var b0 = slot.color.b * attColor.b;
                    spriteColor.setLight(light[0] *
                        r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));
                    if (slot.darkColor) {
                        r0 = slot.darkColor.r;
                        g0 = slot.darkColor.g;
                        b0 = slot.darkColor.b
                    } else {
                        r0 = 0;
                        g0 = 0;
                        b0 = 0
                    }
                    spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0))
                }
                slotContainer.alpha = slot.color.a
            }
            var drawOrder = this.skeleton.drawOrder;
            var clippingAttachment = null;
            var clippingContainer = null;
            for (var i = 0, n = drawOrder.length; i < n; i++) {
                var slot = slots[drawOrder[i].data.index];
                var slotContainer = this.slotContainers[drawOrder[i].data.index];
                if (!clippingContainer)
                    if (slotContainer.parent !== this) {
                        slotContainer.parent.removeChild(slotContainer);
                        slotContainer.parent = this
                    }
                if (slot.currentGraphics && slot.attachment) {
                    clippingContainer = slot.clippingContainer;
                    clippingAttachment = slot.attachment;
                    clippingContainer.children.length = 0;
                    this.children[i] = slotContainer;
                    if (clippingAttachment.endSlot == slot.data) clippingAttachment.endSlot = null
                } else if (clippingContainer) {
                    var c = this.tempClipContainers[i];
                    if (!c) {
                        c = this.tempClipContainers[i] = this.newContainer();
                        c.visible = false
                    }
                    this.children[i] = c;
                    slotContainer.parent = null;
                    clippingContainer.addChild(slotContainer);
                    if (clippingAttachment.endSlot == slot.data) {
                        clippingContainer.renderable = true;
                        clippingContainer = null;
                        clippingAttachment = null
                    }
                } else this.children[i] = slotContainer
            }
        };
        Spine.prototype.setSpriteRegion = function(attachment, sprite, region) {
            sprite.region = region;
            sprite.texture = region.texture;
            if (!region.size) {
                sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;
                sprite.scale.y = -attachment.scaleY *
                    attachment.height / region.originalHeight
            } else {
                sprite.scale.x = region.size.width / region.originalWidth;
                sprite.scale.y = -region.size.height / region.originalHeight
            }
        };
        Spine.prototype.setMeshRegion = function(attachment, mesh, region) {
            mesh.region = region;
            mesh.texture = region.texture;
            region.texture._updateUvs();
            attachment.updateUVs(region, mesh.uvs);
            mesh.dirty++
        };
        Spine.prototype.autoUpdateTransform = function() {
            if (Spine.globalAutoUpdate) {
                this.lastTime = this.lastTime || Date.now();
                var timeDelta = (Date.now() - this.lastTime) *
                    .001;
                this.lastTime = Date.now();
                this.update(Time.deltaTime)
            } else this.lastTime = 0;
            PIXI.Container.prototype.updateTransform.call(this)
        };
        Spine.prototype.createSprite = function(slot, attachment, defName) {
            var region = attachment.region;
            if (slot.tempAttachment === attachment) {
                region = slot.tempRegion;
                slot.tempAttachment = null;
                slot.tempRegion = null
            }
            var texture = region.texture;
            var sprite = this.newSprite(texture);
            sprite.rotation = attachment.rotation * pixi_spine.core.MathUtils.degRad;
            sprite.anchor.x = .5;
            sprite.anchor.y = .5;
            sprite.position.x =
                attachment.x;
            sprite.position.y = attachment.y;
            sprite.alpha = attachment.color.a;
            sprite.region = attachment.region;
            this.setSpriteRegion(attachment, sprite, attachment.region);
            slot.sprites = slot.sprites || {};
            slot.sprites[defName] = sprite;
            return sprite
        };
        Spine.prototype.createMesh = function(slot, attachment) {
            var region = attachment.region;
            if (slot.tempAttachment === attachment) {
                region = slot.tempRegion;
                slot.tempAttachment = null;
                slot.tempRegion = null
            }
            var strip = this.newMesh(region.texture, new Float32Array(attachment.regionUVs.length),
                new Float32Array(attachment.regionUVs.length), new Uint16Array(attachment.triangles), PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);
            strip.canvasPadding = 1.5;
            strip.alpha = attachment.color.a;
            strip.region = attachment.region;
            this.setMeshRegion(attachment, strip, region);
            slot.meshes = slot.meshes || {};
            slot.meshes[attachment.name] = strip;
            return strip
        };
        Spine.prototype.createGraphics = function(slot, clip) {
            var graphics = this.newGraphics();
            var poly = new PIXI.Polygon([]);
            graphics.clear();
            graphics.beginFill(16777215, 1);
            graphics.drawPolygon(poly);
            graphics.renderable = false;
            slot.currentGraphics = graphics;
            slot.clippingContainer = this.newContainer();
            slot.clippingContainer.mask = slot.currentGraphics;
            return graphics
        };
        Spine.prototype.updateGraphics = function(slot, clip) {
            var vertices = slot.currentGraphics.graphicsData[0].shape.points;
            slot.currentGraphics.graphicsData[0].shape.closed = false;
            var n = clip.worldVerticesLength;
            vertices.length = n;
            clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);
            slot.currentGraphics.dirty++;
            slot.currentGraphics.clearDirty++
        };
        Spine.prototype.hackTextureBySlotIndex =
            function(slotIndex, texture, size) {
                if (texture === void 0) texture = null;
                if (size === void 0) size = null;
                var slot = this.skeleton.slots[slotIndex];
                if (!slot) return false;
                var attachment = slot.attachment;
                var region = attachment.region;
                if (texture) {
                    region = new pixi_spine.core.TextureRegion;
                    region.texture = texture;
                    region.size = size
                }
                if (slot.currentSprite && slot.currentSprite.region != region) {
                    this.setSpriteRegion(attachment, slot.currentSprite, region);
                    slot.currentSprite.region = region
                } else if (slot.currentMesh && slot.currentMesh.region !=
                    region) this.setMeshRegion(attachment, slot.currentMesh, region);
                else {
                    slot.tempRegion = region;
                    slot.tempAttachment = attachment
                }
                return true
            };
        Spine.prototype.hackTextureBySlotName = function(slotName, texture, size) {
            if (texture === void 0) texture = null;
            if (size === void 0) size = null;
            var index = this.skeleton.findSlotIndex(slotName);
            if (index == -1) return false;
            return this.hackTextureBySlotIndex(index, texture, size)
        };
        Spine.prototype.newContainer = function() {
            return new PIXI.Container
        };
        Spine.prototype.newSprite = function(tex) {
            return new SpineSprite(tex)
        };
        Spine.prototype.newGraphics = function() {
            return new PIXI.Graphics
        };
        Spine.prototype.newMesh = function(texture, vertices, uvs, indices, drawMode) {
            return new SpineMesh(texture, vertices, uvs, indices, drawMode)
        };
        Spine.prototype.transformHack = function() {
            return 1
        };
        Spine.prototype.hackAttachmentGroups = function(nameSuffix, group, outGroup) {
            if (!nameSuffix) return;
            var list_d = [],
                list_n = [];
            for (var i = 0, len = this.skeleton.slots.length; i < len; i++) {
                var slot = this.skeleton.slots[i];
                var name_2 = slot.currentSpriteName || slot.currentMeshName ||
                    "";
                var target = slot.currentSprite || slot.currentMesh;
                if (name_2.endsWith(nameSuffix)) {
                    target.parentGroup = group;
                    list_n.push(target)
                } else if (outGroup && target) {
                    target.parentGroup = outGroup;
                    list_d.push(target)
                }
            }
            return [list_d, list_n]
        };
        Spine.prototype.destroy = function(options) {
            for (var i = 0, n = this.skeleton.slots.length; i < n; i++) {
                var slot = this.skeleton.slots[i];
                for (var name_3 in slot.meshes) slot.meshes[name_3].destroy(options);
                slot.meshes = null;
                for (var name_4 in slot.sprites) slot.sprites[name_4].destroy(options);
                slot.sprites = null
            }
            for (var i = 0, n = this.slotContainers.length; i < n; i++) this.slotContainers[i].destroy(options);
            this.spineData = null;
            this.skeleton = null;
            this.slotContainers = null;
            this.stateData = null;
            this.state = null;
            this.tempClipContainers = null;
            _super.prototype.destroy.call(this, options)
        };
        Spine.globalAutoUpdate = true;
        Spine.clippingPolygon = [];
        return Spine
    }(PIXI.Container);
    pixi_spine.Spine = Spine;

    function SlotContainerUpdateTransformV3() {
        var pt = this.parent.worldTransform;
        var wt = this.worldTransform;
        var lt = this.localTransform;
        wt.a = lt.a * pt.a + lt.b * pt.c;
        wt.b = lt.a * pt.b + lt.b * pt.d;
        wt.c = lt.c * pt.a + lt.d * pt.c;
        wt.d = lt.c * pt.b + lt.d * pt.d;
        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        this._currentBounds = null
    }
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    PIXI.spine = pixi_spine;
    var TextureProto = PIXI.Texture.prototype;
    if (!TextureProto._updateUvs) TextureProto._updateUvs = TextureProto.updateUvs
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function(pixi_spine) {
    function isJson(resource) {
        return true
    }

    function atlasParser() {
        return function(resource, next) {
            if (!resource.data || !isJson(resource) || !resource.data.bones) return next();
            var metadata = resource.metadata || {};
            var metadataSkeletonScale = metadata ? resource.metadata.spineSkeletonScale : null;
            var metadataAtlas = metadata ? resource.metadata.spineAtlas : null;
            if (metadataAtlas === false) return next();
            if (metadataAtlas && metadataAtlas.pages) {
                var spineJsonParser = new pixi_spine.core.SkeletonJson(new pixi_spine.core.AtlasAttachmentLoader(metadataAtlas));
                var skeletonData = spineJsonParser.readSkeletonData(resource.data);
                resource.spineData = skeletonData;
                resource.spineAtlas = metadataAtlas;
                return next()
            }
            var metadataAtlasSuffix = metadata.spineAtlasSuffix || ".atlas";
            var atlasPath = resource.url.substr(0, resource.url.lastIndexOf(".")) + metadataAtlasSuffix;
            if (resource.metadata && resource.metadata.spineAtlasFile) atlasPath = resource.metadata.spineAtlasFile;
            atlasPath = atlasPath.replace(this.baseUrl, "");
            var atlasOptions = {
                crossOrigin: resource.crossOrigin,
                xhrType: PIXI.loaders.Resource.XHR_RESPONSE_TYPE.TEXT,
                metadata: metadata.spineMetadata || null,
                parentResource: resource
            };
            var imageOptions = {
                crossOrigin: resource.crossOrigin,
                metadata: metadata.imageMetadata || null,
                parentResource: resource
            };
            var baseUrl = resource.url.substr(0, resource.url.lastIndexOf("/") + 1);
            baseUrl = baseUrl.replace(this.baseUrl, "");
            var adapter = metadata.images ? staticImageLoader(metadata.images) : metadata.image ? staticImageLoader({
                    "default": metadata.image
                }) : metadata.imageLoader ? metadata.imageLoader(this, resource.name + "_atlas_page_", baseUrl, imageOptions) :
                imageLoaderAdapter(this, resource.name + "_atlas_page_", baseUrl, imageOptions);
            var createSkeletonWithRawAtlas = function(rawData) {
                new pixi_spine.core.TextureAtlas(rawData, adapter, function(spineAtlas) {
                    var spineJsonParser = new pixi_spine.core.SkeletonJson(new pixi_spine.core.AtlasAttachmentLoader(spineAtlas));
                    if (metadataSkeletonScale) spineJsonParser.scale = metadataSkeletonScale;
                    resource.spineData = spineJsonParser.readSkeletonData(resource.data);
                    resource.spineAtlas = spineAtlas;
                    next()
                })
            };
            if (resource.metadata &&
                resource.metadata.atlasRawData) createSkeletonWithRawAtlas(resource.metadata.atlasRawData);
            else this.add(resource.name + "_atlas", atlasPath, atlasOptions, function(atlasResource) {
                createSkeletonWithRawAtlas(atlasResource.xhr.responseText)
            })
        }
    }
    pixi_spine.atlasParser = atlasParser;

    function imageLoaderAdapter(loader, namePrefix, baseUrl, imageOptions) {
        if (baseUrl && baseUrl.lastIndexOf("/") !== baseUrl.length - 1) baseUrl += "/";
        return function(line, callback) {
            var name = namePrefix + line;
            var url = baseUrl + line;
            loader.add(name,
                url, imageOptions,
                function(resource) {
                    callback(resource.texture.baseTexture)
                })
        }
    }
    pixi_spine.imageLoaderAdapter = imageLoaderAdapter;

    function syncImageLoaderAdapter(baseUrl, crossOrigin) {
        if (baseUrl && baseUrl.lastIndexOf("/") !== baseUrl.length - 1) baseUrl += "/";
        return function(line, callback) {
            callback(PIXI.BaseTexture.fromImage(line, crossOrigin))
        }
    }
    pixi_spine.syncImageLoaderAdapter = syncImageLoaderAdapter;

    function staticImageLoader(pages) {
        return function(line, callback) {
            var page = pages[line] || pages["default"];
            if (page &&
                page.baseTexture) callback(page.baseTexture);
            else callback(page)
        }
    }
    pixi_spine.staticImageLoader = staticImageLoader;
    PIXI.loaders.Loader.addPixiMiddleware(atlasParser);
    PIXI.loader.use(atlasParser())
})(pixi_spine || (pixi_spine = {}));
this.createjs = this.createjs || {},
    function() {
        var a = createjs.SoundJS = createjs.SoundJS || {};
        a.version = "NEXT", a.buildDate = "Thu, 08 Oct 2015 16:30:58 GMT"
    }(), this.createjs = this.createjs || {}, createjs.extend = function(a, b) {
        function c() {
            this.constructor = a
        }
        return c.prototype = b.prototype, a.prototype = new c
    }, this.createjs = this.createjs || {}, createjs.promote = function(a, b) {
        var c = a.prototype,
            d = Object.getPrototypeOf && Object.getPrototypeOf(c) || c.__proto__;
        if (d) {
            c[(b += "_") + "constructor"] = d.constructor;
            for (var e in d) c.hasOwnProperty(e) &&
                "function" == typeof d[e] && (c[b + e] = d[e])
        }
        return a
    }, this.createjs = this.createjs || {}, createjs.indexOf = function(a, b) {
        for (var c = 0, d = a.length; d > c; c++)
            if (b === a[c]) return c;
        return -1
    }, this.createjs = this.createjs || {},
    function() {
        createjs.proxy = function(a, b) {
            var c = Array.prototype.slice.call(arguments, 2);
            return function() {
                return a.apply(b, Array.prototype.slice.call(arguments, 0).concat(c))
            }
        }
    }(), this.createjs = this.createjs || {},
    function() {
        function BrowserDetect() {
            throw "BrowserDetect cannot be instantiated";
        }
        var a =
            BrowserDetect.agent = window.navigator.userAgent;
        BrowserDetect.isWindowPhone = a.indexOf("IEMobile") > -1 || a.indexOf("Windows Phone") > -1, BrowserDetect.isFirefox = a.indexOf("Firefox") > -1, BrowserDetect.isOpera = null != window.opera, BrowserDetect.isChrome = a.indexOf("Chrome") > -1, BrowserDetect.isIOS = (a.indexOf("iPod") > -1 || a.indexOf("iPhone") > -1 || a.indexOf("iPad") > -1) && !BrowserDetect.isWindowPhone, BrowserDetect.isAndroid = a.indexOf("Android") > -1 && !BrowserDetect.isWindowPhone, BrowserDetect.isBlackberry = a.indexOf("Blackberry") >
            -1, createjs.BrowserDetect = BrowserDetect
    }(), this.createjs = this.createjs || {},
    function() {
        function EventDispatcher() {
            this._listeners = null, this._captureListeners = null
        }
        var a = EventDispatcher.prototype;
        EventDispatcher.initialize = function(b) {
                b.addEventListener = a.addEventListener, b.on = a.on, b.removeEventListener = b.off = a.removeEventListener, b.removeAllEventListeners = a.removeAllEventListeners, b.hasEventListener = a.hasEventListener, b.dispatchEvent = a.dispatchEvent, b._dispatchEvent = a._dispatchEvent, b.willTrigger =
                    a.willTrigger
            }, a.addEventListener = function(a, b, c) {
                var d;
                d = c ? this._captureListeners = this._captureListeners || {} : this._listeners = this._listeners || {};
                var e = d[a];
                return e && this.removeEventListener(a, b, c), e = d[a], e ? e.push(b) : d[a] = [b], b
            }, a.on = function(a, b, c, d, e, f) {
                return b.handleEvent && (c = c || b, b = b.handleEvent), c = c || this, this.addEventListener(a, function(a) {
                    b.call(c, a, e), d && a.remove()
                }, f)
            }, a.removeEventListener = function(a, b, c) {
                var d = c ? this._captureListeners : this._listeners;
                if (d) {
                    var e = d[a];
                    if (e)
                        for (var f = 0,
                                g = e.length; g > f; f++)
                            if (e[f] == b) {
                                1 == g ? delete d[a] : e.splice(f, 1);
                                break
                            }
                }
            }, a.off = a.removeEventListener, a.removeAllEventListeners = function(a) {
                a ? (this._listeners && delete this._listeners[a], this._captureListeners && delete this._captureListeners[a]) : this._listeners = this._captureListeners = null
            }, a.dispatchEvent = function(a) {
                if ("string" == typeof a) {
                    var b = this._listeners;
                    if (!b || !b[a]) return !1;
                    a = new createjs.Event(a)
                } else a.target && a.clone && (a = a.clone());
                try {
                    a.target = this
                } catch (c) {}
                if (a.bubbles && this.parent) {
                    for (var d =
                            this, e = [d]; d.parent;) e.push(d = d.parent);
                    var f, g = e.length;
                    for (f = g - 1; f >= 0 && !a.propagationStopped; f--) e[f]._dispatchEvent(a, 1 + (0 == f));
                    for (f = 1; g > f && !a.propagationStopped; f++) e[f]._dispatchEvent(a, 3)
                } else this._dispatchEvent(a, 2);
                return a.defaultPrevented
            }, a.hasEventListener = function(a) {
                var b = this._listeners,
                    c = this._captureListeners;
                return !!(b && b[a] || c && c[a])
            }, a.willTrigger = function(a) {
                for (var b = this; b;) {
                    if (b.hasEventListener(a)) return !0;
                    b = b.parent
                }
                return !1
            }, a.toString = function() {
                return "[EventDispatcher]"
            },
            a._dispatchEvent = function(a, b) {
                var c, d = 1 == b ? this._captureListeners : this._listeners;
                if (a && d) {
                    var e = d[a.type];
                    if (!e || !(c = e.length)) return;
                    try {
                        a.currentTarget = this
                    } catch (f) {}
                    try {
                        a.eventPhase = b
                    } catch (f) {}
                    a.removed = !1, e = e.slice();
                    for (var g = 0; c > g && !a.immediatePropagationStopped; g++) {
                        var h = e[g];
                        h.handleEvent ? h.handleEvent(a) : h(a), a.removed && (this.off(a.type, h, 1 == b), a.removed = !1)
                    }
                }
            }, createjs.EventDispatcher = EventDispatcher
    }(), this.createjs = this.createjs || {},
    function() {
        function Event(a, b, c) {
            this.type = a, this.target =
                null, this.currentTarget = null, this.eventPhase = 0, this.bubbles = !!b, this.cancelable = !!c, this.timeStamp = (new Date).getTime(), this.defaultPrevented = !1, this.propagationStopped = !1, this.immediatePropagationStopped = !1, this.removed = !1
        }
        var a = Event.prototype;
        a.preventDefault = function() {
            this.defaultPrevented = this.cancelable && !0
        }, a.stopPropagation = function() {
            this.propagationStopped = !0
        }, a.stopImmediatePropagation = function() {
            this.immediatePropagationStopped = this.propagationStopped = !0
        }, a.remove = function() {
            this.removed = !0
        }, a.clone = function() {
            return new Event(this.type, this.bubbles, this.cancelable)
        }, a.set = function(a) {
            for (var b in a) this[b] = a[b];
            return this
        }, a.toString = function() {
            return "[Event (type=" + this.type + ")]"
        }, createjs.Event = Event
    }(), this.createjs = this.createjs || {},
    function() {
        function ErrorEvent(a, b, c) {
            this.Event_constructor("error"), this.title = a, this.message = b, this.data = c
        }
        var a = createjs.extend(ErrorEvent, createjs.Event);
        a.clone = function() {
                return new createjs.ErrorEvent(this.title, this.message, this.data)
            },
            createjs.ErrorEvent = createjs.promote(ErrorEvent, "Event")
    }(), this.createjs = this.createjs || {},
    function(a) {
        function ProgressEvent(a, b) {
            this.Event_constructor("progress"), this.loaded = a, this.total = null == b ? 1 : b, this.progress = 0 == b ? 0 : this.loaded / this.total
        }
        var b = createjs.extend(ProgressEvent, createjs.Event);
        b.clone = function() {
            return new createjs.ProgressEvent(this.loaded, this.total)
        }, createjs.ProgressEvent = createjs.promote(ProgressEvent, "Event")
    }(window), this.createjs = this.createjs || {},
    function() {
        function LoadItem() {
            this.src =
                null, this.type = null, this.id = null, this.maintainOrder = !1, this.callback = null, this.data = null, this.method = createjs.LoadItem.GET, this.values = null, this.headers = null, this.withCredentials = !1, this.mimeType = null, this.crossOrigin = null, this.loadTimeout = b.LOAD_TIMEOUT_DEFAULT
        }
        var a = LoadItem.prototype = {},
            b = LoadItem;
        b.LOAD_TIMEOUT_DEFAULT = 8E3, b.create = function(a) {
            if ("string" == typeof a) {
                var c = new LoadItem;
                return c.src = a, c
            }
            if (a instanceof b) return a;
            if (a instanceof Object && a.src) return null == a.loadTimeout && (a.loadTimeout =
                b.LOAD_TIMEOUT_DEFAULT), a;
            throw new Error("Type not recognized.");
        }, a.set = function(a) {
            for (var b in a) this[b] = a[b];
            return this
        }, createjs.LoadItem = b
    }(),
    function() {
        var a = {};
        a.ABSOLUTE_PATT = /^(?:\w+:)?\/{2}/i, a.RELATIVE_PATT = /^[./]*?\//i, a.EXTENSION_PATT = /\/?[^/]+\.(\w{1,5})$/i, a.parseURI = function(b) {
            var c = {
                absolute: !1,
                relative: !1
            };
            if (null == b) return c;
            var d = b.indexOf("?");
            d > -1 && (b = b.substr(0, d));
            var e;
            return a.ABSOLUTE_PATT.test(b) ? c.absolute = !0 : a.RELATIVE_PATT.test(b) && (c.relative = !0), (e = b.match(a.EXTENSION_PATT)) &&
                (c.extension = e[1].toLowerCase()), c
        }, a.formatQueryString = function(a, b) {
            if (null == a) throw new Error("You must specify data.");
            var c = [];
            for (var d in a) c.push(d + "=" + escape(a[d]));
            return b && (c = c.concat(b)), c.join("&")
        }, a.buildPath = function(a, b) {
            if (null == b) return a;
            var c = [],
                d = a.indexOf("?");
            if (-1 != d) {
                var e = a.slice(d + 1);
                c = c.concat(e.split("&"))
            }
            return -1 != d ? a.slice(0, d) + "?" + this._formatQueryString(b, c) : a + "?" + this._formatQueryString(b, c)
        }, a.isCrossDomain = function(a) {
            var b = document.createElement("a");
            b.href =
                a.src;
            var c = document.createElement("a");
            c.href = location.href;
            var d = "" != b.hostname && (b.port != c.port || b.protocol != c.protocol || b.hostname != c.hostname);
            return d
        }, a.isLocal = function(a) {
            var b = document.createElement("a");
            return b.href = a.src, "" == b.hostname && "file:" == b.protocol
        }, a.isBinary = function(a) {
            switch (a) {
                case createjs.AbstractLoader.IMAGE:
                case createjs.AbstractLoader.BINARY:
                    return !0;
                default:
                    return !1
            }
        }, a.isImageTag = function(a) {
            return a instanceof HTMLImageElement
        }, a.isAudioTag = function(a) {
            return window.HTMLAudioElement ?
                a instanceof HTMLAudioElement : !1
        }, a.isVideoTag = function(a) {
            return window.HTMLVideoElement ? a instanceof HTMLVideoElement : !1
        }, a.isText = function(a) {
            switch (a) {
                case createjs.AbstractLoader.TEXT:
                case createjs.AbstractLoader.JSON:
                case createjs.AbstractLoader.MANIFEST:
                case createjs.AbstractLoader.XML:
                case createjs.AbstractLoader.CSS:
                case createjs.AbstractLoader.SVG:
                case createjs.AbstractLoader.JAVASCRIPT:
                case createjs.AbstractLoader.SPRITESHEET:
                    return !0;
                default:
                    return !1
            }
        }, a.getTypeByExtension = function(a) {
            if (null ==
                a) return createjs.AbstractLoader.TEXT;
            switch (a.toLowerCase()) {
                case "jpeg":
                case "jpg":
                case "gif":
                case "png":
                case "webp":
                case "bmp":
                    return createjs.AbstractLoader.IMAGE;
                case "ogg":
                case "mp3":
                case "webm":
                    return createjs.AbstractLoader.SOUND;
                case "mp4":
                case "webm":
                case "ts":
                    return createjs.AbstractLoader.VIDEO;
                case "json":
                    return createjs.AbstractLoader.JSON;
                case "xml":
                    return createjs.AbstractLoader.XML;
                case "css":
                    return createjs.AbstractLoader.CSS;
                case "js":
                    return createjs.AbstractLoader.JAVASCRIPT;
                case "svg":
                    return createjs.AbstractLoader.SVG;
                default:
                    return createjs.AbstractLoader.TEXT
            }
        }, createjs.RequestUtils = a
    }(), this.createjs = this.createjs || {},
    function() {
        function AbstractLoader(a, b, c) {
            this.EventDispatcher_constructor(), this.loaded = !1, this.canceled = !1, this.progress = 0, this.type = c, this.resultFormatter = null, a ? this._item = createjs.LoadItem.create(a) : this._item = null, this._preferXHR = b, this._result = null, this._rawResult = null, this._loadedItems = null, this._tagSrcAttribute = null, this._tag = null
        }
        var a = createjs.extend(AbstractLoader, createjs.EventDispatcher),
            b = AbstractLoader;
        b.POST = "POST", b.GET = "GET", b.BINARY = "binary", b.CSS = "css", b.IMAGE = "image", b.JAVASCRIPT = "javascript", b.JSON = "json", b.JSONP = "jsonp", b.MANIFEST = "manifest", b.SOUND = "sound", b.VIDEO = "video", b.SPRITESHEET = "spritesheet", b.SVG = "svg", b.TEXT = "text", b.XML = "xml", a.getItem = function() {
            return this._item
        }, a.getResult = function(a) {
            return a ? this._rawResult : this._result
        }, a.getTag = function() {
            return this._tag
        }, a.setTag = function(a) {
            this._tag = a
        }, a.load = function() {
            this._createRequest(), this._request.on("complete",
                this, this), this._request.on("progress", this, this), this._request.on("loadStart", this, this), this._request.on("abort", this, this), this._request.on("timeout", this, this), this._request.on("error", this, this);
            var a = new createjs.Event("initialize");
            a.loader = this._request, this.dispatchEvent(a), this._request.load()
        }, a.cancel = function() {
            this.canceled = !0, this.destroy()
        }, a.destroy = function() {
            this._request && (this._request.removeAllEventListeners(), this._request.destroy()), this._request = null, this._item = null, this._rawResult =
                null, this._result = null, this._loadItems = null, this.removeAllEventListeners()
        }, a.getLoadedItems = function() {
            return this._loadedItems
        }, a._createRequest = function() {
            this._preferXHR ? this._request = new createjs.XHRRequest(this._item) : this._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute)
        }, a._createTag = function(a) {
            return null
        }, a._sendLoadStart = function() {
            this._isCanceled() || this.dispatchEvent("loadstart")
        }, a._sendProgress = function(a) {
            if (!this._isCanceled()) {
                var b =
                    null;
                "number" == typeof a ? (this.progress = a, b = new createjs.ProgressEvent(this.progress)) : (b = a, this.progress = a.loaded / a.total, b.progress = this.progress, (isNaN(this.progress) || this.progress == 1 / 0) && (this.progress = 0)), this.hasEventListener("progress") && this.dispatchEvent(b)
            }
        }, a._sendComplete = function() {
            if (!this._isCanceled()) {
                this.loaded = !0;
                var a = new createjs.Event("complete");
                a.rawResult = this._rawResult, null != this._result && (a.result = this._result), this.dispatchEvent(a)
            }
        }, a._sendError = function(a) {
            !this._isCanceled() &&
                this.hasEventListener("error") && (null == a && (a = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY")), this.dispatchEvent(a))
        }, a._isCanceled = function() {
            return null == window.createjs || this.canceled ? !0 : !1
        }, a.resultFormatter = null, a.handleEvent = function(a) {
            switch (a.type) {
                case "complete":
                    this._rawResult = a.target._response;
                    var b = this.resultFormatter && this.resultFormatter(this),
                        c = this;
                    b instanceof Function ? b(function(a) {
                        c._result = a, c._sendComplete()
                    }) : (this._result = b || this._rawResult, this._sendComplete());
                    break;
                case "progress":
                    this._sendProgress(a);
                    break;
                case "error":
                    this._sendError(a);
                    break;
                case "loadstart":
                    this._sendLoadStart();
                    break;
                case "abort":
                case "timeout":
                    this._isCanceled() || this.dispatchEvent(a.type)
            }
        }, a.buildPath = function(a, b) {
            return createjs.RequestUtils.buildPath(a, b)
        }, a.toString = function() {
            return "[PreloadJS AbstractLoader]"
        }, createjs.AbstractLoader = createjs.promote(AbstractLoader, "EventDispatcher")
    }(), this.createjs = this.createjs || {},
    function() {
        function AbstractMediaLoader(a, b, c) {
            this.AbstractLoader_constructor(a, b, c), this.resultFormatter =
                this._formatResult, this._tagSrcAttribute = "src"
        }
        var a = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);
        a.load = function() {
            this._tag || (this._tag = this._createTag(this._item.src)), this._tag.preload = "auto", this._tag.load(), this.AbstractLoader_load()
        }, a._createTag = function() {}, a._createRequest = function() {
            this._preferXHR ? this._request = new createjs.XHRRequest(this._item) : this._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute)
        }, a._formatResult = function(a) {
            return this._tag.removeEventListener &&
                this._tag.removeEventListener("canplaythrough", this._loadedHandler), this._tag.onstalled = null, this._preferXHR && (a.getTag().src = a.getResult(!0)), a.getTag()
        }, createjs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, "AbstractLoader")
    }(), this.createjs = this.createjs || {},
    function() {
        var AbstractRequest = function(a) {
                this._item = a
            },
            a = createjs.extend(AbstractRequest, createjs.EventDispatcher);
        a.load = function() {}, a.destroy = function() {}, a.cancel = function() {}, createjs.AbstractRequest = createjs.promote(AbstractRequest,
            "EventDispatcher")
    }(), this.createjs = this.createjs || {},
    function() {
        function TagRequest(a, b, c) {
            this.AbstractRequest_constructor(a), this._tag = b, this._tagSrcAttribute = c, this._loadedHandler = createjs.proxy(this._handleTagComplete, this), this._addedToDOM = !1, this._startTagVisibility = null
        }
        var a = createjs.extend(TagRequest, createjs.AbstractRequest);
        a.load = function() {
            this._tag.onload = createjs.proxy(this._handleTagComplete, this), this._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this), this._tag.onerror =
                createjs.proxy(this._handleError, this);
            var a = new createjs.Event("initialize");
            a.loader = this._tag, this.dispatchEvent(a), this._hideTag(), this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout), this._tag[this._tagSrcAttribute] = this._item.src, null == this._tag.parentNode && (window.document.body.appendChild(this._tag), this._addedToDOM = !0)
        }, a.destroy = function() {
            this._clean(), this._tag = null, this.AbstractRequest_destroy()
        }, a._handleReadyStateChange = function() {
            clearTimeout(this._loadTimeout);
            var a = this._tag;
            ("loaded" == a.readyState || "complete" == a.readyState) && this._handleTagComplete()
        }, a._handleError = function() {
            this._clean(), this.dispatchEvent("error")
        }, a._handleTagComplete = function() {
            this._rawResult = this._tag, this._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult, this._clean(), this._showTag(), this.dispatchEvent("complete")
        }, a._handleTimeout = function() {
            this._clean(), this.dispatchEvent(new createjs.Event("timeout"))
        }, a._clean = function() {
            this._tag.onload = null, this._tag.onreadystatechange =
                null, this._tag.onerror = null, this._addedToDOM && null != this._tag.parentNode && this._tag.parentNode.removeChild(this._tag), clearTimeout(this._loadTimeout)
        }, a._hideTag = function() {
            this._startTagVisibility = this._tag.style.visibility, this._tag.style.visibility = "hidden"
        }, a._showTag = function() {
            this._tag.style.visibility = this._startTagVisibility
        }, a._handleStalled = function() {}, createjs.TagRequest = createjs.promote(TagRequest, "AbstractRequest")
    }(), this.createjs = this.createjs || {},
    function() {
        function MediaTagRequest(a,
            b, c) {
            this.AbstractRequest_constructor(a), this._tag = b, this._tagSrcAttribute = c, this._loadedHandler = createjs.proxy(this._handleTagComplete, this)
        }
        var a = createjs.extend(MediaTagRequest, createjs.TagRequest);
        a.load = function() {
            var a = createjs.proxy(this._handleStalled, this);
            this._stalledCallback = a;
            var b = createjs.proxy(this._handleProgress, this);
            this._handleProgress = b, this._tag.addEventListener("stalled", a), this._tag.addEventListener("progress", b), this._tag.addEventListener && this._tag.addEventListener("canplaythrough",
                this._loadedHandler, !1), this.TagRequest_load()
        }, a._handleReadyStateChange = function() {
            clearTimeout(this._loadTimeout);
            var a = this._tag;
            ("loaded" == a.readyState || "complete" == a.readyState) && this._handleTagComplete()
        }, a._handleStalled = function() {}, a._handleProgress = function(a) {
            if (a && !(a.loaded > 0 && 0 == a.total)) {
                var b = new createjs.ProgressEvent(a.loaded, a.total);
                this.dispatchEvent(b)
            }
        }, a._clean = function() {
            this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler), this._tag.removeEventListener("stalled",
                this._stalledCallback), this._tag.removeEventListener("progress", this._progressCallback), this.TagRequest__clean()
        }, createjs.MediaTagRequest = createjs.promote(MediaTagRequest, "TagRequest")
    }(), this.createjs = this.createjs || {},
    function() {
        function XHRRequest(a) {
            this.AbstractRequest_constructor(a), this._request = null, this._loadTimeout = null, this._xhrLevel = 1, this._response = null, this._rawResponse = null, this._canceled = !1, this._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this), this._handleProgressProxy =
                createjs.proxy(this._handleProgress, this), this._handleAbortProxy = createjs.proxy(this._handleAbort, this), this._handleErrorProxy = createjs.proxy(this._handleError, this), this._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this), this._handleLoadProxy = createjs.proxy(this._handleLoad, this), this._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this), !this._createXHR(a)
        }
        var a = createjs.extend(XHRRequest, createjs.AbstractRequest);
        XHRRequest.ACTIVEX_VERSIONS = ["Msxml2.XMLHTTP.6.0",
                "Msxml2.XMLHTTP.5.0", "Msxml2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"
            ], a.getResult = function(a) {
                return a && this._rawResponse ? this._rawResponse : this._response
            }, a.cancel = function() {
                this.canceled = !0, this._clean(), this._request.abort()
            }, a.load = function() {
                if (null == this._request) return void this._handleError();
                this._request.addEventListener("loadstart", this._handleLoadStartProxy, !1), this._request.addEventListener("progress", this._handleProgressProxy, !1), this._request.addEventListener("abort",
                    this._handleAbortProxy, !1), this._request.addEventListener("error", this._handleErrorProxy, !1), this._request.addEventListener("timeout", this._handleTimeoutProxy, !1), this._request.addEventListener("load", this._handleLoadProxy, !1), this._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, !1), 1 == this._xhrLevel && (this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout));
                try {
                    this._item.values && this._item.method != createjs.AbstractLoader.GET ? this._item.method ==
                        createjs.AbstractLoader.POST && this._request.send(createjs.RequestUtils.formatQueryString(this._item.values)) : this._request.send()
                } catch (a) {
                    this.dispatchEvent(new createjs.ErrorEvent("XHR_SEND", null, a))
                }
            }, a.setResponseType = function(a) {
                this._request.responseType = a
            }, a.getAllResponseHeaders = function() {
                return this._request.getAllResponseHeaders instanceof Function ? this._request.getAllResponseHeaders() : null
            }, a.getResponseHeader = function(a) {
                return this._request.getResponseHeader instanceof Function ? this._request.getResponseHeader(a) :
                    null
            }, a._handleProgress = function(a) {
                if (a && !(a.loaded > 0 && 0 == a.total)) {
                    var b = new createjs.ProgressEvent(a.loaded, a.total);
                    this.dispatchEvent(b)
                }
            }, a._handleLoadStart = function(a) {
                clearTimeout(this._loadTimeout), this.dispatchEvent("loadstart")
            }, a._handleAbort = function(a) {
                this._clean(), this.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED", null, a))
            }, a._handleError = function(a) {
                this._clean(), this.dispatchEvent(new createjs.ErrorEvent(a.message))
            }, a._handleReadyStateChange = function(a) {
                4 == this._request.readyState &&
                    this._handleLoad()
            }, a._handleLoad = function(a) {
                if (!this.loaded) {
                    this.loaded = !0;
                    var b = this._checkError();
                    if (b) return void this._handleError(b);
                    this._response = this._getResponse(), this._clean(), this.dispatchEvent(new createjs.Event("complete"))
                }
            }, a._handleTimeout = function(a) {
                this._clean(), this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT", null, a))
            }, a._checkError = function() {
                var a = parseInt(this._request.status);
                switch (a) {
                    case 404:
                    case 0:
                        return new Error(a)
                }
                return null
            }, a._getResponse = function() {
                if (null !=
                    this._response) return this._response;
                if (null != this._request.response) return this._request.response;
                try {
                    if (null != this._request.responseText) return this._request.responseText
                } catch (a) {}
                try {
                    if (null != this._request.responseXML) return this._request.responseXML
                } catch (a) {}
                return null
            }, a._createXHR = function(a) {
                var b = createjs.RequestUtils.isCrossDomain(a),
                    c = {},
                    d = null;
                if (window.XMLHttpRequest) d = new XMLHttpRequest, b && void 0 === d.withCredentials && window.XDomainRequest && (d = new XDomainRequest);
                else {
                    for (var e = 0, f =
                            s.ACTIVEX_VERSIONS.length; f > e; e++) {
                        s.ACTIVEX_VERSIONS[e];
                        try {
                            d = new ActiveXObject(axVersions);
                            break
                        } catch (g) {}
                    }
                    if (null == d) return !1
                }
                null == a.mimeType && createjs.RequestUtils.isText(a.type) && (a.mimeType = "text/plain; charset=utf-8"), a.mimeType && d.overrideMimeType && d.overrideMimeType(a.mimeType), this._xhrLevel = "string" == typeof d.responseType ? 2 : 1;
                var h = null;
                if (h = a.method == createjs.AbstractLoader.GET ? createjs.RequestUtils.buildPath(a.src, a.values) : a.src, d.open(a.method || createjs.AbstractLoader.GET, h, !0), b &&
                    d instanceof XMLHttpRequest && 1 == this._xhrLevel && (c.Origin = location.origin), a.values && a.method == createjs.AbstractLoader.POST && (c["Content-Type"] = "application/x-www-form-urlencoded"), b || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest"), a.headers)
                    for (var i in a.headers) c[i] = a.headers[i];
                for (i in c) d.setRequestHeader(i, c[i]);
                return d instanceof XMLHttpRequest && void 0 !== a.withCredentials && (d.withCredentials = a.withCredentials), this._request = d, !0
            }, a._clean = function() {
                clearTimeout(this._loadTimeout),
                    this._request.removeEventListener("loadstart", this._handleLoadStartProxy), this._request.removeEventListener("progress", this._handleProgressProxy), this._request.removeEventListener("abort", this._handleAbortProxy), this._request.removeEventListener("error", this._handleErrorProxy), this._request.removeEventListener("timeout", this._handleTimeoutProxy), this._request.removeEventListener("load", this._handleLoadProxy), this._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy)
            },
            a.toString = function() {
                return "[PreloadJS XHRRequest]"
            }, createjs.XHRRequest = createjs.promote(XHRRequest, "AbstractRequest")
    }(), this.createjs = this.createjs || {},
    function() {
        function SoundLoader(a, b) {
            this.AbstractMediaLoader_constructor(a, b, createjs.AbstractLoader.SOUND), createjs.RequestUtils.isAudioTag(a) ? this._tag = a : createjs.RequestUtils.isAudioTag(a.src) ? this._tag = a : createjs.RequestUtils.isAudioTag(a.tag) && (this._tag = createjs.RequestUtils.isAudioTag(a) ? a : a.src), null != this._tag && (this._preferXHR = !1)
        }
        var a =
            createjs.extend(SoundLoader, createjs.AbstractMediaLoader),
            b = SoundLoader;
        b.canLoadItem = function(a) {
            return a.type == createjs.AbstractLoader.SOUND
        }, a._createTag = function(a) {
            var b = document.createElement("audio");
            return b.autoplay = !1, b.preload = "none", b.src = a, b
        }, createjs.SoundLoader = createjs.promote(SoundLoader, "AbstractMediaLoader")
    }(), this.createjs = this.createjs || {},
    function() {
        var PlayPropsConfig = function() {
                this.interrupt = null, this.delay = null, this.offset = null, this.loop = null, this.volume = null, this.pan = null,
                    this.startTime = null, this.duration = null
            },
            a = PlayPropsConfig.prototype = {},
            b = PlayPropsConfig;
        b.create = function(a) {
            if (a instanceof b || a instanceof Object) {
                var c = new createjs.PlayPropsConfig;
                return c.set(a), c
            }
            throw new Error("Type not recognized.");
        }, a.set = function(a) {
            for (var b in a) this[b] = a[b];
            return this
        }, a.toString = function() {
            return "[PlayPropsConfig]"
        }, createjs.PlayPropsConfig = b
    }(), this.createjs = this.createjs || {},
    function() {
        function Sound() {
            throw "Sound cannot be instantiated";
        }

        function a(a, b) {
            this.init(a,
                b)
        }
        var b = Sound;
        b.INTERRUPT_ANY = "any", b.INTERRUPT_EARLY = "early", b.INTERRUPT_LATE = "late", b.INTERRUPT_NONE = "none", b.PLAY_INITED = "playInited", b.PLAY_SUCCEEDED = "playSucceeded", b.PLAY_INTERRUPTED = "playInterrupted", b.PLAY_FINISHED = "playFinished", b.PLAY_FAILED = "playFailed", b.SUPPORTED_EXTENSIONS = ["mp3", "ogg", "opus", "mpeg", "wav", "m4a", "mp4", "aiff", "wma", "mid"], b.EXTENSION_MAP = {
                m4a: "mp4"
            }, b.FILE_PATTERN = /^(?:(\w+:)\/{2}(\w+(?:\.\w+)*\/?))?([/.]*?(?:[^?]+)?\/)?((?:[^/?]+)\.(\w+))(?:\?(\S+)?)?$/, b.defaultInterruptBehavior =
            b.INTERRUPT_NONE, b.alternateExtensions = [], b.activePlugin = null, b._masterVolume = 1, Object.defineProperty(b, "volume", {
                get: function() {
                    return this._masterVolume
                },
                set: function(a) {
                    if (null == Number(a)) return !1;
                    if (a = Math.max(0, Math.min(1, a)), b._masterVolume = a, !this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(a))
                        for (var c = this._instances, d = 0, e = c.length; e > d; d++) c[d].setMasterVolume(a)
                }
            }), b._masterMute = !1, Object.defineProperty(b, "muted", {
                get: function() {
                    return this._masterMute
                },
                set: function(a) {
                    if (null ==
                        a) return !1;
                    if (this._masterMute = a, !this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(a))
                        for (var b = this._instances, c = 0, d = b.length; d > c; c++) b[c].setMasterMute(a);
                    return !0
                }
            }), Object.defineProperty(b, "capabilities", {
                get: function() {
                    return null == b.activePlugin ? null : b.activePlugin._capabilities
                },
                set: function(a) {
                    return !1
                }
            }), b._pluginsRegistered = !1, b._lastID = 0, b._instances = [], b._idHash = {}, b._preloadHash = {}, b._defaultPlayPropsHash = {}, b.addEventListener = null, b.removeEventListener = null,
            b.removeAllEventListeners = null, b.dispatchEvent = null, b.hasEventListener = null, b._listeners = null, createjs.EventDispatcher.initialize(b), b.getPreloadHandlers = function() {
                return {
                    callback: createjs.proxy(b.initLoad, b),
                    types: ["sound"],
                    extensions: b.SUPPORTED_EXTENSIONS
                }
            }, b._handleLoadComplete = function(a) {
                var c = a.target.getItem().src;
                if (b._preloadHash[c])
                    for (var d = 0, e = b._preloadHash[c].length; e > d; d++) {
                        var f = b._preloadHash[c][d];
                        if (b._preloadHash[c][d] = !0, b.hasEventListener("fileload")) {
                            var a = new createjs.Event("fileload");
                            a.src = f.src, a.id = f.id, a.data = f.data, a.sprite = f.sprite, b.dispatchEvent(a)
                        }
                    }
            }, b._handleLoadError = function(a) {
                var c = a.target.getItem().src;
                if (b._preloadHash[c])
                    for (var d = 0, e = b._preloadHash[c].length; e > d; d++) {
                        var f = b._preloadHash[c][d];
                        if (b._preloadHash[c][d] = !1, b.hasEventListener("fileerror")) {
                            var a = new createjs.Event("fileerror");
                            a.src = f.src, a.id = f.id, a.data = f.data, a.sprite = f.sprite, b.dispatchEvent(a)
                        }
                    }
            }, b._registerPlugin = function(a) {
                return a.isSupported() ? (b.activePlugin = new a, !0) : !1
            }, b.registerPlugins =
            function(a) {
                b._pluginsRegistered = !0;
                for (var c = 0, d = a.length; d > c; c++)
                    if (b._registerPlugin(a[c])) return !0;
                return !1
            }, b.initializeDefaultPlugins = function() {
                return null != b.activePlugin ? !0 : b._pluginsRegistered ? !1 : b.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin]) ? !0 : !1
            }, b.isReady = function() {
                return null != b.activePlugin
            }, b.getCapabilities = function() {
                return null == b.activePlugin ? null : b.activePlugin._capabilities
            }, b.getCapability = function(a) {
                return null == b.activePlugin ? null : b.activePlugin._capabilities[a]
            },
            b.initLoad = function(a) {
                return b._registerSound(a)
            }, b._registerSound = function(c) {
                if (!b.initializeDefaultPlugins()) return !1;
                var d;
                if (c.src instanceof Object ? (d = b._parseSrc(c.src), d.src = c.path + d.src) : d = b._parsePath(c.src), null == d) return !1;
                c.src = d.src, c.type = "sound";
                var e = c.data,
                    f = null;
                if (null != e && (isNaN(e.channels) ? isNaN(e) || (f = parseInt(e)) : f = parseInt(e.channels), e.audioSprite))
                    for (var g, h = e.audioSprite.length; h--;) g = e.audioSprite[h], b._idHash[g.id] = {
                            src: c.src,
                            startTime: parseInt(g.startTime),
                            duration: parseInt(g.duration)
                        },
                        g.defaultPlayProps && (b._defaultPlayPropsHash[g.id] = createjs.PlayPropsConfig.create(g.defaultPlayProps));
                null != c.id && (b._idHash[c.id] = {
                    src: c.src
                });
                var i = b.activePlugin.register(c);
                return a.create(c.src, f), null != e && isNaN(e) ? c.data.channels = f || a.maxPerChannel() : c.data = f || a.maxPerChannel(), i.type && (c.type = i.type), c.defaultPlayProps && (b._defaultPlayPropsHash[c.src] = createjs.PlayPropsConfig.create(c.defaultPlayProps)), i
            }, b.registerSound = function(a, c, d, e, f) {
                var g = {
                    src: a,
                    id: c,
                    data: d,
                    defaultPlayProps: f
                };
                a instanceof
                Object && a.src && (e = c, g = a), g = createjs.LoadItem.create(g), g.path = e, null == e || g.src instanceof Object || (g.src = e + a);
                var h = b._registerSound(g);
                if (!h) return !1;
                if (b._preloadHash[g.src] || (b._preloadHash[g.src] = []), b._preloadHash[g.src].push(g), 1 == b._preloadHash[g.src].length) h.on("complete", createjs.proxy(this._handleLoadComplete, this)), h.on("error", createjs.proxy(this._handleLoadError, this)), b.activePlugin.preload(h);
                else if (1 == b._preloadHash[g.src][0]) return !0;
                return g
            }, b.registerSounds = function(a, b) {
                var c = [];
                a.path && (b ? b += a.path : b = a.path, a = a.manifest);
                for (var d = 0, e = a.length; e > d; d++) c[d] = createjs.Sound.registerSound(a[d].src, a[d].id, a[d].data, b, a[d].defaultPlayProps);
                return c
            }, b.removeSound = function(c, d) {
                if (null == b.activePlugin) return !1;
                c instanceof Object && c.src && (c = c.src);
                var e;
                if (c instanceof Object ? e = b._parseSrc(c) : (c = b._getSrcById(c).src, e = b._parsePath(c)), null == e) return !1;
                c = e.src, null != d && (c = d + c);
                for (var f in b._idHash) b._idHash[f].src == c && delete b._idHash[f];
                return a.removeSrc(c), delete b._preloadHash[c],
                    b.activePlugin.removeSound(c), !0
            }, b.removeSounds = function(a, b) {
                var c = [];
                a.path && (b ? b += a.path : b = a.path, a = a.manifest);
                for (var d = 0, e = a.length; e > d; d++) c[d] = createjs.Sound.removeSound(a[d].src, b);
                return c
            }, b.removeAllSounds = function() {
                b._idHash = {}, b._preloadHash = {}, a.removeAll(), b.activePlugin && b.activePlugin.removeAllSounds()
            }, b.loadComplete = function(a) {
                if (!b.isReady()) return !1;
                var c = b._parsePath(a);
                return a = c ? b._getSrcById(c.src).src : b._getSrcById(a).src, void 0 == b._preloadHash[a] ? !1 : 1 == b._preloadHash[a][0]
            },
            b._parsePath = function(a) {
                "string" != typeof a && (a = a.toString());
                var c = a.match(b.FILE_PATTERN);
                if (null == c) return !1;
                for (var d = c[4], e = c[5], f = b.capabilities, g = 0; !f[e];)
                    if (e = b.alternateExtensions[g++], g > b.alternateExtensions.length) return null;
                a = a.replace("." + c[5], "." + e);
                var h = {
                    name: d,
                    src: a,
                    extension: e
                };
                return h
            }, b._parseSrc = function(a) {
                var c = {
                        name: void 0,
                        src: void 0,
                        extension: void 0
                    },
                    d = b.capabilities;
                for (var e in a)
                    if (a.hasOwnProperty(e) && d[e]) {
                        c.src = a[e], c.extension = e;
                        break
                    }
                if (!c.src) return !1;
                var f = c.src.lastIndexOf("/");
                return -1 != f ? c.name = c.src.slice(f + 1) : c.name = c.src, c
            }, b.play = function(a, c, d, e, f, g, h, i, j) {
                var k;
                k = c instanceof Object || c instanceof createjs.PlayPropsConfig ? createjs.PlayPropsConfig.create(c) : createjs.PlayPropsConfig.create({
                    interrupt: c,
                    delay: d,
                    offset: e,
                    loop: f,
                    volume: g,
                    pan: h,
                    startTime: i,
                    duration: j
                });
                var l = b.createInstance(a, k.startTime, k.duration),
                    m = b._playInstance(l, k);
                return m || l._playFailed(), l
            }, b.createInstance = function(c, d, e) {
                if (!b.initializeDefaultPlugins()) return new createjs.DefaultSoundInstance(c,
                    d, e);
                var f = b._defaultPlayPropsHash[c];
                c = b._getSrcById(c);
                var g = b._parsePath(c.src),
                    h = null;
                return null != g && null != g.src ? (a.create(g.src), null == d && (d = c.startTime), h = b.activePlugin.create(g.src, d, e || c.duration), f = f || b._defaultPlayPropsHash[g.src], f && h.applyPlayProps(f)) : h = new createjs.DefaultSoundInstance(c, d, e), h.uniqueId = b._lastID++, h
            }, b.stop = function() {
                for (var a = this._instances, b = a.length; b--;) a[b].stop()
            }, b.setVolume = function(a) {
                if (null == Number(a)) return !1;
                if (a = Math.max(0, Math.min(1, a)), b._masterVolume =
                    a, !this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(a))
                    for (var c = this._instances, d = 0, e = c.length; e > d; d++) c[d].setMasterVolume(a)
            }, b.getVolume = function() {
                return this._masterVolume
            }, b.setMute = function(a) {
                if (null == a) return !1;
                if (this._masterMute = a, !this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(a))
                    for (var b = this._instances, c = 0, d = b.length; d > c; c++) b[c].setMasterMute(a);
                return !0
            }, b.getMute = function() {
                return this._masterMute
            }, b.setDefaultPlayProps = function(a,
                c) {
                a = b._getSrcById(a), b._defaultPlayPropsHash[b._parsePath(a.src).src] = createjs.PlayPropsConfig.create(c)
            }, b.getDefaultPlayProps = function(a) {
                return a = b._getSrcById(a), b._defaultPlayPropsHash[b._parsePath(a.src).src]
            }, b._playInstance = function(a, c) {
                var d = b._defaultPlayPropsHash[a.src] || {};
                if (null == c.interrupt && (c.interrupt = d.interrupt || b.defaultInterruptBehavior), null == c.delay && (c.delay = d.delay || 0), null == c.offset && (c.offset = a.getPosition()), null == c.loop && (c.loop = a.loop), null == c.volume && (c.volume = a.volume),
                    null == c.pan && (c.pan = a.pan), 0 == c.delay) {
                    var e = b._beginPlaying(a, c);
                    if (!e) return !1
                } else {
                    var f = setTimeout(function() {
                        b._beginPlaying(a, c)
                    }, c.delay);
                    a.delayTimeoutId = f
                }
                return this._instances.push(a), !0
            }, b._beginPlaying = function(b, c) {
                if (!a.add(b, c.interrupt)) return !1;
                var d = b._beginPlaying(c);
                if (!d) {
                    var e = createjs.indexOf(this._instances, b);
                    return e > -1 && this._instances.splice(e, 1), !1
                }
                return !0
            }, b._getSrcById = function(a) {
                return b._idHash[a] || {
                    src: a
                }
            }, b._playFinished = function(b) {
                a.remove(b);
                var c = createjs.indexOf(this._instances,
                    b);
                c > -1 && this._instances.splice(c, 1)
            }, createjs.Sound = Sound, a.channels = {}, a.create = function(b, c) {
                var d = a.get(b);
                return null == d ? (a.channels[b] = new a(b, c), !0) : !1
            }, a.removeSrc = function(b) {
                var c = a.get(b);
                return null == c ? !1 : (c._removeAll(), delete a.channels[b], !0)
            }, a.removeAll = function() {
                for (var b in a.channels) a.channels[b]._removeAll();
                a.channels = {}
            }, a.add = function(b, c) {
                var d = a.get(b.src);
                return null == d ? !1 : d._add(b, c)
            }, a.remove = function(b) {
                var c = a.get(b.src);
                return null == c ? !1 : (c._remove(b), !0)
            }, a.maxPerChannel =
            function() {
                return c.maxDefault
            }, a.get = function(b) {
                return a.channels[b]
            };
        var c = a.prototype;
        c.constructor = a, c.src = null, c.max = null, c.maxDefault = 100, c.length = 0, c.init = function(a, b) {
            this.src = a, this.max = b || this.maxDefault, -1 == this.max && (this.max = this.maxDefault), this._instances = []
        }, c._get = function(a) {
            return this._instances[a]
        }, c._add = function(a, b) {
            return this._getSlot(b, a) ? (this._instances.push(a), this.length++, !0) : !1
        }, c._remove = function(a) {
            var b = createjs.indexOf(this._instances, a);
            return -1 == b ? !1 : (this._instances.splice(b,
                1), this.length--, !0)
        }, c._removeAll = function() {
            for (var a = this.length - 1; a >= 0; a--) this._instances[a].stop()
        }, c._getSlot = function(a, b) {
            var c, d;
            if (a != Sound.INTERRUPT_NONE && (d = this._get(0), null == d)) return !0;
            for (var e = 0, f = this.max; f > e; e++) {
                if (c = this._get(e), null == c) return !0;
                if (c.playState == Sound.PLAY_FINISHED || c.playState == Sound.PLAY_INTERRUPTED || c.playState == Sound.PLAY_FAILED) {
                    d = c;
                    break
                }
                a != Sound.INTERRUPT_NONE && (a == Sound.INTERRUPT_EARLY && c.getPosition() < d.getPosition() || a == Sound.INTERRUPT_LATE && c.getPosition() >
                    d.getPosition()) && (d = c)
            }
            return null != d ? (d._interrupt(), this._remove(d), !0) : !1
        }, c.toString = function() {
            return "[Sound SoundChannel]"
        }
    }(), this.createjs = this.createjs || {},
    function() {
        var AbstractSoundInstance = function(a, b, c, d) {
                this.EventDispatcher_constructor(), this.src = a, this.uniqueId = -1, this.playState = null, this.delayTimeoutId = null, this._volume = 1, Object.defineProperty(this, "volume", {
                        get: this.getVolume,
                        set: this.setVolume
                    }), this._pan = 0, Object.defineProperty(this, "pan", {
                        get: this.getPan,
                        set: this.setPan
                    }),
                    this._startTime = Math.max(0, b || 0), Object.defineProperty(this, "startTime", {
                        get: this.getStartTime,
                        set: this.setStartTime
                    }), this._duration = Math.max(0, c || 0), Object.defineProperty(this, "duration", {
                        get: this.getDuration,
                        set: this.setDuration
                    }), this._playbackResource = null, Object.defineProperty(this, "playbackResource", {
                        get: this.getPlaybackResource,
                        set: this.setPlaybackResource
                    }), d !== !1 && d !== !0 && this.setPlaybackResource(d), this._position = 0, Object.defineProperty(this, "position", {
                        get: this.getPosition,
                        set: this.setPosition
                    }),
                    this._loop = 0, Object.defineProperty(this, "loop", {
                        get: this.getLoop,
                        set: this.setLoop
                    }), this._muted = !1, Object.defineProperty(this, "muted", {
                        get: this.getMuted,
                        set: this.setMuted
                    }), this._paused = !1, Object.defineProperty(this, "paused", {
                        get: this.getPaused,
                        set: this.setPaused
                    })
            },
            a = createjs.extend(AbstractSoundInstance, createjs.EventDispatcher);
        a.play = function(a, b, c, d, e, f) {
                var g;
                return g = a instanceof Object || a instanceof createjs.PlayPropsConfig ? createjs.PlayPropsConfig.create(a) : createjs.PlayPropsConfig.create({
                    interrupt: a,
                    delay: b,
                    offset: c,
                    loop: d,
                    volume: e,
                    pan: f
                }), this.playState == createjs.Sound.PLAY_SUCCEEDED ? (this.applyPlayProps(g), void(this._paused && this.setPaused(!1))) : (this._cleanUp(), createjs.Sound._playInstance(this, g), this)
            }, a.stop = function() {
                return this._position = 0, this._paused = !1, this._handleStop(), this._cleanUp(), this.playState = createjs.Sound.PLAY_FINISHED, this
            }, a.destroy = function() {
                this._cleanUp(), this.src = null, this.playbackResource = null, this.removeAllEventListeners()
            }, a.applyPlayProps = function(a) {
                return null !=
                    a.offset && this.setPosition(a.offset), null != a.loop && this.setLoop(a.loop), null != a.volume && this.setVolume(a.volume), null != a.pan && this.setPan(a.pan), null != a.startTime && (this.setStartTime(a.startTime), this.setDuration(a.duration)), this
            }, a.toString = function() {
                return "[AbstractSoundInstance]"
            }, a.getPaused = function() {
                return this._paused
            }, a.setPaused = function(a) {
                return a !== !0 && a !== !1 || this._paused == a || 1 == a && this.playState != createjs.Sound.PLAY_SUCCEEDED ? void 0 : (this._paused = a, a ? this._pause() : this._resume(),
                    clearTimeout(this.delayTimeoutId), this)
            }, a.setVolume = function(a) {
                return a == this._volume ? this : (this._volume = Math.max(0, Math.min(1, a)), this._muted || this._updateVolume(), this)
            }, a.getVolume = function() {
                return this._volume
            }, a.setMuted = function(a) {
                return a === !0 || a === !1 ? (this._muted = a, this._updateVolume(), this) : void 0
            }, a.getMuted = function() {
                return this._muted
            }, a.setPan = function(a) {
                return a == this._pan ? this : (this._pan = Math.max(-1, Math.min(1, a)), this._updatePan(), this)
            }, a.getPan = function() {
                return this._pan
            },
            a.getPosition = function() {
                return this._paused || this.playState != createjs.Sound.PLAY_SUCCEEDED || (this._position = this._calculateCurrentPosition()), this._position
            }, a.setPosition = function(a) {
                return this._position = Math.max(0, a), this.playState == createjs.Sound.PLAY_SUCCEEDED && this._updatePosition(), this
            }, a.getStartTime = function() {
                return this._startTime
            }, a.setStartTime = function(a) {
                return a == this._startTime ? this : (this._startTime = Math.max(0, a || 0), this._updateStartTime(), this)
            }, a.getDuration = function() {
                return this._duration
            },
            a.setDuration = function(a) {
                return a == this._duration ? this : (this._duration = Math.max(0, a || 0), this._updateDuration(), this)
            }, a.setPlaybackResource = function(a) {
                return this._playbackResource = a, 0 == this._duration && this._setDurationFromSource(), this
            }, a.getPlaybackResource = function() {
                return this._playbackResource
            }, a.getLoop = function() {
                return this._loop
            }, a.setLoop = function(a) {
                null != this._playbackResource && (0 != this._loop && 0 == a ? this._removeLooping(a) : 0 == this._loop && 0 != a && this._addLooping(a)), this._loop = a
            }, a._sendEvent =
            function(a) {
                var b = new createjs.Event(a);
                this.dispatchEvent(b)
            }, a._cleanUp = function() {
                clearTimeout(this.delayTimeoutId), this._handleCleanUp(), this._paused = !1, createjs.Sound._playFinished(this)
            }, a._interrupt = function() {
                this._cleanUp(), this.playState = createjs.Sound.PLAY_INTERRUPTED, this._sendEvent("interrupted")
            }, a._beginPlaying = function(a) {
                return this.setPosition(a.offset), this.setLoop(a.loop), this.setVolume(a.volume), this.setPan(a.pan), null != a.startTime && (this.setStartTime(a.startTime), this.setDuration(a.duration)),
                    null != this._playbackResource && this._position < this._duration ? (this._paused = !1, this._handleSoundReady(), this.playState = createjs.Sound.PLAY_SUCCEEDED, this._sendEvent("succeeded"), !0) : (this._playFailed(), !1)
            }, a._playFailed = function() {
                this._cleanUp(), this.playState = createjs.Sound.PLAY_FAILED, this._sendEvent("failed")
            }, a._handleSoundComplete = function(a) {
                return this._position = 0, 0 != this._loop ? (this._loop--, this._handleLoop(), void this._sendEvent("loop")) : (this._cleanUp(), this.playState = createjs.Sound.PLAY_FINISHED,
                    void this._sendEvent("complete"))
            }, a._handleSoundReady = function() {}, a._updateVolume = function() {}, a._updatePan = function() {}, a._updateStartTime = function() {}, a._updateDuration = function() {}, a._setDurationFromSource = function() {}, a._calculateCurrentPosition = function() {}, a._updatePosition = function() {}, a._removeLooping = function(a) {}, a._addLooping = function(a) {}, a._pause = function() {}, a._resume = function() {}, a._handleStop = function() {}, a._handleCleanUp = function() {}, a._handleLoop = function() {}, createjs.AbstractSoundInstance =
            createjs.promote(AbstractSoundInstance, "EventDispatcher"), createjs.DefaultSoundInstance = createjs.AbstractSoundInstance
    }(), this.createjs = this.createjs || {},
    function() {
        var AbstractPlugin = function() {
                this._capabilities = null, this._loaders = {}, this._audioSources = {}, this._soundInstances = {}, this._volume = 1, this._loaderClass, this._soundInstanceClass
            },
            a = AbstractPlugin.prototype;
        AbstractPlugin._capabilities = null, AbstractPlugin.isSupported = function() {
                return !0
            }, a.register = function(a) {
                var b = this._loaders[a.src];
                return b &&
                    !b.canceled ? this._loaders[a.src] : (this._audioSources[a.src] = !0, this._soundInstances[a.src] = [], b = new this._loaderClass(a), b.on("complete", createjs.proxy(this._handlePreloadComplete, this)), this._loaders[a.src] = b, b)
            }, a.preload = function(a) {
                a.on("error", createjs.proxy(this._handlePreloadError, this)), a.load()
            }, a.isPreloadStarted = function(a) {
                return null != this._audioSources[a]
            }, a.isPreloadComplete = function(a) {
                return !(null == this._audioSources[a] || 1 == this._audioSources[a])
            }, a.removeSound = function(a) {
                if (this._soundInstances[a]) {
                    for (var b =
                            this._soundInstances[a].length; b--;) {
                        var c = this._soundInstances[a][b];
                        c.destroy()
                    }
                    delete this._soundInstances[a], delete this._audioSources[a], this._loaders[a] && this._loaders[a].destroy(), delete this._loaders[a]
                }
            }, a.removeAllSounds = function() {
                for (var a in this._audioSources) this.removeSound(a)
            }, a.create = function(a, b, c) {
                this.isPreloadStarted(a) || this.preload(this.register(a));
                var d = new this._soundInstanceClass(a, b, c, this._audioSources[a]);
                return void 0 == this._soundInstances[a] && (this._soundInstances[a] = []), d
            }, a.setVolume = function(a) {
                return this._volume = a, this._updateVolume(), !0
            }, a.getVolume = function() {
                return this._volume
            }, a.setMute = function(a) {
                return this._updateVolume(), !0
            }, a.toString = function() {
                return "[AbstractPlugin]"
            }, a._handlePreloadComplete = function(a) {
                var b = a.target.getItem().src;
                this._audioSources[b] = a.result;
                for (var c = 0, d = this._soundInstances[b].length; d > c; c++) {
                    var e = this._soundInstances[b][c];
                    e.setPlaybackResource(this._audioSources[b])
                }
            }, a._handlePreloadError = function(a) {}, a._updateVolume =
            function() {}, createjs.AbstractPlugin = AbstractPlugin
    }(), this.createjs = this.createjs || {},
    function() {
        function a(a) {
            this.AbstractLoader_constructor(a, !0, createjs.AbstractLoader.SOUND)
        }
        var b = createjs.extend(a, createjs.AbstractLoader);
        a.context = null, b.toString = function() {
            return "[WebAudioLoader]"
        }, b._createRequest = function() {
            this._request = new createjs.XHRRequest(this._item, !1), this._request.setResponseType("arraybuffer")
        }, b._sendComplete = function(b) {
            a.context.decodeAudioData(this._rawResult, createjs.proxy(this._handleAudioDecoded,
                this), createjs.proxy(this._sendError, this))
        }, b._handleAudioDecoded = function(a) {
            this._result = a, this.AbstractLoader__sendComplete()
        }, createjs.WebAudioLoader = createjs.promote(a, "AbstractLoader")
    }(), this.createjs = this.createjs || {},
    function() {
        function WebAudioSoundInstance(a, c, d, e) {
            this.AbstractSoundInstance_constructor(a, c, d, e), this.gainNode = b.context.createGain(), this.panNode = b.context.createPanner(), this.panNode.panningModel = b._panningModel, this.panNode.connect(this.gainNode), this.sourceNode = null, this._soundCompleteTimeout =
                null, this._sourceNodeNext = null, this._playbackStartTime = 0, this._endedHandler = createjs.proxy(this._handleSoundComplete, this)
        }
        var a = createjs.extend(WebAudioSoundInstance, createjs.AbstractSoundInstance),
            b = WebAudioSoundInstance;
        b.context = null, b.destinationNode = null, b._panningModel = "equalpower", a.destroy = function() {
                this.AbstractSoundInstance_destroy(), this.panNode.disconnect(0), this.panNode = null, this.gainNode.disconnect(0), this.gainNode = null
            }, a.toString = function() {
                return "[WebAudioSoundInstance]"
            }, a._updatePan =
            function() {
                this.panNode.setPosition(this._pan, 0, -.5)
            }, a._removeLooping = function(a) {
                this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext)
            }, a._addLooping = function(a) {
                this.playState == createjs.Sound.PLAY_SUCCEEDED && (this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0))
            }, a._setDurationFromSource = function() {
                this._duration = 1E3 * this.playbackResource.duration
            }, a._handleCleanUp = function() {
                this.sourceNode && this.playState == createjs.Sound.PLAY_SUCCEEDED && (this.sourceNode = this._cleanUpAudioNode(this.sourceNode),
                    this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext)), 0 != this.gainNode.numberOfOutputs && this.gainNode.disconnect(0), clearTimeout(this._soundCompleteTimeout), this._playbackStartTime = 0
            }, a._cleanUpAudioNode = function(a) {
                if (a) {
                    try {
                        a.stop(0)
                    } catch (b) {}
                    a.disconnect(0), a = null
                }
                return a
            }, a._handleSoundReady = function(a) {
                this.gainNode.connect(b.destinationNode);
                var c = .001 * this._duration,
                    d = .001 * this._position;
                d > c && (d = c), this.sourceNode = this._createAndPlayAudioNode(b.context.currentTime - c, d), this._playbackStartTime =
                    this.sourceNode.startTime - d, this._soundCompleteTimeout = setTimeout(this._endedHandler, 1E3 * (c - d)), 0 != this._loop && (this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0))
            }, a._createAndPlayAudioNode = function(a, c) {
                var d = b.context.createBufferSource();
                d.buffer = this.playbackResource, d.connect(this.panNode);
                var e = .001 * this._duration;
                return d.startTime = a + e, d.start(d.startTime, c + .001 * this._startTime, e - c), d
            }, a._pause = function() {
                this._position = 1E3 * (b.context.currentTime - this._playbackStartTime),
                    this.sourceNode = this._cleanUpAudioNode(this.sourceNode), this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext), 0 != this.gainNode.numberOfOutputs && this.gainNode.disconnect(0), clearTimeout(this._soundCompleteTimeout)
            }, a._resume = function() {
                this._handleSoundReady()
            }, a._updateVolume = function() {
                var a = this._muted ? 0 : this._volume;
                a != this.gainNode.gain.value && (this.gainNode.gain.value = a)
            }, a._calculateCurrentPosition = function() {
                return 1E3 * (b.context.currentTime - this._playbackStartTime)
            }, a._updatePosition =
            function() {
                this.sourceNode = this._cleanUpAudioNode(this.sourceNode), this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext), clearTimeout(this._soundCompleteTimeout), this._paused || this._handleSoundReady()
            }, a._handleLoop = function() {
                this._cleanUpAudioNode(this.sourceNode), this.sourceNode = this._sourceNodeNext, this._playbackStartTime = this.sourceNode.startTime, this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0), this._soundCompleteTimeout = setTimeout(this._endedHandler, this._duration)
            },
            a._updateDuration = function() {
                this.playState == createjs.Sound.PLAY_SUCCEEDED && (this._pause(), this._resume())
            }, createjs.WebAudioSoundInstance = createjs.promote(WebAudioSoundInstance, "AbstractSoundInstance")
    }(), this.createjs = this.createjs || {},
    function() {
        function WebAudioPlugin() {
            this.AbstractPlugin_constructor(), this._panningModel = b._panningModel, this.context = b.context, this.dynamicsCompressorNode = this.context.createDynamicsCompressor(), this.dynamicsCompressorNode.connect(this.context.destination), this.gainNode =
                this.context.createGain(), this.gainNode.connect(this.dynamicsCompressorNode), createjs.WebAudioSoundInstance.destinationNode = this.gainNode, this._capabilities = b._capabilities, this._loaderClass = createjs.WebAudioLoader, this._soundInstanceClass = createjs.WebAudioSoundInstance, this._addPropsToClasses()
        }
        var a = createjs.extend(WebAudioPlugin, createjs.AbstractPlugin),
            b = WebAudioPlugin;
        b._capabilities = null, b._panningModel = "equalpower", b.context = null, b.isSupported = function() {
            var a = createjs.BrowserDetect.isIOS ||
                createjs.BrowserDetect.isAndroid || createjs.BrowserDetect.isBlackberry;
            return "file:" != location.protocol || a || this._isFileXHRSupported() ? (b._generateCapabilities(), null == b.context ? !1 : !0) : !1
        }, b.playEmptySound = function() {
            if (null != b.context) {
                var a = b.context.createBufferSource();
                a.buffer = b.context.createBuffer(1, 1, 22050), a.connect(b.context.destination), a.start(0, 0, 0)
            }
        }, b._isFileXHRSupported = function() {
            var a = !0,
                b = new XMLHttpRequest;
            try {
                b.open("GET", "WebAudioPluginTest.fail", !1)
            } catch (c) {
                return a = !1
            }
            b.onerror =
                function() {
                    a = !1
                }, b.onload = function() {
                    a = 404 == this.status || 200 == this.status || 0 == this.status && "" != this.response
                };
            try {
                b.send()
            } catch (c) {
                a = !1
            }
            return a
        }, b._generateCapabilities = function() {
            if (null == b._capabilities) {
                var a = document.createElement("audio");
                if (null == a.canPlayType) return null;
                if (null == b.context)
                    if (window.AudioContext) b.context = new AudioContext;
                    else {
                        if (!window.webkitAudioContext) return null;
                        b.context = new webkitAudioContext
                    }
                b._compatibilitySetUp(), b.playEmptySound(), b._capabilities = {
                    panning: !0,
                    volume: !0,
                    tracks: -1
                };
                for (var c = createjs.Sound.SUPPORTED_EXTENSIONS, d = createjs.Sound.EXTENSION_MAP, e = 0, f = c.length; f > e; e++) {
                    var g = c[e],
                        h = d[g] || g;
                    b._capabilities[g] = "no" != a.canPlayType("audio/" + g) && "" != a.canPlayType("audio/" + g) || "no" != a.canPlayType("audio/" + h) && "" != a.canPlayType("audio/" + h)
                }
                b.context.destination.numberOfChannels < 2 && (b._capabilities.panning = !1)
            }
        }, b._compatibilitySetUp = function() {
            if (b._panningModel = "equalpower", !b.context.createGain) {
                b.context.createGain = b.context.createGainNode;
                var a =
                    b.context.createBufferSource();
                a.__proto__.start = a.__proto__.noteGrainOn, a.__proto__.stop = a.__proto__.noteOff, b._panningModel = 0
            }
        }, a.toString = function() {
            return "[WebAudioPlugin]"
        }, a._addPropsToClasses = function() {
            var a = this._soundInstanceClass;
            a.context = this.context, a.destinationNode = this.gainNode, a._panningModel = this._panningModel, this._loaderClass.context = this.context
        }, a._updateVolume = function() {
            var a = createjs.Sound._masterMute ? 0 : this._volume;
            a != this.gainNode.gain.value && (this.gainNode.gain.value =
                a)
        }, createjs.WebAudioPlugin = createjs.promote(WebAudioPlugin, "AbstractPlugin")
    }(), this.createjs = this.createjs || {},
    function() {
        function HTMLAudioTagPool() {
            throw "HTMLAudioTagPool cannot be instantiated";
        }

        function a(a) {
            this._tags = []
        }
        var b = HTMLAudioTagPool;
        b._tags = {}, b._tagPool = new a, b._tagUsed = {}, b.get = function(a) {
                var c = b._tags[a];
                return null == c ? (c = b._tags[a] = b._tagPool.get(), c.src = a) : b._tagUsed[a] ? (c = b._tagPool.get(), c.src = a) : b._tagUsed[a] = !0, c
            }, b.set = function(a, c) {
                c == b._tags[a] ? b._tagUsed[a] = !1 : b._tagPool.set(c)
            },
            b.remove = function(a) {
                var c = b._tags[a];
                return null == c ? !1 : (b._tagPool.set(c), delete b._tags[a], delete b._tagUsed[a], !0)
            }, b.getDuration = function(a) {
                var c = b._tags[a];
                return null == c ? 0 : 1E3 * c.duration
            }, createjs.HTMLAudioTagPool = HTMLAudioTagPool;
        var c = a.prototype;
        c.constructor = a, c.get = function() {
                var a;
                return a = 0 == this._tags.length ? this._createTag() : this._tags.pop(), null == a.parentNode && document.body.appendChild(a), a
            }, c.set = function(a) {
                var b = createjs.indexOf(this._tags, a); - 1 == b && (this._tags.src = null, this._tags.push(a))
            },
            c.toString = function() {
                return "[TagPool]"
            }, c._createTag = function() {
                var a = document.createElement("audio");
                return a.autoplay = !1, a.preload = "none", a
            }
    }(), this.createjs = this.createjs || {},
    function() {
        function HTMLAudioSoundInstance(a, b, c, d) {
            this.AbstractSoundInstance_constructor(a, b, c, d), this._audioSpriteStopTime = null, this._delayTimeoutId = null, this._endedHandler = createjs.proxy(this._handleSoundComplete, this), this._readyHandler = createjs.proxy(this._handleTagReady, this), this._stalledHandler = createjs.proxy(this._playFailed,
                this), this._audioSpriteEndHandler = createjs.proxy(this._handleAudioSpriteLoop, this), this._loopHandler = createjs.proxy(this._handleSoundComplete, this), c ? this._audioSpriteStopTime = .001 * (b + c) : this._duration = createjs.HTMLAudioTagPool.getDuration(this.src)
        }
        var a = createjs.extend(HTMLAudioSoundInstance, createjs.AbstractSoundInstance);
        a.setMasterVolume = function(a) {
                this._updateVolume()
            }, a.setMasterMute = function(a) {
                this._updateVolume()
            }, a.toString = function() {
                return "[HTMLAudioSoundInstance]"
            }, a._removeLooping =
            function() {
                null != this._playbackResource && (this._playbackResource.loop = !1, this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1))
            }, a._addLooping = function() {
                null == this._playbackResource || this._audioSpriteStopTime || (this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1), this._playbackResource.loop = !0)
            }, a._handleCleanUp = function() {
                var a = this._playbackResource;
                if (null != a) {
                    a.pause(), a.loop = !1, a.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED,
                        this._endedHandler, !1), a.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, !1), a.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, !1), a.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1), a.removeEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, !1);
                    try {
                        a.currentTime = this._startTime
                    } catch (b) {}
                    createjs.HTMLAudioTagPool.set(this.src, a), this._playbackResource = null
                }
            }, a._beginPlaying = function(a) {
                return this._playbackResource =
                    createjs.HTMLAudioTagPool.get(this.src), this.AbstractSoundInstance__beginPlaying(a)
            }, a._handleSoundReady = function(a) {
                if (4 !== this._playbackResource.readyState) {
                    var b = this._playbackResource;
                    return b.addEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, !1), b.addEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, !1), b.preload = "auto", void b.load()
                }
                this._updateVolume(), this._playbackResource.currentTime = .001 * (this._startTime + this._position), this._audioSpriteStopTime ?
                    this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, !1) : (this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, !1), 0 != this._loop && (this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1), this._playbackResource.loop = !0)), this._playbackResource.play()
            }, a._handleTagReady = function(a) {
                this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY,
                    this._readyHandler, !1), this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, !1), this._handleSoundReady()
            }, a._pause = function() {
                this._playbackResource.pause()
            }, a._resume = function() {
                this._playbackResource.play()
            }, a._updateVolume = function() {
                if (null != this._playbackResource) {
                    var a = this._muted || createjs.Sound._masterMute ? 0 : this._volume * createjs.Sound._masterVolume;
                    a != this._playbackResource.volume && (this._playbackResource.volume = a)
                }
            }, a._calculateCurrentPosition =
            function() {
                return 1E3 * this._playbackResource.currentTime - this._startTime
            }, a._updatePosition = function() {
                this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1), this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, !1);
                try {
                    this._playbackResource.currentTime = .001 * (this._position + this._startTime)
                } catch (a) {
                    this._handleSetPositionSeek(null)
                }
            }, a._handleSetPositionSeek = function(a) {
                null != this._playbackResource &&
                    (this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, !1), this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1))
            }, a._handleAudioSpriteLoop = function(a) {
                this._playbackResource.currentTime <= this._audioSpriteStopTime || (this._playbackResource.pause(), 0 == this._loop ? this._handleSoundComplete(null) : (this._position = 0, this._loop--, this._playbackResource.currentTime = .001 * this._startTime, this._paused || this._playbackResource.play(),
                    this._sendEvent("loop")))
            }, a._handleLoop = function(a) {
                0 == this._loop && (this._playbackResource.loop = !1, this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1))
            }, a._updateStartTime = function() {
                this._audioSpriteStopTime = .001 * (this._startTime + this._duration), this.playState == createjs.Sound.PLAY_SUCCEEDED && (this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, !1), this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE,
                    this._audioSpriteEndHandler, !1))
            }, a._updateDuration = function() {
                this._audioSpriteStopTime = .001 * (this._startTime + this._duration), this.playState == createjs.Sound.PLAY_SUCCEEDED && (this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, !1), this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, !1))
            }, createjs.HTMLAudioSoundInstance = createjs.promote(HTMLAudioSoundInstance, "AbstractSoundInstance")
    }(), this.createjs =
    this.createjs || {},
    function() {
        function HTMLAudioPlugin() {
            this.AbstractPlugin_constructor(), this.defaultNumChannels = 2, this._capabilities = b._capabilities, this._loaderClass = createjs.SoundLoader, this._soundInstanceClass = createjs.HTMLAudioSoundInstance
        }
        var a = createjs.extend(HTMLAudioPlugin, createjs.AbstractPlugin),
            b = HTMLAudioPlugin;
        b.MAX_INSTANCES = 30, b._AUDIO_READY = "canplaythrough", b._AUDIO_ENDED = "ended", b._AUDIO_SEEKED = "seeked", b._AUDIO_STALLED = "stalled", b._TIME_UPDATE = "timeupdate", b._capabilities = null,
            b.isSupported = function() {
                return b._generateCapabilities(), null != b._capabilities
            }, b._generateCapabilities = function() {
                if (null == b._capabilities) {
                    var a = document.createElement("audio");
                    if (null == a.canPlayType) return null;
                    b._capabilities = {
                        panning: !1,
                        volume: !0,
                        tracks: -1
                    };
                    for (var c = createjs.Sound.SUPPORTED_EXTENSIONS, d = createjs.Sound.EXTENSION_MAP, e = 0, f = c.length; f > e; e++) {
                        var g = c[e],
                            h = d[g] || g;
                        b._capabilities[g] = "no" != a.canPlayType("audio/" + g) && "" != a.canPlayType("audio/" + g) || "no" != a.canPlayType("audio/" + h) &&
                            "" != a.canPlayType("audio/" + h)
                    }
                }
            }, a.register = function(a) {
                var b = createjs.HTMLAudioTagPool.get(a.src),
                    c = this.AbstractPlugin_register(a);
                return c.setTag(b), c
            }, a.removeSound = function(a) {
                this.AbstractPlugin_removeSound(a), createjs.HTMLAudioTagPool.remove(a)
            }, a.create = function(a, b, c) {
                var d = this.AbstractPlugin_create(a, b, c);
                return d.setPlaybackResource(null), d
            }, a.toString = function() {
                return "[HTMLAudioPlugin]"
            }, a.setVolume = a.getVolume = a.setMute = null, createjs.HTMLAudioPlugin = createjs.promote(HTMLAudioPlugin,
                "AbstractPlugin")
    }();
! function(u, D) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = D() : "function" == typeof define && define.amd ? define(D) : u.JSON5 = D()
}(this, function() {
    function u(u, D) {
        return u(D = {
            exports: {}
        }, D.exports), D.exports
    }
    var D = u(function(u) {
            var D = u.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
            "number" == typeof __g && (__g = D)
        }),
        e = u(function(u) {
            var D = u.exports = {
                version: "2.5.7"
            };
            "number" == typeof __e && (__e = D)
        }),
        t = (e.version, function(u) {
            return "object" == typeof u ? null !== u : "function" == typeof u
        }),
        r = function(u) {
            if (!t(u)) throw TypeError(u + " is not an object!");
            return u
        },
        F = function(u) {
            try {
                return !!u()
            } catch (u) {
                return !0
            }
        },
        n = !F(function() {
            return 7 != Object.defineProperty({}, "a", {
                get: function() {
                    return 7
                }
            }).a
        }),
        C = D.document,
        A = t(C) && t(C.createElement),
        E = !n && !F(function() {
            return 7 != Object.defineProperty((u = "div", A ? C.createElement(u) : {}), "a", {
                get: function() {
                    return 7
                }
            }).a;
            var u
        }),
        i = Object.defineProperty,
        o = {
            f: n ? Object.defineProperty : function(u, D, e) {
                if (r(u), D = function(u, D) {
                        if (!t(u)) return u;
                        var e, r;
                        if (D && "function" == typeof(e = u.toString) && !t(r = e.call(u))) return r;
                        if ("function" == typeof(e = u.valueOf) && !t(r = e.call(u))) return r;
                        if (!D && "function" == typeof(e = u.toString) && !t(r = e.call(u))) return r;
                        throw TypeError("Can't convert object to primitive value");
                    }(D, !0), r(e), E) try {
                    return i(u, D, e)
                } catch (u) {}
                if ("get" in e || "set" in e) throw TypeError("Accessors not supported!");
                return "value" in e && (u[D] = e.value), u
            }
        },
        a = n ? function(u, D, e) {
            return o.f(u,
                D,
                function(u, D) {
                    return {
                        enumerable: !(1 & u),
                        configurable: !(2 & u),
                        writable: !(4 & u),
                        value: D
                    }
                }(1, e))
        } : function(u, D, e) {
            return u[D] = e, u
        },
        c = {}.hasOwnProperty,
        B = function(u, D) {
            return c.call(u, D)
        },
        s = 0,
        f = Math.random(),
        l = u(function(u) {
            var t, r = "Symbol(".concat(void 0 === (t = "src") ? "" : t, ")_", (++s + f).toString(36)),
                F = Function.toString,
                n = ("" + F).split("toString");
            e.inspectSource = function(u) {
                return F.call(u)
            }, (u.exports = function(u, e, t, F) {
                var C = "function" == typeof t;
                C && (B(t, "name") || a(t, "name", e)), u[e] !== t && (C && (B(t, r) || a(t,
                    r, u[e] ? "" + u[e] : n.join(String(e)))), u === D ? u[e] = t : F ? u[e] ? u[e] = t : a(u, e, t) : (delete u[e], a(u, e, t)))
            })(Function.prototype, "toString", function() {
                return "function" == typeof this && this[r] || F.call(this)
            })
        }),
        d = function(u, D, e) {
            if (function(u) {
                    if ("function" != typeof u) throw TypeError(u + " is not a function!");
                }(u), void 0 === D) return u;
            switch (e) {
                case 1:
                    return function(e) {
                        return u.call(D, e)
                    };
                case 2:
                    return function(e, t) {
                        return u.call(D, e, t)
                    };
                case 3:
                    return function(e, t, r) {
                        return u.call(D, e, t, r)
                    }
            }
            return function() {
                return u.apply(D,
                    arguments)
            }
        },
        v = function(u, t, r) {
            var F, n, C, A, E = u & v.F,
                i = u & v.G,
                o = u & v.S,
                c = u & v.P,
                B = u & v.B,
                s = i ? D : o ? D[t] || (D[t] = {}) : (D[t] || {}).prototype,
                f = i ? e : e[t] || (e[t] = {}),
                p = f.prototype || (f.prototype = {});
            for (F in i && (r = t), r) C = ((n = !E && s && void 0 !== s[F]) ? s : r)[F], A = B && n ? d(C, D) : c && "function" == typeof C ? d(Function.call, C) : C, s && l(s, F, C, u & v.U), f[F] != C && a(f, F, A), c && p[F] != C && (p[F] = C)
        };
    D.core = e, v.F = 1, v.G = 2, v.S = 4, v.P = 8, v.B = 16, v.W = 32, v.U = 64, v.R = 128;
    var p, h = v,
        m = Math.ceil,
        g = Math.floor,
        y = function(u) {
            return isNaN(u = +u) ? 0 : (u > 0 ? g : m)(u)
        },
        w = (p = !1, function(u, D) {
            var e, t, r = String(function(u) {
                    if (null == u) throw TypeError("Can't call method on  " + u);
                    return u
                }(u)),
                F = y(D),
                n = r.length;
            return F < 0 || F >= n ? p ? "" : void 0 : (e = r.charCodeAt(F)) < 55296 || e > 56319 || F + 1 === n || (t = r.charCodeAt(F + 1)) < 56320 || t > 57343 ? p ? r.charAt(F) : e : p ? r.slice(F, F + 2) : t - 56320 + (e - 55296 << 10) + 65536
        });
    h(h.P, "String", {
        codePointAt: function(u) {
            return w(this, u)
        }
    });
    e.String.codePointAt;
    var S = Math.max,
        b = Math.min,
        x = String.fromCharCode,
        N = String.fromCodePoint;
    h(h.S + h.F * (!!N && 1 != N.length), "String", {
        fromCodePoint: function(u) {
            for (var D, e, t, r = arguments, F = [], n = arguments.length, C = 0; n > C;) {
                if (D = +r[C++], t = 1114111, ((e = y(e = D)) < 0 ? S(e + t, 0) : b(e, t)) !== D) throw RangeError(D + " is not a valid code point");
                F.push(D < 65536 ? x(D) : x(55296 + ((D -= 65536) >> 10), D % 1024 + 56320))
            }
            return F.join("")
        }
    });
    e.String.fromCodePoint;
    var P, I, O, _, j, V, J, M, L, k, T, H, $, z, R = {
            Space_Separator: /[\u1680\u2000-\u200A\u202F\u205F\u3000]/,
            ID_Start: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/,
            ID_Continue: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
        },
        G = {
            isSpaceSeparator: function(u) {
                return R.Space_Separator.test(u)
            },
            isIdStartChar: function(u) {
                return u >= "a" && u <= "z" || u >= "A" && u <= "Z" || "$" === u || "_" === u || R.ID_Start.test(u)
            },
            isIdContinueChar: function(u) {
                return u >= "a" && u <= "z" || u >= "A" && u <= "Z" || u >= "0" && u <= "9" || "$" === u || "_" === u || "" === u || "" === u || R.ID_Continue.test(u)
            },
            isDigit: function(u) {
                return /[0-9]/.test(u)
            },
            isHexDigit: function(u) {
                return /[0-9A-Fa-f]/.test(u)
            }
        };

    function U() {
        for (k = "default", T = "", H = !1, $ = 1;;) {
            z = Z();
            var u = W[k]();
            if (u) return u
        }
    }

    function Z() {
        if (P[_]) return String.fromCodePoint(P.codePointAt(_))
    }

    function q() {
        var u = Z();
        return "\n" === u ? (j++, V = 0) : u ? V += u.length : V++, u && (_ += u.length), u
    }
    var W = {
        "default": function() {
            switch (z) {
                case "\t":
                case "\v":
                case "\f":
                case " ":
                case "":
                case "":
                case "\n":
                case "\r":
                case "\u2028":
                case "\u2029":
                    return void q();
                case "/":
                    return q(), void(k = "comment");
                case void 0:
                    return q(), X("eof")
            }
            if (!G.isSpaceSeparator(z)) return W[I]();
            q()
        },
        comment: function() {
            switch (z) {
                case "*":
                    return q(), void(k = "multiLineComment");
                case "/":
                    return q(), void(k = "singleLineComment")
            }
            throw eu(q());
        },
        multiLineComment: function() {
            switch (z) {
                case "*":
                    return q(),
                        void(k = "multiLineCommentAsterisk");
                case void 0:
                    throw eu(q());
            }
            q()
        },
        multiLineCommentAsterisk: function() {
            switch (z) {
                case "*":
                    return void q();
                case "/":
                    return q(), void(k = "default");
                case void 0:
                    throw eu(q());
            }
            q(), k = "multiLineComment"
        },
        singleLineComment: function() {
            switch (z) {
                case "\n":
                case "\r":
                case "\u2028":
                case "\u2029":
                    return q(), void(k = "default");
                case void 0:
                    return q(), X("eof")
            }
            q()
        },
        value: function() {
            switch (z) {
                case "{":
                case "[":
                    return X("punctuator", q());
                case "n":
                    return q(), K("ull"), X("null", null);
                case "t":
                    return q(),
                        K("rue"), X("boolean", !0);
                case "f":
                    return q(), K("alse"), X("boolean", !1);
                case "-":
                case "+":
                    return "-" === q() && ($ = -1), void(k = "sign");
                case ".":
                    return T = q(), void(k = "decimalPointLeading");
                case "0":
                    return T = q(), void(k = "zero");
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                    return T = q(), void(k = "decimalInteger");
                case "I":
                    return q(), K("nfinity"), X("numeric", 1 / 0);
                case "N":
                    return q(), K("aN"), X("numeric", NaN);
                case '"':
                case "'":
                    return H = '"' === q(), T = "", void(k = "string")
            }
            throw eu(q());
        },
        identifierNameStartEscape: function() {
            if ("u" !== z) throw eu(q());
            q();
            var u = Q();
            switch (u) {
                case "$":
                case "_":
                    break;
                default:
                    if (!G.isIdStartChar(u)) throw ru();
            }
            T += u, k = "identifierName"
        },
        identifierName: function() {
            switch (z) {
                case "$":
                case "_":
                case "":
                case "":
                    return void(T += q());
                case "\\":
                    return q(), void(k = "identifierNameEscape")
            }
            if (!G.isIdContinueChar(z)) return X("identifier", T);
            T += q()
        },
        identifierNameEscape: function() {
            if ("u" !== z) throw eu(q());
            q();
            var u = Q();
            switch (u) {
                case "$":
                case "_":
                case "":
                case "":
                    break;
                default:
                    if (!G.isIdContinueChar(u)) throw ru();
            }
            T += u, k = "identifierName"
        },
        sign: function() {
            switch (z) {
                case ".":
                    return T = q(), void(k = "decimalPointLeading");
                case "0":
                    return T = q(), void(k = "zero");
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                    return T = q(), void(k = "decimalInteger");
                case "I":
                    return q(), K("nfinity"), X("numeric", $ * (1 / 0));
                case "N":
                    return q(), K("aN"), X("numeric", NaN)
            }
            throw eu(q());
        },
        zero: function() {
            switch (z) {
                case ".":
                    return T += q(), void(k = "decimalPoint");
                case "e":
                case "E":
                    return T +=
                        q(), void(k = "decimalExponent");
                case "x":
                case "X":
                    return T += q(), void(k = "hexadecimal")
            }
            return X("numeric", 0 * $)
        },
        decimalInteger: function() {
            switch (z) {
                case ".":
                    return T += q(), void(k = "decimalPoint");
                case "e":
                case "E":
                    return T += q(), void(k = "decimalExponent")
            }
            if (!G.isDigit(z)) return X("numeric", $ * Number(T));
            T += q()
        },
        decimalPointLeading: function() {
            if (G.isDigit(z)) return T += q(), void(k = "decimalFraction");
            throw eu(q());
        },
        decimalPoint: function() {
            switch (z) {
                case "e":
                case "E":
                    return T += q(), void(k = "decimalExponent")
            }
            return G.isDigit(z) ?
                (T += q(), void(k = "decimalFraction")) : X("numeric", $ * Number(T))
        },
        decimalFraction: function() {
            switch (z) {
                case "e":
                case "E":
                    return T += q(), void(k = "decimalExponent")
            }
            if (!G.isDigit(z)) return X("numeric", $ * Number(T));
            T += q()
        },
        decimalExponent: function() {
            switch (z) {
                case "+":
                case "-":
                    return T += q(), void(k = "decimalExponentSign")
            }
            if (G.isDigit(z)) return T += q(), void(k = "decimalExponentInteger");
            throw eu(q());
        },
        decimalExponentSign: function() {
            if (G.isDigit(z)) return T += q(), void(k = "decimalExponentInteger");
            throw eu(q());
        },
        decimalExponentInteger: function() {
            if (!G.isDigit(z)) return X("numeric", $ * Number(T));
            T += q()
        },
        hexadecimal: function() {
            if (G.isHexDigit(z)) return T += q(), void(k = "hexadecimalInteger");
            throw eu(q());
        },
        hexadecimalInteger: function() {
            if (!G.isHexDigit(z)) return X("numeric", $ * Number(T));
            T += q()
        },
        string: function() {
            switch (z) {
                case "\\":
                    return q(), void(T += function() {
                        switch (Z()) {
                            case "b":
                                return q(), "\b";
                            case "f":
                                return q(), "\f";
                            case "n":
                                return q(), "\n";
                            case "r":
                                return q(), "\r";
                            case "t":
                                return q(), "\t";
                            case "v":
                                return q(),
                                    "\v";
                            case "0":
                                if (q(), G.isDigit(Z())) throw eu(q());
                                return "\x00";
                            case "x":
                                return q(),
                                    function() {
                                        var u = "",
                                            D = Z();
                                        if (!G.isHexDigit(D)) throw eu(q());
                                        if (u += q(), D = Z(), !G.isHexDigit(D)) throw eu(q());
                                        return u += q(), String.fromCodePoint(parseInt(u, 16))
                                    }();
                            case "u":
                                return q(), Q();
                            case "\n":
                            case "\u2028":
                            case "\u2029":
                                return q(), "";
                            case "\r":
                                return q(), "\n" === Z() && q(), "";
                            case "1":
                            case "2":
                            case "3":
                            case "4":
                            case "5":
                            case "6":
                            case "7":
                            case "8":
                            case "9":
                            case void 0:
                                throw eu(q());
                        }
                        return q()
                    }());
                case '"':
                    return H ?
                        (q(), X("string", T)) : void(T += q());
                case "'":
                    return H ? void(T += q()) : (q(), X("string", T));
                case "\n":
                case "\r":
                    throw eu(q());
                case "\u2028":
                case "\u2029":
                    ! function(u) {
                        console.warn("JSON5: '" + Fu(u) + "' in strings is not valid ECMAScript; consider escaping")
                    }(z);
                    break;
                case void 0:
                    throw eu(q());
            }
            T += q()
        },
        start: function() {
            switch (z) {
                case "{":
                case "[":
                    return X("punctuator", q())
            }
            k = "value"
        },
        beforePropertyName: function() {
            switch (z) {
                case "$":
                case "_":
                    return T = q(), void(k = "identifierName");
                case "\\":
                    return q(), void(k = "identifierNameStartEscape");
                case "}":
                    return X("punctuator", q());
                case '"':
                case "'":
                    return H = '"' === q(), void(k = "string")
            }
            if (G.isIdStartChar(z)) return T += q(), void(k = "identifierName");
            throw eu(q());
        },
        afterPropertyName: function() {
            if (":" === z) return X("punctuator", q());
            throw eu(q());
        },
        beforePropertyValue: function() {
            k = "value"
        },
        afterPropertyValue: function() {
            switch (z) {
                case ",":
                case "}":
                    return X("punctuator", q())
            }
            throw eu(q());
        },
        beforeArrayValue: function() {
            if ("]" === z) return X("punctuator", q());
            k = "value"
        },
        afterArrayValue: function() {
            switch (z) {
                case ",":
                case "]":
                    return X("punctuator",
                        q())
            }
            throw eu(q());
        },
        end: function() {
            throw eu(q());
        }
    };

    function X(u, D) {
        return {
            type: u,
            value: D,
            line: j,
            column: V
        }
    }

    function K(u) {
        for (var D = 0, e = u; D < e.length; D += 1) {
            var t = e[D];
            if (Z() !== t) throw eu(q());
            q()
        }
    }

    function Q() {
        for (var u = "", D = 4; D-- > 0;) {
            var e = Z();
            if (!G.isHexDigit(e)) throw eu(q());
            u += q()
        }
        return String.fromCodePoint(parseInt(u, 16))
    }
    var Y = {
        start: function() {
            if ("eof" === J.type) throw tu();
            uu()
        },
        beforePropertyName: function() {
            switch (J.type) {
                case "identifier":
                case "string":
                    return M = J.value, void(I = "afterPropertyName");
                case "punctuator":
                    return void Du();
                case "eof":
                    throw tu();
            }
        },
        afterPropertyName: function() {
            if ("eof" === J.type) throw tu();
            I = "beforePropertyValue"
        },
        beforePropertyValue: function() {
            if ("eof" === J.type) throw tu();
            uu()
        },
        beforeArrayValue: function() {
            if ("eof" === J.type) throw tu();
            "punctuator" !== J.type || "]" !== J.value ? uu() : Du()
        },
        afterPropertyValue: function() {
            if ("eof" === J.type) throw tu();
            switch (J.value) {
                case ",":
                    return void(I = "beforePropertyName");
                case "}":
                    Du()
            }
        },
        afterArrayValue: function() {
            if ("eof" === J.type) throw tu();
            switch (J.value) {
                case ",":
                    return void(I = "beforeArrayValue");
                case "]":
                    Du()
            }
        },
        end: function() {}
    };

    function uu() {
        var u;
        switch (J.type) {
            case "punctuator":
                switch (J.value) {
                    case "{":
                        u = {};
                        break;
                    case "[":
                        u = []
                }
                break;
            case "null":
            case "boolean":
            case "numeric":
            case "string":
                u = J.value
        }
        if (void 0 === L) L = u;
        else {
            var D = O[O.length - 1];
            Array.isArray(D) ? D.push(u) : D[M] = u
        }
        if (null !== u && "object" == typeof u) O.push(u), I = Array.isArray(u) ? "beforeArrayValue" : "beforePropertyName";
        else {
            var e = O[O.length - 1];
            I = null == e ? "end" : Array.isArray(e) ?
                "afterArrayValue" : "afterPropertyValue"
        }
    }

    function Du() {
        O.pop();
        var u = O[O.length - 1];
        I = null == u ? "end" : Array.isArray(u) ? "afterArrayValue" : "afterPropertyValue"
    }

    function eu(u) {
        return nu(void 0 === u ? "JSON5: invalid end of input at " + j + ":" + V : "JSON5: invalid character '" + Fu(u) + "' at " + j + ":" + V)
    }

    function tu() {
        return nu("JSON5: invalid end of input at " + j + ":" + V)
    }

    function ru() {
        return nu("JSON5: invalid identifier character at " + j + ":" + (V -= 5))
    }

    function Fu(u) {
        var D = {
            "'": "\\'",
            '"': '\\"',
            "\\": "\\\\",
            "\b": "\\b",
            "\f": "\\f",
            "\n": "\\n",
            "\r": "\\r",
            "\t": "\\t",
            "\x0B": "\\v",
            "\x00": "\\0",
            "\u2028": "\\u2028",
            "\u2029": "\\u2029"
        };
        if (D[u]) return D[u];
        if (u < " ") {
            var e = u.charCodeAt(0).toString(16);
            return "\\x" + ("00" + e).substring(e.length)
        }
        return u
    }

    function nu(u) {
        var D = new SyntaxError(u);
        return D.lineNumber = j, D.columnNumber = V, D
    }
    return {
        parse: function(u, D) {
            P = String(u), I = "start", O = [], _ = 0, j = 1, V = 0, J = void 0, M = void 0, L = void 0;
            do J = U(), Y[I](); while ("eof" !== J.type);
            return "function" == typeof D ? function u(D, e, t) {
                var r = D[e];
                if (null != r && "object" ==
                    typeof r)
                    for (var F in r) {
                        var n = u(r, F, t);
                        void 0 === n ? delete r[F] : r[F] = n
                    }
                return t.call(D, e, r)
            }({
                "": L
            }, "", D) : L
        },
        stringify: function(u, D, e) {
            var t, r, F, n = [],
                C = "",
                A = "";
            if (null == D || "object" != typeof D || Array.isArray(D) || (e = D.space, F = D.quote, D = D.replacer), "function" == typeof D) r = D;
            else if (Array.isArray(D)) {
                t = [];
                for (var E = 0, i = D; E < i.length; E += 1) {
                    var o = i[E],
                        a = void 0;
                    "string" == typeof o ? a = o : ("number" == typeof o || o instanceof String || o instanceof Number) && (a = String(o)), void 0 !== a && t.indexOf(a) < 0 && t.push(a)
                }
            }
            return e instanceof
            Number ? e = Number(e) : e instanceof String && (e = String(e)), "number" == typeof e ? e > 0 && (e = Math.min(10, Math.floor(e)), A = "          ".substr(0, e)) : "string" == typeof e && (A = e.substr(0, 10)), c("", {
                "": u
            });

            function c(u, D) {
                var e = D[u];
                switch (null != e && ("function" == typeof e.toJSON5 ? e = e.toJSON5(u) : "function" == typeof e.toJSON && (e = e.toJSON(u))), r && (e = r.call(D, u, e)), e instanceof Number ? e = Number(e) : e instanceof String ? e = String(e) : e instanceof Boolean && (e = e.valueOf()), e) {
                    case null:
                        return "null";
                    case !0:
                        return "true";
                    case !1:
                        return "false"
                }
                return "string" ==
                    typeof e ? B(e) : "number" == typeof e ? String(e) : "object" == typeof e ? Array.isArray(e) ? function(u) {
                        if (n.indexOf(u) >= 0) throw TypeError("Converting circular structure to JSON5");
                        n.push(u);
                        var D = C;
                        C += A;
                        for (var e, t = [], r = 0; r < u.length; r++) {
                            var F = c(String(r), u);
                            t.push(void 0 !== F ? F : "null")
                        }
                        if (0 === t.length) e = "[]";
                        else if ("" === A) {
                            var E = t.join(",");
                            e = "[" + E + "]"
                        } else {
                            var i = ",\n" + C,
                                o = t.join(i);
                            e = "[\n" + C + o + ",\n" + D + "]"
                        }
                        return n.pop(), C = D, e
                    }(e) : function(u) {
                        if (n.indexOf(u) >= 0) throw TypeError("Converting circular structure to JSON5");
                        n.push(u);
                        var D = C;
                        C += A;
                        for (var e, r, F = t || Object.keys(u), E = [], i = 0, o = F; i < o.length; i += 1) {
                            var a = o[i],
                                B = c(a, u);
                            if (void 0 !== B) {
                                var f = s(a) + ":";
                                "" !== A && (f += " "), f += B, E.push(f)
                            }
                        }
                        if (0 === E.length) e = "{}";
                        else if ("" === A) r = E.join(","), e = "{" + r + "}";
                        else {
                            var l = ",\n" + C;
                            r = E.join(l), e = "{\n" + C + r + ",\n" + D + "}"
                        }
                        return n.pop(), C = D, e
                    }(e) : void 0
            }

            function B(u) {
                for (var D = {
                            "'": .1,
                            '"': .2
                        }, e = {
                            "'": "\\'",
                            '"': '\\"',
                            "\\": "\\\\",
                            "\b": "\\b",
                            "\f": "\\f",
                            "\n": "\\n",
                            "\r": "\\r",
                            "\t": "\\t",
                            "\x0B": "\\v",
                            "\x00": "\\0",
                            "\u2028": "\\u2028",
                            "\u2029": "\\u2029"
                        },
                        t = "", r = 0, n = u; r < n.length; r += 1) {
                    var C = n[r];
                    switch (C) {
                        case "'":
                        case '"':
                            D[C]++, t += C;
                            continue
                    }
                    if (e[C]) t += e[C];
                    else if (C < " ") {
                        var A = C.charCodeAt(0).toString(16);
                        t += "\\x" + ("00" + A).substring(A.length)
                    } else t += C
                }
                var E = F || Object.keys(D).reduce(function(u, e) {
                    return D[u] < D[e] ? u : e
                });
                return E + (t = t.replace(new RegExp(E, "g"), e[E])) + E
            }

            function s(u) {
                if (0 === u.length) return B(u);
                var D = String.fromCodePoint(u.codePointAt(0));
                if (!G.isIdStartChar(D)) return B(u);
                for (var e = D.length; e < u.length; e++)
                    if (!G.isIdContinueChar(String.fromCodePoint(u.codePointAt(e)))) return B(u);
                return u
            }
        }
    }
});
var DgaVars = {
    Evt_Internal_DgaConnected: "Evt_Internal_DgaConnected",
    Evt_Internal_DgaMessage: "Evt_Internal_DgaMessage",
    DgaMessage: "DgaMessage"
};
var xlg = {
    websocket: null,
    wsUrl: null,
    tableId: null,
    casinoId: null,
    tryToConnect: true,
    connect: function(wsUrl, casinoId, tableId) {
        var self = this;
        self.tryToConnect = true;
        self.wsUrl = wsUrl;
        console.log("connecting to " + wsUrl);
        if (self.websocket !== null && self.websocket.readyState !== 3) {
            self.websocket.close();
            console.log("Socket open closing it")
        }
        self.websocket = new WebSocket(wsUrl);
        self.websocket.onopen = function(evt) {
            self.onWsOpen(evt, casinoId, tableId)
        };
        self.websocket.onclose = function(evt) {
            self.onWsClose(evt)
        };
        self.websocket.onmessage =
            function(evt) {
                self.onWsMessage(evt)
            };
        self.websocket.onerror = function(evt) {
            self.onWsError(evt)
        };
        if (tableId) self.tableId = tableId;
        self.casinoId = casinoId
    },
    onMessage: function(data) {
        XT.SetObject(DgaVars.DgaMessage, data);
        XT.TriggerEvent(DgaVars.Evt_Internal_DgaMessage)
    },
    onConnect: function() {
        XT.TriggerEvent(DgaVars.Evt_Internal_DgaConnected)
    },
    disconnect: function() {
        var self = this;
        self.tryToConnect = false;
        self.websocket.close();
        console.log("Disconnected")
    },
    subscribe: function(casinoId, tableId, currency) {
        var subscribeMessage = {
            type: "subscribe",
            key: tableId,
            casinoId: casinoId,
            currency: currency
        };
        console.log("subscribing" + tableId);
        var self = this;
        var jsonSub = JSON.stringify(subscribeMessage);
        self.doWsSend(jsonSub)
    },
    available: function(casinoId) {
        var availableMessage = {
            type: "available",
            casinoId: casinoId
        };
        console.log("checking availability");
        var self = this;
        var jsonSub = JSON.stringify(availableMessage);
        self.doWsSend(jsonSub)
    },
    onWsOpen: function(evt) {
        var self = this;
        if (self.onConnect != null) self.onConnect();
        console.log("Connected to wss server");
        if (self.tableId) self.subscribe(self.casinoId, self.tableId)
    },
    onWsClose: function(evt) {
        console.log("DISCONNECTED");
        var self = this;
        if (self.tryToConnect === true) {
            console.log("RECONNECTING");
            self.connect(self.wsUrl, self.casinoId, self.tableId)
        }
    },
    onWsMessage: function(evt) {
        var self = this;
        var data = JSON.parse(evt.data);
        if (self.onMessage != null) self.onMessage(data)
    },
    onWsError: function(evt) {
        console.log("ERROR: " + evt.data)
    },
    ping: function() {
        var self = this;
        var pingMessage = {
            type: "ping",
            pingTime: Date.now().toString()
        };
        var jsonSub = JSON.stringify(pingMessage);
        self.doWsSend(jsonSub)
    },
    doWsSend: function(message) {
        var self = this;
        console.log("SENT: " + message);
        self.websocket.send(message)
    }
};
var dga = xlg;

function AnimationClip() {
    this.curves = [];
    this.events = [];
    this.name = "";
    this.length = 0;
    this.wrapMode = WrapMode.Default
}

function AnimationClipCurveData() {
    this.path = "";
    this.propertyName = "";
    this.type = "";
    this.curve = null
}

function AnimationEvent() {
    this.functionName = "";
    this.time = 0;
    this.param = ""
}
goog.provide("UHT.AnimationCurve");

function Keyframe(time, value, inTangent, outTangent) {
    var undefined;
    this.time = time;
    this.value = value;
    this.inTangent = inTangent !== undefined ? inTangent : 0;
    this.outTangent = outTangent ? outTangent : 0
}
Keyframe.prototype.__type_name_hack__ = "Keyframe";

function AnimationCurve(keys) {
    this._lastKey = 0;
    this.keys = [];
    var undefined;
    if (keys === undefined) return;
    this.addKeys(keys)
}
AnimationCurve.prototype.clearKeys = function() {
    this.keys = []
};
AnimationCurve.prototype.addKeys = function(keys) {
    var i = keys.length;
    while (i--) this.addKey(keys[i]);
    this.sortKeys()
};
AnimationCurve.prototype.addKey = function(key) {
    this.keys.push(key)
};
AnimationCurve.prototype.sortKeys = function() {
    this.keys.sort(function(a, b) {
        return a.time - b.time
    })
};

function _source() {
    this.times = {
        timesCount: 0,
        increase: 0
    };
    this.inTangents = null;
    this.outTangents = null
}
AnimationCurve.prototype.deserialize = function(source, helper, resolveReference) {
    var i = 0;
    var times = [];
    if (source.times.timesCount != undefined)
        for (i = 0; i < source.times.timesCount; i++) times.push(i * source.times.increase);
    else
        for (i = 0; i < source.times.length; i++) times.push(source.times[i]);
    var values = [];
    for (i = 0; i < source.values.length; i++) values.push(source.values[i]);
    var trimmed;
    trimmed = values[values.length - 1];
    while (values.length < times.length) values.push(trimmed);
    var inTs = [];
    for (i = 0; i < source.inTangents.length; i++) inTs.push(source.inTangents[i]);
    trimmed = inTs[inTs.length - 1];
    while (inTs.length < times.length) inTs.push(trimmed);
    var outTs = [];
    if (source.outTangents == "copy")
        for (i = 0; i < inTs.length; i++) outTs.push(inTs[i]);
    else {
        for (i = 0; i < source.outTangents.length; i++) outTs.push(source.outTangents[i]);
        trimmed = outTs[outTs.length - 1];
        while (outTs.length < times.length) outTs.push(trimmed)
    }
    for (i = 0; i < times.length; i++) {
        var key = new Keyframe(times[i], values[i], inTs[i], outTs[i]);
        this.addKey(key)
    }
};
AnimationCurve.prototype.Evaluate = function(animTime) {
    var undefined;
    var time = animTime;
    var len = this.keys.length;
    if (len === 1) return this.keys[0].value;
    var i, k0, k1;
    this._lastKey = Math.min(this._lastKey, len - 1);
    if (time <= this.keys[0].time) return this.keys[0].value;
    else if (time >= this.keys[len - 1].time) return this.keys[len - 1].value;
    var start = this.keys[this._lastKey].time <= time ? this._lastKey : 0;
    for (i = start; i < len - 1; i++)
        if (this.keys[i].time <= time && this.keys[i + 1].time > time) {
            k0 = this.keys[i];
            k1 = this.keys[i + 1];
            this._lastKey =
                i;
            break
        }
    if (!isFinite(k0.outTangent) || !isFinite(k1.inTangent)) return k0.value;
    var t = UHTMath.inverseLerp(k0.time, k1.time, time);
    var dt = k1.time - k0.time;
    var m0 = k0.outTangent * dt;
    var m1 = k1.inTangent * dt;
    var t2 = t * t;
    var t3 = t2 * t;
    var a = 2 * t3 - 3 * t2 + 1;
    var b = t3 - 2 * t2 + t;
    var c = t3 - t2;
    var d = -2 * t3 + 3 * t2;
    return a * k0.value + b * m0 + c * m1 + d * k1.value
};
AnimationCurve.linear = function(timeStart, valueStart, timeEnd, valueEnd) {
    var k0 = new Keyframe(timeStart, valueStart, 0, 0);
    var k1 = new Keyframe(timeEnd, valueEnd, 0, 0);
    return new AnimationCurve([k0, k1])
};
goog.provide("UHT.AnimationUtils");
var AnimationUtils = {};
var WrapMode = {
    Default: 0,
    Once: 1,
    Clamp: 1,
    Loop: 2,
    PingPong: 4,
    ClampForever: 8
};
goog.provide("UHT.AudioClip");

function AudioClip(name, path) {
    this.name = name;
    this.path = path;
    this.soundjsObject = null
}
AudioClip.prototype.length = 0;
Object.defineProperties(AudioClip.prototype, {
    length: {
        get: function() {
            if (this.soundjsObject != null) return this.soundjsObject.duration / 1E3;
            return 0
        }
    }
});
goog.provide("UHT.Component");
var __component_ctor_just_called = false;

function Component() {
    this.gameObject = null;
    this.enabled = true;
    this._rawData = null;
    this.transform = null;
    this.flags = ComponentStateFlags.onDisable_called;
    __component_ctor_just_called = true
}
Component.prototype.scriptUpdatePriority = 5;
Component.prototype.canReceiveMessage = true;
var ComponentStateFlags = {
    awake_called: 1,
    start_called: 2,
    onEnable_called: 4,
    onDisable_called: 8
};
Component.prototype.deserialize = function(source, helper, resolveReference) {
    deserializeComponentRec(source, this, helper, resolveReference)
};
Component.prototype.copyFromSource = function(source, helper, resolveReference) {
    copyComponentHelper(source, this, helper, resolveReference)
};
Component.prototype.Awake = function() {};
Component.prototype.Start = function() {};
Component.prototype.OnEnable = function() {};
Component.prototype.OnDisable = function() {};
Component.prototype.GetComponent = function(componentType) {
    return this.gameObject.GetComponent(componentType)
};
Component.prototype.GetComponentsInChildren = function(type, includeInactive) {
    return this.gameObject.GetComponentsInChildren(type, includeInactive)
};
Component.prototype.GetComponentInChildren = function(type) {
    return this.gameObject.GetComponentInChildren(type)
};
Component.FindObjectOfType = function(type) {
    var objects = globalRuntime.sceneRoots;
    for (var i = 0; i < objects.length; ++i) {
        var component = objects[i].GetComponentInChildren(type);
        if (component != null && component.gameObject.activeInHierarchy) return component
    }
    return null
};
goog.require("UHT.Component");
var AudioVelocityUpdateMode = {
    Auto: 0,
    Fixed: 1,
    Dynamic: 2
};
UHTAudioListener.prototype = Object.create(Component.prototype);
UHTAudioListener.prototype.constructor = UHTAudioListener;

function UHTAudioListener() {
    Component.call(this)
}
UHTAudioListener.volume = 1;
goog.provide("UHT.Animation");
goog.require("UHT.Component");
Animation.prototype = Object.create(Component.prototype);
Animation.prototype.constructor = Animation;

function Animation() {
    Component.call(this);
    this._clip = null;
    this.playAutomatically = false;
    this.clips = [];
    this._isPlaying = false;
    this.animStates = [];
    this.currentAnimState = null;
    this.isInited = false;
    this._runtime_cache = null
}
Object.defineProperties(Animation.prototype, {
    isPlaying: {
        set: function(value) {},
        get: function() {
            return this._isPlaying
        }
    },
    clip: {
        set: function(value) {
            var isok = false;
            for (var i = 0; i < this.clips.length; i++)
                if (this.clips[i] == value) {
                    isok = true;
                    break
                }
            if (isok && value != null) this._clip = value;
            else {
                this._clip = null;
                console.log("Animation: Tried to set an invalid clip for animation")
            }
        },
        get: function() {
            return this._clip
        }
    }
});
Animation.prototype.canReceiveMessage = false;
Animation.prototype.Start = function() {
    this.Init()
};
Animation.prototype.OnEnable = function() {
    if (this.playAutomatically) this.Play()
};
Animation.prototype.OnDisable = function() {
    this.Stop()
};
Animation.prototype.UpdateAnimation = function() {
    if (this._isPlaying)
        if (this.currentAnimState.Update() == false) this.Stop()
};
Animation.prototype.Init = function() {
    if (this.isInited == false) {
        for (var i = 0; i < this.clips.length; i++) {
            var c = this.clips[i];
            this.AddAnimStateForClip(c)
        }
        this.isInited = true
    }
};
Animation.prototype.GetAnimationState = function(clipName) {
    if (this.isInited == false) this.Init();
    for (var i = 0; i < this.animStates.length; i++)
        if (this.animStates[i].name == clipName) return this.animStates[i];
    return null
};
Animation.prototype.Play = function(clipName) {
    if (!this.gameObject.activeInHierarchy) console.error("Trying to start an animation on an inactive object (" + this.gameObject.name + "). This is undefined behaviour!");
    this.Stop();
    var name = "";
    var undefined;
    if (clipName === undefined)
        if (this.clip != null) name = this.clip.name;
        else return false;
    else name = clipName;
    this.currentAnimState = this.GetAnimationState(name);
    this.currentAnimState.enabled = true;
    this._isPlaying = true;
    globalRuntime.RegisterAnimation(this);
    return true
};
Animation.prototype.IsPlaying = function(clipName) {
    if (this._isPlaying) {
        var astate = this.GetAnimationState(clipName);
        if (astate != null)
            if (astate.enabled) return true
    }
    return false
};
Animation.prototype.Stop = function() {
    if (this._isPlaying && this.currentAnimState != null) {
        this.currentAnimState.Stop();
        this.currentAnimState.enabled = false;
        this.currentAnimState = null;
        this._isPlaying = false;
        globalRuntime.UnregisterAnimation(this)
    }
};
Animation.prototype.Sample = function() {
    for (var i = 0; i < this.animStates.length; i++)
        if (this.animStates[i].enabled) this.animStates[i].Sample()
};
Animation.prototype.AddClip = function(_clip, unusedName) {
    if (this.clips.indexOf(_clip) >= 0) return;
    this.clips.push(_clip);
    this.AddAnimStateForClip(_clip)
};
Animation.prototype.GetClip = function(clipName) {
    for (var i = 0; i < this.clips.length; i++)
        if (this.clips[i].name == clipName) return this.clips[i];
    return null
};
Animation.prototype.AddAnimStateForClip = function(_clip) {
    if (_clip != null) {
        var curState = new AnimationState(_clip);
        curState.Init(this.gameObject);
        this.animStates.push(curState)
    }
};
goog.provide("UHT.AudioSource");
goog.require("UHT.Component");
goog.require("UHT.AudioClip");
AudioSource.prototype = Object.create(Component.prototype);
AudioSource.prototype.constructor = AudioSource;

function AudioSource() {
    Component.call(this);
    this.audio = this;
    this.clip = null;
    this.playOnAwake = false;
    this._volume = 1;
    this._loop = false;
    this._MustPlayClipWhenSoundsAreLoaded = false;
    this.oneShotInstances = []
}
Object.defineProperties(AudioSource.prototype, {
    volume: {
        set: function(value) {
            this._volume = UHTMath.clamp(value, 1E-5, 1);
            if (this.clip != null && this.clip.soundjsObject != null) this.clip.soundjsObject.volume = this._volume;
            for (var i = 0; i < this.oneShotInstances.length; ++i) this.oneShotInstances[i].volume = this._volume
        },
        get: function() {
            return this._volume
        }
    },
    loop: {
        set: function(value) {
            this._loop = value;
            if (this.clip != null && this.clip.soundjsObject != null) this.clip.soundjsObject.loop = this._loop ? -1 : 0
        },
        get: function() {
            return this._loop
        }
    }
});
AudioSource.prototype.canReceiveMessage = false;
AudioSource.prototype.Play = function() {
    if (UHTEngine.SoundsAreLoaded() == false && this.loop) {
        this._MustPlayClipWhenSoundsAreLoaded = true;
        return
    }
    if (this.clip == null || this.clip.soundjsObject == null) return;
    this.clip.soundjsObject.volume = this.volume;
    this.clip.soundjsObject.loop = this.loop ? -1 : 0;
    this.clip.soundjsObject.stop();
    this.clip.soundjsObject.play()
};
AudioSource.prototype.Update = function() {
    if (this._MustPlayClipWhenSoundsAreLoaded && UHTEngine.SoundsAreLoaded()) {
        this._MustPlayClipWhenSoundsAreLoaded = false;
        this.Play()
    }
};
AudioSource.prototype.PlayOneShot = function(clip, volumeScale) {
    if (clip == null || clip.soundjsObject == null) return;
    var options = {
        interrupt: createjs.Sound.INTERRUPT_ANY,
        loop: 0
    };
    if (volumeScale != undefined) options.volume = volumeScale;
    var obj = createjs.Sound.play(clip.name, options);
    var self = this;
    var oneShotCallback = function() {
        self.OnOneShotComplete.apply(self, arguments)
    };
    obj.on("complete", oneShotCallback);
    obj.on("failed", oneShotCallback);
    obj.on("interrupted", oneShotCallback);
    this.oneShotInstances.push(obj)
};
AudioSource.prototype.Stop = function() {
    this._MustPlayClipWhenSoundsAreLoaded = false;
    if (this.clip == null || this.clip.soundjsObject == null) return;
    this.clip.soundjsObject.stop()
};
AudioSource.prototype.OnOneShotComplete = function(event) {
    var idx = this.oneShotInstances.indexOf(event.target);
    this.oneShotInstances.splice(idx, 1)
};
goog.require("UHT.Component");
goog.provide("UHT.Camera");
Camera.prototype = Object.create(Component.prototype);
Camera.prototype.constructor = Camera;

function Camera() {
    Component.call(this);
    this.cullingMask = 0;
    this.depth = 0;
    this.orthographicSize = 1;
    this.container = new PIXI.Container;
    this.clipMaskContainer = new PIXI.Container;
    this.oldSW = 0;
    this.oldSH = 0;
    this.cachedWTSP = new UHTMath.Vector3;
    this.mask = new PIXI.Graphics;
    this.scaledMask = new PIXI.Graphics;
    this.scale = UHTScreen.height / 2 / this.orthographicSize;
    this.extraCameraSettings = undefined;
    this.extraCameraSettingsList = undefined;
    this.ignoreInputBlocked = false;
    this.clipMaskLayer = 0
}
Camera.prototype.canReceiveMessage = false;
Camera.prototype.ComputeClipMask = function() {
    var combinedUsed = false;
    this.mask.clear();
    for (var i = 0; i < this.extraCameraSettingsList.length; i++) {
        var TL = new UHTMath.Vector3(-this.extraCameraSettingsList[i].clipLeft, this.extraCameraSettingsList[i].clipUp, 0);
        var BR = new UHTMath.Vector3(this.extraCameraSettingsList[i].clipRight, -this.extraCameraSettingsList[i].clipDown, 0);
        var TLW = this.gameObject.transform.transformPoint(TL);
        var BRW = this.gameObject.transform.transformPoint(BR);
        var TLS = this.WorldToScreenPoint(TLW);
        var BRS = this.WorldToScreenPoint(BRW);
        var clipX = TLS.x;
        var clipY = TLS.y;
        var clipW = BRS.x - TLS.x;
        var clipH = BRS.y - TLS.y;
        clipX = Math.max(clipX, 0);
        clipY = Math.max(clipY, 0);
        clipW = Math.min(clipW, UHTScreen.width);
        clipH = Math.min(clipH, UHTScreen.height);
        this.mask.beginFill(16777215);
        this.mask.drawRect(clipX, clipY, clipW, clipH);
        if (this.extraCameraSettingsList[i].combineClips) {
            clipX = TLS.x * globalRenderer.MaskResize;
            clipY = TLS.y * globalRenderer.MaskResize;
            clipW = (BRS.x - TLS.x) * globalRenderer.MaskResize;
            clipH = (BRS.y - TLS.y) *
                globalRenderer.MaskResize;
            clipX = Math.max(clipX, 0);
            clipY = Math.max(clipY, 0);
            clipW = Math.min(clipW, UHTScreen.width * globalRenderer.MaskResize);
            clipH = Math.min(clipH, UHTScreen.height * globalRenderer.MaskResize);
            if (!combinedUsed) this.scaledMask.clear();
            this.scaledMask.beginFill(16777215);
            this.scaledMask.drawRect(clipX, clipY, clipW, clipH)
        }
    }
    if (combinedUsed) this.scaledMask.endFill();
    this.mask.endFill()
};
Camera.allCameras = [];
Camera.prototype.Update = function() {
    this.scale = UHTScreen.height / 2 / this.orthographicSize
};
Camera.prototype.OnEnable = function() {
    this.Update()
};
Camera.prototype.OnWillRenderObject = function() {
    var c = this.container;
    var cm = this.clipMaskContainer;
    var isClipping = this.IsClipping();
    var csDirtyFlag = false;
    for (var i = 0; i < this.extraCameraSettingsList.length; i++) csDirtyFlag = true;
    if (this.gameObject.transform.IsDirtyUserFlag(Transform._DirtyFlagCamera) || UHTScreen.width != this.oldSW || UHTScreen.height != this.oldSH || isClipping && csDirtyFlag) {
        this.cachedWTSP = this.WorldToScreenPoint(new UHTMath.Vector3);
        this.gameObject.transform.ClearDirtyUserFlag(Transform._DirtyFlagCamera);
        this.oldSW =
            UHTScreen.width;
        this.oldSH = UHTScreen.height;
        if (isClipping) {
            if (this.clipMaskLayer == 0 || this.extraCameraSettings.combineClips) this.ComputeClipMask();
            this.extraCameraSettings.dirtyFlag = false
        }
        c.dirtyWT = true;
        cm.dirtyWT = true
    }
    c.x = this.cachedWTSP.x;
    c.y = this.cachedWTSP.y;
    c.scale.x = this.scale;
    c.scale.y = this.scale;
    c.mask = isClipping ? this.mask : null;
    if (this.clipMaskLayer != 0) {
        cm.x = this.cachedWTSP.x;
        cm.y = this.cachedWTSP.y;
        cm.scale.x = this.scale;
        cm.scale.y = this.scale;
        if (this.extraCameraSettings.combineClips) {
            c.mask =
                null;
            cm.mask = this.scaledMask
        }
    }
};
Camera.prototype.ScreenToWorldPoint = function(scrPoint) {
    var ret = new UHTMath.Vector3(scrPoint);
    ret.x -= UHTScreen.width / 2;
    ret.y -= UHTScreen.height / 2;
    ret.x *= 1 / this.scale;
    ret.y *= -1 / this.scale;
    ret.add(this.gameObject.transform.position());
    return ret
};
Camera.prototype.WorldToScreenPoint = function(worldPoint) {
    var ret = UHTMath.Vector3.sub(worldPoint, this.gameObject.transform.position());
    ret.x *= this.scale;
    ret.y *= -this.scale;
    ret.x += UHTScreen.width / 2;
    ret.y += UHTScreen.height / 2;
    return ret
};
Camera.prototype.IsClipping = function() {
    if (this.extraCameraSettingsList === undefined) this.extraCameraSettingsList = this.gameObject.GetComponents(ExtraCameraSettings);
    this.extraCameraSettings = this.extraCameraSettingsList[0];
    if (this.extraCameraSettings != null) this.clipMaskLayer = this.extraCameraSettings.clipMaskLayer.mask;
    return this.extraCameraSettings != null && this.extraCameraSettings.enabled && (this.clipMaskLayer == 0 || this.extraCameraSettings.combineClips)
};
Camera.prototype.HasClippingMask = function() {
    return this.clipMaskLayer != 0
};
Camera.prototype.IsClippingInput = function() {
    return this.IsClipping() && this.extraCameraSettings.clipInput
};
goog.provide("UHT.Collider");
goog.require("UHT.Component");
Collider.prototype = Object.create(Component.prototype);
Collider.prototype.constructor = Collider;

function Collider() {
    Component.call(this);
    this.center = new UHTMath.Vector3;
    this.size = new UHTMath.Vector3;
    this.isSphere = false;
    this.cachedTransformedCenter = new UHTMath.Vector3;
    this.cachedTransformedSize = new UHTMath.Vector3
}
Collider.prototype.canReceiveMessage = false;
Collider.prototype.Start = function() {
    globalColliderInputManager.registerCollider(this)
};
Collider.prototype.GetTransformedCenterAndSize = function() {
    if (this.gameObject.transform.IsDirtyUserFlag(Transform._DirtyFlagCollider)) {
        this.UpdateCachedMembers();
        this.gameObject.transform.ClearDirtyUserFlag(Transform._DirtyFlagCollider)
    }
    return {
        center: new UHTMath.Vector3(this.cachedTransformedCenter),
        size: new UHTMath.Vector3(this.cachedTransformedSize)
    }
};
Collider.prototype.UpdateCachedMembers = function() {
    this.cachedTransformedCenter = this.gameObject.transform.transformPoint(this.center);
    this.cachedTransformedSize = this.gameObject.transform.transformVector(this.size)
};
goog.provide("UHT.ClampVelocityModule");

function ClampVelocityModule(ps) {
    this.dampen = 0;
    this.magnitude = null;
    this.x = null;
    this.y = null;
    this.z = null;
    this.separateAxis = false;
    this.inWorldSpace = false;
    this.dampPos = 0;
    this.particleSystem = ps
}
ClampVelocityModule.prototype.deserialize = function(src) {
    this.reset();
    this.inWorldSpace = src.inWorldSpace === "True";
    this.separateAxis = src.separateAxis === "True";
    this.dampen = UHTMath.clamp(Number(src.dampen), 0, 1);
    if (this.separateAxis) {
        this.x = new ParticleSystemEvaluator;
        this.y = new ParticleSystemEvaluator;
        this.z = new ParticleSystemEvaluator;
        this.x.deserialize(src.x);
        this.y.deserialize(src.y);
        this.z.deserialize(src.z)
    } else {
        this.magnitude = new ParticleSystemEvaluator;
        this.magnitude.deserialize(src.magnitude)
    }
};
ClampVelocityModule.prototype.Evaluate = function(time, velocity) {
    var ret = new UHTMath.Vector3;
    if (this.separateAxis === true) {
        var coords = ["x", "y", "z"];
        var i = coords.length;
        var desiredMagnitude = new UHTMath.Vector3;
        while (i--) desiredMagnitude[coords[i]] = Math.max(0, this[coords[i]].Evaluate(time));
        if (!this.inWorldSpace) {
            desiredMagnitude = this.particleSystem.gameObject.transform.transformDirection(desiredMagnitude);
            i = coords.length;
            while (i--) {
                var c = coords[i];
                if (desiredMagnitude[c] < 0) desiredMagnitude[c] = 0
            }
        }
        i = coords.length;
        while (i--) {
            var c = coords[i];
            var av = Math.abs(velocity[c]);
            var sign = velocity[c] / av;
            if (av > desiredMagnitude[c]) ret[c] = UHTMath.lerp(av, desiredMagnitude[c], this.dampPos) * sign;
            else ret[c] = velocity[c]
        }
    } else {
        var curMagnitude = velocity.magnitude();
        if (Math.abs(curMagnitude) > 1E-5) {
            var unit = UHTMath.Vector3.scale(velocity, 1 / curMagnitude);
            var desiredMagnitude = this.magnitude.Evaluate(time);
            var delta = UHTMath.lerp(curMagnitude, desiredMagnitude, this.dampPos);
            ret.set(UHTMath.Vector3.scale(unit, delta))
        }
    }
    this.dampPos += this.dampen;
    return ret
};
ClampVelocityModule.prototype.reset = function() {
    if (this.magnitude != null) this.magnitude.reset();
    if (this.x != null) this.x.reset();
    if (this.y != null) this.y.reset();
    if (this.z != null) this.z.reset();
    this.dampPos = 0
};
goog.provide("UHT.ParticleSystemEvaluator");

function ParticleSystemEvaluator() {
    this.minMaxState = 0;
    this.scalar = 0;
    this.minCurve = new AnimationCurve;
    this.maxCurve = new AnimationCurve;
    this.random = 0
}
ParticleSystemEvaluator.prototype.Evaluate = function(time) {
    switch (this.minMaxState) {
        case 3:
        case 2:
            var min = this.minCurve.Evaluate(time);
            var max = this.maxCurve.Evaluate(time);
            return this.scalar * (min + (max - min) * this.random);
            break;
        case 1:
            return this.maxCurve.Evaluate(time) * this.scalar;
            break;
        default:
            return this.scalar
    }
};
ParticleSystemEvaluator.prototype.deserialize = function(src) {
    this.random = Math.random();
    this.minMaxState = Number(src.minMaxState);
    this.scalar = Number(src.scalar);
    this.fillFrom(this.minCurve, src.minCurve);
    this.fillFrom(this.maxCurve, src.maxCurve)
};
ParticleSystemEvaluator.prototype.ReRandomize = function() {
    this.random = Math.random()
};
ParticleSystemEvaluator.prototype.fillFrom = function(dest, src) {
    if (src.cachedKeys !== undefined) {
        dest.keys = src.cachedKeys;
        return
    }
    dest.clearKeys();
    var i = src.m_Curve.Array.size;
    while (i--) {
        var o = src.m_Curve.Array["data[" + i.toString() + "]"];
        var key = new Keyframe(Number(o.time), Number(o.value), Number(o.inSlope), Number(o.outSlope));
        dest.addKey(key)
    }
    dest.sortKeys();
    src.cachedKeys = dest.keys
};
ParticleSystemEvaluator.prototype.reset = function() {
    this.minCurve.clearKeys();
    this.maxCurve.clearKeys()
};
goog.provide("UHT.ParticleSystemEvaluatorBySpeed");

function ParticleSystemEvaluatorBySpeed(ev) {
    this.evaluator = ev;
    this.intervalMin = 0;
    this.intervalMax = 0;
    this.evaluator.scalar = 1
}
ParticleSystemEvaluatorBySpeed.prototype.Evaluate = function(time) {
    var v = UHTMath.inverseLerp(this.intervalMin, this.intervalMax, time);
    return this.evaluator.Evaluate(v)
};
ParticleSystemEvaluatorBySpeed.prototype.deserialize = function(src) {
    var undefined;
    this.evaluator.deserialize(src.curve !== undefined ? src.curve : src.gradient);
    this.intervalMin = Number(src.range.x);
    this.intervalMax = Number(src.range.y)
};
ParticleSystemEvaluatorBySpeed.prototype.reset = function() {
    this.evaluator.reset()
};
goog.provide("UHT.ParticleSystemEvaluatorColor");

function GradientColor() {
    this.r = 1;
    this.g = 1;
    this.b = 1;
    this.a = 1
}
GradientColor.prototype.fromString = function(str) {
    var n = Number(str) | 0;
    this.r = n & 255;
    this.g = n >> 8 & 255;
    this.b = n >> 16 & 255;
    this.a = n >> 24 & 255
};
GradientColor.prototype.toRGBHex = function() {
    return Math.floor((this.r << 16) + (this.g << 8) + this.b)
};
GradientColor.prototype.toARGBHex = function() {
    return Math.floor((this.a << 24) + (this.r << 16) + (this.g << 8) + this.b)
};

function GradientNEW() {
    this.numColorKeys = 0;
    this.numAlphaKeys = 0;
    this.keysColor = [];
    this.keysTimeAlpha = [];
    this.keysTimeColor = [];
    this._lastKeyColor = 0;
    this._lastKeyAlpha = 0
}
GradientNEW.prototype.fromString = function(str) {
    this.reset();
    this.numAlphaKeys = Number(str.m_NumAlphaKeys);
    this.numColorKeys = Number(str.m_NumColorKeys);
    for (var i = 0; i < 8; i++) {
        var c = new GradientColor;
        c.fromString(str["key" + i]["rgba"]);
        this.keysColor.push(c);
        this.keysTimeAlpha.push(Number(str["atime" + i]) / 65535);
        this.keysTimeColor.push(Number(str["ctime" + i]) / 65535)
    }
};
GradientNEW.prototype.searchNearestKey = function(keys, percent, maxNumKeys, cache) {
    var i;
    var start = cache || 0;
    if (!(keys[start] <= percent && keys[start + 1] > percent)) start = 0;
    var n = maxNumKeys - 1;
    for (i = start; i < n; i++)
        if (keys[i] < percent && keys[i + 1] > percent) return i;
    return Math.max(0, n - 1)
};
GradientNEW.prototype.Evaluate = function(percent) {
    var ck;
    var pc;
    var ak;
    var pa;
    var gc = new GradientColor;
    if (percent < this.keysTimeColor[0]) {
        gc.r = this.keysColor[0].r;
        gc.g = this.keysColor[0].g;
        gc.b = this.keysColor[0].b
    } else if (percent > this.keysTimeColor[this.numColorKeys - 1]) {
        var k = this.numColorKeys - 1;
        gc.r = this.keysColor[k].r;
        gc.g = this.keysColor[k].g;
        gc.b = this.keysColor[k].b
    } else {
        ck = this.searchNearestKey(this.keysTimeColor, percent, this.numColorKeys, this._lastKeyColor);
        this._lastKeyColor = ck;
        pc = UHTMath.inverseLerp(this.keysTimeColor[ck],
            this.keysTimeColor[ck + 1], percent);
        gc.r = UHTMath.lerp(this.keysColor[ck].r, this.keysColor[ck + 1].r, pc);
        gc.g = UHTMath.lerp(this.keysColor[ck].g, this.keysColor[ck + 1].g, pc);
        gc.b = UHTMath.lerp(this.keysColor[ck].b, this.keysColor[ck + 1].b, pc)
    }
    if (percent < this.keysTimeAlpha[0]) gc.a = this.keysColor[0].a;
    else if (percent > this.keysTimeAlpha[this.numAlphaKeys - 1]) {
        var k = this.numAlphaKeys - 1;
        gc.a = this.keysColor[k].a
    } else {
        ak = this.searchNearestKey(this.keysTimeAlpha, percent, this.numAlphaKeys, this._lastKeyAlpha);
        this._lastKeyAlpha =
            ak;
        pa = UHTMath.inverseLerp(this.keysTimeAlpha[ak], this.keysTimeAlpha[ak + 1], percent);
        gc.a = UHTMath.lerp(this.keysColor[ak].a, this.keysColor[ak + 1].a, pa)
    }
    return gc
};
GradientNEW.prototype.reset = function() {
    this.numColorKeys = 0;
    this.numAlphaKeys = 0;
    this.keysColor = [];
    this.keysTimeAlpha = [];
    this.keysTimeColor = [];
    this._lastKeyColor = 0;
    this._lastKeyAlpha = 0
};

function ParticleSystemEvaluatorColor() {
    this.minMaxState = 0;
    this.minGradient = new GradientNEW;
    this.maxGradient = new GradientNEW;
    this.random = 0;
    this.minColor = new GradientColor;
    this.maxColor = new GradientColor
}
ParticleSystemEvaluatorColor.prototype.Evaluate = function(time) {
    switch (this.minMaxState) {
        case 3:
            var min = this.minGradient.Evaluate(time);
            var max = this.maxGradient.Evaluate(time);
            var gc = new GradientColor;
            gc.r = min.r + (max.r - min.r) * this.random;
            gc.g = min.g + (max.g - min.g) * this.random;
            gc.b = min.b + (max.b - min.b) * this.random;
            gc.a = min.a + (max.a - min.a) * this.random;
            return gc;
            break;
        case 2:
            var min = this.minColor;
            var max = this.maxColor;
            var gc = new GradientColor;
            gc.r = min.r + (max.r - min.r) * this.random;
            gc.g = min.g + (max.g - min.g) *
                this.random;
            gc.b = min.b + (max.b - min.b) * this.random;
            gc.a = min.a + (max.a - min.a) * this.random;
            return gc;
            break;
        case 1:
            return this.maxGradient.Evaluate(time);
            break;
        case 0:
            return this.maxColor;
            break;
        default:
            return new GradientColor
    }
};
ParticleSystemEvaluatorColor.prototype.deserialize = function(src) {
    this.random = Math.random();
    this.minMaxState = Number(src.minMaxState);
    this.minGradient.fromString(src.minGradient);
    this.maxGradient.fromString(src.maxGradient);
    this.maxColor.fromString(src.maxColor.rgba);
    this.minColor.fromString(src.minColor.rgba)
};
goog.provide("UHT.ParticleSystemShape");
goog.provide("UHT.ParticleSystemShapeType");
var ParticleSystemShapeType = {
    sphere: 0,
    sphereShell: 1,
    hemisphere: 2,
    mesh: 3,
    cone: 4,
    box: 5,
    coneBaseShell: 7
};

function ParticleSystemShape() {}
ParticleSystemShape.prototype.generateNewPosition = function() {
    return new UHTMath.Vector3
};
ParticleSystemShape.prototype.getEmissionDirection = function() {
    return new UHTMath.Vector3
};
goog.provide("UHT.ParticleSystemShapeBox");
ParticleSystemShapeBox.prototype = Object.create(ParticleSystemShape.prototype);
ParticleSystemShapeBox.prototype.constructor = ParticleSystemShape;

function ParticleSystemShapeBox() {
    this.boxX = 1;
    this.boxY = 1;
    this.boxZ = 1
}
ParticleSystemShapeBox.prototype.generateNewPosition = function() {
    return new UHTMath.Vector3(this.boxX * (Math.random() - .5), this.boxY * (Math.random() - .5), this.boxZ * (Math.random() - .5))
};
ParticleSystemShapeBox.prototype.deserialize = function(src) {
    this.boxX = Number(src.boxX);
    this.boxY = Number(src.boxY);
    this.boxZ = Number(src.boxZ)
};
ParticleSystemShapeBox.prototype.getEmissionDirection = function(forPosition) {
    var undefined;
    if (forPosition !== undefined) return new UHTMath.Vector3(0, 0, 1);
    else {
        var d = new UHTMath.Vector3(2 * Math.random() - 1, 2 * Math.random() - 1, 2 * Math.random() - 1);
        d.normalize();
        return d
    }
};
goog.provide("UHT.ParticleSystemShapeCone");
ParticleSystemShapeCone.prototype = Object.create(ParticleSystemShape.prototype);
ParticleSystemShapeCone.prototype.constructor = ParticleSystemShape;

function ParticleSystemShapeCone() {
    this.angle = 0;
    this.radius = 1;
    this.type = 7
}
ParticleSystemShapeCone.prototype.generateNewPosition = function() {
    var alpha = Math.random() * 2 * UHTMath.PI;
    var x = this.type == ParticleSystemShapeType.coneBaseShell ? 1 : Math.random();
    var y = this.type == ParticleSystemShapeType.coneBaseShell ? 1 : Math.random();
    return new UHTMath.Vector3(x * this.radius * Math.cos(alpha), y * this.radius * Math.sin(alpha), 0)
};
ParticleSystemShapeCone.prototype.deserialize = function(src) {
    this.angle = Number(src.angle);
    this.radius = Number(src.radius) / 2;
    this.type = Number(src.type)
};
ParticleSystemShapeCone.prototype.getEmissionDirection = function(forPosition) {
    var undefined;
    var percent = 1;
    var x, z;
    if (forPosition !== undefined) {
        var f = new UHTMath.Vector3(forPosition);
        f.z = 0;
        var l = f.magnitude();
        percent = l / this.radius;
        x = f.x;
        z = f.y
    } else {
        x = 2 * Math.random() - 1;
        z = 2 * Math.random() - 1
    }
    var c = Math.cos(UHTMath.toRad(this.angle * percent));
    var ssq = 1 - c * c;
    var lsq = x * x + z * z;
    var scale = Math.sqrt(ssq / lsq);
    x *= scale;
    z *= scale;
    var v = new UHTMath.Vector3(x, z, c);
    v.normalize();
    return v
};
goog.provide("UHT.ParticleSystemShapeSphere");
ParticleSystemShapeSphere.prototype = Object.create(ParticleSystemShape.prototype);
ParticleSystemShapeSphere.prototype.constructor = ParticleSystemShape;

function ParticleSystemShapeSphere() {
    this.radius = 1;
    this.type = 7
}
ParticleSystemShapeSphere.prototype.generateNewPosition = function() {
    var phi = Math.random() * 2 * UHTMath.PI;
    var cosTheta = Math.random() * 2 - 1;
    var u = this.type == ParticleSystemShapeType.sphereShell ? 1 : Math.random();
    var theta = Math.acos(cosTheta);
    var r = this.radius * Math.pow(u, 1 / 3);
    return new UHTMath.Vector3(r * Math.sin(theta) * Math.cos(phi), r * Math.sin(theta) * Math.sin(phi), r * Math.cos(theta))
};
ParticleSystemShapeSphere.prototype.deserialize = function(src) {
    this.radius = Number(src.radius);
    this.type = Number(src.type)
};
ParticleSystemShapeSphere.prototype.getEmissionDirection = function(forPosition) {
    var undefined;
    if (forPosition !== undefined) {
        var f = new UHTMath.Vector3(forPosition);
        f.normalize();
        return f
    } else {
        var x = 2 * Math.random() - 1;
        var y = 2 * Math.random() - 1;
        var z = 2 * Math.random() - 1;
        var f = new UHTMath.Vector3(x, y, z);
        f.normalize();
        return f
    }
};
goog.provide("UHT.FontLoader");
var FontDetect = function() {
    var _isInitialized = false;
    var _aFallbackFonts = ["serif", "sans-serif", "monospace", "cursive", "fantasy"];
    var span = null;
    var span_dots = null;

    function _init() {
        if (_isInitialized) return;
        _isInitialized = true;
        var body = document.body;
        var firstChild = document.body.firstChild;
        var div = document.createElement("div");
        div.id = "fontdetectHelper";
        span = document.createElement("span");
        span.innerText = "0123456789";
        div.appendChild(span);
        span_dots = document.createElement("span_dots");
        span_dots.innerText = "..........";
        div.appendChild(span_dots);
        body.insertBefore(div, firstChild);
        div.style.position = "absolute";
        div.style.visibility = "hidden";
        div.style.top = "-200px";
        div.style.left = "-100000px";
        div.style.width = "100000px";
        div.style.height = "200px";
        div.style.fontSize = "100px"
    }
    return {
        onFontLoaded: function(p_cssFontName, p_onLoad, p_onFail, p_options) {
            if (!p_cssFontName) return;
            var msInterval = p_options && p_options.msInterval ? p_options.msInterval : 100;
            var msTimeout = p_options && p_options.msTimeout ? p_options.msTimeout : 1E4;
            if (!p_onLoad &&
                !p_onFail) return;
            if (!_isInitialized) _init();
            if (this.isFontLoaded(p_cssFontName, p_options)) {
                if (p_onLoad) p_onLoad(p_cssFontName);
                return
            }
            var outerThis = this;
            var utStart = (new Date).getTime();
            var idInterval = setInterval(function() {
                if (outerThis.isFontLoaded(p_cssFontName, p_options)) {
                    clearInterval(idInterval);
                    p_onLoad(p_cssFontName);
                    return
                } else {
                    var utNow = (new Date).getTime();
                    if (utNow - utStart > msTimeout) {
                        clearInterval(idInterval);
                        if (p_onFail) p_onFail(p_cssFontName)
                    }
                }
            }, msInterval)
        },
        isFontLoaded: function(p_cssFontName,
            p_options) {
            var wThisFont = 0;
            var wPrevFont = 0;
            span.innerText = p_options && p_options.text ? p_options.text : "0123456789";
            if (!_isInitialized) _init();
            for (var ix = 0; ix < _aFallbackFonts.length; ++ix) {
                span.style.fontFamily = p_cssFontName + "," + _aFallbackFonts[ix];
                span_dots.style.fontFamily = p_cssFontName + "," + _aFallbackFonts[ix];
                if (span.offsetWidth == span_dots.offsetWidth) return false;
                wThisFont = span.offsetWidth;
                if (ix > 0 && wThisFont != wPrevFont) return false;
                wPrevFont = wThisFont
            }
            return true
        }
    }
}();
var FontLoader = function() {
    var FontStatus = {
        Loading: 0,
        Loaded: 1,
        Failed: 2
    };
    var fontStatus = {};
    var handlers = {};

    function onFontFail(fontName) {
        var fn = SafeFontName(fontName);
        fontStatus[fn] = FontStatus.Failed;
        Trigger(fn, FontStatus.Failed)
    }

    function onFontLoad(fontName) {
        var fn = SafeFontName(fontName);
        fontStatus[fn] = FontStatus.Loaded;
        Trigger(fn, FontStatus.Loaded)
    }

    function AppendFontFace(fontFace) {
        var ss = document.createElement("style");
        if (ss.styleSheet) ss.styleSheet.cssText = fontFace;
        else ss.appendChild(document.createTextNode(fontFace));
        document.getElementsByTagName("head")[0].appendChild(ss)
    }

    function LoadFont(fontName, fontFace, options) {
        var fn = SafeFontName(fontName);
        var force = options && options.force ? options.force : false;
        if (force || fontStatus[fn] == undefined) {
            fontStatus[fn] = FontStatus.Loading;
            if (fontFace != null) AppendFontFace(fontFace);
            FontDetect.onFontLoaded(fontName, onFontLoad, onFontFail, options)
        }
    }

    function AddHandler(fontName, callback, object) {
        var fn = SafeFontName(fontName);
        if (fontStatus[fn] == FontStatus.Loaded || fontStatus[fn] == FontStatus.Failed) {
            callback.call(object,
                fontStatus[fn]);
            return
        }
        if (handlers[fn] == undefined) handlers[fn] = [];
        handlers[fn].push({
            obj: object,
            func: callback
        })
    }

    function IsLoaded(fontName) {
        var fn = SafeFontName(fontName);
        return fontStatus[fn] == FontStatus.Loaded
    }

    function Trigger(safeFontName, status) {
        if (handlers[safeFontName] == undefined) return;
        for (var i = 0; i < handlers[safeFontName].length; ++i) handlers[safeFontName][i].func.call(handlers[safeFontName][i].obj, status);
        delete handlers[safeFontName]
    }

    function SafeFontName(fontName) {
        return fontName.replace(/\s/g,
            "_")
    }
    return {
        LoadFont: LoadFont,
        AddHandler: AddHandler,
        IsLoaded: IsLoaded
    }
}();
goog.provide("UHT.GameObject");
goog.require("UHT.Collider");
goog.require("UHT.Animation");

function GameObject() {
    this.name = "";
    this.activeSelf = false;
    this.layer = 0;
    this.activeInHierarchy = false;
    this.components = [];
    this.transform = null;
    this.collider = null;
    this.animation = null
}
GameObject.prototype.GetComponent = function(componentType) {
    var realType = componentType;
    if (typeof realType == "string") realType = window[realType];
    for (var i = 0; i < this.components.length; i++)
        if (this.components[i] instanceof realType) return this.components[i];
    return null
};
GameObject.prototype.GetComponents = function(componentType) {
    var list = [];
    var realType = componentType;
    if (typeof realType == "string") realType = window[realType];
    for (var i = 0; i < this.components.length; i++)
        if (this.components[i] instanceof realType) list.push(this.components[i]);
    return list
};
GameObject.prototype.GetComponentsInChildren = function(componentType, includeInactive) {
    var list = [];
    if (this.activeInHierarchy || includeInactive) {
        for (var i = 0; i < this.components.length; i++)
            if (this.components[i] instanceof componentType) list.push(this.components[i]);
        for (var j = 0; j < this.transform.children.length; j++) list = list.concat(this.transform.children[j].gameObject.GetComponentsInChildren(componentType, includeInactive))
    }
    return list
};
GameObject.prototype.GetComponentInChildren = function(componentType) {
    if (this.activeInHierarchy) {
        for (var i = 0; i < this.components.length; i++)
            if (this.components[i] instanceof componentType) return this.components[i];
        for (var j = 0; j < this.transform.children.length; j++) {
            var component = this.transform.children[j].gameObject.GetComponentInChildren(componentType);
            if (component != null) return component
        }
    }
    return null
};
GameObject.prototype.SetActive = function(active) {
    if (this.activeSelf != active) {
        this.activeSelf = active;
        this.internalUpdateActive(true, true)
    }
};
GameObject.prototype.SendMessage = function(methodName, value) {
    if (!this.activeInHierarchy) return;
    for (var i = 0; i < this.components.length; i++) {
        var curComp = this.components[i];
        if (curComp.canReceiveMessage)
            if (curComp[methodName] != undefined) curComp[methodName](value)
    }
};
GameObject.prototype.AddComponent = function(componentName) {
    var newComp = createComponent(componentName, true);
    if (newComp != null) {
        this.components.push(newComp);
        newComp.gameObject = this;
        if (this.activeInHierarchy) {
            newComp.Awake();
            callOnEnable(newComp);
            newComp.Start();
            newComp.flags |= ComponentStateFlags.awake_called | ComponentStateFlags.start_called
        }
        this.internalCacheComponent(newComp);
        newComp.transform = this.transform
    }
    return newComp
};
GameObject.prototype.internalUpdateActive = function(onEnableCallAllowed, onDisableCallAllowed) {
    computeActiveState(this);
    callComponentCallback(this, "Awake", ComponentStateFlags.awake_called);
    if (onEnableCallAllowed) callComponentOnEnable(this);
    callComponentCallback(this, "Start", ComponentStateFlags.start_called);
    if (onDisableCallAllowed) callComponentOnDisable(this)
};
GameObject.prototype.internalCopyFromOther = function(source) {
    this.name = source.name;
    this.activeSelf = source.activeSelf;
    this.layer = source.layer
};
GameObject.prototype.internalCacheComponent = function(newComp) {
    if (newComp instanceof Transform) this.transform = newComp;
    else if (newComp instanceof Collider) this.collider = newComp;
    else if (newComp instanceof Animation) this.animation = newComp
};
goog.require("UHT.Component");
goog.require("UHT.GameObject");

function AnimationState(_clip) {
    this.name = _clip.name;
    this.enabled = false;
    this.weight = 0;
    this.length = _clip.length;
    this.speed = 1;
    this.normalizedTime = 0;
    this.time = 0;
    this.wrapMode = _clip.wrapMode;
    this.clip = _clip;
    this.applyData = [];
    this._rootGameObject = null;
    this.extraTime = 0;
    this.sortedEvents = []
}
AnimationState.CurveApplyData = function(_type, _obj) {
    this.type = _type;
    this.obj = _obj;
    this.comp = null;
    this.propertyName = "";
    this.curve1 = null;
    this.curve2 = null;
    this.curve3 = null;
    this.curve4 = null
};
AnimationState.CurveApplyType = {
    Invalid: 0,
    TransformPosition: 1,
    TransformRotation: 2,
    TransformScale: 3,
    GameObjectActive: 4,
    Custom: 5
};
AnimationState.prototype.Init = function(rootGameObject) {
    this._rootGameObject = rootGameObject;
    var isProcessed = _array.create(this.clip.curves.length, false);
    for (var i = 0; i < this.clip.curves.length; i++) {
        if (isProcessed[i]) continue;
        var curData = this.clip.curves[i];
        var obj = rootGameObject.transform.Find(curData.path);
        if (obj != null) {
            isProcessed[i] = true;
            var t = this.ComputeApplyType(curData.propertyName);
            var curApplyData = new AnimationState.CurveApplyData(t.type, obj.gameObject);
            curApplyData["curve" + t.index] = curData.curve;
            if (t.type == AnimationState.CurveApplyType.Custom) {
                curApplyData.propertyName = curData.propertyName;
                curApplyData.comp = obj.gameObject.GetComponent(curData.type);
                this.applyData.push(curApplyData);
                continue
            }
            for (var k = i + 1; k < this.clip.curves.length; k++) {
                if (isProcessed[k]) continue;
                var nextData = this.clip.curves[k];
                if (curData.path != nextData.path) continue;
                var obj2 = rootGameObject.transform.Find(nextData.path);
                if (obj2 != null && obj2 == obj) {
                    var t2 = this.ComputeApplyType(nextData.propertyName);
                    if (t2.type != t.type) continue;
                    curApplyData["curve" + t2.index] = nextData.curve;
                    isProcessed[k] = true
                }
            }
            this.applyData.push(curApplyData)
        }
    }
    this.SortEvents()
};
AnimationState.prototype.Sample = function() {
    for (var i = 0; i < this.applyData.length; i++) this.Apply(this.applyData[i])
};
AnimationState.prototype.Update = function() {
    this.Sample();
    if (this.speed == 0) return true;
    for (var j = 0; j < this.sortedEvents.length; j++) {
        var event = this.sortedEvents[j];
        if (Math.abs(event.time - this.time) < 1E-6) this._rootGameObject.SendMessage(event.functionName, event.param)
    }
    var s = this.speed;
    var forward = s >= 0;
    if (forward && this.time > this.length || !forward && this.time < 0)
        if (this.wrapMode == WrapMode.Loop) {
            this.time += forward ? -this.length : this.length;
            return true
        } else return false;
    var timeIncrement = (Time.deltaTime + this.extraTime) *
        s;
    var d = Math.abs(this.ComputeTimeToNextEvent(forward) / s);
    if (d < Math.abs(timeIncrement)) {
        this.extraTime += Math.abs(timeIncrement / s) - Math.abs(d * s);
        this.time += forward ? d : -d
    } else {
        this.extraTime = 0;
        this.time += timeIncrement
    }
    return true
};
AnimationState.prototype.ComputeTimeToNextEvent = function(forward) {
    if (forward)
        for (var i = 0; i < this.sortedEvents.length; i++) {
            var d = this.sortedEvents[i].time - this.time;
            if (d > 0) return d
        } else
            for (var j = this.sortedEvents.length - 1; j >= 0; j--) {
                var d2 = this.time - this.sortedEvents[j].time;
                if (d2 > 0) return d2
            }
    return Number.MAX_VALUE
};
AnimationState.prototype.SortEvents = function() {
    this.sortedEvents = [];
    for (var i = 0; i < this.clip.events.length; i++) this.sortedEvents.push(this.clip.events[i]);
    this.sortedEvents.sort(function(a, b) {
        return a.time - b.time
    })
};
AnimationState.prototype.Stop = function() {
    this.time = 0
};
AnimationState.prototype.Apply = function(applyData) {
    var x;
    var y;
    var z;
    var w;
    switch (applyData.type) {
        case AnimationState.CurveApplyType.TransformPosition:
            x = applyData.curve1.Evaluate(this.time);
            y = applyData.curve2.Evaluate(this.time);
            z = applyData.curve3.Evaluate(this.time);
            applyData.obj.transform.fastSetLocalPosition(x, y, z);
            break;
        case AnimationState.CurveApplyType.TransformRotation:
            x = applyData.curve1.Evaluate(this.time);
            y = applyData.curve2.Evaluate(this.time);
            z = applyData.curve3.Evaluate(this.time);
            w = applyData.curve4.Evaluate(this.time);
            applyData.obj.transform.fastSetLocalRotation(x, y, z, w);
            break;
        case AnimationState.CurveApplyType.TransformScale:
            x = applyData.curve1.Evaluate(this.time);
            y = applyData.curve2.Evaluate(this.time);
            z = applyData.curve3.Evaluate(this.time);
            applyData.obj.transform.fastSetLocalScale(x, y, z);
            break;
        case AnimationState.CurveApplyType.GameObjectActive:
            if (applyData.curve1 != null) {
                var isActive = applyData.curve1.Evaluate(this.time);
                applyData.obj.SetActive(isActive > .5)
            }
            break;
        case AnimationState.CurveApplyType.Custom:
            if (applyData.curve1 !=
                null && applyData.comp != null && applyData.propertyName != "") {
                var value = applyData.curve1.Evaluate(this.time);
                var path = applyData.propertyName.split(".");
                var field = applyData.comp;
                for (var i = 0; i < path.length - 1; i++) {
                    if (field[path[i]] == undefined) {
                        console.error("Animation: Property path '" + applyData.propertyName + "' is invalid!");
                        return
                    }
                    field = field[path[i]]
                }
                if (field[path[path.length - 1]] == undefined) {
                    console.error("Animation: Property path '" + applyData.propertyName + "' is invalid!");
                    return
                }
                field[path[path.length - 1]] =
                    value
            }
            break;
        default:
            break
    }
};
AnimationState.prototype.ComputeApplyType = function(propPath) {
    switch (propPath) {
        case "m_LocalPosition.x":
            return {
                type: AnimationState.CurveApplyType.TransformPosition,
                index: 1
            };
        case "m_LocalPosition.y":
            return {
                type: AnimationState.CurveApplyType.TransformPosition,
                index: 2
            };
        case "m_LocalPosition.z":
            return {
                type: AnimationState.CurveApplyType.TransformPosition,
                index: 3
            };
        case "m_LocalRotation.x":
            return {
                type: AnimationState.CurveApplyType.TransformRotation,
                index: 1
            };
        case "m_LocalRotation.y":
            return {
                type: AnimationState.CurveApplyType.TransformRotation,
                index: 2
            };
        case "m_LocalRotation.z":
            return {
                type: AnimationState.CurveApplyType.TransformRotation,
                index: 3
            };
        case "m_LocalRotation.w":
            return {
                type: AnimationState.CurveApplyType.TransformRotation,
                index: 4
            };
        case "m_LocalScale.x":
            return {
                type: AnimationState.CurveApplyType.TransformScale,
                index: 1
            };
        case "m_LocalScale.y":
            return {
                type: AnimationState.CurveApplyType.TransformScale,
                index: 2
            };
        case "m_LocalScale.z":
            return {
                type: AnimationState.CurveApplyType.TransformScale,
                index: 3
            };
        case "m_IsActive":
            return {
                type: AnimationState.CurveApplyType.GameObjectActive,
                index: 1
            };
        default:
            return {
                type: AnimationState.CurveApplyType.Custom,
                index: 1
            }
    }
};

function deserializeComponentRec(source, dest, helper, resolveReference) {
    var keys = Object.keys(source);
    for (var i = 0; i < keys.length; i++) {
        var name = keys[i];
        var cur = source[name];
        if (internalRawDataIsReference(cur)) {
            dest[name] = helper[resolveReference](source[name]);
            if (source[name]["guid"]) dest[name + "_@GUID"] = source[name]["guid"]
        } else if (internalProcessAsNestedClass(cur, dest, name, helper, resolveReference));
        else if (Array.isArray(cur)) {
            dest[name] = new Array(cur.length);
            for (var k = 0; k < cur.length; k++)
                if (cur[k] == null) dest[name][k] =
                    null;
                else if (cur[k] instanceof Object) deserializeComponentRec(cur[k], dest[name][k], helper, resolveReference);
            else dest[name][k] = cur[k]
        } else if (cur instanceof Object) dest[name] = JSON.parse(JSON.stringify(cur));
        else dest[name] = cur
    }
}

function internalRawDataIsReference(data) {
    var prop = "fileID";
    if (Array.isArray(data) && data.length > 0) {
        for (var i = 0; i < data.length; i++)
            if (data[i] instanceof Object && data[i].hasOwnProperty(prop)) return true;
        return false
    } else if (data instanceof Object && data.hasOwnProperty(prop)) return true;
    return false
}

function internalProcessAsNestedClass(source, dest, fieldName, helper, resolveReference) {
    var prop = "nestedFieldType";
    if (Array.isArray(source) && source.length > 0 && source[0] instanceof Object && source[0].hasOwnProperty(prop)) {
        dest[fieldName] = new Array(source.length);
        for (var i = 0; i < source.length; i++) {
            var typeName = source[i][prop];
            dest[fieldName][i] = createNestedObject(typeName);
            if (dest[fieldName][i]["deserialize"] != null) dest[fieldName][i]["deserialize"](source[i]["serializableData"], helper, resolveReference);
            else if (dest[fieldName][i] !=
                null) deserializeComponentRec(source[i]["serializableData"], dest[fieldName][i], helper, resolveReference)
        }
        return true
    } else if (source instanceof Object && source.hasOwnProperty(prop)) {
        dest[fieldName] = createNestedObject(source[prop]);
        if (dest[fieldName]["deserialize"] != null) dest[fieldName]["deserialize"](source["serializableData"], helper, resolveReference);
        else if (dest[fieldName] != null) deserializeComponentRec(source["serializableData"], dest[fieldName], helper, resolveReference);
        return true
    }
    return false
}

function isReference(obj) {
    return obj instanceof GameObject || obj instanceof Component || obj instanceof TextAsset || obj instanceof AudioClip || obj instanceof AnimationClip || obj instanceof UHTSpine
}
goog.provide("UHT.KeyboardManager");
var KeyCode = {
    Space: 32,
    Return: 13,
    Backspace: 8,
    Alpha0: 48,
    Alpha1: 49,
    Alpha2: 50,
    Alpha3: 51,
    Alpha4: 52,
    Alpha5: 53,
    Alpha6: 54,
    Alpha7: 55,
    Alpha8: 56,
    Alpha9: 57,
    Keypad0: 96,
    Keypad1: 97,
    Keypad2: 98,
    Keypad3: 99,
    Keypad4: 100,
    Keypad5: 101,
    Keypad6: 102,
    Keypad7: 103,
    Keypad8: 104,
    Keypad9: 105,
    DecimalPoint: 110,
    Comma: 188,
    Period: 190
};
var KeyboardManager = {
    _internalStates: {},
    _states: {},
    _keyboardReceiver: {}
};
KeyboardManager.KeyState = {
    Up: 0,
    JustDown: 1,
    Down: 2,
    Consumed: 3
};
KeyboardManager.focus = true;
KeyboardManager.Init = function() {
    if (UHT_DEVICE_TYPE.MOBILE) return;
    window.addEventListener("keyup", function(event) {
        KeyboardManager.onKeyUp(event)
    }, false);
    window.addEventListener("keydown", function(event) {
        KeyboardManager.onKeyDown(event)
    }, false);
    if (UHT_FRAME) document.body.addEventListener("mousedown", function() {
        window.focus()
    }, true);
    window.addEventListener("blur", function(event) {
        KeyboardManager.SetFocus(false)
    }, true);
    window.addEventListener("focus", function(event) {
        KeyboardManager.SetFocus(true)
    }, true)
};
KeyboardManager.SetFocus = function(isFocus) {
    KeyboardManager.focus = isFocus
};
KeyboardManager.Update = function() {
    if (UHT_DEVICE_TYPE.MOBILE) return;
    KeyboardManager._states = JSON.parse(JSON.stringify(KeyboardManager._internalStates));
    for (var i in KeyboardManager._internalStates)
        if (KeyboardManager._internalStates.hasOwnProperty(i)) {
            if (KeyboardManager._internalStates[i] == KeyboardManager.KeyState.JustDown) KeyboardManager._internalStates[i] = KeyboardManager.KeyState.Down;
            if (!KeyboardManager.focus) KeyboardManager._internalStates[i] = KeyboardManager.KeyState.Up
        }
};
KeyboardManager.onKeyUp = function(event) {
    KeyboardManager._internalStates[event.keyCode] = KeyboardManager.KeyState.Up;
    UHTEngine.RegisterUserInteraction()
};
KeyboardManager.onKeyDown = function(event) {
    if (loaderIsVisible) return;
    var state = KeyboardManager._internalStates[event.keyCode];
    if (state == KeyboardManager.KeyState.Up || state == undefined) KeyboardManager._internalStates[event.keyCode] = KeyboardManager.KeyState.JustDown;
    else if (state != KeyboardManager.KeyState.Consumed) KeyboardManager._internalStates[event.keyCode] = KeyboardManager.KeyState.Down;
    if (KeyboardManager._keyboardReceiver["OnKeyDown"] != undefined) KeyboardManager._keyboardReceiver["OnKeyDown"](event.key);
    UHTEngine.RegisterUserInteraction()
};
KeyboardManager.IsKeyDown = function(keyCode, consume) {
    if (KeyboardManager._states.hasOwnProperty(keyCode) && KeyboardManager._keyboardReceiver["OnKeyDown"] == undefined && !Globals.WatchingReplay) {
        var ret = KeyboardManager._states[keyCode] == KeyboardManager.KeyState.JustDown;
        if (ret && consume == true) {
            KeyboardManager._states[keyCode] = KeyboardManager.KeyState.Consumed;
            KeyboardManager._internalStates[keyCode] = KeyboardManager.KeyState.Consumed
        }
        return ret
    }
    return false
};
KeyboardManager.IsKey = function(keyCode) {
    if (KeyboardManager._states.hasOwnProperty(keyCode) && KeyboardManager._keyboardReceiver["OnKeyDown"] == undefined && !Globals.WatchingReplay) return KeyboardManager._states[keyCode] == KeyboardManager.KeyState.Down;
    return false
};
goog.provide("UHT.Color");

function Color() {
    this._r = 0;
    this._g = 0;
    this._b = 0;
    this.a = 0;
    this.rgbAsHex = 0
}
Object.defineProperties(Color.prototype, {
    r: {
        get: function() {
            return this._r
        },
        set: function(nR) {
            this._r = nR;
            this.compute_rgbAsHex()
        }
    },
    g: {
        get: function() {
            return this._g
        },
        set: function(nG) {
            this._g = nG;
            this.compute_rgbAsHex()
        }
    },
    b: {
        get: function() {
            return this._b
        },
        set: function(nB) {
            this._b = nB;
            this.compute_rgbAsHex()
        }
    }
});
Color.prototype.deserialize = function(source, helper, resolveReference) {
    var c = source["c"];
    var sColorLen = c.length;
    if (sColorLen == 1) switch (c) {
        case "w":
            this._r = 1;
            this._g = 1;
            this._b = 1;
            this.a = 1;
            break;
        case "k":
            this._r = 0;
            this._g = 0;
            this._b = 0;
            this.a = 1;
            break;
        case "r":
            this._r = 1;
            this._g = 0;
            this._b = 0;
            this.a = 1;
            break;
        case "g":
            this._r = 0;
            this._g = 1;
            this._b = 0;
            this.a = 1;
            break;
        case "b":
            this._r = 0;
            this._g = 0;
            this._b = 1;
            this.a = 1;
            break
    } else if (sColorLen >= 6) {
        this._r = UHTMath.lerp(0, 1, parseInt(c.substring(0, 2), 16) / 255);
        this._g = UHTMath.lerp(0,
            1, parseInt(c.substring(2, 4), 16) / 255);
        this._b = UHTMath.lerp(0, 1, parseInt(c.substring(4, 6), 16) / 255);
        if (sColorLen == 6) this.a = 1;
        else this.a = UHTMath.lerp(0, 1, parseInt(c.substring(6, 8), 16) / 255)
    }
    this.compute_rgbAsHex()
};
Color.prototype.rgbAsString = function() {
    return "RGB(" + Math.floor(this._r * 255) + ", " + Math.floor(this._g * 255) + ", " + Math.floor(this._b * 255) + ")"
};
Color.prototype.rgbaAsString = function() {
    var ret = "RGBA(" + Math.floor(this._r * 255) + ", " + Math.floor(this._g * 255) + ", " + Math.floor(this._b * 255) + ", " + this.a + ")";
    return ret
};
Color.prototype.compute_rgbAsHex = function() {
    this.rgbAsHex = Math.floor((this._r * 255 << 16) + (this._g * 255 << 8) + this._b * 255)
};
Color.prototype.argbAsHex = function() {
    return Math.floor((this.a * 255 << 24) + (this._r * 255 << 16) + (this._g * 255 << 8) + this._b * 255)
};
Color.Lerp = function(color1, color2, t) {
    var ret = new Color;
    var _t = UHTMath.clamp(t, 0, 1);
    ret.r = color1.r + (color2.r - color1.r) * _t;
    ret.g = color1.g + (color2.g - color1.g) * _t;
    ret.b = color1.b + (color2.b - color1.b) * _t;
    ret.a = color1.a + (color2.a - color1.a) * _t;
    return ret
};
Color.qLerp = function(target, color1, color2, t) {
    var _t = UHTMath.clamp(t, 0, 1);
    target.r = color1.r + (color2.r - color1.r) * _t;
    target.g = color1.g + (color2.g - color1.g) * _t;
    target.b = color1.b + (color2.b - color1.b) * _t;
    target.a = color1.a + (color2.a - color1.a) * _t
};
goog.provide("UHT.EventHandler");

function EventHandler(object, callback) {
    this.object = object;
    this.callback = callback;
    this.isEnabled = true
}
EventHandler.prototype.equals = function(object, callback) {
    return object == this.object && callback == this.callback
};
EventHandler.prototype.call = function() {
    if (this.isEnabled) this.callback.apply(this.object, arguments)
};
goog.provide("UHT.Gradient");
goog.require("UHT.Color");

function GradientColorKey(color, time) {
    this.color = color == undefined ? null : color;
    this.time = time == undefined ? 0 : time
}

function GradientAlphaKey() {
    this.alpha = 0;
    this.time = 0
}

function Gradient() {
    this.colorKeys = [];
    this.alphaKeys = []
}

function LayerMask() {
    this.mask = 0
}
LayerMask.prototype.value = function() {
    var val = -1;
    var m = this.mask;
    while (m != 0) {
        val++;
        m = m / 2;
        m = Math.floor(m)
    }
    return val
};
goog.provide("UHT.Random");
var Random = {
    Range: function(min, max) {
        var rand = Math.random() * (max - min) + min;
        if (_number.isFloat(min) || _number.isFloat(max)) return rand;
        else return Math.floor(rand)
    }
};
goog.provide("UHT.TextAsset");

function TextAsset(content) {
    this.text = content
}
var Time = {
    deltaTime: 0,
    time: 0,
    frameCount: 0,
    deltaTimeInRealTime: 0
};
goog.provide("UHT.System.Misc.Utils");
var _string = {
    IsNullOrEmpty: function(str) {
        return !(typeof str == "string" && _string.Trim(str).length > 0)
    },
    Trim: function(str, trimChars) {
        if (trimChars == undefined) trimChars = "\\s";
        return String(str).replace(new RegExp("^[" + trimChars + "]+|[" + trimChars + "]+$", "g"), "")
    },
    TrimEnd: function(str, trimChars) {
        if (trimChars == undefined) trimChars = "\\s";
        return String(str).replace(new RegExp("[" + trimChars + "]+$", "g"), "")
    }
};
_string.PadLeft = function(target, character, length) {
    var res = String(target);
    var count = length - res.length;
    for (var i = 0; i < count; ++i) res = character + res;
    return res
};
var _number = {
    otod: function(param) {
        var s = String(param);
        s = s.replace(/,/g, "");
        var rv = parseFloat(s);
        rv = isFinite(rv) && !isNaN(rv) ? rv : 0;
        return rv
    },
    otoi: function(param) {
        var rv = parseInt(param, 10);
        rv = isFinite(rv) && !isNaN(rv) ? rv : 0;
        return rv
    },
    otoui: function(param) {
        return _number.otoi(param)
    },
    isFloat: function(n) {
        return n === +n && n !== (n | 0)
    },
    isInt: function(n) {
        return n === +n && n === (n | 0)
    }
};
var _bool = {
    Parse: function(s) {
        var tmp = _string.Trim(s);
        return tmp == "true" || tmp == "True"
    }
};
var _window = {
    OnLoad: function(handler) {
        if (window.addEventListener) window.addEventListener("load", handler, false);
        else if (window.attachEvent) window.attachEvent("onload", handler)
    }
};
var _MonoBehaviour = {
    StartCoroutine: function(method, object, seconds, args) {
        setTimeout(function() {
            method.call(object, args)
        }, seconds * 1E3)
    }
};
var _array = {
    create: function(length, defaultValue) {
        var arr = [];
        arr.length = length;
        if (defaultValue != undefined)
            for (var i = 0; i < length; ++i) arr[i] = defaultValue;
        return arr
    },
    indexOf: function(element, arr) {
        for (var i = 0; i < arr.length; i++)
            if (arr[i] == element) return i;
        return -1
    },
    ConvertAll: function(array, converter) {
        var ret = [];
        for (var i = 0; i < array.length; ++i)
            if (!_string.IsNullOrEmpty(array[i])) ret.push(converter(array[i]));
        return ret
    },
    InsertRange: function(target, index, collection) {
        for (var i = collection.length - 1; i >= 0; --i) target.splice(index,
            0, collection[i])
    },
    AddRange: function(target, collection) {
        for (var i = 0; i < collection.length; ++i) target.push(collection[i])
    }
};

function TimeSpan(h, m, s) {
    this.Hours = h;
    this.Minutes = m;
    this.Seconds = s
}
TimeSpan.prototype.ToString = function() {
    var res = [];
    res.push(_string.PadLeft(this.Hours, "0", 2));
    res.push(_string.PadLeft(this.Minutes, "0", 2));
    res.push(_string.PadLeft(this.Seconds, "0", 2));
    return res.join(":")
};
TimeSpan.FromSeconds = function(seconds) {
    var h = Math.floor(seconds / 3600);
    seconds %= 3600;
    var m = Math.floor(seconds / 60);
    var s = seconds % 60;
    return new TimeSpan(h, m, s)
};
var DateTime = {};
DateTime.ToString = function(date, format) {
    return format.replace("dd", _string.PadLeft(date.getDate(), "0", 2)).replace("MM", _string.PadLeft(date.getMonth() + 1, "0", 2)).replace("yyyy", _string.PadLeft(date.getFullYear(), "0", 4)).replace("HH", _string.PadLeft(date.getHours(), "0", 2)).replace("mm", _string.PadLeft(date.getMinutes(), "0", 2)).replace("ss", _string.PadLeft(date.getSeconds(), "0", 2))
};
var jsonParse = function() {
    var r = "(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)",
        k = '(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))';
    k = '(?:"' + k + '*")';
    var s = new RegExp("(?:false|true|null|[\\{\\}\\[\\]]|" + r + "|" + k + ")", "g"),
        t = new RegExp("\\\\(?:([^u])|u(.{4}))", "g"),
        u = {
            '"': '"',
            "/": "/",
            "\\": "\\",
            b: "\b",
            f: "\f",
            n: "\n",
            r: "\r",
            t: "\t"
        };

    function v(h, j, e) {
        return j ? u[j] : String.fromCharCode(parseInt(e, 16))
    }
    var w = new String(""),
        x = Object.hasOwnProperty;
    return function(h, j) {
        h =
            h.match(s);
        var e, c = h[0],
            l = false;
        if ("{" === c) e = {};
        else if ("[" === c) e = [];
        else {
            e = [];
            l = true
        }
        for (var b, d = [e], m = 1 - l, y = h.length; m < y; ++m) {
            c = h[m];
            var a;
            switch (c.charCodeAt(0)) {
                default: a = d[0];a[b || a.length] = +c;b = void 0;
                break;
                case 34:
                        c = c.substring(1, c.length - 1);
                    if (c.indexOf("\\") !== -1) c = c.replace(t, v);a = d[0];
                    if (!b)
                        if (a instanceof Array) b = a.length;
                        else {
                            b = c || w;
                            break
                        }
                    a[b] = c;b = void 0;
                    break;
                case 91:
                        a = d[0];d.unshift(a[b || a.length] = []);b = void 0;
                    break;
                case 93:
                        d.shift();
                    break;
                case 102:
                        a = d[0];a[b || a.length] = false;b = void 0;
                    break;
                case 110:
                        a = d[0];a[b || a.length] = null;b = void 0;
                    break;
                case 116:
                        a = d[0];a[b || a.length] = true;b = void 0;
                    break;
                case 123:
                        a = d[0];d.unshift(a[b || a.length] = {});b = void 0;
                    break;
                case 125:
                        d.shift();
                    break
            }
        }
        if (l) {
            if (d.length !== 1) throw new Error;
            e = e[0]
        } else if (d.length) throw new Error;
        if (j) {
            var p = function(n, o) {
                var f = n[o];
                if (f && typeof f === "object") {
                    var i = null;
                    for (var g in f)
                        if (x.call(f, g) && f !== n) {
                            var q = p(f, g);
                            if (q !== void 0) f[g] = q;
                            else {
                                i || (i = []);
                                i.push(g)
                            }
                        }
                    if (i)
                        for (g = i.length; --g >= 0;) delete f[i[g]]
                }
                return j.call(n,
                    o, f)
            };
            e = p({
                "": e
            }, "")
        }
        return e
    }
}();
var UID = {};
UID.generated = [];
UID.Generate = function() {
    var uid = null;
    do uid = Math.random().toString(36).substring(2) + (new Date).getTime().toString(36); while (UID.generated.indexOf(uid) > -1);
    UID.generated.push(uid);
    return uid
};

function ListOfInts() {
    this.list = []
}

function ListOfFloats() {
    this.list = []
}
var _JSON = {};
_JSON.TryParse = function(json) {
    var ret = null;
    try {
        ret = JSON.parse(json)
    } catch (e) {}
    return ret
};
var _PIXI = {};
_PIXI.Texture = {};
_PIXI.Texture.white = null;
_PIXI.Texture.WHITE = function() {
    var pt = _PIXI.Texture;
    if (pt.white != null) return pt.white;
    var size = 16;
    var gr = new PIXI.Graphics;
    gr.beginFill(16777215);
    gr.drawRect(0, 0, size, size);
    gr.endFill();
    var ret = new PIXI.RenderTexture(globalRenderer.renderer, size, size);
    ret.render(gr);
    pt.white = ret;
    return ret
};
_PIXI.Sprite = {};
_PIXI.Sprite.white = null;
_PIXI.Sprite.WHITE = function() {
    var ps = _PIXI.Sprite;
    if (ps.white != null) return ps.white;
    var pt = _PIXI.Texture;
    var ret = new PIXI.Sprite(pt.WHITE());
    ps.white = ret;
    return ret
};
var _Color = {};
_Color.white = null;
_Color.WHITE = function() {
    var c = _Color;
    if (c.white != null) return c.white;
    var ret = new Color;
    ret.r = ret.g = ret.b = ret.a = 1;
    c.white = ret;
    return ret
};

function _Available() {
    this.all = [];
    this.available = []
}
_Available.prototype.Create = function() {};
_Available.prototype.Reset = function(obj) {};
_Available.prototype.Get = function() {
    if (this.available.length < 1) {
        var obj = this.Create();
        this.all.push(obj);
        this.available.push(obj)
    }
    return this.available.pop()
};
_Available.prototype.Set = function(obj) {
    this.Reset(obj);
    this.available.push(obj)
};
_PIXI.Text = {};
_PIXI.Text.Create = function() {
    return new PIXI.Text("")
};
_PIXI.Text.Reset = function(obj) {
    obj.canvas.width = 1;
    obj.canvas.height = 1;
    obj.context.scale(1, 1);
    obj.updateTexture()
};
_PIXI.Text.available = null;
_PIXI.Text.GetAvailable = function() {
    var av = _PIXI.Text.available;
    if (av == null) {
        var rt = _PIXI.Text;
        av = new _Available;
        av.Create = rt.Create;
        av.Reset = rt.Reset;
        _PIXI.Text.available = av
    }
    return av.Get()
};
_PIXI.Text.SetAvailable = function(rt) {
    var av = _PIXI.Text.available;
    if (av != null) av.Set(rt)
};
var LML_renderOptions = {
    view: null,
    resolution: 1,
    antialias: false,
    forceFXAA: false,
    autoResize: false,
    transparent: true,
    backgroundColor: 0,
    clearBeforeRender: false,
    preserveDrawingBuffer: false
};
var LML_renderer = PIXI.autoDetectRenderer(100, 100, LML_renderOptions, true);
_PIXI.RenderTexture = {};
_PIXI.RenderTexture.Create = function() {
    return new PIXI.RenderTexture(LML_renderer)
};
_PIXI.RenderTexture.Reset = function(obj) {
    obj.resolution = 1;
    obj.resize(1, 1, true)
};
_PIXI.RenderTexture.available = null;
_PIXI.RenderTexture.GetAvailable = function() {
    var av = _PIXI.RenderTexture.available;
    if (av == null) {
        var rt = _PIXI.RenderTexture;
        av = new _Available;
        av.Create = rt.Create;
        av.Reset = rt.Reset;
        _PIXI.RenderTexture.available = av
    }
    return av.Get()
};
_PIXI.RenderTexture.SetAvailable = function(rt) {
    var av = _PIXI.RenderTexture.available;
    if (av != null) av.Set(rt)
};
var _Clipboard = {};
_Clipboard.CopyText = function(text) {
    var textArea = document.createElement("textarea");
    textArea.style.position = "fixed";
    textArea.style.top = 0;
    textArea.style.left = 0;
    textArea.style.width = "2em";
    textArea.style.height = "2em";
    textArea.style.padding = 0;
    textArea.style.border = "none";
    textArea.style.outline = "none";
    textArea.style.boxShadow = "none";
    textArea.style.background = "transparent";
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    var supported = false;
    try {
        supported = document.execCommand("copy")
    } catch (err) {}
    document.body.removeChild(textArea);
    return supported
};
var _HTML = {};
_HTML.CreateElement = function(tag, attributes, append) {
    var el = document.createElement(tag);
    for (var name in attributes) el.setAttribute(name, attributes[name]);
    if (append) document.body.appendChild(el);
    return el
};
_HTML.RemoveClass = function(element, className) {
    var newClass = String(element.className).replace(new RegExp(className, "g"), "").replace(/\s+/g, " ").replace(/^\s+|\s+$/g, "");
    element.className = newClass
};
_HTML.AddClass = function(element, className) {
    _HTML.RemoveClass(element, className);
    var newClass = [String(element.className), className].join(" ");
    element.className = newClass
};
goog.provide("UHT.Runtime");

function Runtime() {
    this.sceneRoots = [];
    this.animComponentList = null;
    this.updateList = [];
    for (var suo = 0; suo < 10; suo++) this.updateList.push({
        components: [],
        availableIndices: [],
        activeItems: 0
    });
    this.lateUpdateList = {
        components: [],
        availableIndices: [],
        activeItems: 0
    };
    this.onWillRenderList = {
        components: [],
        availableIndices: [],
        activeItems: 0
    }
}

function AnimListNode(_data) {
    this.data = _data;
    this.prev = null;
    this.next = null
}
Runtime.prototype.addNewSceneRoot = function(obj) {
    this.sceneRoots.push(obj);
    obj.internalUpdateActive(true, false)
};
Runtime.prototype.doFrame = function() {
    for (var suo = 0; suo < 10; suo++) this.CallOnGameObjectList(this.updateList[suo], "Update", "internalUpdateIdx");
    this.UpdateAnimations();
    this.CallOnGameObjectList(this.lateUpdateList, "LateUpdate", "internalLateUpdateIdx");
    this.CallOnGameObjectList(this.onWillRenderList, "OnWillRenderObject", "internalOnWillRenderIdx")
};
Runtime.prototype.RegisterAnimation = function(anim) {
    var n = new AnimListNode(anim);
    anim._runtime_cache = n;
    n.next = this.animComponentList;
    if (this.animComponentList != null) this.animComponentList.prev = n;
    this.animComponentList = n
};
Runtime.prototype.UnregisterAnimation = function(anim) {
    var o = anim._runtime_cache;
    var p = o.prev;
    var n = o.next;
    if (p == null) this.animComponentList = n;
    else p.next = n;
    if (n != null) n.prev = p;
    anim._runtime_cache = null
};
Runtime.prototype.UpdateAnimations = function() {
    var n = this.animComponentList;
    while (n != null) {
        n.data.UpdateAnimation();
        n = n.next
    }
};
Runtime.prototype.CallOnGameObjectList = function(listDesc, methodName, compIdxName) {
    this.DefragmentList(listDesc, compIdxName);
    var comps = listDesc.components;
    var l = comps.length;
    for (var i = 0; i < l; i++) {
        var c = comps[i];
        if (c != null) c[methodName]()
    }
};
Runtime.prototype.DefragmentList = function(listDesc, compIdxName) {
    if (listDesc.activeItems < .75 * listDesc.components.length) {
        var old = listDesc.components;
        listDesc.components = [];
        for (var i = 0; i < old.length; i++)
            if (old[i] != null) {
                old[i][compIdxName] = listDesc.components.length;
                listDesc.components.push(old[i])
            }
        listDesc.availableIndices = []
    }
};
Runtime.prototype.InternalAddToList = function(comp, listDesc, compIdxName) {
    if (comp[compIdxName] != undefined) console.log("Bataie si mai mare de joc!");
    var newIdx = -1;
    if (listDesc.availableIndices.length > 0) {
        newIdx = listDesc.availableIndices.pop();
        listDesc.components[newIdx] = comp
    } else {
        newIdx = listDesc.components.length;
        listDesc.components.push(comp)
    }
    comp[compIdxName] = newIdx;
    listDesc.activeItems++
};
Runtime.prototype.InternalRemoveFromList = function(comp, listDesc, compIdxName) {
    var idx = comp[compIdxName];
    if (idx == undefined) console.log("Bataie de joc!");
    listDesc.components[idx] = null;
    listDesc.availableIndices.push(idx);
    delete comp[compIdxName];
    listDesc.activeItems--
};
Runtime.prototype.AddToUpdateList = function(comp) {
    var suo = comp.scriptUpdatePriority;
    if (suo > 9) console.log("Bad script priority " + suo);
    this.InternalAddToList(comp, this.updateList[suo], "internalUpdateIdx")
};
Runtime.prototype.AddToLateUpdateList = function(comp) {
    this.InternalAddToList(comp, this.lateUpdateList, "internalLateUpdateIdx")
};
Runtime.prototype.AddToOnWillRenderList = function(comp) {
    this.InternalAddToList(comp, this.onWillRenderList, "internalOnWillRenderIdx")
};
Runtime.prototype.RemoveFromUpdateList = function(comp) {
    var suo = comp.scriptUpdatePriority;
    this.InternalRemoveFromList(comp, this.updateList[suo], "internalUpdateIdx")
};
Runtime.prototype.RemoveFromLateUpdateList = function(comp) {
    this.InternalRemoveFromList(comp, this.lateUpdateList, "internalLateUpdateIdx")
};
Runtime.prototype.RemoveFromOnWillRenderList = function(comp) {
    this.InternalRemoveFromList(comp, this.onWillRenderList, "internalOnWillRenderIdx")
};
goog.provide("UHT.UHTScreen");
var UHTScreen = {
    width: -1,
    height: -1
};
goog.provide("UHT.Tracking");

function Tracking() {
    this.trackedTimers = {};
    this.QueuedTimers = [];
    this.QueuedEvents = [];
    this.PauseTime = 0
}
Tracking.prototype.PauseTimers = function() {
    this.PauseTime = (new Date).getTime()
};
Tracking.prototype.ResumeTimers = function() {
    if (this.PauseTime != 0) {
        var diff = (new Date).getTime() - this.PauseTime;
        for (var timer in this.trackedTimers) this.trackedTimers[timer] += diff
    }
};
Tracking.prototype._internalUseStartTime = function(category, timer, time, type) {
    this.trackedTimers[type + "____" + category + "____" + timer] = time
};
Tracking.prototype.StartTimer = function(category, variable, type) {
    this.trackedTimers[type + "____" + category + "____" + variable] = (new Date).getTime()
};
Tracking.prototype.StopTimerAndSend = function(category, variable, type) {
    var time = this.GetTimerValue(category, variable, type);
    if (time > 0 && time < 1 * 60 * 60 * 1E3) {
        var qTimer = {
            category: category,
            variable: variable,
            time: time,
            type: type
        };
        globalTracking.QueuedTimers.push(qTimer)
    }
};
Tracking.prototype.GetTimerValue = function(category, timer, type) {
    if (this.trackedTimers[type + "____" + category + "____" + timer] === undefined) {
        console.log("[Tracking] Tried to stop timer " + type + "____" + category + "____" + timer + " before starting it");
        return 0
    }
    return (new Date).getTime() - this.trackedTimers[type + "____" + category + "____" + timer]
};
Tracking.prototype.SendEvent = function(category, action, value, type) {
    var qEvent = {
        category: category,
        action: action,
        value: value,
        type: type
    };
    globalTracking.QueuedEvents.push(qEvent)
};
Tracking.prototype.SendTimer = function(category, variable, time, type) {
    var qTimer = {
        category: category,
        variable: variable,
        time: time,
        type: type
    };
    globalTracking.QueuedTimers.push(qTimer)
};
var globalTracking = new Tracking;
var SendTrackingIfQueued = function() {
    if (globalTracking.QueuedTimers.length > 0) {
        var qTimer = globalTracking.QueuedTimers[0];
        globalTracking.QueuedTimers.splice(0, 1);
        ga(qTimer.type + ".send", "timing", qTimer.category, qTimer.variable, qTimer.time, ServerOptions.gameSymbol);
        if (UHT_LOCAL) console.log("GA (timer): C[" + qTimer.type + "." + qTimer.category + "] V[" + qTimer.variable + "] T[" + qTimer.time / 1E3 + "s] - " + ServerOptions.gameSymbol)
    }
    if (globalTracking.QueuedEvents.length > 0) {
        var qEvent = globalTracking.QueuedEvents[0];
        globalTracking.QueuedEvents.splice(0,
            1);
        ga(qEvent.type + ".send", "event", qEvent.category, qEvent.action, ServerOptions.gameSymbol, qEvent.value);
        if (UHT_LOCAL) console.log("GA          (event): C[" + qEvent.type + "." + qEvent.category + "] A[" + qEvent.action + "] V[" + qEvent.value + "] - " + ServerOptions.gameSymbol)
    }
    setTimeout(SendTrackingIfQueued, 1250)
};
SendTrackingIfQueued();
goog.provide("UHT.UHTEngine");
var UHTEngine = {
    StartDownloadingMainGame: function(listener, callbackDownloadDone, callbackHide) {
        downloadMainGame(listener, callbackDownloadDone, callbackHide)
    },
    HideLoader: function() {
        loaderController[loaderCallbackHide]()
    },
    SignalLoaderIsHidden: function() {
        loaderIsVisible = false
    },
    LoadAssetBundle: function(data, path) {
        if (globalImporter.state == Importer.State.Idle) {
            globalImporter.StartImport(0, [data]);
            var ret = globalImporter.Advance([data], path);
            globalImporter.clear();
            return ret.objects[0]
        } else {
            console.error("Importer not ready!");
            return null
        }
    },
    StartLoadingSounds: function() {
        SoundLoader.LoadSounds()
    },
    SoundsAreLoaded: function() {
        return SoundLoader.soundsAreLoaded
    },
    SoundsAreLoading: function() {
        return !SoundLoader.soundsAreLoaded && SoundLoader.soundsAreBeingLoaded
    },
    WaitingForSounds: function() {
        return false
    },
    IsFullscreen: function() {
        return IsFullscreen()
    },
    RequestFullscreen: function() {
        return RequestFullscreen()
    },
    ExitFullscreen: function() {
        return ExitFullscreen()
    },
    CheckUserAgent: function(browserWarningShown, callback, object) {
        var msgMng = window["SystemMessageManager"] ||
            null;
        if (msgMng == null) {
            setTimeout(function() {
                UHTEngine.CheckUserAgent(browserWarningShown, callback, object)
            }, 200);
            return
        }
        msgMng.CheckUserAgent(browserWarningShown, callback, object)
    },
    HideFirstLoader: function() {
        document.getElementById("wheelofpatience").style.display = "none";
        EventManager.AddHandler("EVT_UHT_BEFOREUPDATE", UHTInterfaceBOSS.OnUHTUpdate, UHTInterfaceBOSS)
    },
    RegisterUserInteraction: function() {
        var msgMng = window["SystemMessageManager"] || null;
        if (msgMng != null) window["SystemMessageManager"].UserInteraction();
        UHTInterfaceBOSS.UserInteraction()
    },
    SetBatterySaverState: function(isOn) {
        batterySaverIsOff = !isOn
    },
    SignalCanStartPrefetchingUnusedAtlasses: function() {
        timerToStartPrefetching = 5
    }
};
var UHTInterfaceBOSS = {};
UHTInterfaceBOSS.enabled = UHT_GAME_CONFIG["extend_events"];
UHTInterfaceBOSS.currentRoundID = "0";
UHTInterfaceBOSS.listener = window[UHT_GAME_CONFIG_SRC["extend_events_listener"]] || null;
UHTInterfaceBOSS.inGameRound = false;
UHTInterfaceBOSS.gameSoundIsOn = null;
UHTInterfaceBOSS.pauseCommands = [];
UHTInterfaceBOSS.soundCommands = [];
UHTInterfaceBOSS.setMaxBetCommands = [];
UHTInterfaceBOSS.setBetCommands = [];
UHTInterfaceBOSS.commands = [];
UHTInterfaceBOSS.isXTInit = false;
UHTInterfaceBOSS.isPaytableOpen = false;
UHTInterfaceBOSS.paytableIsOpenedFromPaytable = false;
UHTInterfaceBOSS.PostMessage = function(message) {
    if (message == "gameRoundEnded")
        if (GameConnection.I.requestState == RequestState.Collect || GameConnection.I.srvResponse.NextGameActions != null && GameConnection.I.srvResponse.NextGameActions.indexOf(NextGameAction.Collect) > -1) {
            GameConnection.I.mustPostGameRoundEndedOnCollect = true;
            return
        }
    if (message == "resultShown") {
        UHTInterfaceBOSS.OnVisualBalanceUpdate();
        if (UHTInterfaceBOSS.inGameRound) return
    }
    var args = {};
    if (UHTInterfaceBOSS.enabled) {
        args.sender = URLGameSymbol;
        args.lang =
            UHT_GAME_CONFIG["LANGUAGE"].toUpperCase();
        args.success = true;
        if (!/gameLoading/.test(message) && message != "post_updateBalance") {
            var balance = XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived);
            args.winAmount = XT.GetDouble(Vars.SpinCycleWinReceived) + XT.GetDouble(TournamentVars.Promotion_WinReceived);
            args.balanceAfter = balance;
            args.betAmount = CoinManager.GetNextTotalBet();
            args.balanceBefore = balance;
            args.amount = balance
        }
        if (message == "gameRoundStarted") {
            args.name = "gameRoundStart";
            UHTInterfaceBOSS.PostMessageRec(window.parent,
                args);
            UHTInterfaceBOSS.inGameRound = true
        }
        args.name = message;
        UHTInterfaceBOSS.PostMessageRec(window.parent, args);
        if (message == "gameRoundEnded") {
            UHTInterfaceBOSS.inGameRound = false;
            if (XT.GetDouble(Vars.SpinCycleWinReceived) == 0) {
                args.name = "resultShown";
                UHTInterfaceBOSS.PostMessageRec(window.parent, args);
                UHTInterfaceBOSS.OnVisualBalanceUpdate()
            }
            args.name = "balanceChanged";
            UHTInterfaceBOSS.PostMessageRec(window.parent, args);
            if (UHTInterfaceBOSS.pauseCommands.length > 0) UHTInterfaceBOSS.Pause(UHTInterfaceBOSS.pauseCommands.shift())
        }
        if (message ==
            "gameLoadingStarted") {
            args.event = "loaded";
            UHTInterfaceBOSS.PostMessageRec(window.parent, args)
        }
        if (message == "gameLoadingEnded") {
            XT.RegisterCallbackEvent(Vars.Evt_DataToCode_StartAutoplay, UHTInterfaceBOSS.OnStartAutoplay, UHTInterfaceBOSS);
            XT.RegisterCallbackEvent(Vars.Evt_DataToCode_StopAutoplay, UHTInterfaceBOSS.OnStopAutoplay, UHTInterfaceBOSS);
            XT.RegisterCallbackEvent("Evt_SetSmartBetFinished", UHTInterfaceBOSS.OnBetChanged, UHTInterfaceBOSS);
            XT.RegisterCallbackEvent(Vars.Evt_Internal_SoundStateChanged,
                UHTInterfaceBOSS.OnXTSoundStateChanged, UHTInterfaceBOSS);
            XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableOpen, UHTInterfaceBOSS.OnXTPaytableOpen, UHTInterfaceBOSS);
            XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_PaytableClosed, UHTInterfaceBOSS.OnXTPaytableClose, UHTInterfaceBOSS)
        }
        if (message == "gameRoundEnded" || message == "post_updateBalance") {
            args.event = "updateBalance";
            args.params = {
                total: {
                    currency: ServerOptions.currency,
                    amount: (XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived)) *
                        100 + .5 | 0
                }
            };
            UHTInterfaceBOSS.PostMessageRec(window.parent, args)
        }
    }
};
UHTInterfaceBOSS.PostMessageRec = function(receiver, args) {
    if (UHTInterfaceBOSS.listener != null) {
        UHTInterfaceBOSS.listener.postMessage(args, "*");
        return
    }
    receiver.postMessage(args, "*");
    if (receiver != window.top) UHTInterfaceBOSS.PostMessageRec(receiver.parent, args)
};
UHTInterfaceBOSS.ReceiveMessage = function(event) {
    if (UHTInterfaceBOSS.enabled) {
        if (event.data == "updateBalance") EventManager.Trigger(BalanceEvents.evtUpdateBalanceForced, null);
        if (event.data.event == "refreshBalance") EventManager.Trigger(BalanceEvents.evtUpdateBalanceForced, null);
        if (event.data.event == "setVolume")
            if (event.data.params != undefined)
                if (event.data.params.muted == true) {
                    if (XT.GetObject(Vars.SoundState).gameSoundIsOn) UHTInterfaceBOSS.soundCommands.push(false);
                    SoundManager.forcedMute = true
                } else {
                    SoundManager.forcedMute =
                        false;
                    if (!XT.GetObject(Vars.SoundState).gameSoundIsOn) UHTInterfaceBOSS.soundCommands.push(true)
                }
        if (event.data.action == "game.resize") {
            window.innerWidth = parseInt(event.data["actionData"].width, 10);
            window.innerHeight = parseInt(event.data["actionData"].height, 10)
        }
        if (event.data == "stopAutoplay") window["globalMustStopAutoplay"] = true;
        if (event.data == "pause") {
            Globals.GamePaused = true;
            Globals.InputBlocked = true
        }
        if (event.data == "resume") {
            Globals.GamePaused = false;
            Globals.InputBlocked = false
        }
        if (event.data == "requestPause") {
            UHTInterfaceBOSS.pauseCommands.push(true);
            if (!UHTInterfaceBOSS.inGameRound) UHTInterfaceBOSS.Pause(UHTInterfaceBOSS.pauseCommands.shift())
        }
        if (event.data == "requestResume") {
            UHTInterfaceBOSS.pauseCommands.push(false);
            if (!UHTInterfaceBOSS.inGameRound) UHTInterfaceBOSS.Pause(UHTInterfaceBOSS.pauseCommands.shift())
        }
        if (event.data.name == "setMaxBet")
            if (event.data.params != undefined && event.data.params["maxBetPerLine"] != null) UHTInterfaceBOSS.setMaxBetCommands.push(event.data.params["maxBetPerLine"]);
        if (event.data.name == "setBet")
            if (event.data.params != undefined &&
                event.data.params["betPerLine"] != null) UHTInterfaceBOSS.setBetCommands.push(event.data.params["betPerLine"]);
        if (event.data.name == "closeSession") UHTInterfaceBOSS.RequestLogout();
        if (event.data.name == "togglePaytable") UHTInterfaceBOSS.commands.push("toggle");
        if (event.data.name == "toggleHelp") UHTInterfaceBOSS.commands.push("help");
        if (event.data.name == "paytableNextPage") UHTInterfaceBOSS.commands.push("next");
        if (event.data.name == "paytablePreviousPage") UHTInterfaceBOSS.commands.push("previous");
        if (event.data.name ==
            "hidePaytableControls") UHTInterfaceBOSS.commands.push("hidePaytableControls");
        if (event.data.name == "hideSoundButton") UHTInterfaceBOSS.commands.push("hideSoundButton");
        if (event.data.name == "hideMenuButton") UHTInterfaceBOSS.commands.push("hideMenuButton");
        if (event.data.name == "hidePaytableButton") UHTInterfaceBOSS.commands.push("hidePaytableButton");
        if (event.data.name == "enableFastPlay") UHTInterfaceBOSS.commands.push("enableFastPlay");
        if (event.data.name == "disableFastPlay") UHTInterfaceBOSS.commands.push("disableFastPlay")
    }
};
UHTInterfaceBOSS.HandleGameHistory = function() {
    return false
};
UHTInterfaceBOSS.UserInteraction = function() {};
UHTInterfaceBOSS.Init = function() {
    window.addEventListener("message", UHTInterfaceBOSS.ReceiveMessage, false)
};
UHTInterfaceBOSS.Init();
UHTInterfaceBOSS.Pause = function(pause) {
    Globals.GamePaused = pause;
    Globals.InputBlocked = pause;
    var args = {
        event: pause ? "confirmPause" : "confirmResume"
    };
    UHTInterfaceBOSS.PostMessageRec(window.parent, args)
};
UHTInterfaceBOSS.OnLoadingPercentChanged = function(loadingPercentage) {
    if (UHTInterfaceBOSS.enabled) {
        var args = {
            event: "loadingProgress",
            params: {
                percentage: Math.round(loadingPercentage * 100)
            }
        };
        UHTInterfaceBOSS.PostMessageRec(window.parent, args)
    }
};
UHTInterfaceBOSS.OnStartAutoplay = function() {
    var args = {
        event: "autoplayStarted",
        params: {
            autospins: XT.GetInt(Vars.AutoplaySpinsRequested)
        }
    };
    UHTInterfaceBOSS.PostMessageRec(window.parent, args)
};
UHTInterfaceBOSS.OnStopAutoplay = function() {
    var args = {
        event: "autoplayEnded"
    };
    UHTInterfaceBOSS.PostMessageRec(window.parent, args)
};
UHTInterfaceBOSS.OnBetChanged = function() {
    var args = {
        event: "betChanged",
        params: {
            bet: CoinManager.GetNextTotalBet()
        }
    };
    UHTInterfaceBOSS.PostMessageRec(window.parent, args)
};
UHTInterfaceBOSS.OnVisualBalanceUpdate = function() {
    var args = {
        event: "visualBalanceUpdate",
        params: {
            currency: ServerOptions.currency,
            newAmount: XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived),
            win: XT.GetDouble(Vars.SpinCycleWinReceived) + XT.GetDouble(TournamentVars.Promotion_WinReceived)
        }
    };
    UHTInterfaceBOSS.PostMessageRec(window.parent, args)
};
UHTInterfaceBOSS.OnXTSoundStateChanged = function() {
    var sndState = XT.GetObject(Vars.SoundState);
    if (sndState.gameSoundIsOn == UHTInterfaceBOSS.gameSoundIsOn) return;
    UHTInterfaceBOSS.gameSoundIsOn = sndState.gameSoundIsOn;
    var args = {
        event: sndState.gameSoundIsOn ? "soundOn" : "soundOff"
    };
    UHTInterfaceBOSS.PostMessageRec(window.parent, args)
};
UHTInterfaceBOSS.OnUHTUpdate = function() {
    if (!UHTInterfaceBOSS.isXTInit)
        if (XT.RegisterAndInitDone) {
            UHTInterfaceBOSS.isXTInit = true;
            XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, UHTInterfaceBOSS.SendBetInfo, UHTInterfaceBOSS);
            XT.RegisterCallbackInt(Vars.BetToTotalBetMultiplier, UHTInterfaceBOSS.OnBetToTotalBetMultiplier, UHTInterfaceBOSS)
        }
    if (UHTInterfaceBOSS.soundCommands.length > 0) {
        UHTInterfaceBOSS.soundCommands.shift();
        XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_SoundBtn)
    }
    if (UHTInterfaceBOSS.setMaxBetCommands.length >
        0 && !UHTInterfaceBOSS.inGameRound) UHTInterfaceBOSS.SetMaxBet(UHTInterfaceBOSS.setMaxBetCommands.shift());
    if (UHTInterfaceBOSS.setBetCommands.length > 0 && !UHTInterfaceBOSS.inGameRound) UHTInterfaceBOSS.SetBet(UHTInterfaceBOSS.setBetCommands.shift());
    if (UHTInterfaceBOSS.commands.length > 0) {
        var currentCommand = UHTInterfaceBOSS.commands.shift();
        if (currentCommand == "toggle") UHTInterfaceBOSS.TogglePaytable();
        else if (currentCommand == "help") {
            XT.TriggerEvent(Vars.Evt_Internal_PaytableOpenHelp);
            UHTInterfaceBOSS.paytableIsOpenedFromPaytable =
                false
        } else if (currentCommand == "next") XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_PaytableNext);
        else if (currentCommand == "previous") XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_PaytablePrevious);
        else if (currentCommand == "hidePaytableControls") UHTInterfaceBOSS.HideMenuButtons(["UI Root/XTRoot/Root/Paytable/Buttons"], []);
        else if (currentCommand == "hideSoundButton") UHTInterfaceBOSS.HideMenuButtons(["UI Root/XTRoot/Root/GUI/Interface/BottomBar/Elements/LeftContent/SoundButtons"], []);
        else if (currentCommand ==
            "hideMenuButton") UHTInterfaceBOSS.HideMenuButtons(["UI Root/XTRoot/Root/GUI/Interface/BottomBar/Elements/LeftContent/Settings"], ["UI Root/XTRoot/Root/GUI_mobile/Interface_Landscape/ContentInterface/BottomBar/AnchoredLeft/MenuButton", "UI Root/XTRoot/Root/GUI_mobile/Interface_Portrait/ContentInterface/BottomBar/AnchoredLeft/MenuButton"]);
        else if (currentCommand == "hidePaytableButton") UHTInterfaceBOSS.HideMenuButtons(["UI Root/XTRoot/Root/GUI/Interface/TopBar/Paytable"], ["UI Root/XTRoot/Root/GUI_mobile/Interface_Landscape/ContentInterface/BottomBar/AnchoredRight/PaytableButton",
            "UI Root/XTRoot/Root/GUI_mobile/Interface_Portrait/ContentInterface/BottomBar/AnchoredRight/PaytableButton"
        ]);
        else if (currentCommand == "enableFastPlay") XT.SetBool(Vars.FastPlay, true);
        else if (currentCommand == "disableFastPlay") XT.SetBool(Vars.FastPlay, false)
    }
};
UHTInterfaceBOSS.SetMaxBet = function(maxBetPerLine) {
    if (CoinManager.initialBetsFromServer != null) {
        var newBets = [];
        for (var i = 0; i < CoinManager.initialBetsFromServer.length; i++)
            if (CoinManager.initialBetsFromServer[i] <= maxBetPerLine) newBets.push(CoinManager.initialBetsFromServer[i]);
        if (newBets.length > 0) {
            maxBetPerLine = newBets[newBets.length - 1];
            var lastBet = CoinManager.GetNextBet();
            if (lastBet > maxBetPerLine) lastBet = maxBetPerLine;
            CoinManager.ComputeCoinValuesAndCurrentBet(newBets, lastBet, CoinManager.defaultBet);
            CoinManager.SetStrictBetMode(!CoinManager.isStrictMode);
            CoinManager.SetStrictBetMode(!CoinManager.isStrictMode)
        }
    }
};
UHTInterfaceBOSS.SetBet = function(betPerLine) {
    var bets = XT.GetObject(Vars.Bets);
    if (bets != null) {
        var betIndex = bets.indexOf(betPerLine);
        if (betIndex != -1) {
            CoinManager.SetBetIndex(betIndex);
            CoinManager.SetStrictBetMode(!CoinManager.isStrictMode);
            CoinManager.SetStrictBetMode(!CoinManager.isStrictMode)
        }
    }
};
UHTInterfaceBOSS.SendBetInfo = function() {
    var args = {
        event: "betInfo",
        params: {
            betsPerLine: CoinManager.initialBetsFromServer
        }
    };
    UHTInterfaceBOSS.PostMessageRec(window.parent, args)
};
UHTInterfaceBOSS.OnBetToTotalBetMultiplier = function(value) {
    var args = {
        event: "betMultiplier",
        params: {
            betMultiplier: value
        }
    };
    UHTInterfaceBOSS.PostMessageRec(window.parent, args)
};
UHTInterfaceBOSS.RequestLogout = function() {
    var xhr = new XMLHttpRequest;
    xhr.open("POST", UHT_GAME_CONFIG["LOGOUT"], true);
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4)
            if (xhr.responseText == "OK") UHTInterfaceBOSS.OnSessionClosed();
            else setTimeout(function() {
                UHTInterfaceBOSS.RequestLogout()
            }, 2E3)
    };
    xhr.send()
};
UHTInterfaceBOSS.OnSessionClosed = function() {
    var args = {
        event: "sessionClosed"
    };
    UHTInterfaceBOSS.PostMessageRec(window.parent, args)
};
UHTInterfaceBOSS.OnSystemMessage = function(type) {
    var args = {
        event: "systemMessageShown",
        params: {
            type: type
        }
    };
    UHTInterfaceBOSS.PostMessageRec(window.parent, args)
};
UHTInterfaceBOSS.HideMenuButtons = function(pathsDesktop, pathsMobile) {
    if (!Globals.isMobile)
        for (var i = 0; i < pathsDesktop.length; i++) {
            var t = globalRuntime.sceneRoots[1].transform.Find(pathsDesktop[i]);
            if (t != null) t.gameObject.SetActive(false)
        } else
            for (var i = 0; i < pathsMobile.length; i++) {
                var t = globalRuntime.sceneRoots[1].transform.Find(pathsMobile[i]);
                if (t != null) t.gameObject.SetActive(false)
            }
};
UHTInterfaceBOSS.TogglePaytable = function() {
    if (!UHTInterfaceBOSS.isPaytableOpen) {
        UHTInterfaceBOSS.paytableIsOpenedFromPaytable = true;
        if (!Globals.isMobile) {
            var desktopInterface = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["InterfaceController"]);
            if (desktopInterface.length > 0) desktopInterface[0].Pressed_Paytable_Open()
        } else {
            var landscapeInterface = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["InterfaceControllerMobile_1"]);
            var portraitInterface = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["InterfaceControllerMobile_2"]);
            if (landscapeInterface.length > 0) landscapeInterface[0].Pressed_Paytable_Open();
            if (portraitInterface.length > 0) portraitInterface[0].Pressed_Paytable_Open()
        }
    } else {
        XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_PaytableClosed);
        if (!UHTInterfaceBOSS.paytableIsOpenedFromPaytable) UHTInterfaceBOSS.TogglePaytable()
    }
};
UHTInterfaceBOSS.OnXTPaytableOpen = function() {
    UHTInterfaceBOSS.isPaytableOpen = true
};
UHTInterfaceBOSS.OnXTPaytableClose = function() {
    UHTInterfaceBOSS.isPaytableOpen = false
};
goog.provide("UHTMath");
var UHTMath = {
    PI: 3.1415926,
    numberError: 1E-6,
    angularError: 1
};
UHTMath.toDeg = function(r) {
    return r * 180 / UHTMath.PI
};
UHTMath.toRad = function(d) {
    return d / 180 * UHTMath.PI
};
UHTMath.clamp = function(n, min, max) {
    return Math.min(Math.max(n, min), max)
};
UHTMath.lerp = function(a, b, t) {
    var _t = UHTMath.clamp(t, 0, 1);
    return a + (b - a) * _t
};
UHTMath.inverseLerp = function(a, b, v) {
    if (a === b) return 0;
    var _v = UHTMath.clamp(v, a, b);
    return (v - a) / (b - a)
};
UHTMath.lerpUnclamped = function(a, b, t) {
    return a + (b - a) * t
};
goog.provide("UHTMath.Vector3");
UHTMath.Vector3 = function(_x, _y, _z) {
    this.set(_x, _y, _z)
};
UHTMath.Vector3.prototype = {
    constructor: UHTMath.Vector3,
    set: function(x, y, z) {
        if (x === undefined) {
            x = 0;
            y = 0;
            z = 0
        } else if (y === undefined)
            if (x.x !== undefined) {
                y = x.y;
                z = x.z;
                x = x.x
            } else return undefined;
        this.x = x;
        this.y = y;
        this.z = z
    },
    equals: function(x, y, z) {
        var v = new UHTMath.Vector3(x, y, z);
        return Math.abs(this.x - v.x) < UHTMath.numberError && Math.abs(this.y - v.y) < UHTMath.numberError && Math.abs(this.z - v.z) < UHTMath.numberError
    },
    magnitude: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    },
    sqrMagnitude: function() {
        return this.x *
            this.x + this.y * this.y + this.z * this.z
    },
    normalize: function() {
        var l = this.magnitude();
        if (l < UHTMath.numberError) this.set(0, 0, 0);
        else {
            l = 1 / l;
            this.set(this.x * l, this.y * l, this.z * l)
        }
    },
    normalized: function() {
        var l = this.magnitude();
        var ret = new UHTMath.Vector3;
        if (l !== 0) {
            l = 1 / l;
            ret.x = this.x * l;
            ret.y = this.y * l;
            ret.z = this.z * l
        }
        return ret
    },
    add: function(u) {
        this.x += u.x;
        this.y += u.y;
        this.z += u.z;
        return this
    },
    toString: function() {
        return JSON.stringify(this)
    }
};
UHTMath.Vector3.dot = function(u, v) {
    if (v === undefined || u === undefined) return 0;
    return u.x * v.x + u.y * v.y + u.z * v.z
};
UHTMath.Vector3.angle = function(u, v) {
    var d = UHTMath.Vector3.dot(u.normalized(), v.normalized());
    d = UHTMath.clamp(d, -1, 1);
    return UHTMath.toDeg(Math.acos(d))
};
UHTMath.Vector3.cross = function(u, v) {
    return new UHTMath.Vector3(u.y * v.z - u.z * v.y, u.z * v.x - u.x * v.z, u.x * v.y - u.y * v.x)
};
UHTMath.Vector3.distance = function(u, v) {
    var d = new UHTMath.Vector3(u.x - v.x, u.y - v.y, u.z - v.z);
    return d.magnitude()
};
UHTMath.Vector3.lerp = function(s, e, a) {
    var t = UHTMath.clamp(a, 0, 1);
    var ret = new UHTMath.Vector3(s.x + (e.x - s.x) * t, s.y + (e.y - s.y) * t, s.z + (e.z - s.z) * t);
    return ret
};
UHTMath.Vector3.nlerp = function(start, end, percent) {
    var t = UHTMath.clamp(percent, 0, 1);
    var v = UHTMath.Vector3.lerp(start, end, t);
    v.normalize();
    return v
};
UHTMath.Vector3.slerp = function(_start, _end, _percent) {
    var ls = _start.magnitude();
    var le = _end.magnitude();
    var start = Math.abs(ls) > 0 ? UHTMath.Vector3.scale(_start, 1 / ls) : UHTMath.Vector3.up;
    var end = Math.abs(le) > 0 ? UHTMath.Vector3.scale(_end, 1 / le) : UHTMath.Vector3.up;
    var t = UHTMath.clamp(_percent, 0, 1);
    var rot = UHTMath.Quaternion.fromToRotation(start, end);
    var interpolatedRot = UHTMath.Quaternion.slerp(UHTMath.Quaternion.identity, rot, t);
    var v = UHTMath.Quaternion.multiplyVec(interpolatedRot, start);
    var lp = UHTMath.lerp(ls,
        le, t);
    return UHTMath.Vector3.scale(v, lp)
};
UHTMath.Vector3.min = function(u, v) {
    return new UHTMath.Vector3(Math.min(u.x, v.x), Math.min(u.y, v.y), Math.min(u.z, v.z))
};
UHTMath.Vector3.max = function(u, v) {
    return new UHTMath.Vector3(Math.max(u.x, v.x), Math.max(u.y, v.y), Math.max(u.z, v.z))
};
UHTMath.Vector3.moveTowards = function(current, target, maxDistanceDelta) {
    var d = new UHTMath.Vector3(target.x - current.x, target.y - current.y, target.z - current.z);
    var m = d.magnitude();
    if (m < UHTMath.numberError) return target;
    var dl = Math.min(maxDistanceDelta, m) / m;
    return UHTMath.Vector3.lerp(current, target, dl)
};
UHTMath.Vector3.orthoNormalize = function(normal, tangent, binormal) {
    normal.normalize();
    binormal.set(UHTMath.Vector3.cross(normal, tangent));
    binormal.normalize();
    tangent.set(UHTMath.Vector3.cross(binormal, normal));
    tangent.normalize()
};
UHTMath.Vector3.scale = function(a, b) {
    var x, y, z;
    if (b.x === undefined) {
        x = b;
        y = b;
        z = b
    } else {
        x = b.x;
        y = b.y;
        z = b.z
    }
    return new UHTMath.Vector3(a.x * x, a.y * y, a.z * z)
};
UHTMath.Vector3.add = function(a, b) {
    return new UHTMath.Vector3(a.x + b.x, a.y + b.y, a.z + b.z)
};
UHTMath.Vector3.sub = function(a, b) {
    return new UHTMath.Vector3(a.x - b.x, a.y - b.y, a.z - b.z)
};
UHTMath.Vector3.equal = function(a, b) {
    if (a == null) return b == null;
    if (b == null) return a == null;
    return Math.abs(a.x - b.x) < UHTMath.numberError && Math.abs(a.y - b.y) < UHTMath.numberError && Math.abs(a.z - b.z) < UHTMath.numberError
};
UHTMath.Vector3.back = new UHTMath.Vector3(0, 0, -1);
UHTMath.Vector3.down = new UHTMath.Vector3(0, -1, 0);
UHTMath.Vector3.forward = new UHTMath.Vector3(0, 0, 1);
UHTMath.Vector3.left = new UHTMath.Vector3(-1, 0, 0);
UHTMath.Vector3.one = new UHTMath.Vector3(1, 1, 1);
UHTMath.Vector3.right = new UHTMath.Vector3(1, 0, 0);
UHTMath.Vector3.up = new UHTMath.Vector3(0, 1, 0);
UHTMath.Vector3.zero = new UHTMath.Vector3(0, 0, 0);
goog.require("UHTMath.Vector3");
goog.require("UHT.Component");
goog.require("UHT.ParticleSystemEvaluator");
goog.require("UHT.ParticleSystemEvaluatorBySpeed");
goog.require("UHT.ParticleSystemEvaluatorColor");
goog.require("UHT.ClampVelocityModule");

function Particle() {
    this.parent = null;
    this._angularVelocity = null;
    this._angularVelocityBySpeed = null;
    this.startColor = new GradientColor;
    this._color = null;
    this._colorBySpeed = null;
    this._lifetime = -1;
    this.position = new UHTMath.Vector3;
    this.randomSeed = 0;
    this.startSize = 1;
    this._size = null;
    this._sizeBySpeed = null;
    this.startLifetime = -1;
    this.rotation = 0;
    this.startSpeed = 0;
    this.speed = new UHTMath.Vector3;
    this._velocity = new UHTMath.Vector3;
    this._velocityX = null;
    this._velocityY = null;
    this._velocityZ = null;
    this._forceX = null;
    this._forceY = null;
    this._forceZ = null;
    this.velocityDirection = new UHTMath.Vector3(0, 1, 0);
    this.isOld = false;
    this.clampVelocity = null;
    this.sprite
}
Particle.prototype.velocityX = 0;
Particle.prototype.velocityY = 0;
Particle.prototype.velocityZ = 0;
Particle.prototype.forceX = 0;
Particle.prototype.forceY = 0;
Particle.prototype.forceZ = 0;
Particle.prototype.angularVelocity = 0;
Particle.prototype.angularVelocityBySpeed = 0;
Particle.prototype.sizeBySpeed = 0;
Object.defineProperties(Particle.prototype, {
    "lifetime": {
        set: function(value) {
            var mustKill = false;
            if (value <= 0 && this._lifetime > 0) mustKill = true;
            this._lifetime = value;
            if (mustKill) {
                this.parent.particleCount--;
                this.parent.killParticle(this)
            }
        },
        get: function() {
            return this._lifetime
        }
    },
    "color": {
        set: function(value) {
            if (this._color === null) this._color = new ParticleSystemEvaluatorColor;
            this._color.deserialize(value)
        },
        get: function() {
            if (this._color === null) return new GradientColor;
            var s = this.lifetime / this.startLifetime;
            var gc = this._color.Evaluate(1 - s);
            gc.r /= 255;
            gc.g /= 255;
            gc.b /= 255;
            gc.a /= 255;
            return gc
        }
    },
    "colorBySpeed": {
        set: function(value) {
            if (this._colorBySpeed === null) this._colorBySpeed = new ParticleSystemEvaluatorBySpeed(new ParticleSystemEvaluatorColor);
            this._colorBySpeed.deserialize(value)
        },
        get: function(value) {
            if (this._colorBySpeed === null) return new GradientColor;
            var gc = this._colorBySpeed.Evaluate(this.speed.magnitude());
            gc.r /= 255;
            gc.g /= 255;
            gc.b /= 255;
            gc.a /= 255;
            return gc
        }
    },
    "isDead": {
        set: function(value) {
            if (value) this.lifetime =
                0;
            else if (this.lifetime <= 0) this.lifetime = this.startLifetime
        },
        get: function() {
            return this.lifetime <= 0
        }
    },
    "velocityX": {
        set: function(value) {
            this._velocityX = value
        },
        get: function() {
            var s = this.lifetime / this.startLifetime;
            var v = this._velocityX.Evaluate(1 - s);
            return v
        }
    },
    "velocityY": {
        set: function(value) {
            this._velocityY = value
        },
        get: function() {
            var s = this.lifetime / this.startLifetime;
            var v = this._velocityY.Evaluate(1 - s);
            return v
        }
    },
    "velocityZ": {
        set: function(value) {
            this._velocityZ = value
        },
        get: function() {
            var s = this.lifetime /
                this.startLifetime;
            var v = this._velocityZ.Evaluate(1 - s);
            return v
        }
    },
    "forceX": {
        set: function(value) {
            this._forceX = value
        },
        get: function() {
            var s = this.lifetime / this.startLifetime;
            var v = this._forceX.Evaluate(1 - s);
            return v
        }
    },
    "forceY": {
        set: function(value) {
            this._forceY = value
        },
        get: function() {
            var s = this.lifetime / this.startLifetime;
            var v = this._forceY.Evaluate(1 - s);
            return v
        }
    },
    "forceZ": {
        set: function(value) {
            this._forceZ = value
        },
        get: function() {
            var s = this.lifetime / this.startLifetime;
            var v = this._forceZ.Evaluate(1 - s);
            return v
        }
    },
    "size": {
        set: function(value) {
            if (this._size === null) this._size = new ParticleSystemEvaluator;
            if (value instanceof Number) {
                this._size.minMaxState = 0;
                this._size.scalar = value
            } else this._size.deserialize(value)
        },
        get: function() {
            return this._size.Evaluate(1 - this.lifetime / this.startLifetime)
        }
    },
    "sizeBySpeed": {
        set: function(value) {
            if (this._sizeBySpeed === null) this._sizeBySpeed = new ParticleSystemEvaluatorBySpeed(new ParticleSystemEvaluator);
            if (value instanceof Number) {
                this._sizeBySpeed.minMaxState = 0;
                this._sizeBySpeed.scalar =
                    value
            } else this._sizeBySpeed.deserialize(value)
        },
        get: function() {
            if (this._sizeBySpeed === null) return 1;
            return this._sizeBySpeed.Evaluate(this.speed.magnitude())
        }
    },
    "angularVelocityBySpeed": {
        set: function(value) {
            if (this._angularVelocityBySpeed === null) this._angularVelocityBySpeed = new ParticleSystemEvaluatorBySpeed(new ParticleSystemEvaluator);
            if (value instanceof Number) {
                this._angularVelocityBySpeed.minMaxState = 0;
                this._angularVelocityBySpeed.scalar = value
            } else this._angularVelocityBySpeed.deserialize(value)
        },
        get: function(value) {
            if (this._angularVelocityBySpeed === null) return 0;
            return this._angularVelocityBySpeed.Evaluate(this.speed.magnitude())
        }
    },
    "angularVelocity": {
        set: function(value) {
            if (value instanceof ParticleSystemEvaluator) this._angularVelocity = value;
            else if (value instanceof Number) {
                this._angularVelocity.minMaxState = 0;
                this._angularVelocity.scalar = value
            } else this._angularVelocity.deserialize(value)
        },
        get: function(value) {
            if (this._angularVelocity === null) return 0;
            var s = this.lifetime / this.startLifetime;
            var v = this._angularVelocity.Evaluate(1 - s);
            return v
        }
    }
});
Particle.prototype.Spawn = function() {
    this.lifetime = this.startLifetime;
    this.isDead = false;
    this._velocity.set(0, 0, 0);
    this.speed.set(0, 0, 0)
};
Particle.prototype.Update = function(dt) {
    var velocity = Particle.velocity;
    var force = Particle.force;
    var tppsc = this.parent.ParticleSystemComponent;
    var parentTransform = this.parent.gameObject.transform;
    this.lifetime -= dt;
    if (this.lifetime < 0) return;
    var g = this.parent.gravityModifier;
    this._velocity.y -= g * dt;
    if (this._velocityX !== null) velocity.set(this.velocityX, this.velocityY, this.velocityZ);
    else velocity.set(0, 0, 0);
    if (tppsc.VelocityModule.enabled === "True")
        if (tppsc.VelocityModule.inWorldSpace !== "True") velocity.set(parentTransform.transformDirection(velocity));
    if (this._forceX !== null) force.set(this.forceX, this.forceY, this.forceZ);
    else force.set(0, 0, 0);
    if (tppsc.ForceModule.enabled === "True")
        if (tppsc.ForceModule.inWorldSpace !== "True") force.set(parentTransform.transformDirection(force));
    this.speed.set(this._velocity.x + velocity.x + force.x, this._velocity.y + velocity.y + force.y, this._velocity.z + velocity.z + force.z);
    if (this.clampVelocity != null) {
        var s = 1 - this.lifetime / this.startLifetime;
        var c = UHTMath.Vector3.scale(this.clampVelocity.Evaluate(s, this.speed), 1);
        this.speed.set(c)
    }
    var p =
        UHTMath.Vector3.scale(this.speed, dt * this.parent.goodScale);
    this.position.add(p);
    this.rotation += (this.angularVelocityBySpeed + this.angularVelocity) * dt
};
Particle.prototype.setupSpritePosition = function(parent) {
    var sprite = this.sprite;
    var tsc = this.startColor;
    var tc = this.color;
    var tcbs = this.colorBySpeed;
    var gc = Particle.gradientColor;
    gc.r = tsc.r * tc.r * tcbs.r;
    gc.g = tsc.g * tc.g * tcbs.g;
    gc.b = tsc.b * tc.b * tcbs.b;
    gc.a = tsc.a * tc.a * tcbs.a;
    sprite.tint = gc.toRGBHex();
    sprite.alpha = gc.a / 255;
    sprite.x = this.position.x;
    sprite.y = -this.position.y;
    sprite.width = this.size * this.sizeBySpeed * this.startSize * this.parent.goodScale;
    sprite.height = sprite.width;
    sprite.rotation = this.rotation
};
Particle.velocity = new UHTMath.Vector3;
Particle.force = new UHTMath.Vector3;
Particle.gradientColor = new GradientColor;
goog.provide("UHT.ParticleSystemExtraData");
goog.require("UHT.Component");
goog.require("UHTMath.Vector3");
ParticleSystemExtraData.prototype = Object.create(Component.prototype);
ParticleSystemExtraData.prototype.constructor = ParticleSystemExtraData;

function ParticleSystemExtraData() {
    Component.call(this);
    this.SubEmitterBirth0 = null;
    this.SubEmitterBirth1 = null;
    this.SubEmitterCollision0 = null;
    this.SubEmitterCollision1 = null;
    this.SubEmitterDeath0 = null;
    this.SubEmitterDeath1 = null
}
ParticleSystemExtraData.prototype.deserialize = function(source, helper, resolveReference) {
    deserializeComponentRec(source, this, helper, resolveReference)
};
ParticleSystemExtraData.prototype.Awake = function() {
    if (this.SubEmitterBirth0 != null) {
        this.SubEmitterBirth0.playOnAwake = false;
        this.SubEmitterBirth0.emissionRate = 0
    }
    if (this.SubEmitterBirth1 != null) {
        this.SubEmitterBirth1.playOnAwake = false;
        this.SubEmitterBirth1.emissionRate = 0
    }
    if (this.SubEmitterCollision0 != null) {
        this.SubEmitterCollision0.playOnAwake = false;
        this.SubEmitterCollision0.emissionRate = 0
    }
    if (this.SubEmitterCollision1 != null) {
        this.SubEmitterCollision1.playOnAwake = false;
        this.SubEmitterCollision1.emissionRate =
            0
    }
    if (this.SubEmitterDeath0 != null) {
        this.SubEmitterDeath0.playOnAwake = false;
        this.SubEmitterDeath0.emissionRate = 0
    }
    if (this.SubEmitterDeath1 != null) {
        this.SubEmitterDeath1.playOnAwake = false;
        this.SubEmitterDeath1.emissionRate = 0
    }
};
goog.require("UHT.Component");
goog.require("UHT.ParticleSystemEvaluator");
goog.require("UHT.ParticleSystemEvaluatorBySpeed");
goog.require("UHT.ParticleSystemEvaluatorColor");
goog.require("UHT.ParticleSystemShape");
goog.require("UHT.ParticleSystemShapeBox");
goog.require("UHT.ParticleSystemShapeCone");
goog.require("UHT.ParticleSystemShapeSphere");
goog.require("UHT.ParticleSystemShapeType");
goog.require("UHT.ParticleSystemExtraData");
goog.require("UHT.ClampVelocityModule");
var ParticleSystemSimulationSpace = {
    Local: 0,
    World: 1
};
var ParticleSystemState = {
    isStopped: 0,
    isPaused: 1,
    isPlaying: 2
};
ParticleSystem.prototype = Object.create(Component.prototype);
ParticleSystem.prototype.constructor = ParticleSystem;

function ParticleSystem() {
    Component.call(this);
    this.depth = 1E4;
    this.goodScale = 1;
    this._emissionRate = new ParticleSystemEvaluator;
    this._enableEmission = true;
    this._gravityModifier = 0;
    this._loop = false;
    this._maxParticles = new ParticleSystemEvaluator;
    this._playbackSpeed = new ParticleSystemEvaluator;
    this._playOnAwake = new ParticleSystemEvaluator;
    this._randomSeed = new ParticleSystemEvaluator;
    this._simulationSpace = new ParticleSystemEvaluator;
    this._startColor = new ParticleSystemEvaluatorColor;
    this._startDelay = 0;
    this._startLifetime =
        new ParticleSystemEvaluator;
    this._startRotation = new ParticleSystemEvaluator;
    this._startSize = new ParticleSystemEvaluator;
    this._startSpeed = new ParticleSystemEvaluator;
    this.duration = 0;
    this._prewarm = false;
    this._shape = null;
    this.bursts = [];
    this.particles = [];
    this.particleCount = 0;
    this._state = ParticleSystemState.isStopped;
    this.time = 0;
    this._deadParticles = [];
    this._lest = 0;
    this.texturica = null;
    this.subEmitors = null;
    this.textureContent;
    this.ParticleSystemComponent;
    this.fastContainer = true;
    this.epm = []
}
ParticleSystem.prototype.startColor = null;
Object.defineProperties(ParticleSystem.prototype, {
    "emissionRate": {
        set: function(value) {
            if (typeof value === "number") {
                this._emissionRate.minMaxState = 0;
                this._emissionRate.scalar = value
            } else this._emissionRate = value
        },
        get: function() {
            return this._emissionRate.Evaluate((this.time - this.startDelay) / this.duration)
        }
    },
    "enableEmission": {
        set: function(value) {
            this._enableEmission = value
        },
        get: function() {
            return this._enableEmission
        }
    },
    "gravityModifier": {
        set: function(value) {
            this._gravityModifier = value
        },
        get: function() {
            return this._gravityModifier
        }
    },
    "state": {
        set: function(value) {
            this._state = value
        },
        get: function() {
            return this._state
        }
    },
    "loop": {
        set: function(value) {
            this._loop = value
        },
        get: function() {
            return this._loop
        }
    },
    "maxParticles": {
        set: function(value) {
            this._maxParticles = value
        },
        get: function() {
            return this._maxParticles.Evaluate((this.time - this.startDelay) / this.duration)
        }
    },
    "playbackSpeed": {
        set: function(value) {
            this._playbackSpeed = value
        },
        get: function() {
            return this._playbackSpeed.Evaluate((this.time - this.startDelay) / this.duration)
        }
    },
    "playOnAwake": {
        set: function(value) {
            if (typeof value ===
                "boolean") {
                this._playOnAwake.scalar = value ? 1 : 0;
                this._playOnAwake.minMaxState = 0
            } else this._playOnAwake = value
        },
        get: function() {
            return this._playOnAwake.Evaluate((this.time - this.startDelay) / this.duration)
        }
    },
    "randomSeed": {
        set: function(value) {
            this._randomSeed = value
        },
        get: function() {
            return this._randomSeed.Evaluate((this.time - this.startDelay) / this.duration)
        }
    },
    "simulationSpace": {
        set: function(value) {
            this._simulationSpace = value
        },
        get: function() {
            return this._simulationSpace.Evaluate((this.time - this.startDelay) /
                this.duration)
        }
    },
    "startColor": {
        set: function(value) {
            this._startColor = value
        },
        get: function() {
            return this._startColor.Evaluate((this.time - this.startDelay) / this.duration)
        }
    },
    "startDelay": {
        set: function(value) {
            this._startDelay = value
        },
        get: function() {
            return this._startDelay
        }
    },
    "startLifetime": {
        set: function(value) {
            this._startLifetime = value
        },
        get: function() {
            return this._startLifetime.Evaluate((this.time - this.startDelay) / this.duration)
        }
    },
    "startRotation": {
        set: function(value) {
            this._startRotation = value
        },
        get: function() {
            return this._startRotation.Evaluate((this.time -
                this.startDelay) / this.duration)
        }
    },
    "startSize": {
        set: function(value) {
            this._startSize = value
        },
        get: function() {
            return this._startSize.Evaluate((this.time - this.startDelay) / this.duration)
        }
    },
    "startSpeed": {
        set: function(value) {
            this._startSpeed = value
        },
        get: function() {
            return this._startSpeed.Evaluate((this.time - this.startDelay) / this.duration)
        }
    },
    "prewarm": {
        set: function(value) {
            this._prewarm = value
        },
        get: function() {
            return this._prewarm
        }
    }
});
ParticleSystem.prototype.deserialize = function(source, helper, resolveReference) {
    deserializeComponentRec(source, this, helper, resolveReference);
    this.fromSource(source, helper, resolveReference)
};
ParticleSystem.prototype.copyFromSource = function(source, helper, resolveReference) {
    copyComponentHelper(source, this, helper, resolveReference);
    this.fromSource(source, helper, resolveReference)
};
ParticleSystem.prototype.fromSource = function(source, helper, resolveReference) {
    var hasTexture = this.textureContent !== null;
    if (hasTexture) {
        this.texturica = PIXI.Texture.fromImage(this.textureContent, undefined, undefined, this["textureContent_@GUID"]);
        this.textureContent = {
            src: ""
        }
    }
    this.blendMode = source.blendMode;
    var em = source.ParticleSystemComponent.EmissionModule;
    this._burstCnt = em.m_BurstCount;
    var cnt = this._burstCnt;
    while (cnt--) {
        var t = "time" + cnt.toString();
        var c = "cnt" + cnt.toString();
        this.bursts.push({
            time: Number(em[t]),
            cnt: Number(em[c]),
            emited: false
        })
    }
    this._startColor = new ParticleSystemEvaluatorColor;
    this._startColor.deserialize(source.ParticleSystemComponent.InitialModule.startColor);
    this._enableEmission = this.valueFromString(em.enabled);
    this.gravityModifier = 9.81 * this.valueFromString(source.ParticleSystemComponent.InitialModule.gravityModifier) || 0;
    this.prewarm = this.valueFromString(source.ParticleSystemComponent.prewarm) || false;
    this.startDelay = this.valueFromString(source.ParticleSystemComponent.startDelay) || 0;
    this.duration =
        this.valueFromString(source.ParticleSystemComponent.lengthInSec) || 0;
    this.loop = this.valueFromString(source.ParticleSystemComponent.looping) || 0;
    this.emissionRate = this.CreateParticleSystemComponent(source.ParticleSystemComponent.EmissionModule.rate || 0);
    this.playOnAwake = this.CreateParticleSystemComponent(source.ParticleSystemComponent.playOnAwake || 0);
    this.startLifetime = this.CreateParticleSystemComponent(source.ParticleSystemComponent.InitialModule.startLifetime || 0);
    this.startRotation = this.CreateParticleSystemComponent(source.ParticleSystemComponent.InitialModule.startRotation ||
        0);
    this.startSize = this.CreateParticleSystemComponent(source.ParticleSystemComponent.InitialModule.startSize || 0);
    this.startSpeed = this.CreateParticleSystemComponent(source.ParticleSystemComponent.InitialModule.startSpeed || 0);
    this.maxParticles = this.CreateParticleSystemComponent(source.ParticleSystemComponent.InitialModule.maxNumParticles || 0);
    this.InitializeEmissionShape(source.ParticleSystemComponent.ShapeModule);
    if (this.ParticleSystemComponent.ColorModule.enabled === undefined || this.ParticleSystemComponent.ColorModule.enabled ===
        "False") this.fastContainer = false;
    if (!Renderer.IsWebGL) this.fastContainer = false
};
ParticleSystem.prototype.InitializeEmissionShape = function(src) {
    var undefined;
    if (src === undefined) {
        this._shape = new ParticleSystemShape;
        return
    }
    if (src.enabled === undefined || src.enabled === "False") {
        this._shape = new ParticleSystemShape;
        return
    }
    switch (Number(src.type)) {
        case ParticleSystemShapeType.box:
            this._shape = new ParticleSystemShapeBox;
            this._shape.deserialize(src);
            break;
        case ParticleSystemShapeType.cone:
        case ParticleSystemShapeType.coneBaseShell:
            this._shape = new ParticleSystemShapeCone;
            this._shape.deserialize(src);
            break;
        case ParticleSystemShapeType.sphere:
        case ParticleSystemShapeType.sphereShell:
            this._shape = new ParticleSystemShapeSphere;
            this._shape.deserialize(src);
            break;
        default:
            this._shape = new ParticleSystemShape;
            break
    }
};
ParticleSystem.prototype.valueFromString = function(source) {
    var n = Number(source);
    if (isNaN(n) == false) return n;
    else return source === "True"
};
ParticleSystem.prototype.CreateParticleSystemComponent = function(source) {
    var ret = new ParticleSystemEvaluator;
    var undefined;
    if (source.minMaxState !== undefined) ret.deserialize(source);
    else {
        ret.minMaxState = 0;
        ret.scalar = this.valueFromString(source)
    }
    return ret
};
ParticleSystem.prototype.OnEnable = function() {
    if (this.playOnAwake) {
        this.time = 0;
        this.Clear(false);
        this.resetBursts()
    }
    this.subEmitors = this.gameObject.GetComponent("ParticleSystemExtraData");
    if (this.playOnAwake) this.Play();
    if (this.prewarm) {
        var step = 1 / 15;
        var adunator = 0;
        while (adunator < this.duration) {
            this.internalUpdate(step);
            adunator += step
        }
    }
};
ParticleSystem.prototype.Start = function() {};
ParticleSystem.prototype.Awake = function() {
    this.epm = this.gameObject.GetComponents(ExtraParticleModule);
    for (var i = 0; i < this.epm.length; i++)
        if (!this.epm[i].SupportsFastParticleContainer()) this.fastContainer = false;
    if (this.fastContainer) {
        this.pixiZOrderedContainer = new PIXI.ParticleContainer(500, {
            scale: true,
            position: true,
            rotation: true,
            uvs: false,
            alpha: true
        }, 500);
        this.pixiZOrderedContainer.blendMode = this.blendMode
    } else this.pixiZOrderedContainer = new PIXI.Container
};
ParticleSystem.prototype.OnDisable = function() {};
ParticleSystem.prototype.Play = function(withChildren) {
    this.state = ParticleSystemState.isPlaying;
    var undefined;
    if (withChildren === undefined || withChildren === false) return;
    this.callOnChildren("Play")
};
ParticleSystem.prototype.callOnChildren = function(func) {
    var g = this.gameObject;
    var l = g.GetComponentsInChildren(ParticleSystem, true);
    var i = l.length;
    while (i--) l[i][func](false)
};
ParticleSystem.prototype.Stop = function(withChildren) {
    this.state = ParticleSystemState.isStopped;
    this.time = 0;
    var undefined;
    if (withChildren === undefined || withChildren === false) return;
    this.callOnChildren("Stop")
};
ParticleSystem.prototype.Pause = function(withChildren) {
    this.state = ParticleSystemState.isPaused;
    var undefined;
    if (withChildren === undefined || withChildren === false) return;
    this.callOnChildren("Pause")
};
ParticleSystem.prototype.isPaused = function() {
    return this.state === ParticleSystemState.isPaused
};
ParticleSystem.prototype.isPlaying = function() {
    return this.state === ParticleSystemState.isPlaying
};
ParticleSystem.prototype.isStopped = function() {
    return this.state === ParticleSystemState.isStopped
};
ParticleSystem.prototype.spawnNewParticles = function(dt) {
    var c = this.emissionRate * dt + this._lest;
    var n = Math.floor(c);
    this._lest = c - n;
    var cnt = this._burstCnt;
    while (cnt--) {
        var b = this.bursts[cnt];
        if (b.emited === false && (b.time >= this.time - this.startDelay - dt && b.time <= this.time - this.startDelay + dt)) {
            b.emited = true;
            n += b.cnt;
            break
        }
    }
    this.Emit(Math.min(n, Math.max(0, this.maxParticles - Math.max(0, this.particleCount))))
};
ParticleSystem.prototype.Update = function() {};
ParticleSystem.prototype.OnWillRenderObject = function() {
    if (this.texturica === null) return;
    var dt = Time.deltaTime;
    if (this.state !== ParticleSystemState.isPlaying) return;
    if (this.time < this.startDelay && !this.prewarm) return;
    if (this.time - this.startDelay > this.duration && !this.loop) return;
    if (this.time - this.startDelay > this.duration) {
        this.time -= this.duration + this.startDelay;
        this.resetBursts()
    }
    this.internalUpdate(dt)
};
ParticleSystem.prototype.resetBursts = function() {
    var cnt = this._burstCnt;
    while (cnt--) {
        var b = this.bursts[cnt];
        b.emited = false
    }
};
ParticleSystem.prototype.killParticle = function(p) {
    if (p instanceof Particle) {
        p.isDead = true;
        this.pixiZOrderedContainer.removeChild(p.sprite);
        this._deadParticles.push(p);
        if (this.subEmitors != null) {
            if (this.subEmitors.SubEmitterDeath0 != null) {
                this.subEmitors.SubEmitterDeath0.Play(false);
                this.subEmitors.SubEmitterDeath0.time = 0;
                this.subEmitors.SubEmitterDeath0.resetBursts()
            }
            if (this.subEmitors.SubEmitterDeath1 != null) {
                this.subEmitors.SubEmitterDeath1.Play(false);
                this.subEmitors.SubEmitterDeath1.time = 0;
                this.subEmitors.SubEmitterDeath1.resetBursts()
            }
        }
    }
};
ParticleSystem.prototype.internalUpdate = function(dt) {
    this.time += dt;
    this.spawnNewParticles(dt);
    var i = this.particles.length;
    var cappedAspectRatio = Math.min(UHTScreen.width / UHTScreen.height, 1.44544);
    this.goodScale = cappedAspectRatio / 1.44544;
    this.pixiZOrderedContainer.scale.x = 1;
    this.pixiZOrderedContainer.scale.y = 1;
    if (this.ParticleSystemComponent.moveWithTransform === "True") {
        this.pixiZOrderedContainer.position.x = this.gameObject.transform.position().x;
        this.pixiZOrderedContainer.position.y = -this.gameObject.transform.position().y
    }
    this.particleCount =
        0;
    while (i--) {
        var p = this.particles[i];
        if (!p.isDead) {
            this.particleCount++;
            p.Update(dt);
            if (!p.isDead)
                for (var j = 0; j < this.epm.length; j++) this.epm[j].OnUpdateParticle(p);
            p.setupSpritePosition(this.gameObject);
            if (this.subEmitors != null) {
                var emitors = ["SubEmitterBirth0", "SubEmitterBirth1", "SubEmitterCollision0", "SubEmitterCollision1", "SubEmitterDeath0", "SubEmitterDeath1"];
                var id = emitors.length;
                while (id--)
                    if (this.subEmitors[emitors[id]] != null) {
                        var ps = this.subEmitors[emitors[id]];
                        ps.gameObject.transform.position(p.position);
                        ps.Update(dt)
                    }
            }
        }
    }
};
ParticleSystem.prototype.GetParticles = function() {
    return this.particles
};
ParticleSystem.prototype.SetParticles = function(p, size) {
    this.particles = p.splice(1, size)
};
ParticleSystem.prototype.Clear = function(withChildren) {
    var i = this.particles.length;
    while (i--)
        if (!this.particles[i].isDead) this.killParticle(this.particles[i]);
    var undefined;
    if (withChildren !== undefined && withChildren === true) this.GetComponentsInChildren(ParticleSystem, true).forEach(function(p) {
        p.Clear(false)
    })
};
ParticleSystem.prototype.setupParticleVelocity = function(p) {
    if (this.ParticleSystemComponent.ShapeModule.randomDirection == "False") {
        var pp;
        if (this.ParticleSystemComponent.moveWithTransform === "True") pp = p.position;
        else pp = UHTMath.Vector3.sub(p.position, this.gameObject.transform.position());
        p.velocityDirection.set(this.gameObject.transform.transformDirection(this._shape.getEmissionDirection(pp)))
    } else {
        var v = new UHTMath.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
        v.normalize();
        p.velocityDirection.set(v)
    }
    p.startSpeed =
        this.startSpeed;
    p._velocity.set(UHTMath.Vector3.scale(p.velocityDirection, this.startSpeed))
};
ParticleSystem.prototype.generateNewParticlePosition = function() {
    var pp = this.gameObject.transform.transformVector(this._shape.generateNewPosition());
    if (this.ParticleSystemComponent.moveWithTransform === "True") return pp;
    else {
        var dp = UHTMath.Vector3.add(this.gameObject.transform.position(), pp);
        return dp
    }
};
ParticleSystem.prototype.generatePositionAndVelocityForParticle = function(p) {
    var g = this._shape.generateNewPosition();
    var pp = this.gameObject.transform.transformVector(g);
    if (this.ParticleSystemComponent.moveWithTransform !== "True") pp.set(UHTMath.Vector3.add(this.gameObject.transform.position(), pp));
    p.position.set(pp);
    if (this.ParticleSystemComponent.ShapeModule.randomDirection === "False") p.velocityDirection.set(this.gameObject.transform.transformDirection(this._shape.getEmissionDirection(g)).normalized());
    else p.velocityDirection.set(this.gameObject.transform.transformDirection(this._shape.getEmissionDirection()).normalized());
    p.startSpeed = this.startSpeed;
    p._velocity.set(UHTMath.Vector3.scale(p.velocityDirection, this.startSpeed))
};
ParticleSystem.prototype.Emit = function(countOrPositionOrParticle, velocity, size, lifetime, color) {
    if (this.enableEmission !== true) return;
    var undefined;
    if (typeof countOrPositionOrParticle === "number" && isFinite(countOrPositionOrParticle) && Math.floor(countOrPositionOrParticle) === countOrPositionOrParticle) {
        var requestedCount = countOrPositionOrParticle;
        var i = requestedCount;
        while (i--) {
            var p = this.getNewParticle();
            this.Emit(p);
            p.lifetime = this.startLifetime;
            p.startLifetime = this.startLifetime;
            p.startSize = this.startSize;
            if (p._size === null) p._size = new ParticleSystemEvaluator;
            if (this.ParticleSystemComponent.SizeModule.enabled !== undefined) p._size.deserialize(this.ParticleSystemComponent.SizeModule.curve);
            else {
                p._size.scalar = 1;
                p._size.minMaxState = 0
            }
            if (this.ParticleSystemComponent.SizeBySpeedModule.enabled !== undefined) {
                if (p._sizeBySpeed === null) p._sizeBySpeed = new ParticleSystemEvaluatorBySpeed(new ParticleSystemEvaluator);
                p.sizeBySpeed = this.ParticleSystemComponent.SizeBySpeedModule
            }
            if (this.ParticleSystemComponent.ColorBySpeedModule.enabled !==
                undefined) {
                if (p._colorBySpeed === null) p._colorBySpeed = new ParticleSystemEvaluatorBySpeed(new ParticleSystemEvaluatorColor);
                p.colorBySpeed = this.ParticleSystemComponent.ColorBySpeedModule
            }
            if (this.ParticleSystemComponent.ClampVelocityModule.enabled !== undefined) {
                if (p.clampVelocity == null) p.clampVelocity = new ClampVelocityModule(this);
                p.clampVelocity.deserialize(this.ParticleSystemComponent.ClampVelocityModule)
            }
            if (this.ParticleSystemComponent.ForceModule.enabled == "True") {
                if (p._forceX === null) p._forceX = new ParticleSystemEvaluator;
                if (p._forceY === null) p._forceY = new ParticleSystemEvaluator;
                if (p._forceZ === null) p._forceZ = new ParticleSystemEvaluator;
                p._forceX.deserialize(this.ParticleSystemComponent.ForceModule.x);
                p._forceY.deserialize(this.ParticleSystemComponent.ForceModule.y);
                p._forceZ.deserialize(this.ParticleSystemComponent.ForceModule.z)
            }
            if (this.ParticleSystemComponent.VelocityModule.enabled == "True") {
                if (p._velocityX === null) p._velocityX = new ParticleSystemEvaluator;
                if (p._velocityY === null) p._velocityY = new ParticleSystemEvaluator;
                if (p._velocityZ === null) p._velocityZ = new ParticleSystemEvaluator;
                p._velocityX.deserialize(this.ParticleSystemComponent.VelocityModule.x);
                p._velocityY.deserialize(this.ParticleSystemComponent.VelocityModule.y);
                p._velocityZ.deserialize(this.ParticleSystemComponent.VelocityModule.z)
            }
            this._startRotation.ReRandomize();
            this._startSize.ReRandomize();
            p.rotation = this.startRotation;
            if (this.ParticleSystemComponent.RotationModule.enabled != null) {
                if (p._angularVelocity === null) p._angularVelocity = new ParticleSystemEvaluator;
                p.angularVelocity = this.ParticleSystemComponent.RotationModule.curve
            }
            if (this.ParticleSystemComponent.RotationBySpeedModule.enabled != null) {
                if (this["_angularVelocityBySpeed"] === null) p._angularVelocityBySpeed = new ParticleSystemEvaluatorBySpeed(new ParticleSystemEvaluator);
                p.angularVelocityBySpeed = this.ParticleSystemComponent.RotationBySpeedModule
            }
            p.startColor = this.startColor;
            if (this.ParticleSystemComponent.ColorModule.enabled != null) p.color = this.ParticleSystemComponent.ColorModule.gradient;
            this.generatePositionAndVelocityForParticle(p)
        }
    } else if (countOrPositionOrParticle instanceof Particle) {
        var p = countOrPositionOrParticle;
        if (!p.isOld) {
            this.particles.push(p);
            p.isOld = true
        }
        this.pixiZOrderedContainer.addChild(p.sprite);
        p.parent = this;
        p.Spawn();
        if (this.subEmitors != null) {
            if (this.subEmitors.SubEmitterBirth0 != null) {
                this.subEmitors.SubEmitterBirth0.Play(false);
                this.subEmitors.SubEmitterBirth0.time = 0;
                this.subEmitors.SubEmitterBirth0.resetBursts()
            }
            if (this.subEmitors.SubEmitterBirth1 != null) {
                this.subEmitors.SubEmitterBirth1.Play(false);
                this.subEmitors.SubEmitterBirth1.time = 0;
                this.subEmitors.SubEmitterBirth1.resetBursts()
            }
        }
    } else if (countOrPositionOrParticle instanceof UHTMath.Vector3) {
        var p = this.getNewParticle();
        this.Emit(p);
        p.position.set(countOrPositionOrParticle);
        p._velocity.set(velocity);
        if (size !== undefined) p.size = size;
        if (lifetime !== undefined) p.startLifetime = lifetime;
        if (color !== undefined) p.color = color
    }
};
ParticleSystem.prototype.getNewParticle = function() {
    var undefined;
    var p = this._deadParticles.pop();
    if (p === undefined) {
        p = new Particle;
        p.sprite = null;
        for (var i = 0; i < this.epm.length; i++) this.epm[i].OnNewParticle(p);
        if (p.sprite == null) p.sprite = new PIXI.Sprite(this.texturica);
        if (!this.fastContainer) p.sprite.blendMode = this.blendMode;
        p.sprite.anchor.x = .5;
        p.sprite.anchor.y = .5
    }
    return p
};
ParticleSystem.prototype.removeDuplicateParticles = function() {
    this.uniqueArray(this.particles);
    this.uniqueArray(this._deadParticles)
};
ParticleSystem.prototype.uniqueArray = function(a) {
    var seen = {};
    a.filter(function(p) {
        return seen.hasOwnProperty(p) ? false : seen[p] = true
    })
};
goog.provide("UHT.Input");
goog.require("UHTMath");
goog.require("UHTMath.Vector3");
var Input = {
    mousePosition: new UHTMath.Vector3(0, 0, 0),
    lastUsedInputDeviceIsTouch: true,
    _mousePressed: false,
    _mouseStateChangedThisFrame: false,
    GetMouseButton: function(unused) {
        return Input._mousePressed
    },
    GetMouseButtonDown: function(unused) {
        return Input._mousePressed && Input._mouseStateChangedThisFrame
    },
    GetKeyDown: function(keyCode, consume) {
        return KeyboardManager.IsKeyDown(keyCode, consume)
    },
    GetKey: function(keyCode) {
        return KeyboardManager.IsKey(keyCode)
    }
};
goog.provide("UHT.ColliderInputManager");
goog.require("UHT.Input");
goog.require("UHTMath");
goog.require("UHTMath.Vector3");
var ColliderEvent = {
    ButtonDown: "ButtonDown",
    ButtonUp: "ButtonUp",
    MouseMove: "MouseMove"
};
var MOUSE_EVENT_TYPE = {
    DOWN: 0,
    MOVE: 1,
    UP: 2
};

function QueuedMouseEvent(type, evt) {
    this.m_type = type;
    this.m_event = evt
}

function ColliderInputManager() {
    this.pixiObject = null;
    this.mouseIsInScreen = false;
    this.colliders = [];
    this.mousePosition = new UHTMath.Vector3(0, 0, 0);
    this._mousePressed = false;
    this._mouseStateChanged = false;
    this.handlers = {};
    this.queuedEvents = []
}
ColliderInputManager.prototype.initInput = function() {
    this.colliders = [];
    this.pixiObject = new PIXI.Sprite(null);
    this.pixiObject.x = 0;
    this.pixiObject.y = 0;
    this.pixiObject.width = UHTScreen.width;
    this.pixiObject.height = UHTScreen.height;
    this.pixiObject.alpha = 0;
    this.pixiObject.worldAlpha = 0;
    this.pixiObject.interactive = true;
    this.pixiObject.on("mousedown", onCIMButtonDown);
    this.pixiObject.on("touchstart", onCIMButtonDown);
    this.pixiObject.on("mouseup", onCIMButtonUp);
    this.pixiObject.on("mouseupoutside", onCIMButtonUp);
    this.pixiObject.on("touchend", onCIMButtonUp);
    this.pixiObject.on("touchendoutside", onCIMButtonUp);
    this.pixiObject.on("mousemove", onCIMMouseMove);
    this.pixiObject.on("touchmove", onCIMMouseMove)
};

function onCIMButtonDown(event) {
    globalColliderInputManager.queuedEvents.push(new QueuedMouseEvent(MOUSE_EVENT_TYPE.DOWN, event));
    globalColliderInputManager.notifyListeners(ColliderEvent.ButtonDown, event);
    UHTEngine.RegisterUserInteraction()
}

function onCIMButtonUp(event) {
    globalColliderInputManager.queuedEvents.push(new QueuedMouseEvent(MOUSE_EVENT_TYPE.UP, event));
    globalColliderInputManager.notifyListeners(ColliderEvent.ButtonUp, event);
    UHTEngine.RegisterUserInteraction()
}

function onCIMMouseMove(event) {
    if (globalColliderInputManager.queuedEvents.length > 0)
        if (globalColliderInputManager.queuedEvents[globalColliderInputManager.queuedEvents.length - 1].m_type == MOUSE_EVENT_TYPE.MOVE) globalColliderInputManager.queuedEvents.splice(globalColliderInputManager.queuedEvents.length - 1, 1);
    globalColliderInputManager.queuedEvents.push(new QueuedMouseEvent(MOUSE_EVENT_TYPE.MOVE, event));
    globalColliderInputManager.notifyListeners(ColliderEvent.MouseMove, event)
}
ColliderInputManager.prototype.HandleNextQueuedEvent = function() {
    if (this.queuedEvents.length == 0) return;
    var nqe = this.queuedEvents[0];
    this.queuedEvents.splice(0, 1);
    switch (nqe.m_type) {
        case MOUSE_EVENT_TYPE.DOWN:
            if (globalColliderInputManager._mousePressed == false) globalColliderInputManager._mouseStateChanged = true;
            globalColliderInputManager._mousePressed = true;
            globalColliderInputManager.mousePosition = new UHTMath.Vector3(nqe.m_event.data.global.x, nqe.m_event.data.global.y, 0);
            Input.lastUsedInputDeviceIsTouch =
                nqe.m_event.type.search("touch") != -1 || nqe.m_event.type.search("tap") != -1;
            break;
        case MOUSE_EVENT_TYPE.MOVE:
            globalColliderInputManager.mousePosition = new UHTMath.Vector3(nqe.m_event.data.global.x, nqe.m_event.data.global.y, 0);
            Input.lastUsedInputDeviceIsTouch = nqe.m_event.type.search("touch") != -1 || nqe.m_event.type.search("tap") != -1;
            break;
        case MOUSE_EVENT_TYPE.UP:
            globalColliderInputManager._mousePressed = false;
            globalColliderInputManager.mousePosition = new UHTMath.Vector3(nqe.m_event.data.global.x, nqe.m_event.data.global.y,
                0);
            Input.lastUsedInputDeviceIsTouch = nqe.m_event.type.search("touch") != -1 || nqe.m_event.type.search("tap") != -1;
            break
    }
};
ColliderInputManager.prototype.notifyListeners = function(eventName, event) {
    if (this.handlers[eventName] != undefined)
        for (var i = 0; i < this.handlers[eventName].length; ++i) this.handlers[eventName][i].call(event)
};
ColliderInputManager.prototype.updateInput = function() {
    this.HandleNextQueuedEvent();
    this.pixiObject.width = UHTScreen.width;
    this.pixiObject.height = UHTScreen.height;
    Input.mousePosition = this.mousePosition;
    Input._mousePressed = this._mousePressed;
    Input._mouseStateChangedThisFrame = this._mouseStateChanged;
    this._mouseStateChanged = false
};
ColliderInputManager.prototype.registerCollider = function(newCollider) {
    this.colliders.push(newCollider)
};
ColliderInputManager.prototype.getHoveredCollider = function(worldMousePosition, layerMask) {
    var foundDepth = Number.MAX_VALUE;
    var foundCollider = null;
    for (var i = 0; i < this.colliders.length; i++) {
        var curCollider = this.colliders[i];
        if (curCollider.enabled == false || curCollider.gameObject.activeInHierarchy == false) continue;
        var correctLayer = 1 << curCollider.gameObject.layer & layerMask.mask;
        if (correctLayer == 0) continue;
        var curCenterAndSize = curCollider.GetTransformedCenterAndSize();
        var curCenter = curCenterAndSize.center;
        var curSize =
            curCenterAndSize.size;
        if (curCollider.isSphere == false) curSize = UHTMath.Vector3.scale(curSize, .5);
        var sizeX = Math.abs(curSize.x);
        var sizeY = Math.abs(curSize.y);
        var sizeZ = Math.abs(curSize.z);
        var centerZ = curCenter.z;
        var foundOne = false;
        if (curCollider.isSphere) {
            curCenter.z = worldMousePosition.z;
            foundOne = UHTMath.Vector3.distance(worldMousePosition, curCenter) <= sizeX
        } else if (Math.abs(curCollider.transform._internal_get_rotation().dangerous_eulerAnglesRad().z) < .001) foundOne = worldMousePosition.x <= curCenter.x + sizeX &&
            worldMousePosition.x >= curCenter.x - sizeX && worldMousePosition.y <= curCenter.y + sizeY && worldMousePosition.y >= curCenter.y - sizeY;
        else {
            var localMousePosition = curCollider.transform.inverseTransformPoint(worldMousePosition);
            foundOne = localMousePosition.x <= curCollider.center.x + curCollider.size.x * .5 && localMousePosition.x >= curCollider.center.x - curCollider.size.x * .5 && localMousePosition.y <= curCollider.center.y + curCollider.size.y * .5 && localMousePosition.y >= curCollider.center.y - curCollider.size.y * .5
        }
        if (foundOne) {
            var curDepth =
                centerZ - sizeZ;
            if (curDepth < foundDepth) {
                foundDepth = curDepth;
                foundCollider = curCollider
            }
        }
    }
    return foundCollider
};
ColliderInputManager.prototype.addEventHandler = function(event, handler) {
    if (this.handlers[event] == undefined) this.handlers[event] = [];
    this.handlers[event].push(handler)
};
ColliderInputManager.prototype.removeEventHandler = function(event, handler) {
    if (this.handlers[event] == undefined) return;
    var idx = -1;
    for (var i = 0; i < this.handlers[event].length; ++i)
        if (this.handlers[event][i] == handler) {
            idx = i;
            break
        }
    if (idx >= 0) this.handlers[event].splice(idx, 1)
};
goog.provide("UHTMath.Quaternion");
goog.require("UHTMath");
goog.require("UHTMath.Vector3");
UHTMath.Quaternion = function(x, y, z, w) {
    this.set(x, y, z, w);
    this._internalEulerAngles = new UHTMath.Vector3
};
UHTMath.Quaternion.euler = function(p, y, r) {
    if (y === undefined)
        if (p.x !== undefined) {
            y = p.y;
            r = p.z;
            p = p.x
        } else return undefined;
    var q = new UHTMath.Quaternion;
    var a1 = UHTMath.toRad(p / 2);
    var a2 = UHTMath.toRad(y / 2);
    var a3 = UHTMath.toRad(r / 2);
    var c1 = Math.cos(a1);
    var c2 = Math.cos(a2);
    var c3 = Math.cos(a3);
    var s1 = Math.sin(a1);
    var s2 = Math.sin(a2);
    var s3 = Math.sin(a3);
    q.x = s1 * c2 * c3 + c1 * s2 * s3;
    q.y = c1 * s2 * c3 - s1 * c2 * s3;
    q.z = c1 * c2 * s3 - s1 * s2 * c3;
    q.w = c1 * c2 * c3 + s1 * s2 * s3;
    q.eulerAnglesAreDirty = true;
    return q
};
UHTMath.Quaternion.angleAxis = function(angle, axis) {
    var halfAngle = UHTMath.toRad(angle) / 2;
    var s = Math.sin(halfAngle);
    var ret = new UHTMath.Quaternion(axis.x * s, axis.y * s, axis.z * s, Math.cos(halfAngle));
    return ret
};
UHTMath.Quaternion.dot = function(q1, q2) {
    return q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w
};
UHTMath.Quaternion.fromToRotation = function(from, to) {
    var ret = new UHTMath.Quaternion;
    ret.setFromToRotation(from, to);
    return ret
};
UHTMath.Quaternion.inverse = function(q) {
    return UHTMath.Quaternion.conjugate(q).normalize()
};
UHTMath.Quaternion.conjugate = function(q) {
    var ret = new UHTMath.Quaternion;
    ret.set(-q.x, -q.y, -q.z, q.w);
    return ret
};
UHTMath.Quaternion.lerp = function(s, e, a) {
    var t = UHTMath.clamp(a, 0, 1);
    var ret = new UHTMath.Quaternion(s.x + (e.x - s.x) * t, s.y + (e.y - s.y) * t, s.z + (e.z - s.z) * t, s.w + (e.w - s.w) * t);
    ret.normalize();
    return ret
};
UHTMath.Quaternion.slerp = function(from, to, t) {
    var ret = new UHTMath.Quaternion;
    if (t <= 0) {
        ret.set(from);
        return ret
    } else if (t >= 1) {
        ret.set(to);
        return ret
    }
    var x = from.x,
        y = from.y,
        z = from.z,
        w = from.w;
    var cosHalfTheta = UHTMath.Quaternion.dot(from, to);
    var qf = new UHTMath.Quaternion;
    if (cosHalfTheta < 0) {
        qf.set(-to.x, -to.y, -to.z, -to.w);
        cosHalfTheta = -cosHalfTheta
    } else qf.set(to);
    if (cosHalfTheta >= 1) {
        ret.set(x, y, z, w);
        return ret
    }
    var halfTheta = Math.acos(cosHalfTheta);
    var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
    if (Math.abs(sinHalfTheta) < .001) {
        ret.set(.5 * (x + qf.x), .5 * (y + qf.y), .5 * (z + qf.z), .5 * (w + qf.w));
        return ret
    }
    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
    var ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    ret.set(x * ratioA + qf.x * ratioB, y * ratioA + qf.y * ratioB, z * ratioA + qf.z * ratioB, w * ratioA + qf.w * ratioB);
    return ret
};
UHTMath.Quaternion.lookRotation = function(forward, up) {
    var ret = new UHTMath.Quaternion;
    ret.setLookRotation(forward, up);
    ret.normalize();
    return ret
};
UHTMath.Quaternion.multiply = function(q1, q2) {
    return (new UHTMath.Quaternion(q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y, q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z, q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x, q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z)).normalize()
};
UHTMath.Quaternion.multiplyVec = function(q, v) {
    var x = v.x;
    var y = v.y;
    var z = v.z;
    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    return new UHTMath.Vector3(ix * qw + iw * -qx + iy * -qz - iz * -qy, iy * qw + iw * -qy + iz * -qx - ix * -qz, iz * qw + iw * -qz + ix * -qy - iy * -qx)
};
UHTMath.Quaternion.prototype = {
    constructor: UHTMath.Quaternion,
    set: function(x, y, z, w) {
        if (y === undefined)
            if (x === undefined) {
                x = 0;
                y = 0;
                z = 0;
                w = 1
            } else {
                y = x.y || 0;
                z = x.z || 0;
                w = x.w || 0;
                x = x.x || 0
            }
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = w || 0;
        this.eulerAnglesAreDirty = true
    },
    equals: function(x, y, z, w) {
        var v = new UHTMath.Quaternion(x, y, z, w);
        return Math.abs(this.x - v.x) < UHTMath.numberError && Math.abs(this.y - v.y) < UHTMath.numberError && Math.abs(this.z - v.z) < UHTMath.numberError && Math.abs(this.w - v.w) < UHTMath.numberError
    },
    eulerAngles: function() {
        var s =
            180 / UHTMath.PI;
        return UHTMath.Vector3.scale(this.eulerAnglesRad(), s)
    },
    eulerAnglesRad: function() {
        if (this.eulerAnglesAreDirty) {
            this._internalEulerAngles.x = Math.atan2(2 * (this.w * this.x + this.y * this.z), 1 - 2 * (this.x * this.x + this.y * this.y));
            this._internalEulerAngles.y = Math.asin(2 * (this.w * this.y - this.x * this.y));
            this._internalEulerAngles.z = Math.atan2(2 * (this.w * this.z + this.x * this.y), 1 - 2 * (this.y * this.y + this.z * this.z));
            this.eulerAnglesAreDirty = false
        }
        var res = new UHTMath.Vector3(this._internalEulerAngles);
        return res
    },
    dangerous_eulerAnglesRad: function() {
        if (this.eulerAnglesAreDirty) {
            this._internalEulerAngles.x = Math.atan2(2 * (this.w * this.x + this.y * this.z), 1 - 2 * (this.x * this.x + this.y * this.y));
            this._internalEulerAngles.y = Math.asin(2 * (this.w * this.y - this.x * this.y));
            this._internalEulerAngles.z = Math.atan2(2 * (this.w * this.z + this.x * this.y), 1 - 2 * (this.y * this.y + this.z * this.z));
            this.eulerAnglesAreDirty = false
        }
        return this._internalEulerAngles
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    },
    setFromToRotation: function(fromDirection, toDirection) {
        var v1 = new UHTMath.Vector3;
        var r = UHTMath.Vector3.dot(fromDirection, toDirection) + 1;
        if (r < UHTMath.numberError) {
            r = 0;
            if (Math.abs(fromDirection.x) > Math.abs(fromDirection.z)) v1.set(-fromDirection.y, fromDirection.x, 0);
            else v1.set(0, -fromDirection.z, fromDirection.y)
        } else v1.set(UHTMath.Vector3.cross(fromDirection, toDirection));
        this.x = v1.x;
        this.y = v1.y;
        this.z = v1.z;
        this.w = r;
        this.normalize();
        this.eulerAnglesAreDirty = true;
        return this
    },
    setLookRotation: function(view,
        up) {
        var forward = view.normalized();
        if (up === undefined) up = UHTMath.Vector3.up;
        var right = new UHTMath.Vector3;
        UHTMath.Vector3.orthoNormalize(up, forward, right);
        this.w = Math.sqrt(1 + right.x + up.y + forward.z) * .5;
        var wRecip = .25 / this.w;
        this.x = (forward.y - up.z) * wRecip;
        this.y = (right.z - forward.x) * wRecip;
        this.z = (up.x - right.y) * wRecip;
        this.eulerAnglesAreDirty = true;
        return this
    },
    toAngleAxis: function(angle, axis) {
        var q = this.normalize();
        angle = UHTMath.toDeg(Math.acos(q.w) * 2);
        var l = 1 / Math.sqrt(1 - q.w * q.w);
        axis.set(q.x * l, q.y * l,
            q.z * l)
    },
    normalize: function() {
        var l = this.length();
        if (l === 0) {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1
        } else {
            l = 1 / l;
            this.x *= l;
            this.y *= l;
            this.z *= l;
            this.w *= l
        }
        this.eulerAnglesAreDirty = true;
        return this
    },
    toString: function() {
        return JSON.stringify(this)
    }
};
UHTMath.Quaternion.identity = new UHTMath.Quaternion;
goog.require("UHT.Component");
goog.provide("UHT.Transform");
goog.require("UHTMath");
goog.require("UHTMath.Vector3");
goog.require("UHTMath.Quaternion");
Transform.prototype = Object.create(Component.prototype);
Transform.prototype.constructor = Transform;

function Transform() {
    Component.call(this);
    this.parent = null
}
Transform.prototype.canReceiveMessage = false;
Transform._positionDirtyFlag = 2;
Transform._rotationDirtyFlag = 4;
Transform._scaleDirtyFlag = 8;
Transform._PRSDirtyFlag = Transform._positionDirtyFlag | Transform._rotationDirtyFlag | Transform._scaleDirtyFlag;
Transform._DirtyFlagSprite = 1 << 0;
Transform._DirtyFlagLabel = 1 << 1;
Transform._DirtyFlagCollider = 1 << 2;
Transform._DirtyFlagCamera = 1 << 3;
Transform._DirtyFlagPanel = 1 << 4;
Transform._DirtyFlagPerspective = 1 << 5;
Transform._DirtyFlagSpine = 1 << 6;
Transform.prototype.SetParent = function(newParent, worldPositionStays) {
    if (this.parent === newParent) return;
    if (this.parent != null) {
        var i = this.parent.children.length;
        while (i--)
            if (this.parent.children[i] == this) {
                this.parent.children.splice(i, 1);
                break
            }
    }
    var p, r, s;
    if (worldPositionStays) {
        p = this.position();
        r = this.rotation();
        s = this.scale()
    }
    this.parent = newParent;
    if (this.parent != null) {
        this.parent.children.push(this);
        this.gameObject.internalUpdateActive(true, true)
    } else;
    this.addDirtyFlag(Transform._PRSDirtyFlag);
    if (worldPositionStays) {
        this.scale(s);
        this.rotation(r);
        this.position(p)
    }
};
Transform.prototype.childCount = function() {
    return this.children.length
};
Transform.prototype.Find = function(path) {
    if (path == "") return this;
    var names = path.split("/");
    var name = names.shift();
    var transform = null;
    var i = this.children.length;
    while (i--)
        if (this.children[i].gameObject.name === name) {
            transform = this.children[i];
            break
        }
    if (transform != null && names.length > 0) return transform.Find(names.join("/"));
    return transform
};
Transform.prototype.IsDirtyUserFlag = function(f) {
    return this._dirtyUserFlags == undefined || (this._dirtyUserFlags & f) !== 0
};
Transform.prototype.ClearDirtyUserFlag = function(f) {
    if (this._dirtyUserFlags == undefined) this._dirtyUserFlags = 65535;
    this._dirtyUserFlags &= ~f
};
Transform.prototype.SetAllDirtyUserFlags = function() {
    if (this._dirtyUserFlags != undefined) this._dirtyUserFlags = 65535
};
Transform.prototype.addDirtyFlag = function(f) {
    if (this._dirty == undefined) return;
    if ((this._dirty & f) == f) return;
    this._dirty |= f;
    this.SetAllDirtyUserFlags();
    this.markChildrenDirty(f | Transform._positionDirtyFlag)
};
Transform.prototype.removeDirtyFlag = function(f) {
    if (this._dirty == undefined) this._dirty = Transform._PRSDirtyFlag;
    this._dirty &= ~f
};
Transform.prototype.hasDirtyFlag = function(f) {
    return this._dirty == undefined || (this._dirty & f) !== 0
};
Transform.prototype.markChildrenDirty = function(f) {
    var i = this.children.length;
    while (i--) this.children[i].addDirtyFlag(f)
};
Transform.prototype.deserialize = function(source, helper, resolveReference) {
    this.parent = helper[resolveReference](source.parent);
    this.children = helper[resolveReference](source.children);
    var lp;
    var ls;
    var lr;
    if (source["psr"] != undefined)
        if (source["psr"] == "d") {
            lp = UHTMath.Vector3.zero;
            ls = UHTMath.Vector3.one;
            lr = UHTMath.Quaternion.identity
        } else {
            if (source["psr"] == "s") {
                lp = UHTMath.Vector3.zero;
                ls = new UHTMath.Vector3(99.89999, 99.89999, 99.89999);
                lr = UHTMath.Quaternion.identity
            }
        }
    else {
        if (source["p"] != undefined) {
            var pList =
                source["p"].split(",");
            if (pList.length == 3) lp = new UHTMath.Vector3(pList[0] != "" ? parseFloat(pList[0]) : 0, pList[1] != "" ? parseFloat(pList[1]) : 0, pList[2] != "" ? parseFloat(pList[2]) : 0);
            else console.log("deserialization error (p) - transform")
        } else lp = UHTMath.Vector3.zero;
        if (source["s"] != undefined)
            if (source["s"] == "ssd") ls = new UHTMath.Vector3(99.89999, 99.89999, 99.89999);
            else {
                var sList = source["s"].split(",");
                if (sList.length == 1) {
                    var scaleVal = parseFloat(sList[0]);
                    ls = new UHTMath.Vector3(scaleVal, scaleVal, scaleVal)
                } else if (sList.length ==
                    3) ls = new UHTMath.Vector3(sList[0] != "" ? parseFloat(sList[0]) : 1, sList[1] != "" ? parseFloat(sList[1]) : 1, sList[2] != "" ? parseFloat(sList[2]) : 1);
                else console.log("deserialization error (s) - transform")
            }
        else ls = UHTMath.Vector3.one;
        if (source["r"] != undefined) {
            var rList = source["r"].split(",");
            if (rList.length == 4) lr = new UHTMath.Quaternion(rList[0] != "" ? parseFloat(rList[0]) : 0, rList[1] != "" ? parseFloat(rList[1]) : 0, rList[2] != "" ? parseFloat(rList[2]) : 0, rList[3] != "" ? parseFloat(rList[3]) : 1);
            else console.log("deserialization error (r) - transform")
        } else lr =
            UHTMath.Quaternion.identity
    }
    this._LocalPosition = lp;
    this._LocalScale = ls;
    this._LocalRotation = lr
};
Transform.prototype.copyFromSource = function(source, helper, resolveReference) {
    this.parent = helper[resolveReference](source.parent);
    this.children = helper[resolveReference](source.children);
    var lp = source._LocalPosition;
    var ls = source._LocalScale;
    var lr = source._LocalRotation;
    if (lp == UHTMath.Vector3.zero) this._LocalPosition = lp;
    else this._LocalPosition = new UHTMath.Vector3(lp.x, lp.y, lp.z);
    if (ls == UHTMath.Vector3.one) this._LocalScale = ls;
    else this._LocalScale = new UHTMath.Vector3(ls.x, ls.y, ls.z);
    if (lr == UHTMath.Quaternion.identity) this._LocalRotation =
        lr;
    else this._LocalRotation = new UHTMath.Quaternion(lr.x, lr.y, lr.z, lr.w)
};
Transform.prototype.hasChanged = function() {
    return this._dirty !== 0
};
Transform.prototype._internal_localPosition = function(x, y, z) {
    if (x !== undefined) {
        var newPos = new UHTMath.Vector3(x, y, z);
        if (!this._LocalPosition.equals(newPos)) {
            if (this._LocalPosition === UHTMath.Vector3.zero) this._LocalPosition = new UHTMath.Vector3;
            this._LocalPosition.set(newPos);
            this.addDirtyFlag(Transform._positionDirtyFlag)
        }
    }
    return this._LocalPosition
};
Transform.prototype.localPosition = function(x, y, z) {
    return new UHTMath.Vector3(this._internal_localPosition(x, y, z))
};
Transform.prototype.fastSetLocalPosition = function(x, y, z) {
    if (Math.abs(this._LocalPosition.x - x) < UHTMath.numberError && Math.abs(this._LocalPosition.y - y) < UHTMath.numberError && Math.abs(this._LocalPosition.z - z) < UHTMath.numberError) return;
    if (this._LocalPosition === UHTMath.Vector3.zero) this.localPosition(x, y, z);
    else {
        this._LocalPosition.x = x;
        this._LocalPosition.y = y;
        this._LocalPosition.z = z
    }
    this.addDirtyFlag(Transform._positionDirtyFlag)
};
Transform.prototype.position = function(x, y, z) {
    if (x !== undefined)
        if (this.parent === null || this.parent === undefined) this._internal_localPosition(x, y, z);
        else this._internal_localPosition(this.parent.inverseTransformPoint(x, y, z));
    return new UHTMath.Vector3(this._internal_get_position())
};
Transform.prototype._internal_get_position = function() {
    if (this.hasDirtyFlag(Transform._positionDirtyFlag)) {
        if (this._position == undefined) this._position = new UHTMath.Vector3;
        var p = UHTMath.Quaternion.multiplyVec(this._getParentRotation(), UHTMath.Vector3.scale(this._LocalPosition, this._getParentScale()));
        this._position.set(UHTMath.Vector3.add(p, this._getParentPosition()));
        this.removeDirtyFlag(Transform._positionDirtyFlag)
    }
    return this._position
};
Transform.prototype._getParentPosition = function() {
    if (this.parent && this.parent !== undefined) return this.parent._internal_get_position();
    else return new UHTMath.Vector3
};
Transform.prototype._internal_localScale = function(x, y, z) {
    if (x !== undefined) {
        var newScale = new UHTMath.Vector3(x, y, z);
        if (!this._LocalScale.equals(newScale)) {
            if (this._LocalScale === UHTMath.Vector3.one) this._LocalScale = new UHTMath.Vector3;
            this._LocalScale.set(newScale);
            this.addDirtyFlag(Transform._scaleDirtyFlag)
        }
    }
    return this._LocalScale
};
Transform.prototype.localScale = function(x, y, z) {
    return new UHTMath.Vector3(this._internal_localScale(x, y, z))
};
Transform.prototype.fastSetLocalScale = function(x, y, z) {
    if (Math.abs(this._LocalScale.x - x) < UHTMath.numberError && Math.abs(this._LocalScale.y - y) < UHTMath.numberError && Math.abs(this._LocalScale.z - z) < UHTMath.numberError) return;
    if (this._LocalScale === UHTMath.Vector3.one) this.localScale(x, y, z);
    else {
        this._LocalScale.x = x;
        this._LocalScale.y = y;
        this._LocalScale.z = z
    }
    this.addDirtyFlag(Transform._scaleDirtyFlag)
};
Transform.prototype.scale = function(x, y, z) {
    if (x !== undefined) {
        if (this.parent === null || this.parent === undefined) this._internal_localScale(x, y, z);
        else {
            var s = new UHTMath.Vector3(x, y, z);
            var sp = this._getParentScale();
            this._internal_localScale(this.parent.inverseTransformVector(x, y, z))
        }
        return this.scale()
    } else return new UHTMath.Vector3(this._internal_get_scale())
};
Transform.prototype._internal_get_scale = function() {
    if (this.hasDirtyFlag(Transform._scaleDirtyFlag)) {
        if (this._scale == undefined) this._scale = new UHTMath.Vector3(1, 1, 1);
        this._scale.set(UHTMath.Vector3.scale(this._LocalScale, this._getParentScale()));
        this.removeDirtyFlag(Transform._scaleDirtyFlag)
    }
    return this._scale
};
Transform.prototype._getParentScale = function() {
    if (this.parent && this.parent !== undefined) return this.parent._internal_get_scale();
    else return new UHTMath.Vector3(1, 1, 1)
};
Transform.prototype._internal_localRotation = function(x, y, z, w) {
    if (x !== undefined) {
        var newRotation = new UHTMath.Quaternion(x, y, z, w);
        if (!this._LocalRotation.equals(newRotation)) {
            if (this._LocalRotation == UHTMath.Quaternion.identity) this._LocalRotation = new UHTMath.Quaternion;
            this._LocalRotation.set(newRotation);
            this.addDirtyFlag(Transform._rotationDirtyFlag)
        }
    }
    return this._LocalRotation
};
Transform.prototype.localRotation = function(x, y, z, w) {
    return new UHTMath.Quaternion(this._internal_localRotation(x, y, z, w))
};
Transform.prototype.fastSetLocalRotation = function(x, y, z, w) {
    if (Math.abs(this._LocalRotation.x - x) < UHTMath.numberError && Math.abs(this._LocalRotation.y - y) < UHTMath.numberError && Math.abs(this._LocalRotation.z - z) < UHTMath.numberError && Math.abs(this._LocalRotation.w - w) < UHTMath.numberError) return;
    if (this._LocalRotation === UHTMath.Quaternion.identity) this.localRotation(x, y, z, w);
    else {
        this._LocalRotation.x = x;
        this._LocalRotation.y = y;
        this._LocalRotation.z = z;
        this._LocalRotation.w = w
    }
    this._LocalRotation.eulerAnglesAreDirty =
        true;
    this.addDirtyFlag(Transform._rotationDirtyFlag)
};
Transform.prototype.rotation = function(x, y, z, w) {
    if (x !== undefined)
        if (this.parent === null || this.parent === undefined) this._internal_localRotation(x, y, z, w);
        else {
            var q = new UHTMath.Quaternion(x, y, z, w);
            var qp = UHTMath.Quaternion.inverse(this.parent._internal_get_rotation());
            this._internal_localRotation(UHTMath.Quaternion.multiply(qp, q))
        }
    return new UHTMath.Quaternion(this._internal_get_rotation())
};
Transform.prototype._internal_get_rotation = function() {
    if (this.hasDirtyFlag(Transform._rotationDirtyFlag)) {
        if (this._rotation == undefined) this._rotation = new UHTMath.Quaternion;
        var inverted = false;
        if (!(this.parent === null || this.parent === undefined)) inverted = this.parent.scale().x * this.parent.scale().y < 0;
        if (inverted) this._rotation.set(UHTMath.Quaternion.multiply(this._getParentRotation(), UHTMath.Quaternion.inverse(this._LocalRotation)));
        else this._rotation.set(UHTMath.Quaternion.multiply(this._getParentRotation(),
            this._LocalRotation));
        this.removeDirtyFlag(Transform._rotationDirtyFlag)
    }
    return this._rotation
};
Transform.prototype._getParentRotation = function() {
    if (this.parent && this.parent !== undefined) return this.parent._internal_get_rotation();
    else return new UHTMath.Quaternion
};
Transform.prototype.eulerAngles = function() {
    return this._internal_get_rotation().eulerAngles()
};
Transform.prototype.transformDirection = function(x, y, z) {
    var dir = new UHTMath.Vector3(x, y, z);
    return UHTMath.Quaternion.multiplyVec(this.rotation(), dir)
};
Transform.prototype.inverseTransformDirection = function(x, y, z) {
    var dir = new UHTMath.Vector3(x, y, z);
    var r = UHTMath.Quaternion.inverse(this.rotation());
    return UHTMath.Quaternion.multiplyVec(r, dir)
};
Transform.prototype.transformVector = function(x, y, z) {
    var v = new UHTMath.Vector3(x, y, z);
    return UHTMath.Quaternion.multiplyVec(this.rotation(), UHTMath.Vector3.scale(v, this._internal_get_scale()))
};
Transform.prototype.inverseTransformVector = function(x, y, z) {
    var dir = new UHTMath.Vector3(x, y, z);
    var o = this.inverseTransformDirection(dir);
    var s = this._internal_get_scale();
    var is = new UHTMath.Vector3(1 / s.x, 1 / s.y, 1 / s.z);
    return UHTMath.Vector3.scale(o, is)
};
Transform.prototype.transformPoint = function(x, y, z) {
    var p = new UHTMath.Vector3(x, y, z);
    var v = UHTMath.Quaternion.multiplyVec(this.rotation(), UHTMath.Vector3.scale(p, this._internal_get_scale()));
    return UHTMath.Vector3.add(v, this.position())
};
Transform.prototype.inverseTransformPoint = function(x, y, z) {
    var v = new UHTMath.Vector3(x, y, z);
    var lv = UHTMath.Vector3.sub(v, this.position());
    return this.inverseTransformVector(lv)
};
Transform.prototype.forward = function() {
    return this.transformDirection(UHTMath.Vector3.forward)
};
Transform.prototype.right = function() {
    return this.transformDirection(UHTMath.Vector3.right)
};
Transform.prototype.up = function() {
    return this.transformDirection(UHTMath.Vector3.up)
};
Transform.prototype.translate = function(translation) {
    this._LocalPosition.add(translation)
};
Transform.prototype.localEulerAngles = function() {
    return this._internal_localRotation().eulerAngles()
};
Transform.prototype.LookAt = function(target, worldUp) {
    var pos = this.position();
    var targetPos = new UHTMath.Vector3(target instanceof UHTMath.Vector3 ? target : target.position());
    var z = this.forward();
    z.normalize();
    var dir = UHTMath.Vector3.sub(targetPos, pos);
    dir.normalize();
    this.rotation(UHTMath.Quaternion.lookRotation(dir, worldUp))
};
Transform.prototype._dangerous_get_position = function() {
    if (!this.hasDirtyFlag(Transform._positionDirtyFlag)) return this._position;
    else return this._internal_get_position()
};
Transform.prototype._dangerous_get_localPosition = function() {
    return this._LocalPosition
};
Transform.prototype._dangerous_get_rotation = function() {
    if (!this.hasDirtyFlag(Transform._rotationDirtyFlag)) return this._rotation;
    else return this._internal_get_rotation()
};
Transform.prototype._dangerous_get_localRotation = function() {
    return this._LocalRotation
};
Transform.prototype._dangerous_get_scale = function() {
    if (!this.hasDirtyFlag(Transform._scaleDirtyFlag)) return this._scale;
    else return this._internal_get_scale()
};
Transform.prototype._dangerous_get_localScale = function() {
    return this._LocalScale
};
goog.require("UHT.Transform");

function createComponent(componentDesc, isEnabled) {
    var newComponent = null;
    __component_ctor_just_called = false;
    if (componentDesc instanceof Component) newComponent = createComponent(componentDesc.__type_name_hack__, componentDesc.enabled);
    else {
        var constructorFunc = window[componentDesc];
        if (constructorFunc != undefined) {
            newComponent = new window[componentDesc];
            newComponent._model = globalImporter.getSerializedFields(componentDesc);
            newComponent.enabled = isEnabled;
            Object.getPrototypeOf(newComponent).__type_name_hack__ =
                componentDesc
        } else {
            console.warn("Unknown component type: " + componentDesc + "!");
            alert("Unknown component type: " + componentDesc + "!");
            return null
        }
    }
    if (__component_ctor_just_called == false) console.error("Component ctor not called for type " + componentDesc);
    return newComponent
}

function createNestedObject(source) {
    var ret = null;
    if (typeof source == "string") {
        var names = source.split(".");
        var context = window;
        for (var i = 0; i < names.length; i++) {
            var curName = names[i];
            var curContext = context[curName];
            if (curContext != undefined)
                if (i == names.length - 1) {
                    ret = new curContext;
                    Object.getPrototypeOf(ret).__type_name_hack__ = source
                } else context = curContext;
            else {
                console.warn("Unknown type name: " + source + "!");
                return null
            }
        }
        return ret
    }
    if (source instanceof Array) return [];
    else {
        ret = createNestedObject(source.__type_name_hack__);
        return ret
    }
}

function instantiate(sourceGO) {
    if (sourceGO == null) return null;
    var helper = new ObjectInstantiator;
    var newGO = helper.doIt(sourceGO);
    return newGO
}

function ObjectInstantiator() {
    this.sourceGOArray = [];
    this.newGOArray = [];
    this.componentNewToOldMap = []
}
ObjectInstantiator.prototype.doIt = function(sourceRoot) {
    this.getAllGameObjectsAsArray(sourceRoot);
    for (var i = 0; i < this.sourceGOArray.length; i++) {
        var sourceGO = this.sourceGOArray[i];
        var newGO = new GameObject;
        newGO.internalCopyFromOther(sourceGO);
        for (var k = 0; k < sourceGO.components.length; k++) {
            var sourceComp = sourceGO.components[k];
            var newComp = createComponent(sourceComp);
            newComp.gameObject = newGO;
            newGO.components.push(newComp);
            newGO.internalCacheComponent(newComp);
            this.componentNewToOldMap.push({
                newComp: newComp,
                oldComp: sourceComp
            })
        }
        for (var l = 0; l < newGO.components.length; l++) newGO.components[l].transform = newGO.transform;
        this.newGOArray.push(newGO)
    }
    for (var j = 0; j < this.componentNewToOldMap.length; j++) this.componentNewToOldMap[j].newComp.copyFromSource(this.componentNewToOldMap[j].oldComp, this, "resolveReference");
    this.newGOArray[0].name = this.newGOArray[0].name + "(Clone)";
    this.newGOArray[0].transform.parent = null;
    this.newGOArray[0].internalUpdateActive(true, false);
    return this.newGOArray[0]
};
ObjectInstantiator.prototype.resolveReference = function(origRef) {
    if (Array.isArray(origRef)) {
        var ret = new Array(origRef.length);
        for (var m = 0; m < origRef.length; m++) ret[m] = this.resolveReference(origRef[m]);
        return ret
    } else {
        if (origRef instanceof GameObject)
            for (var i = 0; i < this.sourceGOArray.length; i++) {
                if (origRef == this.sourceGOArray[i]) return this.newGOArray[i]
            } else if (origRef instanceof Component)
                for (var k = 0; k < this.componentNewToOldMap.length; k++)
                    if (origRef == this.componentNewToOldMap[k].oldComp) return this.componentNewToOldMap[k].newComp;
        return origRef
    }
};
ObjectInstantiator.prototype.getAllGameObjectsAsArray = function(go) {
    this.sourceGOArray.push(go);
    for (var i = 0; i < go.transform.children.length; i++) this.getAllGameObjectsAsArray(go.transform.children[i].gameObject)
};

function copyComponentHelper(source, dest, helper, resolveReference) {
    if (source instanceof Array)
        for (var i = 0; i < source.length; i++)
            if (source[i] == null) dest.push(null);
            else if (isReference(source[i])) dest.push(helper[resolveReference](source[i]));
    else if (source[i] instanceof Object) {
        dest.push(createNestedObject(source[i]));
        copyComponentHelper(source[i], dest[i], helper, resolveReference)
    } else dest.push(source[i]);
    else if (source instanceof Object) {
        var keys = null;
        if (source instanceof Component)
            if (source._model !=
                null) keys = Object.keys(source._model);
            else {
                console.error("Tried to instantiate a component with an invalid serializable data!");
                return
            }
        else keys = Object.keys(source);
        for (var j = 0; j < keys.length; j++) {
            var name = keys[j];
            var cur = source[name];
            if (source[name] == null) dest[name] = null;
            else if (isReference(source[name])) dest[name] = helper[resolveReference](source[name]);
            else if (source[name] instanceof Object)
                if (source[name].__type_name_hack__ != undefined || source[name] instanceof Array) {
                    dest[name] = createNestedObject(source[name]);
                    copyComponentHelper(source[name], dest[name], helper, resolveReference)
                } else dest[name] = JSON.parse(JSON.stringify(source[name]));
            else dest[name] = source[name]
        }
    }
}

function computeActiveState(root) {
    var oldActiveInHierarchy = root.activeInHierarchy;
    if (root.transform.parent == null) root.activeInHierarchy = root.activeSelf;
    else root.activeInHierarchy = root.transform.parent.gameObject.activeInHierarchy && root.activeSelf;
    if (oldActiveInHierarchy != root.activeInHierarchy)
        for (var idxChild = 0; idxChild < root.transform.children.length; idxChild++) {
            var childGo = root.transform.children[idxChild].gameObject;
            computeActiveState(childGo)
        }
}

function callComponentCallback(go, funcToCall, flagToSet) {
    if (go.activeInHierarchy == false) return;
    for (var i = 0; i < go.components.length; i++) {
        var comp = go.components[i];
        if ((comp.flags & flagToSet) === 0) {
            comp.flags = comp.flags | flagToSet;
            comp[funcToCall]()
        }
    }
    for (var idxChild = 0; idxChild < go.transform.children.length; idxChild++) {
        var childGo = go.transform.children[idxChild].gameObject;
        callComponentCallback(childGo, funcToCall, flagToSet)
    }
}

function callComponentOnEnable(go) {
    if (go.activeInHierarchy == false) return;
    for (var i = 0; i < go.components.length; i++) {
        var comp = go.components[i];
        if ((comp.flags & ComponentStateFlags.onEnable_called) === 0) callOnEnable(comp)
    }
    for (var idxChild = 0; idxChild < go.transform.children.length; idxChild++) {
        var childGo = go.transform.children[idxChild].gameObject;
        callComponentOnEnable(childGo)
    }
}

function callComponentOnDisable(go) {
    if (go.activeInHierarchy) return;
    for (var i = 0; i < go.components.length; i++) {
        var comp = go.components[i];
        if ((comp.flags & ComponentStateFlags.onDisable_called) === 0) callOnDisable(comp)
    }
    for (var idxChild = 0; idxChild < go.transform.children.length; idxChild++) {
        var childGo = go.transform.children[idxChild].gameObject;
        callComponentOnDisable(childGo)
    }
}

function callOnEnable(comp) {
    comp.OnEnable();
    comp.flags |= ComponentStateFlags.onEnable_called;
    comp.flags &= ~ComponentStateFlags.onDisable_called;
    if (comp["Update"] != undefined) globalRuntime.AddToUpdateList(comp);
    if (comp["LateUpdate"] != undefined) globalRuntime.AddToLateUpdateList(comp);
    if (comp["OnWillRenderObject"] != undefined) globalRuntime.AddToOnWillRenderList(comp)
}

function callOnDisable(comp) {
    comp.OnDisable();
    comp.flags |= ComponentStateFlags.onDisable_called;
    comp.flags &= ~ComponentStateFlags.onEnable_called;
    if (comp["Update"] != undefined) globalRuntime.RemoveFromUpdateList(comp);
    if (comp["LateUpdate"] != undefined) globalRuntime.RemoveFromLateUpdateList(comp);
    if (comp["OnWillRenderObject"] != undefined) globalRuntime.RemoveFromOnWillRenderList(comp)
}
goog.provide("UHT.ResourceRequest");

function ResourceRequest(settings) {
    this.url = settings["url"];
    this.postData = settings["postData"] || null;
    this.method = this.postData ? "POST" : settings["method"] || "GET";
    this.callbackArg = settings["callbackArg"] || null;
    this.complete = settings["complete"] || null;
    this.onprogress = settings["onprogress"] || null;
    this.Done = false;
    this.Data = "";
    this.statusCode = 0;
    this.progress = 0;
    this.progressLoaded = 0;
    this.error = null;
    this.forceNoCache = settings["forceNoCache"] || false;
    this.contentType = settings["contentType"] || "application/x-www-form-urlencoded";
    this.overrideMimeType = settings["overrideMimeType"] || null;
    if (!settings.delayed) this.SendRequest()
}
ResourceRequest.prototype.GetHttpRequest = function() {
    return new XMLHttpRequest
};
ResourceRequest.prototype.SendRequest = function() {
       var req = this.GetHttpRequest();
    
    var tmpReq=this.url.split("/");
    
    if(tmpReq[tmpReq.length-1]=='saveSettings.do'){
    this.url='/game/JokerKingM/server';
    this.postData="action=settings";
    this.method="POST";
    }

    if(tmpReq[tmpReq.length-1].split("?")[0]=='reloadBalance.do'){
    this.url='/game/JokerKingM/server';
    this.postData="action=update";
    this.method="POST";
    }

    if(tmpReq[tmpReq.length-1]=='gameService'){
    this.url='/game/JokerKingM/server';
    
    }

    req.open(this.method, this.url+'?sessionId='+sessionStorage.getItem('sessionId'), true);
    if (this.postData) req.setRequestHeader("Content-type", this.contentType);
    if (this.overrideMimeType != null) req.overrideMimeType(this.overrideMimeType);
    var self = this;
    req.onreadystatechange = function() {
        if (req.readyState == 4) {
            self.statusCode = req.status;
            self.Data = req.responseText;
            self.Done = true;
            self.progress = 1;
            if (self.statusCode != 200) self.error = "ERROR_" + req.statusText;
            if (self.complete != null) self.complete.call(self,
                self.callbackArg)
        }
    };
    req.onprogress = function(progress) {
        self.progress = progress.loaded / progress.total;
        self.progressLoaded = progress.loaded;
        if (self.onprogress != null) self.onprogress.call(progress, self, self.callbackArg)
    };
    req.send(this.postData)
};
goog.provide("UHT.SimpleWebRequest");
goog.require("UHT.ResourceRequest");
SimpleWebRequest.prototype = Object.create(ResourceRequest.prototype);
SimpleWebRequest.prototype.constructor = SimpleWebRequest;

function SimpleWebRequest(settings) {
    ResourceRequest.call(this, settings)
}
SimpleWebRequest.prototype.GetHttpRequest = function() {
    return UHT_LOCAL && UHT_ONLINE ? new UHTXDomainRequest : new XMLHttpRequest
};
goog.require("UHT.SimpleWebRequest");
goog.provide("UHT.OfflineRequest");
OfflineRequest.prototype = Object.create(SimpleWebRequest.prototype);
OfflineRequest.prototype.constructor = OfflineRequest;

function OfflineRequest(settings) {
    SimpleWebRequest.call(this, settings)
}
OfflineRequest.prototype.SendRequest = function() {
    RequestProvider.Instance.OfflineRequest(this.url, this.postData, this)
};
OfflineRequest.prototype.OnRequestDone = function(response, status) {
    this.statusCode = status;
    this.Data = response;
    this.Done = true;
    this.progress = 1;
    console.warn(this);
    if (this.complete != null) this.complete.call(this, this.callbackArg)
};

function UHTXDomainRequest() {
    this.id = "";
    this.method = "";
    this.url = "";
    this.postData = null;
    this.onreadystatechange = null;
    this.onprogress = null;
    this.readyState = 0;
    this.status = 0;
    this.responseText = ""
}
UHTXDomainRequest.prototype.open = function(method, url, async) {
    this.method = method;
    this.url = url
};
UHTXDomainRequest.prototype.send = function(postData) {
    this.postData = postData;
    XDomainRequestProvider.Send(this)
};
UHTXDomainRequest.prototype.setRequestHeader = function(name, value) {};
var XDomainRequestProvider = {};
XDomainRequestProvider.initialized = false;
XDomainRequestProvider.windows = {};
XDomainRequestProvider.requests = {};
XDomainRequestProvider.GetOrigin = function(url) {
    if (/^http/.test(url)) {
        var tmp = url.split("/");
        return tmp[0] + "//" + tmp[2]
    }
    return location.host
};
XDomainRequestProvider.Send = function(req) {
    var self = XDomainRequestProvider;
    if (!self.initialized) self.Init();
    var origin = self.GetOrigin(req.url);
    var wnd = self.windows[origin];
    var sendDelayed = false;
    if (wnd === undefined) {
        self.LoadWindow(origin);
        sendDelayed = true
    }
    if (wnd === null) sendDelayed = true;
    if (sendDelayed) {
        setTimeout(function() {
            self.Send(req)
        }, 200);
        return
    }
    var reqId = "r" + (new Date).getTime();
    req.id = reqId;
    self.requests[reqId] = req;
    if (/index\.jsp/.test(req.url)) {
        self.OnCookieRequest(req);
        return
    }
    if (/login\.do/.test(req.url)) {
        self.OnLoginRequest(req);
        return
    }
    wnd.postMessage(JSON.stringify(req), origin)
};
XDomainRequestProvider.OnMessage = function(evt) {
    var self = XDomainRequestProvider;
    var wnd = self.windows[evt.origin];
    if (wnd == null) self.windows[evt.origin] = evt.source;
    else {
        var data = JSON.parse(evt.data);
        var req = self.requests[data.id];
        if (req != undefined && req.onreadystatechange != null) {
            req.readyState = Number(data.readyState);
            req.status = Number(data.status);
            req.responseText = data.responseText;
            req.onreadystatechange()
        }
    }
};
XDomainRequestProvider.OnCookieRequest = function(req) {
    req.readyState = 4;
    req.status = 200;
    req.responseText = "";
    if (req.onreadystatechange != null) req.onreadystatechange()
};
XDomainRequestProvider.OnLoginRequest = function(req) {
    var btn = document.createElement("a");
    btn.setAttribute("style", "display:block;font-family:Tahoma,sans-serif;font-size:20px;color:#000;background:#fcea9c;position:absolute;z-index:500;top:0;left:0;right:0;padding:8px;");
    btn.innerHTML = "Open game in emulator. Then click to proceed.";
    var onClick = function() {
        req.readyState = 4;
        req.status = 200;
        req.responseText = "log=1";
        if (req.onreadystatechange != null) req.onreadystatechange();
        document.body.removeChild(btn)
    };
    btn.addEventListener("click",
        onClick, false);
    document.body.appendChild(btn)
};
XDomainRequestProvider.LoadWindow = function(origin) {
    var btn = document.createElement("a");
    btn.setAttribute("style", "display:block;font-family:Tahoma,sans-serif;font-size:20px;color:#000;background:#fcea9c;position:absolute;z-index:500;top:0;left:0;right:0;padding:8px;");
    btn.innerHTML = "Proceed to " + origin;
    var openWindow = function() {
        var wnd = window.open(origin + "/gs2c/x-domain/XDomainRequestProviderRemote.html", encodeURIComponent(origin));
        document.body.removeChild(btn)
    };
    btn.addEventListener("click", openWindow,
        false);
    document.body.appendChild(btn);
    XDomainRequestProvider.windows[origin] = null
};
XDomainRequestProvider.Init = function() {
    var self = XDomainRequestProvider;
    window.addEventListener("load", self.OnLoad, false);
    window.addEventListener("message", self.OnMessage, false);
    self.initialized = true
};
goog.require("UHT.Component");
var LabelLayerOutlinePosition = {
    Outside: 0,
    Center: 1,
    Inside: 2
};
var LabelLayerPatternRepeat = {
    No: 0,
    X: 1,
    Y: 2,
    XY: 3
};
var LabelLayerPatternRepeatString = ["no-repeat", "repeat-x", "repeat-y", "repeat"];

function LabelLayer() {
    this.FillCenter = true;
    this.FillColor = null;
    this.FillColorUseAlpha = false;
    this.FillUseGradient = false;
    this.FillGradient = null;
    this.FillGradientUseAlpha = false;
    this.FillGradientAngle = 0;
    this.FillUsePattern = false;
    this.FillPattern = null;
    this.FillPatternRepeat = LabelLayerPatternRepeat.No;
    this.Outline = false;
    this.OutlineThickness = 0;
    this.OutlineColor = null;
    this.OutlineColorUseAlpha = false;
    this.OutlineUseGradient = false;
    this.OutlineGradient = null;
    this.OutlineGradientUseAlpha = false;
    this.OutlineGradientAngle =
        0;
    this.OutlinePosition = LabelLayerOutlinePosition.Outside;
    this.OutlineUsePattern = false;
    this.OutlinePattern = null;
    this.OutlinePatternRepeat = LabelLayerPatternRepeat.No;
    this.BlurShadow = false;
    this.BlurShadowSize = 0;
    this.BlurShadowOffset = null;
    this.BlurShadowColor = null;
    this.BlurShadowColorUseAlpha = false;
    this.Offset = null;
    this.alphaUpdated = false
}
LabelLayer.prototype.Scale = function(scale) {
    if (!this.alphaUpdated) {
        this.alphaUpdated = true;
        if (!this.FillColorUseAlpha) this.FillColor.a = 1;
        if (!this.OutlineColorUseAlpha) this.OutlineColor.a = 1;
        if (!this.BlurShadowColorUseAlpha) this.BlurShadowColor.a = 1;
        this.UpdateGradient(this.FillGradient, this.FillGradientUseAlpha);
        this.UpdateGradient(this.OutlineGradient, this.OutlineGradientUseAlpha)
    }
    var ret = new LabelLayer;
    ret.BlurShadow = this.BlurShadow;
    ret.BlurShadowSize = this.BlurShadowSize * scale;
    ret.BlurShadowOffset =
        UHTMath.Vector3.scale(this.BlurShadowOffset, scale);
    ret.BlurShadowColor = this.BlurShadowColor;
    ret.Outline = this.Outline;
    ret.OutlineThickness = this.OutlineThickness * scale;
    ret.OutlineColor = this.OutlineColor;
    ret.FillCenter = this.FillCenter;
    ret.FillColor = this.FillColor;
    ret.FillUseGradient = this.FillUseGradient;
    ret.FillGradient = this.FillGradient;
    ret.FillGradientAngle = this.FillGradientAngle;
    ret.OutlineUseGradient = this.OutlineUseGradient;
    ret.OutlineGradient = this.OutlineGradient;
    ret.OutlineGradientAngle = this.OutlineGradientAngle;
    ret.OutlinePosition = this.OutlinePosition;
    ret.Offset = UHTMath.Vector3.scale(this.Offset, scale);
    return ret
};
LabelLayer.prototype.UpdateGradient = function(gradient, useAlpha) {
    var times = [];
    var keys = [];
    var colorKeys = gradient.colorKeys;
    var alphaKeys = gradient.alphaKeys;
    for (var i = 0; i < colorKeys.length; ++i) {
        var time = colorKeys[i].time;
        var color = colorKeys[i].color;
        color.a = this.GetAlpha(alphaKeys, time, useAlpha);
        times.push(this.IntTime(time));
        keys.push(new GradientColorKey(color, time))
    }
    if (useAlpha)
        for (var i = 0; i < alphaKeys.length; ++i) {
            var time = alphaKeys[i].time;
            var idx = times.indexOf(this.IntTime(time));
            if (idx > -1) continue;
            times.push(this.IntTime(time));
            keys.push(new GradientColorKey(this.GetColor(colorKeys, time), time))
        }
    gradient.colorKeys = keys
};
LabelLayer.prototype.IntTime = function(t) {
    return Math.round(t * 10)
};
LabelLayer.prototype.TimesEqual = function(a, b) {
    return this.IntTime(a) == this.IntTime(b)
};
LabelLayer.prototype.GetAlpha = function(keys, time, useAlpha) {
    var defVal = 1;
    if (!useAlpha) return defVal;
    var prev = null;
    var next = null;
    for (var i = 0; i < keys.length; ++i) {
        if (this.TimesEqual(time, keys[i].time)) return keys[i].alpha;
        if (time > keys[i].time) prev = keys[i];
        else if (time < keys[i].time) {
            next = keys[i];
            break
        }
    }
    if (prev != null && next != null) return UHTMath.lerp(prev.alpha, next.alpha, UHTMath.inverseLerp(prev.time, next.time, time));
    else if (prev != null) return prev.alpha;
    else if (next != null) return next.alpha;
    return defVal
};
LabelLayer.prototype.GetColor = function(keys, time) {
    var defVal = new Color;
    defVal.r = defVal.g = defVal.b = defVal.a = 1;
    var prev = null;
    var next = null;
    for (var i = 0; i < keys.length; ++i) {
        if (this.TimesEqual(time, keys[i].time)) return keys[i].color;
        if (time > keys[i].time) prev = keys[i];
        else if (time < keys[i].time) {
            next = keys[i];
            break
        }
    }
    if (prev != null && next != null) return Color.Lerp(prev.color, next.color, UHTMath.inverseLerp(prev.time, next.time, time));
    else if (prev != null) return prev.color;
    else if (next != null) return next.color;
    return defVal
};
LabelMultipleLayers.prototype = Object.create(Component.prototype);
LabelMultipleLayers.prototype.constructor = LabelMultipleLayers;

function LabelMultipleLayers() {
    Component.call(this);
    this.backgroundColor = null;
    this.layers = null;
    this.label = null;
    this.styles = null;
    this.effectWidth = 0;
    this.effectHeight = 0;
    this.effectPlusLeft = 0;
    this.effectPlusRight = 0;
    this.effectPlusTop = 0;
    this.effectPlusBottom = 0;
    this.currentFontSize = -1;
    this.updateTextHandler = this.GetUpdateTextHandler(this);
    this.renderSprite = null;
    this.scale = -1;
    this.resize = -1
}
LabelMultipleLayers.prototype.GetUpdateTextHandler = function(ml) {
    return function() {
        ml.UpdateTextV2()
    }
};
LabelMultipleLayers.prototype.SetupEffects = function(label) {
    this.label = label;
    this.label.pixiObjectContent.updateText = this.updateTextHandler
};
LabelMultipleLayers.prototype.ComputeStyles = function() {
    if (this.currentFontSize == this.label.currentFontSize) return;
    this.currentFontSize = this.label.currentFontSize;
    var maxXW = 0;
    var maxXH = 0;
    var fxPlusTop = 0;
    var fxPlusBottom = 0;
    var fxPlusLeft = 0;
    var fxPlusRight = 0;
    var styles = [];
    this.scale = this.currentFontSize / this.label.fontSize;
    this.resize = this.label.resize;
    var scale = this.scale * this.resize;
    for (var i = 0; i < this.layers.length; ++i) {
        var layer = this.layers[i].Scale(scale);
        var style = {};
        style.blurShadow = layer.BlurShadow;
        style.blurShadowX = layer.BlurShadowOffset.x;
        style.blurShadowY = layer.BlurShadowOffset.y;
        style.dropShadowColor = layer.BlurShadowColor.rgbaAsString();
        style.dropShadowDistance = layer.BlurShadowSize;
        style.fillCenter = layer.FillCenter;
        style.fill = layer.FillColor;
        style.stroke = layer.Outline ? layer.OutlineColor.rgbaAsString() : null;
        style.strokeThickness = layer.Outline ? layer.OutlineThickness * (layer.OutlinePosition == LabelLayerOutlinePosition.Center ? 1 : 2) : 0;
        style.mFillUseGradient = layer.FillUseGradient;
        style.mFillGradient =
            layer.FillGradient;
        style.mFillGradientAngle = Math.PI * layer.FillGradientAngle / 180;
        style.mOutlineUseGradient = layer.OutlineUseGradient;
        style.mOutlineGradient = layer.OutlineGradient;
        style.mOutlineGradientAngle = Math.PI * layer.OutlineGradientAngle / 180;
        var xw = style.strokeThickness;
        var xh = style.strokeThickness;
        if (style.blurShadow) {
            xw += Math.max(style.dropShadowDistance * 2 + Math.abs(style.blurShadowX), 0);
            xh += Math.max(style.dropShadowDistance * 2 + Math.abs(style.blurShadowY), 0)
        }
        if (xw > maxXW) {
            maxXW = xw;
            if (layer.Outline) {
                fxPlusLeft =
                    layer.OutlineThickness;
                fxPlusRight = -layer.OutlineThickness
            }
            if (layer.BlurShadow) {
                var extraLeft = Math.max(layer.BlurShadowSize - layer.BlurShadowOffset.x, 0);
                fxPlusLeft += extraLeft;
                fxPlusRight -= Math.max(layer.BlurShadowSize * 2 + Math.abs(layer.BlurShadowOffset.x), 0) - extraLeft
            }
        }
        if (xh > maxXH) {
            maxXH = xh;
            if (layer.Outline) {
                fxPlusTop = layer.OutlineThickness;
                fxPlusBottom = -layer.OutlineThickness
            }
            if (layer.BlurShadow) {
                var extraTop = Math.max(layer.BlurShadowSize - layer.BlurShadowOffset.y, 0);
                fxPlusTop += extraTop;
                fxPlusBottom -=
                    Math.max(layer.BlurShadowSize * 2 + Math.abs(layer.BlurShadowOffset.y), 0) - extraTop
            }
        }
        style.effectWidth = xw;
        style.effectHeight = xh;
        styles.push(style)
    }
    for (var i = 0; i < styles.length; ++i) {
        styles[i].offsetX = this.layers[i].Offset.x * scale + (maxXW - styles[i].effectWidth) * .5;
        styles[i].offsetY = -this.layers[i].Offset.y * scale + (maxXH - styles[i].effectHeight) * .5
    }
    this.styles = styles;
    this.effectWidth = maxXW;
    this.effectHeight = maxXH;
    this.effectPlusLeft = fxPlusLeft;
    this.effectPlusRight = fxPlusRight;
    this.effectPlusTop = fxPlusTop;
    this.effectPlusBottom =
        fxPlusBottom;
    this.isInit = true
};
LabelMultipleLayers.prototype.UpdateText = function() {
    this.ComputeStyles();
    var poc = this.label.pixiObjectContent;
    var style = poc._style;
    poc.context.font = style.font;
    var outputText = style.wordWrap ? poc.wordWrap(poc._text) : poc._text;
    var lines = outputText.split(/(?:\r\n|\r|\n)/);
    var lineWidths = new Array(lines.length);
    var maxLineWidth = 0;
    var fontProperties = poc.determineFontProperties(style.font);
    for (var i = 0; i < lines.length; i++) {
        var lineWidth = poc.context.measureText(lines[i]).width;
        lineWidths[i] = lineWidth;
        maxLineWidth =
            Math.max(maxLineWidth, lineWidth)
    }
    poc.extraWidthDueToEffects = this.effectWidth + fontProperties.fontSize;
    poc.extraHeightDueToEffects = this.effectHeight;
    var width = maxLineWidth + poc.extraWidthDueToEffects;
    poc.canvas.width = width * poc.resolution;
    var lineHeight = poc.style.lineHeight || fontProperties.fontSize;
    var spacingY = poc.style.spacingY || 0;
    var height = lineHeight * lines.length + spacingY * (lines.length - 1) + fontProperties.extraSizeTop;
    height += poc.extraHeightDueToEffects;
    poc.canvas.height = (height + poc._style.padding *
        2) * poc.resolution;
    poc.context.scale(poc.resolution, poc.resolution);
    if (window["safari"] != undefined || document.documentElement.className.indexOf("iOS") >= 0 && document.documentElement.className.indexOf("MobileSafari") >= 0) poc.context.clearRect(0, 0, poc.canvas.width, poc.canvas.height);
    poc.context.font = style.font;
    poc.context.textBaseline = style.textBaseline;
    poc.context.lineJoin = style.lineJoin;
    poc.context.miterLimit = style.miterLimit;
    if (poc._skipUpdateTexture != true)
        for (var i = 0; i < this.styles.length; ++i) this.DrawLayer(this.layers[i],
            this.styles[i], poc, fontProperties, lineWidths, lineHeight, spacingY, lines, maxLineWidth);
    poc._hack_extraOffsetTop = fontProperties.extraSizeTop;
    poc._hack_extraOffsetBottom = spacingY;
    poc.updateTexture()
};
LabelMultipleLayers.prototype.DrawLayer = function(layer, style, poc, fontProperties, lineWidths, lineHeight, spacingY, lines, maxLineWidth) {
    poc.context.strokeStyle = style.stroke;
    poc.context.lineWidth = style.strokeThickness;
    poc.context.shadowColor = "RGBA(0, 0, 0, 0)";
    poc.context.fillStyle = style.fill.rgbaAsString();
    if (style.blurShadow) {
        var needsAdjustment = window["safari"] != undefined || document.documentElement.className.indexOf("iOS") >= 0 && document.documentElement.className.indexOf("MobileSafari") >= 0;
        poc.context.shadowBlur =
            style.dropShadowDistance * (needsAdjustment ? .66 : 1);
        poc.context.shadowOffsetX = style.blurShadowX;
        poc.context.shadowOffsetY = style.blurShadowY
    }
    var linePositionX;
    var linePositionY;
    for (var i = 0; i < lines.length; i++) {
        var strokeThickness = style.strokeThickness * .5;
        linePositionX = style.offsetX + strokeThickness + fontProperties.fontSize * .5;
        linePositionY = style.offsetY + (strokeThickness + i * (lineHeight + spacingY)) + fontProperties.ascent + fontProperties.extraSizeTop;
        if (style.blurShadow) {
            poc.context.shadowColor = style.dropShadowColor;
            linePositionX += Math.max(style.dropShadowDistance - style.blurShadowX, 0);
            linePositionY += Math.max(style.dropShadowDistance - style.blurShadowY, 0)
        }
        if (style.mFillUseGradient || style.mOutlineUseGradient) {
            var H2 = lineHeight * .5;
            var X = linePositionX + lineWidths[i] * .5;
            var Y = style.offsetY + (strokeThickness + i * (lineHeight + spacingY)) + H2 + poc._style.padding;
            if (style.blurShadow) Y += Math.max(style.dropShadowDistance - style.blurShadowY, 0);
            var radius = Math.max(lineWidths[i], lineHeight) * .5;
            var X1 = 0;
            var X2 = 0;
            var Y1 = 0;
            var Y2 = 0;
            if (style.mFillUseGradient) {
                X1 =
                    Math.cos(style.mFillGradientAngle + Math.PI) * radius;
                Y1 = Math.sin(style.mFillGradientAngle + Math.PI) * radius;
                if (Y1 >= 0) Y1 = Math.min(Y1, H2);
                else Y1 = Math.max(Y1, -H2);
                X2 = Math.cos(style.mFillGradientAngle) * radius;
                Y2 = Math.sin(style.mFillGradientAngle) * radius;
                if (Y2 >= 0) Y2 = Math.min(Y2, H2);
                else Y2 = Math.max(Y2, -H2);
                var gradientFill = poc.context.createLinearGradient(X + X1, Y + Y1, X + X2, Y + Y2);
                for (var fgk = 0; fgk < style.mFillGradient.colorKeys.length; fgk++) gradientFill.addColorStop(style.mFillGradient.colorKeys[fgk].time, style.mFillGradient.colorKeys[fgk].color.rgbaAsString());
                poc.context.fillStyle = gradientFill
            }
            if (style.mOutlineUseGradient) {
                X1 = Math.cos(style.mOutlineGradientAngle + Math.PI) * radius;
                Y1 = Math.sin(style.mOutlineGradientAngle + Math.PI) * radius;
                if (Y1 >= 0) Y1 = Math.min(Y1, H2);
                else Y1 = Math.max(Y1, -H2);
                X2 = Math.cos(style.mOutlineGradientAngle) * radius;
                Y2 = Math.sin(style.mOutlineGradientAngle) * radius;
                if (Y2 >= 0) Y2 = Math.min(Y2, H2);
                else Y2 = Math.max(Y2, -H2);
                var gradientOutline = poc.context.createLinearGradient(X + X1, Y + Y1, X + X2, Y + Y2);
                for (var fok = 0; fok < style.mOutlineGradient.colorKeys.length; fok++) gradientOutline.addColorStop(style.mOutlineGradient.colorKeys[fok].time,
                    style.mOutlineGradient.colorKeys[fok].color.rgbaAsString());
                poc.context.strokeStyle = gradientOutline
            }
        }
        if (poc._style.align === "right") linePositionX += maxLineWidth - lineWidths[i];
        else if (poc._style.align === "center") linePositionX += (maxLineWidth - lineWidths[i]) / 2;
        if (style.stroke && style.strokeThickness) {
            if ((style.blurShadow || layer.OutlinePosition == LabelLayerOutlinePosition.Center) && !(style.fillCenter == false)) poc.context.fillText(lines[i], linePositionX, linePositionY + poc._style.padding);
            poc.context.strokeText(lines[i],
                linePositionX, linePositionY + poc._style.padding);
            poc.context.shadowColor = "RGBA(0, 0, 0, 0)"
        }
        if (style.fill && !(style.fillCenter == false) && layer.OutlinePosition != LabelLayerOutlinePosition.Center) poc.context.fillText(lines[i], linePositionX, linePositionY + poc._style.padding)
    }
};
LabelMultipleLayers.prototype.UpdateTextV2 = function() {
    var poc = this.label.pixiObjectContent;
    if (!this.LayersPatternsLoaded()) {
        var skipUpdateTexture = poc._skipUpdateTexture;
        poc._skipUpdateTexture = true;
        this.UpdateText();
        poc._skipUpdateTexture = skipUpdateTexture;
        this.label.textIsUnprocessed = true;
        return
    }
    if (poc._skipUpdateTexture == true) {
        this.UpdateText();
        return
    }
    this.ComputeStyles();
    var style = poc._style;
    poc.context.font = style.font;
    var outputText = style.wordWrap ? poc.wordWrap(poc._text) : poc._text;
    var lines = outputText.split(/(?:\r\n|\r|\n)/);
    var lineWidths = new Array(lines.length);
    var maxLineWidth = 0;
    var fontProperties = poc.determineFontProperties(style.font);
    for (var i = 0; i < lines.length; i++) {
        var lineWidth = poc.context.measureText(lines[i]).width;
        lineWidths[i] = lineWidth;
        maxLineWidth = Math.max(maxLineWidth, lineWidth)
    }
    poc.extraWidthDueToEffects = this.effectWidth + fontProperties.fontSize;
    poc.extraHeightDueToEffects = this.effectHeight;
    var width = maxLineWidth + poc.extraWidthDueToEffects;
    poc.canvas.width = width * poc.resolution;
    var lineHeight = poc.style.lineHeight ||
        fontProperties.fontSize;
    var spacingY = poc.style.spacingY || 0;
    var height = lineHeight * lines.length + spacingY * (lines.length - 1) + fontProperties.extraSizeTop;
    height += poc.extraHeightDueToEffects;
    poc.canvas.height = (height + poc._style.padding * 2) * poc.resolution;
    poc.context.scale(poc.resolution, poc.resolution);
    poc.context.font = style.font;
    poc.context.textBaseline = style.textBaseline;
    poc.context.lineJoin = style.lineJoin;
    poc.context.miterLimit = style.miterLimit;
    if (this.renderSprite == null) this.renderSprite = new PIXI.Sprite(poc.texture);
    var rt = _PIXI.RenderTexture.GetAvailable();
    var rl = _PIXI.Text.GetAvailable();
    var rs = this.renderSprite;
    this.ResetTextures(poc, rt, rl);
    var padding = poc._style.padding;
    for (var i = 0; i < this.styles.length; ++i) {
        var st = this.styles[i];
        var lr = this.layers[i];
        var hasFill = st.fill && !(st.fillCenter == false);
        var hasStroke = st.stroke && st.strokeThickness;
        var strokeFirst = lr.OutlinePosition == LabelLayerOutlinePosition.Outside;
        poc.context.shadowColor = "RGBA(0, 0, 0, 0)";
        if (hasStroke) {
            poc.context.clearRect(0, 0, poc.canvas.width,
                poc.canvas.height);
            this.DrawStroke(lr, st, poc, fontProperties, lineWidths, lineHeight, spacingY, lines, maxLineWidth, rl)
        }
        poc.context.clearRect(0, 0, poc.canvas.width, poc.canvas.height);
        if (hasStroke && strokeFirst) poc.context.drawImage(rl.canvas, 0, 0);
        if (hasFill) this.DrawFill(this.layers[i], st, poc, fontProperties, lineWidths, lineHeight, spacingY, lines, maxLineWidth);
        if (hasStroke && !strokeFirst) poc.context.drawImage(rl.canvas, 0, 0);
        if (hasStroke && lr.OutlinePosition == LabelLayerOutlinePosition.Inside) {
            rl.context.clearRect(0,
                0, poc.canvas.width, poc.canvas.height);
            rl.context.globalCompositeOperation = "source-over";
            rl.context.drawImage(poc.canvas, 0, 0);
            poc.context.clearRect(0, 0, poc.canvas.width, poc.canvas.height);
            this.DrawFillMask(this.layers[i], st, poc, fontProperties, lineWidths, lineHeight, spacingY, lines, maxLineWidth);
            rl.context.globalCompositeOperation = "destination-in";
            rl.context.drawImage(poc.canvas, 0, 0);
            poc.context.clearRect(0, 0, poc.canvas.width, poc.canvas.height);
            poc.context.drawImage(rl.canvas, 0, 0)
        }
        if (st.blurShadow) {
            rl.context.clearRect(0,
                0, poc.canvas.width, poc.canvas.height);
            rl.context.globalCompositeOperation = "source-over";
            rl.context.drawImage(poc.canvas, 0, 0);
            poc.context.shadowColor = st.dropShadowColor;
            poc.context.shadowBlur = st.dropShadowDistance;
            poc.context.shadowOffsetX = st.blurShadowX;
            poc.context.shadowOffsetY = st.blurShadowY;
            poc.context.clearRect(0, 0, poc.canvas.width, poc.canvas.height);
            poc.context.drawImage(rl.canvas, 0, 0)
        }
        poc._style.padding = 0;
        poc.updateTexture();
        poc._style.padding = padding;
        rt.render(rs)
    }
    poc._hack_extraOffsetTop =
        fontProperties.extraSizeTop;
    poc._hack_extraOffsetBottom = spacingY;
    poc.context.shadowColor = "RGBA(0, 0, 0, 0)";
    poc.context.clearRect(0, 0, poc.canvas.width, poc.canvas.height);
    poc.context.drawImage(rt.getCanvas(), 0, 0);
    poc.updateTexture();
    _PIXI.Text.SetAvailable(rl);
    _PIXI.RenderTexture.SetAvailable(rt)
};
LabelMultipleLayers.prototype.DrawFill = function(layer, style, poc, fontProperties, lineWidths, lineHeight, spacingY, lines, maxLineWidth) {
    poc.context.fillStyle = style.fill.rgbaAsString();
    var linePositionX;
    var linePositionY;
    var patternFill = null;
    if (layer.FillUsePattern) patternFill = LabelMultipleLayers.CreatePattern(layer.FillPattern, layer.FillPatternRepeat, poc, this.scale, this.resize);
    for (var i = 0; i < lines.length; i++) {
        var strokeThickness = style.strokeThickness * .5;
        linePositionX = style.offsetX + strokeThickness + fontProperties.fontSize *
            .5;
        linePositionY = style.offsetY + (strokeThickness + i * (lineHeight + spacingY)) + fontProperties.ascent + fontProperties.extraSizeTop;
        if (style.blurShadow) {
            linePositionX += Math.max(style.dropShadowDistance - style.blurShadowX, 0);
            linePositionY += Math.max(style.dropShadowDistance - style.blurShadowY, 0)
        }
        if (style.mFillUseGradient) {
            var H2 = lineHeight * .5;
            var X = linePositionX + lineWidths[i] * .5;
            var Y = style.offsetY + (strokeThickness + i * (lineHeight + spacingY)) + H2 + poc._style.padding;
            if (style.blurShadow) Y += Math.max(style.dropShadowDistance -
                style.blurShadowY, 0);
            var radius = Math.max(lineWidths[i], lineHeight) * .5;
            var X1 = 0;
            var X2 = 0;
            var Y1 = 0;
            var Y2 = 0;
            X1 = Math.cos(style.mFillGradientAngle + Math.PI) * radius;
            Y1 = Math.sin(style.mFillGradientAngle + Math.PI) * radius;
            if (Y1 >= 0) Y1 = Math.min(Y1, H2);
            else Y1 = Math.max(Y1, -H2);
            X2 = Math.cos(style.mFillGradientAngle) * radius;
            Y2 = Math.sin(style.mFillGradientAngle) * radius;
            if (Y2 >= 0) Y2 = Math.min(Y2, H2);
            else Y2 = Math.max(Y2, -H2);
            var gradientFill = poc.context.createLinearGradient(X + X1, Y + Y1, X + X2, Y + Y2);
            for (var fgk = 0; fgk < style.mFillGradient.colorKeys.length; fgk++) gradientFill.addColorStop(style.mFillGradient.colorKeys[fgk].time,
                style.mFillGradient.colorKeys[fgk].color.rgbaAsString());
            poc.context.fillStyle = gradientFill
        }
        if (patternFill != null) poc.context.fillStyle = patternFill;
        if (poc._style.align === "right") linePositionX += maxLineWidth - lineWidths[i];
        else if (poc._style.align === "center") linePositionX += (maxLineWidth - lineWidths[i]) * .5;
        poc.context.fillText(lines[i], linePositionX, linePositionY + poc._style.padding)
    }
};
LabelMultipleLayers.prototype.DrawFillMask = function(layer, style, poc, fontProperties, lineWidths, lineHeight, spacingY, lines, maxLineWidth) {
    var fill = style.fill;
    var fillUG = style.mFillUseGradient;
    var fillUP = layer.FillUsePattern;
    style.fill = _Color.WHITE();
    style.mFillUseGradient = false;
    layer.FillUsePattern = false;
    this.DrawFill(layer, style, poc, fontProperties, lineWidths, lineHeight, spacingY, lines, maxLineWidth);
    style.fill = fill;
    style.mFillUseGradient = fillUG;
    layer.FillUsePattern = fillUP
};
LabelMultipleLayers.prototype.DrawStroke = function(layer, style, poc, fontProperties, lineWidths, lineHeight, spacingY, lines, maxLineWidth, rl) {
    poc.context.strokeStyle = _Color.WHITE().rgbaAsString();
    poc.context.lineWidth = style.strokeThickness;
    rl.context.fillStyle = style.stroke;
    var linePositionX;
    var linePositionY;
    var patternOutline = null;
    if (layer.OutlineUsePattern) patternOutline = LabelMultipleLayers.CreatePattern(layer.OutlinePattern, layer.OutlinePatternRepeat, rl, this.scale, this.resize);
    for (var i = 0; i < lines.length; i++) {
        var strokeThickness =
            style.strokeThickness * .5;
        linePositionX = style.offsetX + strokeThickness + fontProperties.fontSize * .5;
        linePositionY = style.offsetY + (strokeThickness + i * (lineHeight + spacingY)) + fontProperties.ascent + fontProperties.extraSizeTop;
        if (style.blurShadow) {
            linePositionX += Math.max(style.dropShadowDistance - style.blurShadowX, 0);
            linePositionY += Math.max(style.dropShadowDistance - style.blurShadowY, 0)
        }
        if (style.mOutlineUseGradient) {
            var H2 = lineHeight * .5;
            var X = linePositionX + lineWidths[i] * .5;
            var Y = style.offsetY + (strokeThickness +
                i * (lineHeight + spacingY)) + H2 + poc._style.padding;
            if (style.blurShadow) Y += Math.max(style.dropShadowDistance - style.blurShadowY, 0);
            var radius = Math.max(lineWidths[i], lineHeight) * .5;
            var X1 = 0;
            var X2 = 0;
            var Y1 = 0;
            var Y2 = 0;
            X1 = Math.cos(style.mOutlineGradientAngle + Math.PI) * radius;
            Y1 = Math.sin(style.mOutlineGradientAngle + Math.PI) * radius;
            if (Y1 >= 0) Y1 = Math.min(Y1, H2);
            else Y1 = Math.max(Y1, -H2);
            X2 = Math.cos(style.mOutlineGradientAngle) * radius;
            Y2 = Math.sin(style.mOutlineGradientAngle) * radius;
            if (Y2 >= 0) Y2 = Math.min(Y2, H2);
            else Y2 =
                Math.max(Y2, -H2);
            var gradientOutline = poc.context.createLinearGradient(X + X1, Y + Y1, X + X2, Y + Y2);
            for (var fok = 0; fok < style.mOutlineGradient.colorKeys.length; fok++) gradientOutline.addColorStop(style.mOutlineGradient.colorKeys[fok].time, style.mOutlineGradient.colorKeys[fok].color.rgbaAsString());
            rl.context.fillStyle = gradientOutline
        }
        if (patternOutline != null) rl.context.fillStyle = patternOutline;
        if (poc._style.align === "right") linePositionX += maxLineWidth - lineWidths[i];
        else if (poc._style.align === "center") linePositionX +=
            (maxLineWidth - lineWidths[i]) / 2;
        poc.context.strokeText(lines[i], linePositionX, linePositionY + poc._style.padding);
        var rectX = 0;
        var rectY = linePositionY - fontProperties.ascent - strokeThickness;
        var rectW = poc.canvas.width;
        var rectH = lineHeight + style.strokeThickness + poc._style.padding * 2;
        rl.context.globalCompositeOperation = "source-over";
        rl.context.fillRect(rectX, rectY, rectW, rectH);
        rl.context.globalCompositeOperation = "destination-in";
        rl.context.drawImage(poc.canvas, 0, 0)
    }
};
LabelMultipleLayers.prototype.ResetTextures = function(poc, rt, rl) {
    rt.resolution = poc.resolution;
    rt.resize(poc.canvas.width, poc.canvas.height, true);
    rt.clear();
    if (rt["renderer"]["type"] === PIXI.RENDERER_TYPE.WEBGL) {
        var bc = this.backgroundColor;
        var gl = rt["renderer"]["gl"];
        gl.bindFramebuffer(gl.FRAMEBUFFER, rt["textureBuffer"]["frameBuffer"]);
        gl.clearColor(bc.r, bc.g, bc.b, 0);
        gl.clear(gl.COLOR_BUFFER_BIT)
    }
    rl.canvas.width = poc.canvas.width;
    rl.canvas.height = poc.canvas.height;
    rl.context.scale(poc.resolution, poc.resolution);
    this.renderSprite.texture = poc.texture
};
LabelMultipleLayers.PatternCache = function(sprite, repeat, scale, resize, pattern) {
    this.sprite = sprite;
    this.repeat = repeat;
    this.scale = scale;
    this.resize = resize;
    this.pattern = pattern
};
LabelMultipleLayers.patternCache = null;
LabelMultipleLayers.PatternEquals = function(pattern, sprite, repeat, scale, resize) {
    return pattern.sprite == sprite && pattern.repeat == repeat && pattern.scale == scale && pattern.resize == resize
};
LabelMultipleLayers.CreatePattern = function(pattern, repeat, text, scale, resize) {
    if (pattern == null) return null;
    var patternCache = LabelMultipleLayers.patternCache;
    if (patternCache == null) patternCache = LabelMultipleLayers.patternCache = [];
    for (var i = 0; i < patternCache.length; ++i)
        if (LabelMultipleLayers.PatternEquals(patternCache[i], pattern, repeat, scale, resize)) return patternCache[i].pattern;
    var po = pattern.pixiObject;
    var poc = pattern.pixiObjectContent;
    if (po == null || poc == null) return null;
    po.scale.x = 1;
    po.scale.y = 1;
    po.dirtyWT =
        true;
    var s = (scale + (1 - scale) * .25) * resize;
    var w0 = poc.width;
    var h0 = poc.height;
    var w1 = Math.round(w0 * s);
    var h1 = Math.round(h0 * s);
    poc.width = w1;
    poc.height = h1;
    poc.anchor.x = 0;
    poc.anchor.y = 0;
    poc.position.x = -1;
    poc.position.y = -1;
    poc.dirtyWT = true;
    var rt = _PIXI.RenderTexture.GetAvailable();
    rt.clear();
    rt.resolution = text.resolution;
    rt.resize(poc.width - 2, poc.height - 2, true);
    rt.render(po);
    poc.width = w0;
    poc.height = h0;
    var ret = text.context.createPattern(rt.getCanvas(), LabelLayerPatternRepeatString[repeat]);
    _PIXI.RenderTexture.SetAvailable(rt);
    var cache = new LabelMultipleLayers.PatternCache(pattern, repeat, scale, resize, ret);
    patternCache.push(cache);
    return ret
};
LabelMultipleLayers.prototype.LayersPatternsLoaded = function() {
    for (var i = 0; i < this.layers.length; ++i)
        if (!this.LayerPatternsLoaded(this.layers[i])) return false;
    return true
};
LabelMultipleLayers.prototype.LayerPatternsLoaded = function(layer) {
    return this.PatternLoaded(layer.FillUsePattern, layer.FillPattern) && this.PatternLoaded(layer.OutlineUsePattern, layer.OutlinePattern)
};
LabelMultipleLayers.prototype.PatternLoaded = function(use, pattern) {
    if (use && pattern != null && pattern.atlas != null) return pattern.atlas.isLoaded();
    return true
};
SpringPosition.prototype = Object.create(Component.prototype);
SpringPosition.prototype.constructor = SpringPosition;

function SpringPosition() {
    Component.call(this);
    this.target = null;
    this.strength = 10;
    this.worldSpace = false;
    this.eventReceiver = null;
    this.callWhenFinished = "";
    this.mTrans = null;
    this.mThreshold = 0
}
SpringPosition.prototype.deserialize = function(source, helper, resolveReference) {
    deserializeComponentRec(source, this, helper, resolveReference);
    return
};
SpringPosition.prototype.Start = function() {
    this.mTrans = this.gameObject.transform
};
SpringPosition.prototype.Update = function() {
    if (!this.enabled) return;
    var delta = Time.deltaTime;
    if (this.worldSpace) {
        if (this.mThreshold == 0) this.mThreshold = UHTMath.Vector3.sub(this.target, this.mTrans.position()).sqrMagnitude() * .001;
        var spLerp = SpringPosition.SpringLerp(this.mTrans.position(), this.target, this.strength, delta);
        this.mTrans.position(spLerp.x, spLerp.y, spLerp.z);
        if (this.mThreshold >= UHTMath.Vector3.sub(this.target, this.mTrans.position()).sqrMagnitude()) {
            this.mTrans.position(this.target.x, this.target.y,
                this.target.z);
            this.NotifyListeners();
            this.enabled = false
        }
    } else {
        if (this.mThreshold == 0) this.mThreshold = UHTMath.Vector3.sub(this.target, this.mTrans.localPosition()).sqrMagnitude() * 1E-5;
        var spLerpLocal = SpringPosition.SpringLerp(this.mTrans.localPosition(), this.target, this.strength, delta);
        this.mTrans.localPosition(spLerpLocal.x, spLerpLocal.y, spLerpLocal.z);
        if (this.mThreshold >= UHTMath.Vector3.sub(this.target, this.mTrans.localPosition()).sqrMagnitude()) {
            this.mTrans.localPosition(this.target.x, this.target.y,
                this.target.z);
            this.NotifyListeners();
            this.enabled = false
        }
    }
};
SpringPosition.prototype.NotifyListeners = function() {
    SpringPosition.current = this;
    if (this.eventReceiver != null && this.callWhenFinished != null && this.callWhenFinished != "") this.eventReceiver[this.callWhenFinished]();
    SpringPosition.current = null
};
SpringPosition.Begin = function(go, pos, strength) {
    var sp = go.GetComponent(SpringPosition);
    if (sp == null) sp = go.AddComponent("SpringPosition");
    sp.target = pos;
    sp.strength = strength;
    if (!sp.enabled) {
        sp.mThreshold = 0;
        sp.enabled = true
    }
    return sp
};
SpringPosition.current = null;
SpringPosition.SpringLerp = function(from, to, strength, deltaTime) {
    if (deltaTime > 1) deltaTime = 1;
    var ms = Math.round(deltaTime * 1E3);
    deltaTime = .001 * strength;
    var cumulative = 0;
    for (var i = 0; i < ms; ++i) cumulative = UHTMath.lerp(cumulative, 1, deltaTime);
    return UHTMath.Vector3.lerp(from, to, cumulative)
};
goog.provide("UHT.UIAtlas");
goog.require("UHT.Component");
var AtlasUsageID = 0;
UIAtlas.prototype = Object.create(Component.prototype);
UIAtlas.prototype.constructor = UIAtlas;

function UIAtlas() {
    Component.call(this);
    this.textureContent = null;
    this.spriteList = {};
    this.resourcePriority = 0;
    this.isBlockingResource = true;
    this.fallbackAtlas = null;
    this.fallbackSpriteName = "";
    this.hasLowEndResource = false;
    this.lowEndAtlas = null;
    this.lowEndSpriteName = "";
    this.pixiTexture = null;
    this.isInit = false;
    this.cachedSimpleSpriteInfo = {};
    this.cachedSlicedSpriteInfo = {};
    this.cachedFilledSpriteInfo = {};
    this.cachedSpriteNames = {};
    this.cachedSprites = {};
    this.isDeferred = false;
    this.usesLowEndResource = false;
    this.spritesNeedingRefresh = [];
    this.PPLCAwidth = 0;
    this.PPLCAheight = 0;
    this.resize = 100;
    this.blendMode = 0;
    this.requested = false;
    this.texPPLCA_Color = "";
    this.texPPLCA_Alpha = "";
    this.pixiTexPPLCA_Color = null;
    this.pixiTexPPLCA_Alpha = null;
    this.PPLCAStep = 0;
    this.usageID = "a" + AtlasUsageID;
    AtlasUsageID++
}
UIAtlas.spriteListPrefix = "s_";
UIAtlas.prototype.deserialize = function(source, helper, resolveReference) {
    for (var spriteP in source["spriteList"]) {
        if (source["spriteList"][spriteP]["index"] == undefined) source["spriteList"][spriteP]["index"] = -1;
        if (source["spriteList"][spriteP]["rotate"] == undefined) source["spriteList"][spriteP]["rotate"] = false;
        else source["spriteList"][spriteP]["rotate"] = true;
        if (source["spriteList"][spriteP]["x"] == undefined) source["spriteList"][spriteP]["x"] = 0;
        if (source["spriteList"][spriteP]["y"] == undefined) source["spriteList"][spriteP]["y"] =
            0;
        if (source["spriteList"][spriteP]["paddingLeft"] == undefined) source["spriteList"][spriteP]["paddingLeft"] = 0;
        if (source["spriteList"][spriteP]["paddingTop"] == undefined) source["spriteList"][spriteP]["paddingTop"] = 0;
        if (source["spriteList"][spriteP]["paddingRight"] == undefined) source["spriteList"][spriteP]["paddingRight"] = 0;
        if (source["spriteList"][spriteP]["paddingBottom"] == undefined) source["spriteList"][spriteP]["paddingBottom"] = 0;
        if (source["spriteList"][spriteP]["borderLeft"] == undefined) source["spriteList"][spriteP]["borderLeft"] =
            0;
        if (source["spriteList"][spriteP]["borderTop"] == undefined) source["spriteList"][spriteP]["borderTop"] = 0;
        if (source["spriteList"][spriteP]["borderRight"] == undefined) source["spriteList"][spriteP]["borderRight"] = 0;
        if (source["spriteList"][spriteP]["borderBottom"] == undefined) source["spriteList"][spriteP]["borderBottom"] = 0
    }
    if (source["resourcePriority"] == undefined) source["resourcePriority"] = 0;
    if (source["isBlockingResource"] == undefined) source["isBlockingResource"] = true;
    else source["isBlockingResource"] = false;
    if (source["fallbackAtlas"] == undefined) source["fallbackAtlas"] = null;
    if (source["fallbackSpriteName"] == undefined) source["fallbackSpriteName"] = "";
    if (source["hasLowEndResource"] == undefined) source["hasLowEndResource"] = false;
    else source["hasLowEndResource"] = true;
    if (source["lowEndAtlas"] == undefined) source["lowEndAtlas"] = null;
    if (source["lowEndSpriteName"] == undefined) source["lowEndSpriteName"] = "";
    if (source["resize"] == undefined) source["resize"] = 100;
    if (source["blendMode"] == undefined) source["blendMode"] = 0;
    deserializeComponentRec(source,
        this, helper, resolveReference);
    this.usesLowEndResource = UHT_LOW_END_DEVICE && this.hasLowEndResource;
    if (this.resourcePriority > 0 && !this.usesLowEndResource) registerAtlasForDeferredLoading(this);
    else {
        deserializedAtlases.push(this);
        if (LoaderProgress.Import_Textures_Total != -1) {
            LoaderProgress.Import_Textures_Current++;
            console.log("TEX loaded for: " + this.gameObject.name + " " + LoaderProgress.Import_Textures_Current)
        }
    }
    for (var sprite in this.spriteList) {
        this.cachedSpriteNames[sprite.replace("s_", "")] = sprite;
        this.cachedSprites[sprite.replace("s_",
            "")] = this.spriteList[sprite]
    }
};
UIAtlas.prototype.loadAtlasTexture = function() {
    AtlasUsage[this.usageID] = {
        frame: 0,
        atlas: this,
        allocated: false
    };
    if (this.pixiTexture == null) {
        if (this.textureContent.slice(0, 10) != "data:image") this.textureContent += "?key=" + UHT_REVISION.uncommon;
        this.pixiTexture = PIXI.Texture.fromImage(this.textureContent, undefined, undefined, this["textureContent_@GUID"]);
        if (createjs.BrowserDetect.isIOS && Renderer.IsWebGL) this.pixiTexture.baseTexture.dispose();
        this.textureContent = ""
    }
};
var AtlasUsage = {};
UIAtlas.prototype.UseNow = function() {
    var a = AtlasUsage[this.usageID];
    if (a != undefined) {
        a.allocated = true;
        a.frame = Time.frameCount
    }
};
UIAtlas.CheckUsageAndClean = function() {
    if (!(createjs.BrowserDetect.isIOS && Renderer.IsWebGL)) return;
    for (var i in AtlasUsage) {
        var a = AtlasUsage[i];
        if (a.allocated)
            if (a.frame < Time.frameCount - 200) a.atlas.pixiTexture.baseTexture.dispose()
    }
};
UIAtlas.prototype.initAtlas = function() {
    if (!this.isInit) {
        this.isInit = true;
        if (this.usesLowEndResource) return;
        if (this.resourcePriority > 0 && this.isLoaded() == false)
            if (this.isBlockingResource) {
                this.loadAtlasTexture();
                signalNeedPauseForTexture(this)
            } else this.isDeferred = true;
        else this.loadAtlasTexture()
    }
};
UIAtlas.prototype.isLoaded = function() {
    return this.pixiTexture != null && this.pixiTexture.valid
};
UIAtlas.prototype.internalTextureLoadedCallback = function() {
    if (this.isDeferred) {
        this.isDeferred = false;
        for (var i = 0; i < this.spritesNeedingRefresh.length; i++) {
            var s = this.spritesNeedingRefresh[i];
            if (s != null) s.SetSpriteName(s.spriteName)
        }
        this.spritesNeedingRefresh = []
    }
};
UIAtlas.prototype.hasSprite = function(spriteName) {
    var data = this.cachedSprites[spriteName];
    return data != undefined
};
UIAtlas.prototype.getSpriteNames = function() {
    var ret = [];
    for (var n in this.spriteList) {
        var t = n.slice(UIAtlas.spriteListPrefix.length, n.length);
        ret.push(t)
    }
    return ret
};
UIAtlas.prototype.getTextureInfoForSprite = function(sprite, spriteName) {
    this.initAtlas();
    if (this.usesLowEndResource)
        if (this.lowEndAtlas != null) return this.lowEndAtlas.getTextureInfoForSprite(sprite, this.lowEndSpriteName);
        else return new PIXI.Texture(new PIXI.BaseTexture);
    if (this.isDeferred) {
        this.spritesNeedingRefresh.push(sprite);
        if (this.fallbackAtlas != null) return this.fallbackAtlas.getTextureInfoForSprite(sprite, this.fallbackSpriteName);
        else return new PIXI.Texture(new PIXI.BaseTexture)
    }
    switch (sprite.spriteType) {
        case UISprite.Type.Simple:
            return this.getTextureForSimpleSprite(sprite,
                spriteName);
            break;
        case UISprite.Type.Filled:
            return this.getTextureForFilledSprite(sprite, spriteName);
            break;
        case UISprite.Type.Sliced:
            return this.getTexturesForSlicedSprite(sprite, spriteName);
            break;
        default:
            break
    }
};
UIAtlas.prototype.getTextureForSimpleSprite = function(sprite, spriteName) {
    if (this.cachedSimpleSpriteInfo[this.cachedSpriteNames[spriteName]] != undefined) return this.cachedSimpleSpriteInfo[this.cachedSpriteNames[spriteName]];
    var data = this.cachedSprites[spriteName];
    if (data == undefined) {
        console.error("Invalid sprite name: " + spriteName);
        return null
    }
    var rectFrame = new PIXI.Rectangle(data.x, data.y, data.width, data.height);
    var rectCrop = new PIXI.Rectangle(data.x, data.y, data.width, data.height);
    var rectTrim = new PIXI.Rectangle(data.paddingLeft,
        data.paddingTop, data.width + data.paddingLeft + data.paddingRight, data.height + data.paddingTop + data.paddingBottom);
    var ret = new PIXI.Texture(this.pixiTexture, rectFrame, rectCrop, rectTrim);
    this.cachedSimpleSpriteInfo[this.cachedSpriteNames[spriteName]] = ret;
    return ret
};
UIAtlas.prototype.getTextureForFilledSprite = function(sprite, spriteName) {
    var cacheKey = UIAtlas.spriteListPrefix + spriteName + sprite.fillDirection + sprite.invert + sprite.fillAmount + sprite.fillAmountTop + sprite.fillAmountBottom + sprite.fillAmountLeft + sprite.fillAmountRight;
    if (this.cachedFilledSpriteInfo[cacheKey] != undefined) return this.cachedFilledSpriteInfo[cacheKey];
    var data = this.cachedSprites[spriteName];
    if (data == undefined) {
        console.error("Invalid sprite name: " + spriteName);
        return null
    }
    var pL = data.paddingLeft;
    var pR = data.paddingRight;
    var pT = data.paddingTop;
    var pB = data.paddingBottom;
    var posX = data.x;
    var posY = data.y;
    var width = data.width;
    var height = data.height;
    var fullHeight = height + pT + pB;
    var fullWidth = width + pL + pR;
    var newFill = sprite.fillAmount;
    var fillTop = 0;
    var fillBottom = 0;
    var fillLeft = 0;
    var fillRight = 0;
    switch (sprite.fillDirection) {
        case UISprite.FillDirection.Horizontal:
            newFill = (sprite.fillAmount * fullWidth - (sprite.invert ? pR : pL)) / width;
            if (sprite.invert) {
                posX += width * (1 - newFill);
                pL += width * (1 - newFill)
            } else pR +=
                width * (1 - newFill);
            width *= newFill;
            break;
        case UISprite.FillDirection.Vertical:
            newFill = (sprite.fillAmount * fullHeight - (sprite.invert ? pT : pB)) / height;
            if (sprite.invert) pB += height * (1 - newFill);
            else {
                posY += height * (1 - newFill);
                pT += height * (1 - newFill)
            }
            height *= newFill;
            break;
        case UISprite.FillDirection.Custom:
            fillTop = (sprite.fillAmountTop * fullHeight - pB) / height;
            fillBottom = (sprite.fillAmountBottom * fullHeight - pT) / height;
            fillLeft = (sprite.fillAmountLeft * fullWidth - pR) / width;
            fillRight = (sprite.fillAmountRight * fullWidth - pL) /
                width;
            posY += height * (1 - fillTop);
            pT += height * (1 - fillTop);
            pB += height * (1 - fillBottom);
            height *= fillTop + fillBottom - 1;
            posX += width * (1 - fillLeft);
            pL += width * (1 - fillLeft);
            pR += width * (1 - fillRight);
            width *= fillLeft + fillRight - 1;
            var offsetL = 0;
            var offsetR = 0;
            var offsetT = 0;
            var offsetB = 0;
            if (posX < data.x) {
                offsetL = data.x - posX;
                posX = data.x;
                width -= offsetL
            }
            if (posY < data.y) {
                offsetT = data.y - posY;
                posY = data.y;
                height -= offsetT
            }
            if (width > data.width) {
                offsetR = width - data.width;
                width = data.width
            }
            if (height > data.height) {
                offsetB = height - data.height;
                height = data.height
            }
            pL += offsetL;
            pB += offsetB;
            pR += offsetR;
            pT += offsetT;
            break;
        default:
            console.error("this type of filled sprite is not supported! ", sprite.fillDirection, " For sprite: ", sprite.spriteName);
            break
    }
    var rectFrame = new PIXI.Rectangle(posX, posY, width, height);
    var rectCrop = new PIXI.Rectangle(posX, posY, width, height);
    var rectTrim = new PIXI.Rectangle(pL, pT, width + pL + pR, height + pT + pB);
    var ret = new PIXI.Texture(this.pixiTexture, rectFrame, rectCrop, rectTrim);
    this.cachedFilledSpriteInfo[cacheKey] = ret;
    return ret
};
UIAtlas.prototype.getTexturesForSlicedSprite = function(sprite, spriteName) {
    if (this.cachedSlicedSpriteInfo[this.cachedSpriteNames[spriteName]] != undefined) return this.cachedSlicedSpriteInfo[this.cachedSpriteNames[spriteName]];
    var data = this.cachedSprites[spriteName];
    if (data == undefined) {
        console.error("Invalid sprite name: " + spriteName);
        return null
    }
    var rectFrame = new PIXI.Rectangle(data.x, data.y, data.width, data.height);
    var rectCrop = new PIXI.Rectangle(data.x, data.y, data.width, data.height);
    var rectTrim = new PIXI.Rectangle(data.paddingLeft,
        data.paddingTop, data.width + data.paddingLeft + data.paddingRight, data.height + data.paddingTop + data.paddingBottom);
    var rectFrame00 = rectFrame.clone();
    var rectTrim00 = rectTrim.clone();
    var rectFrame01 = rectFrame.clone();
    var rectTrim01 = rectTrim.clone();
    var rectFrame02 = rectFrame.clone();
    var rectTrim02 = rectTrim.clone();
    var rectFrame10 = rectFrame.clone();
    var rectTrim10 = rectTrim.clone();
    var rectFrame11 = rectFrame.clone();
    var rectTrim11 = rectTrim.clone();
    var rectFrame12 = rectFrame.clone();
    var rectTrim12 = rectTrim.clone();
    var rectFrame20 = rectFrame.clone();
    var rectTrim20 = rectTrim.clone();
    var rectFrame21 = rectFrame.clone();
    var rectTrim21 = rectTrim.clone();
    var rectFrame22 = rectFrame.clone();
    var rectTrim22 = rectTrim.clone();
    var bL = data.borderLeft;
    var bR = data.borderRight;
    var bT = data.borderTop;
    var bB = data.borderBottom;
    var pL = data.paddingLeft;
    var pR = data.paddingRight;
    var pB = data.paddingBottom;
    var pT = data.paddingTop;
    var w = data.width;
    var h = data.height;
    rectFrame00.width = bL;
    rectFrame00.height = bT;
    rectTrim00.width = bL + pL;
    rectTrim00.height =
        bT + pT;
    var rectCrop00 = rectFrame00.clone();
    var tex00 = new PIXI.Texture(this.pixiTexture, rectFrame00, rectCrop00, rectTrim00);
    rectFrame01.x += bL;
    rectFrame01.width = w - bL - bR || 1;
    rectFrame01.height = bT;
    rectTrim01.x = 0;
    rectTrim01.width = w - bL - bR || 1;
    rectTrim01.height = bT + pT;
    var rectCrop01 = rectFrame01.clone();
    var tex01 = new PIXI.Texture(this.pixiTexture, rectFrame01, rectCrop01, rectTrim01);
    rectFrame02.x += w - bR;
    rectFrame02.width = bR;
    rectFrame02.height = bT;
    rectTrim02.x = 0;
    rectTrim02.width = bR + pR;
    rectTrim02.height = bT + pT;
    var rectCrop02 =
        rectFrame02.clone();
    var tex02 = new PIXI.Texture(this.pixiTexture, rectFrame02, rectCrop02, rectTrim02);
    rectFrame10.y += bT;
    rectFrame10.width = bL;
    rectFrame10.height = h - bT - bB || 1;
    rectTrim10.y = 0;
    rectTrim10.width = bL + pL;
    rectTrim10.height = h - bT - bB || 1;
    var rectCrop10 = rectFrame10.clone();
    var tex10 = new PIXI.Texture(this.pixiTexture, rectFrame10, rectCrop10, rectTrim10);
    rectFrame11.x += bL;
    rectFrame11.y += bT;
    rectFrame11.width = w - bL - bR || 1;
    rectFrame11.height = h - bT - bB || 1;
    rectTrim11.x = 0;
    rectTrim11.y = 0;
    rectTrim11.width = w - bL - bR || 1;
    rectTrim11.height = h - bT - bB || 1;
    var rectCrop11 = rectFrame11.clone();
    var tex11 = new PIXI.Texture(this.pixiTexture, rectFrame11, rectCrop11, rectTrim11);
    rectFrame12.x += w - bR;
    rectFrame12.y += bT;
    rectFrame12.width = bR;
    rectFrame12.height = h - bT - bB || 1;
    rectTrim12.x = 0;
    rectTrim12.y = 0;
    rectTrim12.width = bR + pR;
    rectTrim12.height = h - bT - bB || 1;
    var rectCrop12 = rectFrame12.clone();
    var tex12 = new PIXI.Texture(this.pixiTexture, rectFrame12, rectCrop12, rectTrim12);
    rectFrame20.y += h - bB;
    rectFrame20.width = bL;
    rectFrame20.height = bB;
    rectTrim20.y =
        0;
    rectTrim20.width = bL + pL;
    rectTrim20.height = bB + pB;
    var rectCrop20 = rectFrame20.clone();
    var tex20 = new PIXI.Texture(this.pixiTexture, rectFrame20, rectCrop20, rectTrim20);
    rectFrame21.x += bL;
    rectFrame21.y += h - bB;
    rectFrame21.width = w - bL - bR || 1;
    rectFrame21.height = bB;
    rectTrim21.x = 0;
    rectTrim21.y = 0;
    rectTrim21.width = w - bL - bR || 1;
    rectTrim21.height = bB + pB;
    var rectCrop21 = rectFrame21.clone();
    var tex21 = new PIXI.Texture(this.pixiTexture, rectFrame21, rectCrop21, rectTrim21);
    rectFrame22.x += w - bR;
    rectFrame22.y += h - bB;
    rectFrame22.width =
        bR;
    rectFrame22.height = bB;
    rectTrim22.x = 0;
    rectTrim22.y = 0;
    rectTrim22.width = bR + pR;
    rectTrim22.height = bB + pB;
    var rectCrop22 = rectFrame22.clone();
    var tex22 = new PIXI.Texture(this.pixiTexture, rectFrame22, rectCrop22, rectTrim22);
    var ret = {
        texture00: tex00,
        texture01: tex01,
        texture02: tex02,
        texture10: tex10,
        texture11: tex11,
        texture12: tex12,
        texture20: tex20,
        texture21: tex21,
        texture22: tex22,
        borderLeft: data.borderLeft,
        borderRight: data.borderRight,
        borderBottom: data.borderBottom,
        borderTop: data.borderTop,
        paddingLeft: data.paddingLeft,
        paddingRight: data.paddingRight,
        paddingBottom: data.paddingBottom,
        paddingTop: data.paddingTop
    };
    this.cachedSlicedSpriteInfo[this.cachedSpriteNames[spriteName]] = ret;
    return ret
};
PPLCAFilter.prototype = Object.create(PIXI.AbstractFilter.prototype);
PPLCAFilter.prototype.constructor = PPLCAFilter;

function PPLCAFilter(alphaTexture) {
    PIXI.AbstractFilter.call(this, null, "precision mediump float;" + "varying vec2 vTextureCoord;" + "uniform sampler2D uSampler;" + "uniform sampler2D AlphaMap;" + "void main(void)" + "{" + "vec3 col = texture2D(uSampler, vTextureCoord).rgb;" + "float alpha = texture2D(AlphaMap, vTextureCoord).r;" + "gl_FragColor = vec4(col * alpha, alpha);" + "} ", {
        AlphaMap: {
            type: "sampler2D",
            value: alphaTexture
        }
    })
}
goog.provide("UHT.UIButton");
goog.require("UHT.Component");
UIButton.prototype = Object.create(Component.prototype);
UIButton.prototype.constructor = UIButton;

function UIButton() {
    Component.call(this);
    this.target = null;
    this.targetIsSprite = false;
    this.normal = "";
    this.hover = "";
    this.pressed = "";
    this.disabled = "";
    this.color_normal = null;
    this.color_hover = null;
    this.color_pressed = null;
    this.color_disabled = null;
    this.onClick = [];
    this.curState = UIButton.State.None
}
UIButton.State = {
    Normal: 0,
    Hover: 1,
    Pressed: 2,
    Disabled: 3,
    None: 4
};

function UIEventDelegate() {
    this.target = null;
    this.methodName = ""
}
UIButton.prototype.OnHover = function(isHovered) {
    if (this.target == null) return;
    if (this.gameObject.collider != null && this.gameObject.collider.enabled) this.InternalChangeState(isHovered ? UIButton.State.Hover : UIButton.State.Normal);
    else this.InternalChangeState(UIButton.State.Disabled)
};
UIButton.prototype.OnPress = function(isPressed) {
    if (this.target == null) return;
    this.InternalChangeState(isPressed ? UIButton.State.Pressed : UIButton.State.Normal)
};
UIButton.prototype.OnClick = function() {
    for (var i = 0; i < this.onClick.length; i++) {
        var cur = this.onClick[i];
        if (cur.target != null) cur.target[cur.methodName]()
    }
};
UIButton.prototype.SetEnabled = function(isEnabled) {
    if (this.gameObject.collider != null) {
        this.gameObject.collider.enabled = isEnabled;
        this.InternalChangeState(isEnabled ? UIButton.State.Normal : UIButton.State.Disabled)
    }
};
UIButton.prototype.OnDisable = function() {
    var b = this.gameObject.collider != null && this.gameObject.collider.enabled;
    this.InternalChangeState(b ? UIButton.State.Normal : UIButton.State.Disabled)
};
UIButton.prototype.InternalChangeState = function(newState) {
    if (this.target == null) return;
    switch (newState) {
        case UIButton.State.Normal:
            if (this.targetIsSprite) {
                this.target.SetSpriteName(this.normal);
                this.target.color = this.color_normal
            } else this.target.SetColor(this.color_normal);
            break;
        case UIButton.State.Hover:
            if (this.targetIsSprite) {
                this.target.SetSpriteName(this.hover != "" ? this.hover : this.normal);
                this.target.color = this.color_hover
            } else this.target.SetColor(this.color_hover);
            break;
        case UIButton.State.Pressed:
            if (this.targetIsSprite) {
                this.target.SetSpriteName(this.pressed !=
                    "" ? this.pressed : this.normal);
                this.target.color = this.color_pressed
            } else this.target.SetColor(this.color_pressed);
            break;
        case UIButton.State.Disabled:
            if (this.targetIsSprite) {
                this.target.SetSpriteName(this.disabled != "" ? this.disabled : this.normal);
                this.target.color = this.color_disabled
            } else this.target.SetColor(this.color_disabled);
            break
    }
    this.curState = newState
};
goog.provide("UHT.UIButtonScale");
goog.require("UHT.Component");
UIButtonScale.prototype = Object.create(Component.prototype);
UIButtonScale.prototype.constructor = UIButtonScale;

function UIButtonScale() {
    Component.call(this);
    this.tweenTarget = null;
    this.hover = null;
    this.pressed = null;
    this.normalScale = null;
    this.mStarted = false
}
UIButtonScale.State = {
    Normal: 0,
    Hover: 1,
    Pressed: 2
};
UIButtonScale.prototype.Start = function() {
    if (!this.mStarted) {
        this.mStarted = true;
        if (this.tweenTarget == null) this.tweenTarget = this.gameObject.transform;
        this.normalScale = new UHTMath.Vector3(this.tweenTarget.localScale());
        this.hover = new UHTMath.Vector3(this.hover.x * this.normalScale.x, this.hover.y * this.normalScale.y, this.hover.z * this.normalScale.z);
        this.pressed = new UHTMath.Vector3(this.pressed.x * this.normalScale.x, this.pressed.y * this.normalScale.y, this.pressed.z * this.normalScale.z)
    }
};
UIButtonScale.prototype.OnEnable = function() {
    if (this.mStarted) this.InternalChangeState(UIButton.State.Normal)
};
UIButtonScale.prototype.OnDisable = function() {
    if (this.mStarted && this.tweenTarget != null) this.InternalChangeState(UIButton.State.Normal)
};
UIButtonScale.prototype.OnPress = function(isPressed) {
    if (this.enabled) {
        if (!this.mStarted) this.Start();
        this.InternalChangeState(isPressed ? UIButton.State.Pressed : UIButton.State.Normal)
    }
};
UIButtonScale.prototype.OnHover = function(isOver) {
    if (this.enabled) {
        if (!this.mStarted) this.Start();
        this.InternalChangeState(isOver ? UIButton.State.Hover : UIButton.State.Normal)
    }
};
UIButtonScale.prototype.InternalChangeState = function(newState) {
    if (this.tweenTarget == null) return;
    switch (newState) {
        case UIButtonScale.State.Normal:
            this.tweenTarget.localScale(this.normalScale);
            break;
        case UIButtonScale.State.Hover:
            this.tweenTarget.localScale(this.hover);
            break;
        case UIButtonScale.State.Pressed:
            this.tweenTarget.localScale(this.pressed);
            break;
        default:
            this.tweenTarget.localScale(this.normalScale)
    }
};
goog.provide("UHT.UIFont");
goog.require("UHT.Component");
UIFont.prototype = Object.create(Component.prototype);
UIFont.prototype.constructor = UIFont;

function UIFont() {
    Component.call(this);
    this.fontData = "";
    this.hasFontLoaded = false;
    this.texture = "";
    this.name = "";
    this.isLoading = false;
    this.callback = [];
    this.object = [];
    this.chars = ""
}
UIFont.prototype.deserialize = function(source, helper, resolveReference) {
    deserializeComponentRec(source, this, helper, resolveReference);
    this.SetBitmapFontName();
    this.LoadFont()
};
UIFont.prototype.SetBitmapFontName = function() {
    var startIndex = this.fontData.search("face=") + 6;
    var endIndex = this.fontData.search("size=") - 2;
    this.name = this.fontData.substring(startIndex, endIndex)
};
UIFont.prototype.AfterLoad = function() {
    if (this.callback.length > 0)
        for (var i = 0; i < this.callback.length; i++) this.callback[i].call(this.object[i]);
    this.hasFontLoaded = true
};
UIFont.prototype.LoadFont = function() {
    this.isLoading = true;
    var tex = PIXI.Texture.fromImage(this.texture, undefined, undefined, this["texture_@GUID"]);
    this.texture = "";
    var parser = new DOMParser;
    var xmlDoc = parser.parseFromString(this.fontData, "text/xml");
    var charXmlElements = xmlDoc.getElementsByTagName("char");
    this.chars = "";
    for (var i = 0; i < charXmlElements.length; i++) this.chars += String.fromCharCode(charXmlElements[i].id);
    PIXI.extras.BitmapText.parse(xmlDoc, tex);
    this.AfterLoad()
};
goog.provide("UHT.UIInput");
goog.require("UHT.Component");
UIInput.prototype = Object.create(Component.prototype);
UIInput.prototype.constructor = UIInput;

function UIInput() {
    Component.call(this);
    this.label = null;
    this.value = "";
    this.activeTextColor = null;
    this.inactiveTextColor = null;
    this.caretColor = null;
    this.validation = UIInput.Validation.None;
    this.characterLimit = 0;
    this.caretGameObject = null;
    this.clearValueOnSelect = false;
    this.linkedUIInput = null;
    this.localizedDefaultValueLabel = null;
    this.mobilePromptMessage = null;
    this.userCanceledInput = null;
    this.onChange = [];
    this.caretCachedPosition = new UHTMath.Vector3(0, 0, 0);
    this.keysPressed = [];
    this.isSelected = false;
    this.TextExtraHandler =
        null
}
UIInput.Validation = {
    None: 0,
    Integer: 1,
    Float: 2,
    Alphanumeric: 3,
    Username: 4,
    Name: 5
};
UIInput.curSelectedUIInput = null;
UIInput.prototype.Start = function() {
    this.SetValue(this.value);
    this.label.SetColor(this.activeTextColor);
    this.caretCachedPosition = this.caretGameObject.transform.localPosition()
};
UIInput.prototype.OnDisable = function() {
    this.Select(false)
};
UIInput.prototype.OnClick = function() {
    this.Select(true);
    if (Globals.isMobile)
        if (this.mobilePromptMessage != null) {
            var text = prompt(this.mobilePromptMessage.text);
            if (text == null) this.userCanceledInput.Start();
            else {
                this.Insert(text);
                this.Select(false)
            }
        }
};
UIInput.prototype.Update = function() {
    if (!this.isSelected) return;
    if (Input.GetKeyDown(KeyCode.Alpha0) || Input.GetKeyDown(KeyCode.Keypad0)) this.Insert("0");
    if (Input.GetKeyDown(KeyCode.Alpha1) || Input.GetKeyDown(KeyCode.Keypad1)) this.Insert("1");
    if (Input.GetKeyDown(KeyCode.Alpha2) || Input.GetKeyDown(KeyCode.Keypad2)) this.Insert("2");
    if (Input.GetKeyDown(KeyCode.Alpha3) || Input.GetKeyDown(KeyCode.Keypad3)) this.Insert("3");
    if (Input.GetKeyDown(KeyCode.Alpha4) || Input.GetKeyDown(KeyCode.Keypad4)) this.Insert("4");
    if (Input.GetKeyDown(KeyCode.Alpha5) || Input.GetKeyDown(KeyCode.Keypad5)) this.Insert("5");
    if (Input.GetKeyDown(KeyCode.Alpha6) || Input.GetKeyDown(KeyCode.Keypad6)) this.Insert("6");
    if (Input.GetKeyDown(KeyCode.Alpha7) || Input.GetKeyDown(KeyCode.Keypad7)) this.Insert("7");
    if (Input.GetKeyDown(KeyCode.Alpha8) || Input.GetKeyDown(KeyCode.Keypad8)) this.Insert("8");
    if (Input.GetKeyDown(KeyCode.Alpha9) || Input.GetKeyDown(KeyCode.Keypad9)) this.Insert("9");
    if (Input.GetKeyDown(KeyCode.Comma) || Input.GetKeyDown(KeyCode.DecimalPoint) ||
        Input.GetKeyDown(KeyCode.Period)) this.Insert(".");
    if (Input.GetKeyDown(KeyCode.Backspace)) this.DoBackspace();
    this.OnKeyDownUpdate();
    if (this.label.pixiObjectContent != null) {
        var newPos = new UHTMath.Vector3(this.caretCachedPosition);
        newPos.x += this.label.text.length == 0 ? 0 : (this.label.pixiObjectContent.canvas.width - this.label.pixiObjectContent.extraWidthDueToEffects) / this.label.resize;
        this.caretGameObject.transform.localPosition(newPos)
    }
};
UIInput.prototype.Select = function(selected) {
    if (this.isSelected == selected) return;
    if (!selected) KeyboardManager._keyboardReceiver = {};
    else KeyboardManager._keyboardReceiver = this;
    if (this.clearValueOnSelect && !this.isSelected) this.SetValue("");
    this.isSelected = selected;
    if (this.isSelected) {
        if (UIInput.curSelectedUIInput != null) UIInput.curSelectedUIInput.Select(false);
        UIInput.curSelectedUIInput = this
    } else UIInput.curSelectedUIInput = null;
    this.caretGameObject.SetActive(this.isSelected);
    this.InternalSetText()
};
UIInput.prototype.ValidateAndNotify = function(newValue) {
    var oldValue = this.value;
    this.Validate(newValue);
    if (oldValue != this.value) {
        if (this.linkedUIInput != null) this.linkedUIInput.SetValue(this.value);
        for (var i = 0; i < this.onChange.length; i++) {
            var cur = this.onChange[i];
            if (cur.target != null) cur.target[cur.methodName]()
        }
    }
};
UIInput.prototype.Validate = function(newValue) {
    this.value = newValue;
    if (this.characterLimit > 0 && this.value.length > this.characterLimit) this.value = this.value.substring(0, this.characterLimit);
    if (this.validation == UIInput.Validation.Integer) {
        while (this.value.length > 0) {
            var rv = parseInt(this.value, 10);
            if (isFinite(rv) && !isNaN(rv)) {
                this.value = rv.toString();
                return
            } else this.value = this.value.substring(0, this.value.length - 1)
        }
        this.value = "0";
        return
    }
    if (this.validation == UIInput.Validation.Float);
    else console.log("Invalid Validation for UIInput! Only Integer supported!")
};
UIInput.prototype.SetValue = function(str) {
    this.ValidateAndNotify(str);
    this.InternalSetText()
};
UIInput.prototype.Insert = function(str) {
    if (str == ".") {
        if (/\./.test(this.value)) return;
        if (_string.IsNullOrEmpty(this.value)) this.value = "0"
    } else if (this.value == "0") this.value = "";
    this.ValidateAndNotify(this.value + str);
    this.InternalSetText()
};
UIInput.prototype.DoBackspace = function() {
    this.ValidateAndNotify(this.value.substring(0, this.value.length - 1));
    this.InternalSetText()
};
UIInput.prototype.Clear = function() {
    this.ValidateAndNotify("0");
    this.InternalSetText()
};
UIInput.prototype.InternalSetText = function() {
    this.label.text = this.TextExtraHandler != null ? this.TextExtraHandler(this.value) : this.value
};
UIInput.prototype.OnKeyDown = function(key) {
    if (this.isSelected) this.keysPressed.push(key)
};
UIInput.prototype.OnKeyDownUpdate = function() {
    while (this.keysPressed.length > 0) {
        var key = this.keysPressed.shift();
        if (key.length == 1) this.Insert(key);
        else if (key.toLowerCase() == "backspace") this.DoBackspace();
        else if (key.toLowerCase() == "escape") this.userCanceledInput.Start()
    }
};
UIInput.prototype.Reset = function() {
    this.Select(false);
    if (this.localizedDefaultValueLabel) this.SetValue(this.localizedDefaultValueLabel.text)
};
goog.provide("UHT.UILabel");
goog.require("UHT.Component");
UILabel.prototype = Object.create(Component.prototype);
UILabel.prototype.constructor = UILabel;
var LabelUsageID = 0;

function UILabel() {
    Component.call(this);
    this.wasInitCalled = false;
    this.fontName = null;
    this.fontSize = 0;
    this.currentFontSize = 0;
    this._text = "";
    this.anchorX = 0;
    this.anchorY = 0;
    this.depth = 0;
    this.color = null;
    this.overflow = UILabel.Overflow.ShrinkContent;
    this.alignment = UILabel.Alignment.Automatic;
    this.effectStyle = UILabel.Effect.Outline;
    this.effectColor = null;
    this.effectWidth = 0;
    this.effectHeight = 0;
    this.dropShadowDistance = this.effectWidth * 1.5;
    this.maxLines = 0;
    this.width = 2;
    this.height = 2;
    this.spacingY = 0;
    this.multipleLayers =
        null;
    this.pixiObject = null;
    this.pixiObjectContent = null;
    this.panel = null;
    this.mask = null;
    this._pixiPosDirty = true;
    this.oldColor = -1;
    this.textIsUnprocessed = false;
    this.mBlurShadow = false;
    this.mBlurShadowSize = 1;
    this.mBlurShadowOffsetX = 1;
    this.mBlurShadowOffsetY = 1;
    this.mBlurShadowColor = null;
    this.mOutline = false;
    this.mOutlineThickness = 1;
    this.mOutlineColor = null;
    this.mFillCenter = true;
    this.mArcRadius = 0;
    this.circularChildren = [];
    this.circularChildrenWidth = [];
    this.fontNameExpectedFromCallback = "";
    this.zeroScale = false;
    this.isDOG = false;
    this.DOGchars = null;
    this.DOGmonospaceDigits = false;
    this.resize = 1;
    this.dontIgnoreLocalScale = false;
    this.useColorForBitmapFont = false;
    this.keepInMemory = false;
    this.valueDisplayers = null;
    this.IOSresized = false;
    this.usageID = "l" + LabelUsageID;
    LabelUsageID++
}
Object.defineProperties(UILabel.prototype, {
    text: {
        get: function() {
            return this._text
        },
        set: function(value) {
            this.InternalSetText(value, false)
        }
    },
    mColor: {
        get: function() {
            return this.color
        }
    }
});
UILabel.Overflow = {
    ShrinkContent: 0,
    ClampContent: 1,
    ResizeFreely: 2,
    ResizeHeight: 3
};
UILabel.Alignment = {
    Automatic: 0,
    Left: 1,
    Center: 2,
    Right: 3,
    Justified: 4
};
UILabel.Effect = {
    None: 0,
    Shadow: 1,
    Outline: 2,
    Outline8: 3,
    Custom: 4,
    Layered: 5
};
var LabelUsage = {};
UILabel.prototype.UseNow = function() {
    var a = LabelUsage[this.usageID];
    if (a != undefined) {
        a.allocated = true;
        a.frame = Time.frameCount
    }
};
UILabel.CheckUsageAndClean = function() {
    if (!createjs.BrowserDetect.isIOS) return;
    for (var i in LabelUsage) {
        var l = LabelUsage[i];
        if (l.allocated && !l.label.isDOG && !l.label.keepInMemory)
            if (l.frame < Time.frameCount - 3600) {
                l.label.pixiObjectContent["destroy"]({
                    texture: true,
                    baseTexture: true
                });
                l.label.pixiObject = null;
                l.label.pixiObjectContent = null;
                l.label.textIsUnprocessed = true;
                l.allocated = false
            }
    }
};
UILabel.prototype.InternalSetText = function(value, forced) {
    var t = String(value);
    if (this._text == t && !this.textIsUnprocessed) return;
    this._pixiPosDirty = true;
    this._text = t;
    if (!this.gameObject.activeInHierarchy && !forced) {
        this.textIsUnprocessed = true;
        return
    }
    this.textIsUnprocessed = false;
    if (t == "") {
        if (this.overflow == UILabel.Overflow.ResizeFreely) this.width = 0;
        this.pixiObject = null;
        return
    }
    if (this.pixiObject == null) this.init(forced);
    else if (typeof this.fontName != "object")
        if (this.gameObject.activeInHierarchy || forced) {
            if (this.isDOG) {
                this.textIsUnprocessed =
                    true;
                return
            }
            if (this.effectStyle == UILabel.Effect.Custom) this.init(forced);
            this.pixiObjectContent.text = this._text;
            this.processPixiText()
        }
};
UILabel.prototype.Prepare = function() {
    if (Globals.isMobile && typeof this.fontName != "object")
        if (!this.IOSresized) {
            var REFERENCE_FONT_SIZE = 30;
            if (this.fontSize > REFERENCE_FONT_SIZE && this.resize > .9) {
                var RESIZE_FACTOR = (this.fontSize - (this.fontSize - REFERENCE_FONT_SIZE) * .75) / this.fontSize;
                this.resize *= RESIZE_FACTOR;
                this.fontSize *= RESIZE_FACTOR;
                this.fontSize = Math.max(this.fontSize, 2) | 0;
                this.width *= RESIZE_FACTOR;
                this.width = Math.max(this.width, 2) | 0;
                this.height *= RESIZE_FACTOR;
                this.height = Math.max(this.height, 2) |
                    0;
                this.effectWidth *= RESIZE_FACTOR;
                this.effectHeight *= RESIZE_FACTOR;
                this.spacingY *= RESIZE_FACTOR;
                this.mBlurShadowSize *= RESIZE_FACTOR;
                this.mBlurShadowOffsetX *= RESIZE_FACTOR;
                this.mBlurShadowOffsetY *= RESIZE_FACTOR;
                this.mOutlineThickness *= RESIZE_FACTOR;
                this.mArcRadius *= RESIZE_FACTOR
            }
            this.IOSresized = true
        }
    this.fontNameExpectedFromCallback = this.fontName;
    if (typeof this.fontName == "object") {
        this.fontName.callback.push(this.init);
        this.fontName.object.push(this)
    } else FontLoader.AddHandler(this.fontName, this.init,
        this)
};
UILabel.prototype.Start = function() {
    this.Prepare();
    this.panel = FindPanel(this.gameObject.transform)
};
UILabel.prototype.OnWillRenderObject = function() {
    if (this.textIsUnprocessed) this.InternalSetText(this._text, false);
    if (typeof this.fontName == "object") {
        if (!this.fontName.hasFontLoaded) return;
        if (this.fontName.isLoading && !this.wasInitCalled) this.init();
        if (this.pixiObject == null) return;
        this.pixiObject.mask = this.mask;
        var poc = this.pixiObjectContent;
        if (typeof poc.text != "string" || poc.text != this._text) {
            poc.text = this._text;
            poc.updateText();
            this.processPixiText();
            this._pixiPosDirty = true
        }
        this.pixiObject.visible =
            this.enabled;
        var c;
        if (this.isDOG)
            for (var i = 0; i < poc.children.length; i++) {
                c = poc.children[i];
                c.alpha = this.color.a * this.panel.alpha;
                c.worldAlpha = c.alpha
            } else
                for (var i = 0; i < poc.children.length; i++) {
                    c = poc.children[i];
                    if (this.useColorForBitmapFont) {
                        c.alpha = this.color.a * this.panel.alpha;
                        c.tint = this.color.rgbAsHex
                    } else c.alpha = 1 * this.panel.alpha;
                    c.worldAlpha = c.alpha
                }
    } else {
        if (this.isDOG) {
            this.init();
            return
        }
        if (!this.wasInitCalled) this.init();
        if (this.pixiObject == null) return;
        if (this.mArcRadius != 0)
            for (var oc = 0; oc <
                this.circularChildren.length; oc++) {
                var cLabel = this.circularChildren[oc].gameObject.GetComponent(UILabel);
                cLabel.enabled = true;
                cLabel.color = this.color
            }
        this.pixiObject.mask = this.mask;
        var poc = this.pixiObjectContent;
        var tooTransparent = this.color.a < .05;
        this.pixiObject.visible = this.enabled && !tooTransparent;
        if (IS_UCBROWSER && this.mFillUseGradient) {
            var old_a = this.color.a;
            var c = this.mFillGradient.colorKeys[0].color;
            this.color = Color.Lerp(c, c, 0);
            this.color.a = old_a
        }
        var curColor = this.color.rgbAsHex;
        if (this.oldColor !=
            curColor) {
            this.oldColor = curColor;
            poc.style.fill = this.color.rgbAsString();
            poc.dirty = true
        }
        poc.alpha = this.color.a * this.panel.alpha;
        poc.worldAlpha = poc.alpha;
        if (poc.text != this._text) {
            poc.text = this._text;
            this.processPixiText()
        } else poc.text = this._text
    }
    var hc = this.gameObject.transform;
    if (!this.pixiObject.visible) return;
    var ignored = poc.height;
    if (this.zeroScale) this.pixiObject.visible = false;
    else this.UseNow();
    if (!this._pixiPosDirty && !hc.IsDirtyUserFlag(Transform._DirtyFlagLabel)) return;
    hc._internal_get_position();
    hc._internal_get_rotation();
    hc._internal_get_scale();
    hc.ClearDirtyUserFlag(Transform._DirtyFlagLabel);
    this._pixiPosDirty = false;
    this.pixiObject.dirtyWT = true;
    if (this.pixiObject == null) return;
    var parent = this.pixiObject;
    var child = this.pixiObjectContent;
    var hp = hc.parent.transform;
    parent.x = hp._dangerous_get_position().x;
    parent.y = -hp._dangerous_get_position().y;
    var offsets = this.ComputeOffsets(child);
    child.x = hc._dangerous_get_localPosition().x * this.resize - offsets.X;
    child.y = -hc._dangerous_get_localPosition().y *
        this.resize - offsets.Y;
    parent.rotation = -hp._dangerous_get_rotation().eulerAnglesRad().z;
    child.rotation = -hc._dangerous_get_localRotation().eulerAnglesRad().z;
    parent.scale.x = hp._dangerous_get_scale().x / this.resize;
    parent.scale.y = hp._dangerous_get_scale().y / this.resize;
    if (this.dontIgnoreLocalScale) {
        child.scale.x = hc._dangerous_get_localScale().x;
        child.scale.y = hc._dangerous_get_localScale().y
    }
    this.zeroScale = Math.abs(parent.scale.x * parent.scale.y) < 1E-16
};
UILabel.prototype.ComputeOffsets = function(child) {
    var offsetX = 0;
    var offsetY = 0;
    var fxPlusTop = 0;
    var fxPlusBottom = 0;
    var fxPlusLeft = 0;
    var fxPlusRight = 0;
    switch (this.effectStyle) {
        case UILabel.Effect.Outline:
        case UILabel.Effect.Outline8:
            fxPlusTop = this.mOutlineThickness;
            fxPlusBottom = -this.mOutlineThickness;
            fxPlusLeft = this.mOutlineThickness;
            fxPlusRight = -this.mOutlineThickness;
            break;
        case UILabel.Effect.Shadow:
            fxPlusBottom = -this.dropShadowDistance;
            fxPlusRight = -this.dropShadowDistance;
            break;
        case UILabel.Effect.Custom:
            if (this.mOutline) {
                fxPlusTop =
                    this.mOutlineThickness;
                fxPlusBottom = -this.mOutlineThickness;
                fxPlusLeft = this.mOutlineThickness;
                fxPlusRight = -this.mOutlineThickness
            }
            if (this.mBlurShadow) {
                var extraTop = Math.max(this.mBlurShadowSize - this.mBlurShadowOffsetY, 0);
                fxPlusTop += extraTop;
                fxPlusBottom -= Math.max(this.mBlurShadowSize * 2 + Math.abs(this.mBlurShadowOffsetY), 0) - extraTop;
                var extraLeft = Math.max(this.mBlurShadowSize - this.mBlurShadowOffsetX, 0);
                fxPlusLeft += extraLeft;
                fxPlusRight -= Math.max(this.mBlurShadowSize * 2 + Math.abs(this.mBlurShadowOffsetX),
                    0) - extraLeft
            }
            break;
        case UILabel.Effect.Layered:
            fxPlusTop = this.multipleLayers.effectPlusTop;
            fxPlusBottom = this.multipleLayers.effectPlusBottom;
            fxPlusLeft = this.multipleLayers.effectPlusLeft;
            fxPlusRight = this.multipleLayers.effectPlusRight;
            break;
        default:
            break
    }
    if (typeof this.fontName == "object") {
        var offTop = 0;
        var offBottom = 0;
        var temp = {};
        temp.textHeight = 0;
        temp.textWidth = 0;
        temp = this.pixiObjectContent;
        if (this.anchorY < .1) offsetY = offTop + fxPlusTop;
        else if (this.anchorY > .9) offsetY = offBottom + fxPlusBottom + temp.textHeight;
        else offsetY = (offTop + offBottom + fxPlusTop + fxPlusBottom) / 2 + temp.textHeight / 2;
        if (this.anchorX < .1) offsetX = fxPlusLeft;
        else if (this.anchorX > .9) offsetX = fxPlusRight + temp.textWidth;
        else offsetX = (fxPlusLeft + fxPlusRight) / 2 + temp.textWidth / 2;
        return {
            X: offsetX,
            Y: offsetY
        }
    } else {
        var offTop = child["_hack_extraOffsetTop"];
        var offBottom = child["_hack_extraOffsetBottom"];
        var properties = child.determineFontProperties(child._style.font);
        var offPadding = properties.fontSize * .5;
        if (this.anchorY < .1) offsetY = offTop + fxPlusTop;
        else if (this.anchorY >
            .9) offsetY = offBottom + fxPlusBottom;
        else offsetY = (offTop + offBottom + fxPlusTop + fxPlusBottom) / 2;
        if (this.anchorX < .1) offsetX = offPadding + fxPlusLeft;
        else if (this.anchorX > .9) offsetX = -offPadding + fxPlusRight;
        else offsetX = (fxPlusLeft + fxPlusRight) / 2;
        return {
            X: offsetX,
            Y: offsetY
        }
    }
};
var DOG_Cache = [];
UILabel.prototype.init = function(forced) {
    if (!this.gameObject.activeInHierarchy && !(forced === true)) {
        this.textIsUnprocessed = true;
        return
    }
    if (this._text == "") {
        if (this.overflow == UILabel.Overflow.ResizeFreely) this.width = 0;
        return
    }
    if (this.fontNameExpectedFromCallback != this.fontName) return;
    this._pixiPosDirty = true;
    if (this.isDOG && typeof this.fontName != "object") {
        if (this.DOGchars == null || !FontLoader.IsLoaded(this.fontName)) return;
        if (this.pixiObjectContent != null) this.pixiObjectContent["destroy"]({
            texture: true,
            baseTexture: true
        });
        this.pixiObjectContent = new PIXI.Text("");
        var poc = this.pixiObjectContent;
        poc["_hack_NoCutFix"] = true;
        poc.style.font = "" + this.fontSize + "px " + this.fontName;
        poc.style.lineHeight = this.fontSize;
        poc.style.spacingY = this.spacingY;
        poc.style.fill = this.color.rgbAsString();
        poc.alpha = 1;
        poc.text = " ";
        poc.updateText();
        var spw = poc["_width"];
        this.SetupEffects();
        var cacheKey = JSON.stringify(poc.style) + this.DOGchars;
        var useCached = false;
        for (var dci = 0; dci < DOG_Cache.length; dci++)
            if (DOG_Cache[dci].key == cacheKey) {
                this.fontName =
                    DOG_Cache[dci].uif;
                this.fontNameExpectedFromCallback = DOG_Cache[dci].uif;
                this.pixiObjectContent = null;
                DOG_Cache[dci].count++;
                useCached = true
            }
        if (!useCached) {
            var fxw;
            var fxh;
            if (this.effectStyle == UILabel.Effect.Layered) {
                fxw = this.multipleLayers.effectWidth;
                fxh = this.multipleLayers.effectHeight
            } else {
                fxw = poc.style.strokeThickness;
                fxh = poc.style.strokeThickness;
                if (poc.style.dropShadow) {
                    fxw += poc.style.dropShadowDistance;
                    fxh += poc.style.dropShadowDistance
                }
                if (poc.style.blurShadow) {
                    fxw += Math.max(poc.style.dropShadowDistance *
                        2 + Math.abs(poc.style.blurShadowX), 0);
                    fxh += Math.max(poc.style.dropShadowDistance * 2 + Math.abs(poc.style.blurShadowY), 0)
                }
            }
            var chsep = " ";
            if (fxw > 0) {
                var spn = Math.ceil(fxw / spw);
                for (var i = 0; i < spn; ++i) chsep += " "
            }
            fxw *= this.anchorX;
            fxh *= this.anchorY;
            fxh += poc["_hack_extraOffsetTop"];
            if (this.effectStyle == UILabel.Effect.Layered) {
                if (this.anchorY < .1) fxh -= this.multipleLayers.effectPlusTop;
                else if (this.anchorY > .9) fxh -= this.multipleLayers.effectPlusBottom;
                else fxh -= (this.multipleLayers.effectPlusTop + this.multipleLayers.effectPlusBottom) *
                    .5;
                if (this.anchorX < .1) fxw -= this.multipleLayers.effectPlusLeft;
                else if (this.anchorX > .9) fxw -= this.multipleLayers.effectPlusRight;
                else fxw -= (this.multipleLayers.effectPlusLeft + this.multipleLayers.effectPlusRight) * .5
            }
            var chars = this.DOGchars;
            var sp = chars.indexOf(" ") > -1;
            chars.replace(" ", "");
            var ch = [];
            for (var i = 0; i < chars.length; ++i) ch.push(chars[i]);
            chars = (sp ? " " : "") + chsep + ch.join(chsep) + chsep;
            var t = "";
            var ow = 0;
            var chw = 0;
            var add = false;
            var xa = -1;
            ch = [];
            var presentChars = "";
            var xml = '<?xml version="1.0"?><font>';
            xml += '<info face="{0}" size="{1}" bold="0" italic="0" charset="" unicode="1" stretchH="100" smooth="1" aa="1" padding="0,0,0,0" spacing="0,0" outline="0"/>';
            xml += '<common lineHeight="{1}" base="{1}" scaleW="{2}" scaleH="{1}" pages="1" packed="0" alphaChnl="0" redChnl="4" greenChnl="4" blueChnl="4"/>';
            xml += '<chars count="{3}">';
            for (var i = 0; i < chars.length; ++i) {
                add = ch.indexOf(chars[i]) < 0;
                if (add) {
                    poc.text = chars[i];
                    poc.updateText();
                    chw = poc["_width"]
                }
                t += chars[i];
                poc.text = t;
                poc.updateText();
                if (add) {
                    var w =
                        poc["_width"] - ow;
                    var ox = w - chw;
                    var x = ow + ox;
                    var line = '<char id="{0}" x="{1}" y="0" width="{2}" height="{3}" xoffset="{6}" yoffset="{4}" xadvance="{5}" page="0" chnl="15" />';
                    line = line.replace(/\{0\}/g, String(chars[i].charCodeAt(0)));
                    line = line.replace(/\{1\}/g, String(x));
                    line = line.replace(/\{2\}/g, String(chw));
                    line = line.replace(/\{3\}/g, String(poc["_height"]));
                    line = line.replace(/\{4\}/g, String(-fxh));
                    line = line.replace(/\{6\}/g, String(-fxw));
                    if (!this.DOGmonospaceDigits || !/\d/.test(chars[i])) line = line.replace(/\{5\}/g,
                        String(w));
                    else if (xa < w) xa = w;
                    xml += line;
                    ch.push(chars[i]);
                    if (w > 0) presentChars += chars[i]
                }
                ow = poc["_width"]
            }
            if (Renderer.IsWebGL) {
                var gl = globalRenderer.renderer["gl"];
                var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                if (maxSize < ow) {
                    var resize = maxSize / (ow + 1) * .95;
                    this.fontSize *= resize;
                    this.resize *= resize;
                    this.init();
                    return
                }
            }
            xml += "</chars></font>";
            var fontName = UID.Generate();
            xml = xml.replace(/\{0\}/g, fontName);
            xml = xml.replace(/\{1\}/g, String(this.fontSize));
            xml = xml.replace(/\{2\}/g, String(poc["_width"]));
            xml =
                xml.replace(/\{3\}/g, String(chars.length));
            xml = xml.replace(/\{5\}/g, String(xa));
            var xmlDoc = (new DOMParser).parseFromString(xml, "text/xml");
            PIXI.extras.BitmapText.parse(xmlDoc, poc["_texture"]);
            var uif = new UIFont;
            uif.name = fontName;
            uif.isLoading = true;
            uif.hasFontLoaded = true;
            uif.chars = presentChars;
            this.fontName = uif;
            this.fontNameExpectedFromCallback = uif;
            this.pixiObjectContent = null;
            DOG_Cache.push({
                key: cacheKey,
                uif: uif,
                count: 0
            })
        }
    }
    this.pixiObject = new PIXI.Container(null);
    if (typeof this.fontName == "object") {
        if (this.fontName.hasFontLoaded) this.pixiObjectContent =
            new PIXI.extras.BitmapText(this._text, {
                font: this.fontSize + "px " + this.fontName.name
            });
        else return;
        this.pixiObject.addChild(this.pixiObjectContent);
        var poc = this.pixiObjectContent;
        this.currentFontSize = this.fontSize
    } else {
        if (this.pixiObjectContent != null) this.pixiObjectContent["destroy"]({
            texture: true,
            baseTexture: true
        });
        this.pixiObjectContent = new PIXI.Text(this._text);
        this.pixiObjectContent.style.padding = this.fontSize * .25;
        this.pixiObject.addChild(this.pixiObjectContent);
        var poc = this.pixiObjectContent;
        this.currentFontSize =
            this.fontSize;
        poc.style.font = "" + this.fontSize + "px " + this.fontName;
        poc.style.lineHeight = this.fontSize;
        poc.style.spacingY = this.spacingY;
        poc.anchor.x = this.anchorX;
        poc.anchor.y = this.anchorY;
        if (IS_UCBROWSER && this.mFillUseGradient) {
            var old_a = this.color.a;
            var c = this.mFillGradient.colorKeys[0].color;
            this.color = Color.Lerp(c, c, 0);
            this.color.a = old_a
        }
        this.oldColor = this.color.rgbAsHex;
        poc.style.fill = this.color.rgbAsString();
        poc.alpha = this.color.a;
        this.SetupAlignment();
        this.SetupEffects();
        if (this.overflow == UILabel.Overflow.ShrinkContent ||
            this.overflow == UILabel.Overflow.ResizeHeight) {
            poc.style.wordWrap = true;
            poc.style.wordWrapWidth = this.width
        }
    }
    this.processPixiText();
    this.wasInitCalled = true
};
UILabel.prototype.SetColor = function(newColor) {
    this.color = newColor
};
UILabel.prototype.GetColor = function() {
    return this.color
};
UILabel.prototype.SetupEffects = function() {
    this.dropShadowDistance = this.effectWidth * 1.5;
    switch (this.effectStyle) {
        case UILabel.Effect.Shadow:
            this.pixiObjectContent.style.dropShadow = true;
            this.pixiObjectContent.style.dropShadowAngle = Math.PI / 4;
            this.pixiObjectContent.style.dropShadowColor = this.effectColor.rgbAsString();
            this.pixiObjectContent.style.dropShadowDistance = this.dropShadowDistance;
            break;
        case UILabel.Effect.Outline:
        case UILabel.Effect.Outline8:
            this.mOutlineThickness = this.effectWidth;
            this.pixiObjectContent.style.stroke =
                this.effectColor.rgbAsString();
            this.pixiObjectContent.style.strokeThickness = this.mOutlineThickness * 2;
            break;
        case UILabel.Effect.Custom:
            this.pixiObjectContent.style.blurShadow = this.mBlurShadow;
            this.pixiObjectContent.style.blurShadowX = this.mBlurShadowOffsetX;
            this.pixiObjectContent.style.blurShadowY = this.mBlurShadowOffsetY;
            this.pixiObjectContent.style.dropShadowColor = this.mBlurShadowColor.rgbAsString();
            this.pixiObjectContent.style.dropShadowDistance = this.mBlurShadowSize;
            this.pixiObjectContent.style.fillCenter =
                this.mFillCenter;
            this.pixiObjectContent.style.stroke = this.mOutline ? this.mOutlineColor.rgbAsString() : null;
            if (this.mOutline) this.pixiObjectContent.style.strokeThickness = this.mOutlineThickness * 2;
            if (!IS_UCBROWSER) {
                this.pixiObjectContent.style.mFillUseGradient = this.mFillUseGradient;
                this.pixiObjectContent.style.mFillGradient = this.mFillGradient;
                this.pixiObjectContent.style.mFillGradientAngle = Math.PI * this.mFillGradientAngle / 180;
                this.pixiObjectContent.style.mOutlineUseGradient = this.mOutlineUseGradient;
                this.pixiObjectContent.style.mOutlineGradient =
                    this.mOutlineGradient;
                this.pixiObjectContent.style.mOutlineGradientAngle = Math.PI * this.mOutlineGradientAngle / 180
            } else {
                if (this.mFillUseGradient) {
                    var old_a = this.color.a;
                    var c = this.mFillGradient.colorKeys[0].color;
                    this.color = Color.Lerp(c, c, 0);
                    this.color.a = old_a
                }
                if (this.mOutlineUseGradient) this.pixiObjectContent.style.stroke = this.mOutlineGradient.colorKeys[0].color.rgbAsString()
            }
            break;
        case UILabel.Effect.Layered:
            if (this.multipleLayers == null) this.multipleLayers = this.GetComponent(LabelMultipleLayers);
            this.multipleLayers.SetupEffects(this);
            break;
        default:
            break
    }
};
UILabel.prototype.SetupAlignment = function() {
    if (this.alignment == UILabel.Alignment.Automatic)
        if (this.anchorX == .5) this.pixiObjectContent.style.align = "center";
        else {
            if (this.anchorX == 1) this.pixiObjectContent.style.align = "right"
        }
    else switch (this.alignment) {
        case UILabel.Alignment.Center:
            this.pixiObjectContent.style.align = "center";
            break;
        case UILabel.Alignment.Right:
            this.pixiObjectContent.style.align = "right";
            break;
        default:
            break
    }
};
UILabel.prototype.processPixiText = function() {
    var poc = this.pixiObjectContent;
    poc.dirty = true;
    var ignored = poc.height;
    if (this.overflow == UILabel.Overflow.ShrinkContent)
        if (typeof this.fontName == "object") {
            if (this.currentFontSize < this.fontSize)
                while (poc.textHeight < this.height) {
                    poc.dirty = true;
                    this.currentFontSize++;
                    poc = new PIXI.extras.BitmapText(this._text, {
                        font: this.currentFontSize + "px " + this.fontName.name
                    })
                }
            while ((poc.textHeight > this.height || poc.textWidth > this.width) && this.currentFontSize > 1) {
                poc.dirty = true;
                this.currentFontSize--;
                poc = new PIXI.extras.BitmapText(this._text, {
                    font: this.currentFontSize + "px " + this.fontName.name
                })
            }
            this.pixiObjectContent.font.size = this.currentFontSize;
            this.pixiObjectContent.updateText()
        } else {
            var oldStyle = poc.style;
            poc.style = {};
            poc.style.lineHeight = this.currentFontSize;
            poc.style.spacingY = this.spacingY * this.currentFontSize / this.fontSize;
            poc.style.font = "" + this.currentFontSize + "px " + this.fontName;
            poc.style.wordWrap = true;
            poc.style.wordWrapWidth = oldStyle.wordWrapWidth;
            poc._skipUpdateTexture =
                true;
            if (this.currentFontSize < this.fontSize)
                if (poc.height < this.height) {
                    var found = false;
                    var min = this.currentFontSize;
                    var max = this.fontSize;
                    while (!found && this.currentFontSize != this.fontSize) {
                        this.currentFontSize = Math.ceil((min + max) / 2) | 0;
                        poc.dirty = true;
                        poc.style.lineHeight = this.currentFontSize;
                        poc.style.spacingY = this.spacingY * this.currentFontSize / this.fontSize;
                        poc.style.font = "" + this.currentFontSize + "px " + this.fontName;
                        var fit = poc.height < this.height;
                        found = !fit && min >= max - 1;
                        if (fit) min = this.currentFontSize;
                        else max = this.currentFontSize
                    }
                }
            if (this.maxLines > 0) {
                var defaultLines = this._text.split(/(?:\r\n|\r|\n)/);
                var outputText = poc.wordWrap(this._text);
                var lines = outputText.split(/(?:\r\n|\r|\n)/);
                if (lines.length - (defaultLines.length - 1) > this.maxLines) {
                    var found = false;
                    var min = 1;
                    var max = this.currentFontSize;
                    while (!found) {
                        this.currentFontSize = (min + max) / 2 | 0;
                        poc.dirty = true;
                        poc.style.lineHeight = this.currentFontSize;
                        poc.style.spacingY = this.spacingY * this.currentFontSize / this.fontSize;
                        poc.style.font = "" + this.currentFontSize +
                            "px " + this.fontName;
                        ignored = poc.height;
                        outputText = poc.wordWrap(this._text);
                        lines = outputText.split(/(?:\r\n|\r|\n)/);
                        var fit = lines.length - (defaultLines.length - 1) <= this.maxLines;
                        found = fit && min >= max - 1;
                        if (fit) min = this.currentFontSize;
                        else max = this.currentFontSize
                    }
                }
            }
            if (poc.height > this.height || poc.width > this.width) {
                var found = false;
                var min = 1;
                var max = this.currentFontSize;
                while (!found) {
                    this.currentFontSize = (min + max) / 2 | 0;
                    poc.dirty = true;
                    poc.style.lineHeight = this.currentFontSize;
                    poc.style.spacingY = this.spacingY *
                        this.currentFontSize / this.fontSize;
                    poc.style.font = "" + this.currentFontSize + "px " + this.fontName;
                    if (this.maxLines > 0) {
                        var defaultLines = this._text.split(/(?:\r\n|\r|\n)/);
                        var outputText = poc.wordWrap(this._text);
                        var lines = outputText.split(/(?:\r\n|\r|\n)/);
                        if (lines.length - (defaultLines.length - 1) > this.maxLines) {
                            var found2 = false;
                            var min2 = 1;
                            var max2 = this.currentFontSize;
                            while (!found2) {
                                this.currentFontSize = (min2 + max2) / 2 | 0;
                                poc.dirty = true;
                                poc.style.lineHeight = this.currentFontSize;
                                poc.style.spacingY = this.spacingY *
                                    this.currentFontSize / this.fontSize;
                                poc.style.font = "" + this.currentFontSize + "px " + this.fontName;
                                ignored = poc.height;
                                outputText = poc.wordWrap(this._text);
                                lines = outputText.split(/(?:\r\n|\r|\n)/);
                                var fit2 = lines.length - (defaultLines.length - 1) <= this.maxLines;
                                found2 = fit2 && min2 >= max2 - 1;
                                if (fit2) min2 = this.currentFontSize;
                                else max2 = this.currentFontSize
                            }
                        }
                    }
                    var fit = !(poc.height > this.height || poc.width > this.width);
                    found = fit && min >= max - 1;
                    if (fit) min = this.currentFontSize;
                    else max = this.currentFontSize
                }
            }
            poc._style = oldStyle;
            poc.style.lineHeight = this.currentFontSize;
            poc.style.spacingY = this.spacingY * this.currentFontSize / this.fontSize;
            poc.style.font = "" + this.currentFontSize + "px " + this.fontName;
            poc.dirty = true;
            poc._skipUpdateTexture = false;
            ignored = poc.height
        }
    if (this.overflow == UILabel.Overflow.ResizeFreely)
        if (typeof this.fontName == "object") this.width = poc.textWidth;
        else this.width = poc.width;
    if (this.mArcRadius != 0) {
        for (var oc = 0; oc < this.circularChildren.length; oc++) {
            this.circularChildren[oc].gameObject.SetActive(false);
            this.circularChildren[oc].transform.SetParent(null,
                false)
        }
        this.circularChildren = [];
        this.circularChildrenWidth = [];
        this._model.mArcRadius = 0;
        this._model.enabled = false;
        var oAR = this.mArcRadius;
        this.mArcRadius = 0;
        var oResize = this.resize;
        this.resize = 1;
        var oActive = this.gameObject.activeSelf;
        this.gameObject.SetActive(false);
        var letters = this._text.length;
        for (var l = 0; l < letters; l++) {
            var newGO = instantiate(this.gameObject);
            var newLabel = newGO.GetComponent(UILabel);
            newLabel.depth = this.depth + l / letters;
            newLabel.InternalSetText(this._text[l], true);
            newLabel.fontNameExpectedFromCallback =
                this.fontNameExpectedFromCallback;
            newLabel.overflow = UILabel.Overflow.ResizeFreely;
            newLabel.fontSize = this.currentFontSize;
            this.circularChildren.push(newLabel);
            this.circularChildrenWidth.push(0)
        }
        var allWidth = 0;
        for (var l2 = 0; l2 < letters; l2++) {
            var newLabel = this.circularChildren[l2];
            newLabel.transform.SetParent(this.gameObject.transform, false);
            newLabel.transform.localPosition(0, 0, 0);
            newLabel.transform.localScale(1, 1, 1);
            newLabel.gameObject.SetActive(true);
            newLabel.anchorX = .5;
            newLabel.anchorY = .5;
            newLabel.init(true);
            this.circularChildrenWidth[l2] = this.circularChildren[l2].width;
            allWidth += this.circularChildren[l2].width
        }
        this.mArcRadius = oAR;
        this.resize = oResize;
        this.gameObject.SetActive(oActive);
        this.enabled = false;
        var arcRadius = -this.mArcRadius;
        var circlePerimeter = 2 * UHTMath.PI * arcRadius;
        var currentpos = 0;
        for (var i = 0; i < letters; i++) {
            currentpos += this.circularChildrenWidth[i] * .5;
            var letterLabel = this.circularChildren[i];
            var letterGO = letterLabel.gameObject;
            var letterTransform = letterGO.transform;
            var distance = currentpos -
                allWidth / 2;
            var angleWithThisArcLength = distance / circlePerimeter * 2 * UHTMath.PI - .5 * UHTMath.PI;
            var newCenterx = Math.cos(angleWithThisArcLength) * arcRadius;
            var newCentery = Math.sin(angleWithThisArcLength) * arcRadius;
            letterTransform.localPosition(newCenterx, newCentery, 0);
            var rotAngle = (angleWithThisArcLength + .5 * UHTMath.PI) * 180 / UHTMath.PI;
            letterTransform.localRotation(UHTMath.Quaternion.euler(0, 0, rotAngle));
            currentpos += this.circularChildrenWidth[i] * .5
        }
        var scale = 1 / this.resize;
        this.transform.localScale(scale, scale,
            scale)
    } else if (typeof this.fontName != "object") LabelUsage[this.usageID] = {
        frame: Time.frameCount,
        label: this,
        allocated: true
    }
};
UILabel.prototype.GetWidth = function() {
    this.InternalSetText(this._text, false);
    return this.width / this.resize
};
UILabel.prototype.SetWidth = function(width) {
    this.width = width * this.resize;
    this.textIsUnprocessed = true;
    this.InternalSetText(this._text, true)
};
UILabel.prototype.GetHeight = function() {
    this.InternalSetText(this._text, false);
    return this.height / this.resize
};
UILabel.prototype.SetHeight = function(height) {
    this.height = height * this.resize;
    this.textIsUnprocessed = true;
    this.InternalSetText(this._text, true)
};
UILabel.prototype.deserialize = function(source, helper, resolveReference) {
    source["dontIgnoreLocalScale"] = source["dontIgnoreLocalScale"] != undefined ? source["dontIgnoreLocalScale"] : false;
    source["useColorForBitmapFont"] = source["useColorForBitmapFont"] != undefined ? source["useColorForBitmapFont"] : false;
    source["keepInMemory"] = source["keepInMemory"] != undefined ? source["keepInMemory"] : false;
    source["resize"] = source["resize"] != undefined ? source["resize"] : 1;
    source["depth"] = source["depth"] != undefined ? source["depth"] :
        0;
    source["fontSize"] = source["fontSize"] != undefined ? source["fontSize"] : 0;
    source["anchorX"] = source["anchorX"] != undefined ? source["anchorX"] : .5;
    source["anchorY"] = source["anchorY"] != undefined ? source["anchorY"] : .5;
    source["maxLines"] = source["maxLines"] != undefined ? source["maxLines"] : 0;
    source["overflow"] = source["overflow"] != undefined ? source["overflow"] : UILabel.Overflow.ResizeFreely;
    source["alignment"] = source["alignment"] != undefined ? source["alignment"] : UILabel.Alignment.Automatic;
    if (source["color"] == undefined) {
        source["color"] = {};
        source["color"]["nestedFieldType"] = "Color";
        source["color"]["serializableData"] = {};
        source["color"]["serializableData"]["c"] = "w"
    }
    source["effectStyle"] = source["effectStyle"] != undefined ? source["effectStyle"] : UILabel.Effect.None;
    if (source["effectColor"] == undefined) {
        source["effectColor"] = {};
        source["effectColor"]["nestedFieldType"] = "Color";
        source["effectColor"]["serializableData"] = {};
        source["effectColor"]["serializableData"]["c"] = "k"
    }
    source["effectWidth"] = source["effectWidth"] != undefined ? source["effectWidth"] :
        1;
    source["effectHeight"] = source["effectHeight"] != undefined ? source["effectHeight"] : 1;
    source["mBlurShadow"] = source["mBlurShadow"] != undefined ? source["mBlurShadow"] : false;
    source["mBlurShadowSize"] = source["mBlurShadowSize"] != undefined ? source["mBlurShadowSize"] : 10;
    source["mBlurShadowOffsetX"] = source["mBlurShadowOffsetX"] != undefined ? source["mBlurShadowOffsetX"] : 4;
    source["mBlurShadowOffsetY"] = source["mBlurShadowOffsetY"] != undefined ? source["mBlurShadowOffsetY"] : 4;
    if (source["mBlurShadowColor"] == undefined) {
        source["mBlurShadowColor"] = {};
        source["mBlurShadowColor"]["nestedFieldType"] = "Color";
        source["mBlurShadowColor"]["serializableData"] = {};
        source["mBlurShadowColor"]["serializableData"]["c"] = "k"
    }
    source["mOutline"] = source["mOutline"] != undefined ? source["mOutline"] : false;
    source["mOutlineThickness"] = source["mOutlineThickness"] != undefined ? source["mOutlineThickness"] : 4;
    if (source["mOutlineColor"] == undefined) {
        source["mOutlineColor"] = {};
        source["mOutlineColor"]["nestedFieldType"] = "Color";
        source["mOutlineColor"]["serializableData"] = {};
        source["mOutlineColor"]["serializableData"]["c"] =
            "k"
    }
    source["mFillCenter"] = source["mFillCenter"] != undefined ? source["mFillCenter"] : true;
    source["mFillUseGradient"] = source["mFillUseGradient"] != undefined ? source["mFillUseGradient"] : false;
    if (source["mFillGradient"] == undefined) {
        source["mFillGradient"] = {};
        source["mFillGradient"]["nestedFieldType"] = "Gradient";
        source["mFillGradient"]["serializableData"] = {};
        source["mFillGradient"]["serializableData"]["colorKeys"] = [];
        for (var i = 0; i < 2; i++) {
            source["mFillGradient"]["serializableData"]["colorKeys"][i] = {};
            source["mFillGradient"]["serializableData"]["colorKeys"][i]["nestedFieldType"] =
                "GradientColorKey";
            source["mFillGradient"]["serializableData"]["colorKeys"][i]["serializableData"] = {};
            source["mFillGradient"]["serializableData"]["colorKeys"][i]["serializableData"]["color"] = {};
            source["mFillGradient"]["serializableData"]["colorKeys"][i]["serializableData"]["color"]["nestedFieldType"] = "Color";
            source["mFillGradient"]["serializableData"]["colorKeys"][i]["serializableData"]["color"]["serializableData"] = {};
            source["mFillGradient"]["serializableData"]["colorKeys"][i]["serializableData"]["color"]["serializableData"]["c"] =
                "w";
            source["mFillGradient"]["serializableData"]["colorKeys"][i]["serializableData"]["time"] = i
        }
        source["mFillGradient"]["serializableData"]["alphaKeys"] = [];
        for (var i = 0; i < 2; i++) {
            source["mFillGradient"]["serializableData"]["alphaKeys"][i] = {};
            source["mFillGradient"]["serializableData"]["alphaKeys"][i]["nestedFieldType"] = "GradientAlphaKey";
            source["mFillGradient"]["serializableData"]["alphaKeys"][i]["serializableData"] = {};
            source["mFillGradient"]["serializableData"]["alphaKeys"][i]["serializableData"]["alpha"] =
                1;
            source["mFillGradient"]["serializableData"]["alphaKeys"][i]["serializableData"]["time"] = i
        }
    }
    source["mFillGradientAngle"] = source["mFillGradientAngle"] != undefined ? source["mFillGradientAngle"] : 0;
    source["mOutlineUseGradient"] = source["mOutlineUseGradient"] != undefined ? source["mOutlineUseGradient"] : false;
    if (source["mOutlineGradient"] == undefined) {
        source["mOutlineGradient"] = {};
        source["mOutlineGradient"]["nestedFieldType"] = "Gradient";
        source["mOutlineGradient"]["serializableData"] = {};
        source["mOutlineGradient"]["serializableData"]["colorKeys"] = [];
        for (var i = 0; i < 2; i++) {
            source["mOutlineGradient"]["serializableData"]["colorKeys"][i] = {};
            source["mOutlineGradient"]["serializableData"]["colorKeys"][i]["nestedFieldType"] = "GradientColorKey";
            source["mOutlineGradient"]["serializableData"]["colorKeys"][i]["serializableData"] = {};
            source["mOutlineGradient"]["serializableData"]["colorKeys"][i]["serializableData"]["color"] = {};
            source["mOutlineGradient"]["serializableData"]["colorKeys"][i]["serializableData"]["color"]["nestedFieldType"] = "Color";
            source["mOutlineGradient"]["serializableData"]["colorKeys"][i]["serializableData"]["color"]["serializableData"] = {};
            source["mOutlineGradient"]["serializableData"]["colorKeys"][i]["serializableData"]["color"]["serializableData"]["c"] = "w";
            source["mOutlineGradient"]["serializableData"]["colorKeys"][i]["serializableData"]["time"] = i
        }
        source["mOutlineGradient"]["serializableData"]["alphaKeys"] = [];
        for (var i = 0; i < 2; i++) {
            source["mOutlineGradient"]["serializableData"]["alphaKeys"][i] = {};
            source["mOutlineGradient"]["serializableData"]["alphaKeys"][i]["nestedFieldType"] = "GradientAlphaKey";
            source["mOutlineGradient"]["serializableData"]["alphaKeys"][i]["serializableData"] = {};
            source["mOutlineGradient"]["serializableData"]["alphaKeys"][i]["serializableData"]["alpha"] = 1;
            source["mOutlineGradient"]["serializableData"]["alphaKeys"][i]["serializableData"]["time"] = i
        }
    }
    source["mOutlineGradientAngle"] = source["mOutlineGradientAngle"] != undefined ? source["mOutlineGradientAngle"] : 0;
    source["spacingY"] = source["spacingY"] != undefined ? source["spacingY"] : 0;
    source["mArcRadius"] = source["mArcRadius"] != undefined ? source["mArcRadius"] : 0;
    deserializeComponentRec(source, this, helper, resolveReference)
};
goog.provide("UHT.UIPanel");
goog.require("UHT.Component");
UIPanel.prototype = Object.create(Component.prototype);
UIPanel.prototype.constructor = UIPanel;

function UIPanel() {
    Component.call(this);
    this.container = null;
    this.depth = 0;
    this.alpha = 0;
    this.mask = null;
    this.container = new PIXI.Container;
    this.container.worldAlpha = 1
}
Object.defineProperties(UIPanel.prototype, {
    "mAlpha": {
        get: function() {
            return this.alpha
        },
        set: function(value) {
            this.alpha = value
        }
    }
});
UIPanel.prototype.OnWillRenderObject = function() {
    var c = this.container;
    c.children = [];
    var tooTransparent = this.alpha < .05;
    c.visible = this.enabled && !tooTransparent;
    c.mask = this.mask;
    if (this.gameObject.transform.IsDirtyUserFlag(Transform._DirtyFlagPanel)) {
        this.gameObject.transform.ClearDirtyUserFlag(Transform._DirtyFlagPanel);
        this.container.dirtyWT = true
    }
};
UIPanel.prototype.SetPanelAlpha = function(strValue) {
    this.alpha = _number.otod(strValue)
};
goog.provide("UHT.UIRoot");
goog.require("UHT.Component");
UIRoot.prototype = Object.create(Component.prototype);
UIRoot.prototype.constructor = UIRoot;

function UIRoot() {
    Component.call(this);
    this.scalingStyle = 0;
    this.manualWidth = 0;
    this.manualHeight = 0;
    this.minimumHeight = 0;
    this.maximumHeight = 0;
    this.fitWidth = true;
    this.fitHeight = true;
    this.adjustByDPI = false;
    this.shrinkPortraitUI = false;
    this.oldscale = -1
}
UIRoot.prototype.Update = function() {
    var intendedRatio = this.manualWidth / this.manualHeight;
    var currentRatio = UHTScreen.width / UHTScreen.height;
    var s = this.gameObject.transform.scale();
    s.x = Math.min(intendedRatio, currentRatio) / intendedRatio * 2 / this.manualHeight;
    s.y = s.x;
    if (Math.abs(this.oldscale - s.x) > UHTMath.numberError) {
        this.oldscale = s.x;
        this.gameObject.transform.scale(s)
    }
};
goog.provide("UHT.UISprite");
goog.require("UHT.Component");
UISprite.prototype = Object.create(Component.prototype);
UISprite.prototype.constructor = UISprite;

function UISprite() {
    Component.call(this);
    this.spriteName = "";
    this.spriteType = UISprite.Type.Simple;
    this.fillCenter = true;
    this.depth = 0;
    this.atlas = null;
    this.width = 0;
    this.height = 0;
    this.anchorX = 0;
    this.anchorY = 0;
    this.color = null;
    this.autoResizeBoxCollider = false;
    this.pixiObject = null;
    this.pixiObjectContent = null;
    this.panel = null;
    this.mask = null;
    this._pixiPosDirty = true;
    this.oWidth = -1;
    this.oHeight = -1;
    this.fillDirection = UISprite.FillDirection.Horizontal;
    this.fillAmount = 1;
    this.fillAmountTop = 1;
    this.fillAmountBottom =
        1;
    this.fillAmountLeft = 1;
    this.fillAmountRight = 1;
    this.invert = false;
    this.isAtlasLoaded = false;
    this.zeroScale = false
}
Object.defineProperties(UISprite.prototype, {
    "mColor": {
        get: function() {
            return this.color
        }
    }
});
UISprite.Type = {
    Simple: 0,
    Sliced: 1,
    Tiled: 2,
    Filled: 3,
    Advanced: 4
};
UISprite.FillDirection = {
    Horizontal: 0,
    Vertical: 1,
    Radial90: 2,
    Radial180: 3,
    Radial360: 4,
    Custom: 5
};
UISprite.prototype.Start = function() {
    this.SetSpriteName(this.spriteName);
    this.panel = FindPanel(this.gameObject.transform)
};
UISprite.prototype.OnWillRenderObject = function() {
    if (this.pixiObject == null) return;
    if (this.spriteType == UISprite.Type.Sliced)
        if (this.oWidth != this.width || this.oHeight != this.height) this.SetSpriteName(this.spriteName);
    var child = this.pixiObjectContent;
    var tooTransparent = this.color.a < .05 && this.atlas.blendMode == 0;
    this.pixiObject.visible = this.enabled && !tooTransparent;
    switch (this.spriteType) {
        case UISprite.Type.Simple:
        case UISprite.Type.Filled:
            child.tint = this.color.rgbAsHex;
            child.alpha = this.color.a * this.panel.alpha;
            child.worldAlpha = child.alpha;
            break;
        case UISprite.Type.Sliced:
            for (var i = 0; i < child.children.length; i++) {
                var c = child.children[i];
                c.tint = this.color.rgbAsHex;
                c.alpha = this.color.a * this.panel.alpha;
                c.worldAlpha = c.alpha
            }
            break;
        default:
            break
    }
    var hc = this.gameObject.transform;
    if (this.atlas.isLoaded() && !this.isAtlasLoaded) {
        this.isAtlasLoaded = true;
        this.pixiObject.dirtyWT = true
    }
    if (!this.pixiObject.visible) return;
    if (this.zeroScale) this.pixiObject.visible = false;
    else if (this.atlas != null) this.atlas.UseNow();
    if (!this._pixiPosDirty &&
        !hc.IsDirtyUserFlag(Transform._DirtyFlagSprite)) return;
    this.pixiObject.dirtyWT = true;
    hc._internal_get_position();
    hc._internal_get_rotation();
    hc._internal_get_scale();
    hc.ClearDirtyUserFlag(Transform._DirtyFlagSprite);
    this._pixiPosDirty = false;
    var parent = this.pixiObject;
    var hp = hc.parent.transform;
    parent.x = hp._dangerous_get_position().x;
    parent.y = -hp._dangerous_get_position().y;
    child.x = hc._dangerous_get_localPosition().x;
    child.y = -hc._dangerous_get_localPosition().y;
    parent.rotation = -hp._dangerous_get_rotation().eulerAnglesRad().z;
    child.rotation = -hc._dangerous_get_localRotation().eulerAnglesRad().z;
    switch (this.spriteType) {
        case UISprite.Type.Simple:
        case UISprite.Type.Filled:
            parent.scale.x = hp._dangerous_get_scale().x;
            parent.scale.y = hp._dangerous_get_scale().y;
            child.width = this.width * hc._dangerous_get_localScale().x;
            child.height = this.height * hc._dangerous_get_localScale().y;
            break;
        case UISprite.Type.Sliced:
            parent.scale.x = hp._dangerous_get_scale().x;
            parent.scale.y = hp._dangerous_get_scale().y;
            child.scale.x = hc._dangerous_get_localScale().x;
            child.scale.y = hc._dangerous_get_localScale().y;
            break;
        default:
            break
    }
    this.zeroScale = Math.abs(parent.scale.x * parent.scale.y) < 1E-16
};
UISprite.prototype.SetSpriteNameForAnimation = function(newName) {
    this.spriteName = newName;
    if (this.atlas != null)
        if (this.spriteType == UISprite.Type.Simple)
            if (this.pixiObject != null) {
                this.pixiObjectContent.texture = this.atlas.getTextureInfoForSprite(this, this.spriteName);
                var poc = this.pixiObjectContent;
                poc.width = this.width;
                poc.height = this.height;
                return
            }
    this.SetSpriteName(newName)
};
UISprite.prototype.SetSpriteName = function(newName) {
    if (this.panel == null) this.panel = FindPanel(this.gameObject.transform);
    this.spriteName = newName;
    this._pixiPosDirty = true;
    if (this.atlas != null) switch (this.spriteType) {
        case UISprite.Type.Simple:
            var texture = this.atlas.getTextureInfoForSprite(this, this.spriteName);
            this.pixiObject = new PIXI.Container(null);
            this.pixiObjectContent = new PIXI.Sprite(texture);
            var poc = this.pixiObjectContent;
            poc.anchor.x = this.anchorX;
            poc.anchor.y = this.anchorY;
            poc.width = this.width;
            poc.height =
                this.height;
            poc.blendMode = this.atlas.blendMode;
            this.pixiObject.addChild(poc);
            break;
        case UISprite.Type.Filled:
            var texture = this.atlas.getTextureInfoForSprite(this, this.spriteName);
            this.pixiObject = new PIXI.Container(null);
            this.pixiObjectContent = new PIXI.Sprite(texture);
            var poc = this.pixiObjectContent;
            poc.anchor.x = this.anchorX;
            poc.anchor.y = this.anchorY;
            poc.width = this.width;
            poc.height = this.height;
            poc.blendMode = this.atlas.blendMode;
            this.pixiObject.addChild(poc);
            break;
        case UISprite.Type.Sliced:
            this.pixiObject =
                new PIXI.Container(null);
            this.pixiObjectContent = new PIXI.Container(null);
            var poc = this.pixiObjectContent;
            var info = this.atlas.getTextureInfoForSprite(this, this.spriteName);
            var xOffset = (.5 - this.anchorX) * this.width;
            var yOffset = (.5 - this.anchorY) * this.height;
            var hackExtra = Renderer.IsWebGL ? 0 : 1;
            var bL = info.borderLeft;
            var bR = info.borderRight;
            var bT = info.borderTop;
            var bB = info.borderBottom;
            var pL = info.paddingLeft;
            var pR = info.paddingRight;
            var pB = info.paddingBottom;
            var pT = info.paddingTop;
            var rF = 100 / this.atlas.resize;
            bL *= rF;
            bR *= rF;
            bT *= rF;
            bB *= rF;
            pL *= rF;
            pR *= rF;
            pB *= rF;
            pT *= rF;
            var w = this.width;
            var h = this.height;
            var w2 = w / 2;
            var h2 = h / 2;
            var midw = w - bL - pL - bR - pR;
            var midh = h - bT - pT - bB - pB;
            var midw2 = midw / 2;
            var midh2 = midh / 2;
            if (bT > 0 && bL > 0) {
                var slice00 = new PIXI.Sprite(info.texture00);
                slice00.anchor.x = 1;
                slice00.anchor.y = 1;
                slice00.x = xOffset;
                slice00.y = yOffset;
                slice00.x -= w2 - bL - pL;
                slice00.y -= h2 - bT - pT;
                slice00.width = bL + pL;
                slice00.height = bT + pT;
                slice00.blendMode = this.atlas.blendMode;
                poc.addChild(slice00)
            }
            if (bT > 0) {
                var slice01 = new PIXI.Sprite(info.texture01);
                slice01.anchor.x = .5;
                slice01.anchor.y = 1;
                slice01.x = xOffset;
                slice01.y = yOffset;
                slice01.x += midw2 + bL + pL - w2;
                slice01.y -= h2 - bT - pT;
                slice01.width = midw + hackExtra;
                slice01.height = bT + pT;
                slice01.blendMode = this.atlas.blendMode;
                poc.addChild(slice01)
            }
            if (bT > 0 && bR > 0) {
                var slice02 = new PIXI.Sprite(info.texture02);
                slice02.anchor.x = 0;
                slice02.anchor.y = 1;
                slice02.x = xOffset;
                slice02.y = yOffset;
                slice02.x += w2 - bR - pR;
                slice02.y -= h2 - bT - pT;
                slice02.width = bR + pR;
                slice02.height = bT + pT;
                slice02.blendMode = this.atlas.blendMode;
                poc.addChild(slice02)
            }
            if (bL >
                0) {
                var slice10 = new PIXI.Sprite(info.texture10);
                slice10.anchor.x = 1;
                slice10.anchor.y = .5;
                slice10.x = xOffset;
                slice10.y = yOffset;
                slice10.x -= w2 - bL - pL;
                slice10.y += midh2 + bT + pT - h2;
                slice10.width = bL + pL;
                slice10.height = midh + hackExtra;
                slice10.blendMode = this.atlas.blendMode;
                poc.addChild(slice10)
            }
            if (this.fillCenter) {
                var slice11 = new PIXI.Sprite(info.texture11);
                slice11.anchor.x = .5;
                slice11.anchor.y = .5;
                slice11.x = xOffset;
                slice11.y = yOffset;
                slice11.x += midw2 + bL + pL - w2;
                slice11.y += midh2 + bT + pT - h2;
                slice11.width = midw + hackExtra;
                slice11.height =
                    midh + hackExtra;
                slice11.blendMode = this.atlas.blendMode;
                poc.addChild(slice11)
            }
            if (bR > 0) {
                var slice12 = new PIXI.Sprite(info.texture12);
                slice12.anchor.x = 0;
                slice12.anchor.y = .5;
                slice12.x = xOffset;
                slice12.y = yOffset;
                slice12.x += w2 - bR - pR;
                slice12.y += midh2 + bT + pT - h2;
                slice12.width = bR + pR;
                slice12.height = midh + hackExtra;
                slice12.blendMode = this.atlas.blendMode;
                poc.addChild(slice12)
            }
            if (bB > 0 && bL > 0) {
                var slice20 = new PIXI.Sprite(info.texture20);
                slice20.anchor.x = 1;
                slice20.anchor.y = 0;
                slice20.x = xOffset;
                slice20.y = yOffset;
                slice20.x -=
                    w2 - bL - pL;
                slice20.y += h2 - bB - pB;
                slice20.width = bL + pL;
                slice20.height = bB + pB;
                slice20.blendMode = this.atlas.blendMode;
                poc.addChild(slice20)
            }
            if (bB > 0) {
                var slice21 = new PIXI.Sprite(info.texture21);
                slice21.anchor.x = .5;
                slice21.anchor.y = 0;
                slice21.x = xOffset;
                slice21.y = yOffset;
                slice21.x += midw2 + bL + pL - w2;
                slice21.y += h2 - bB - pB;
                slice21.width = midw + hackExtra;
                slice21.height = bB + pB;
                slice21.blendMode = this.atlas.blendMode;
                poc.addChild(slice21)
            }
            if (bB > 0 && bR > 0) {
                var slice22 = new PIXI.Sprite(info.texture22);
                slice22.anchor.x = 0;
                slice22.anchor.y =
                    0;
                slice22.x = xOffset;
                slice22.y = yOffset;
                slice22.x += w2 - bR - pR;
                slice22.y += h2 - bB - pB;
                slice22.width = bR + pR;
                slice22.height = bB + pB;
                slice22.blendMode = this.atlas.blendMode;
                poc.addChild(slice22)
            }
            this.pixiObject.addChild(poc);
            this.oWidth = this.width;
            this.oHeight = this.height;
            break;
        default:
            this.pixiObject = new PIXI.Container(null);
            this.pixiObjectContent = new PIXI.Sprite(null);
            this.pixiObject.addChild(this.pixiObjectContent);
            console.error("Unhandled sprite type " + this.spriteType);
            break
    }
    if (this.autoResizeBoxCollider && this.gameObject.collider !=
        null) {
        this.gameObject.collider.size.x = this.width;
        this.gameObject.collider.size.y = this.height;
        if (this.anchorX < .4) this.gameObject.collider.center.x = this.width / 2;
        else if (this.anchorX > .6) this.gameObject.collider.center.x = -this.width / 2;
        else this.gameObject.collider.center.x = 0;
        if (this.anchorY < .4) this.gameObject.collider.center.y = -this.height / 2;
        else if (this.anchorY > .6) this.gameObject.collider.center.y = this.height / 2;
        else this.gameObject.collider.center.y = 0;
        this.gameObject.collider.UpdateCachedMembers()
    }
};
UISprite.prototype.deserialize = function(source, helper, resolveReference) {
    source["spriteType"] = source["spriteType"] != undefined ? source["spriteType"] : UISprite.Type.Simple;
    source["fillCenter"] = source["fillCenter"] != undefined ? source["fillCenter"] : true;
    source["depth"] = source["depth"] != undefined ? source["depth"] : 0;
    source["anchorX"] = source["anchorX"] != undefined ? source["anchorX"] : .5;
    source["anchorY"] = source["anchorY"] != undefined ? source["anchorY"] : .5;
    source["fillDirection"] = source["fillDirection"] != undefined ?
        source["fillDirection"] : UISprite.FillDirection.Vertical;
    source["fillAmount"] = source["fillAmount"] != undefined ? source["fillAmount"] : 1;
    source["fillAmountTop"] = source["fillAmountTop"] != undefined ? source["fillAmountTop"] : 1;
    source["fillAmountBottom"] = source["fillAmountBottom"] != undefined ? source["fillAmountBottom"] : 1;
    source["fillAmountLeft"] = source["fillAmountLeft"] != undefined ? source["fillAmountLeft"] : 1;
    source["fillAmountRight"] = source["fillAmountRight"] != undefined ? source["fillAmountRight"] : 1;
    source["invert"] =
        source["invert"] != undefined ? source["invert"] : false;
    source["autoResizeBoxCollider"] = source["autoResizeBoxCollider"] != undefined ? source["autoResizeBoxCollider"] : false;
    if (source["color"] == undefined) {
        source["color"] = {};
        source["color"]["nestedFieldType"] = "Color";
        source["color"]["serializableData"] = {};
        source["color"]["serializableData"]["c"] = "w"
    }
    deserializeComponentRec(source, this, helper, resolveReference)
};
goog.provide("UHT.UIZoomSprite");
goog.require("UHT.UISprite");
UIZoomSprite.prototype = Object.create(UISprite.prototype);
UIZoomSprite.prototype.constructor = UIZoomSprite;

function UIZoomSprite() {
    UISprite.call(this);
    this.zoomAmmount = .5;
    this.zoomPivot = new UHTMath.Vector3;
    this.rectFrameO = null;
    this.rectCropO = null;
    this.rectTrimO = null
}
UIZoomSprite.prototype.GetClampedPivot = function() {
    var clampedZoomPivot = {
        x: this.zoomPivot.x,
        y: this.zoomPivot.y
    };
    var pivot_margin = .5 - Math.abs((1 - this.zoomAmmount) / 2 - .5);
    if (this.zoomPivot.x < pivot_margin) clampedZoomPivot.x = pivot_margin;
    if (this.zoomPivot.x > 1 - pivot_margin) clampedZoomPivot.x = 1 - pivot_margin;
    if (this.zoomPivot.y < pivot_margin) clampedZoomPivot.y = pivot_margin;
    if (this.zoomPivot.y > 1 - pivot_margin) clampedZoomPivot.y = 1 - pivot_margin;
    return clampedZoomPivot
};
UIZoomSprite.prototype.ComputeTexture = function() {
    var zoom = Math.max(.001, 1 - this.zoomAmmount);
    var rectFrame = this.rectFrameO.clone();
    var rectTrim = this.rectTrimO.clone();
    var borderW = rectTrim.width - rectFrame.width;
    var borderH = rectTrim.height - rectFrame.height;
    rectTrim.x *= zoom;
    rectTrim.y *= zoom;
    rectTrim.width *= zoom;
    rectTrim.height *= zoom;
    rectFrame.width *= zoom;
    rectFrame.height *= zoom;
    var pivot = this.GetClampedPivot();
    var offsetX = pivot.x * this.rectFrameO.width - rectFrame.width * .5;
    var offsetY = (1 - pivot.y) * this.rectFrameO.height -
        rectFrame.height * .5;
    rectFrame.x += offsetX;
    rectFrame.y += offsetY;
    var rectCrop = rectFrame.clone();
    var poc = this.pixiObjectContent;
    poc.texture.trim = rectTrim;
    poc.texture.crop = rectCrop;
    poc.texture.frame = rectFrame
};
UIZoomSprite.prototype.OnWillRenderObject = function() {
    UISprite.prototype.OnWillRenderObject.call(this);
    this.ComputeTexture();
    var poc = this.pixiObjectContent;
    var hc = this.gameObject.transform;
    poc.width = this.width * hc._dangerous_get_localScale().x;
    poc.height = this.height * hc._dangerous_get_localScale().y;
    this.pixiObject.dirtyWT = true
};
UIZoomSprite.prototype.SetSpriteName = function(newName) {
    UISprite.prototype.SetSpriteName.call(this, newName);
    var poc = this.pixiObjectContent;
    this.rectFrameO = poc.texture.crop.clone();
    this.rectCropO = poc.texture.crop.clone();
    this.rectTrimO = poc.texture.trim.clone();
    poc.texture = new PIXI.Texture(poc.texture, this.rectFrameO.clone(), this.rectCropO.clone(), this.rectTrimO.clone())
};
goog.provide("UHT.Renderer");
goog.require("UHT.UILabel");
goog.require("UHT.UISprite");
goog.require("UHT.UIZoomSprite");
goog.require("UHT.Camera");
goog.require("UHT.UHTScreen");
var UHT_DEBUG_TEXT = null;
var PRESERVE_RB_LIST = [{
    vendor: "Huawei",
    model: "ALE-L21"
}];
var FORCE_CANVAS_LIST = [];
var CachedFrameCount = -1;

function Renderer() {
    this.renderer = null;
    this.stage = null;
    this.orderedCameras = [];
    this.foundCameras = [];
    this.cachedCameraContainersPerLayer = {};
    this.cachedMaskCameraContainersPerLayer = {};
    this.foundPanels = [];
    this.foundZOrderedObjects = [];
    this.RTunder = null;
    this.rtUnderSprite = null;
    this.RTmask = null;
    this.RTclipped = null;
    this.rtCameraSprite = null;
    this.RTfinal = null;
    this.rtFinalSprite = null;
    this.hasMaskedCameras = false;
    this.fpsCounter = null;
    this.debugText = null;
    this.clipMaskFilter = null;
    this.MaskResize = .5
}
Renderer.IsWebGL = false;
var renderCanvas;
var rememberedWindowWidth = -1;
var rememberedWindowHeight = -1;
var canvasSizeDirty = false;
Renderer.prototype.checkWindowSize = function() {
    if (rememberedWindowWidth != window.innerWidth) {
        rememberedWindowWidth = window.innerWidth;
        canvasSizeDirty = true
    }
    if (rememberedWindowHeight != window.innerHeight) {
        rememberedWindowHeight = window.innerHeight;
        canvasSizeDirty = true
    }
};
Renderer.prototype.resizeUHTScreen = function() {
    var PixelRatio = window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI;
    if (UHT_DEVICE_TYPE.DESKTOP == true)
        if (PixelRatio > 1.5) PixelRatio = 1.5;
    if (PixelRatio > 2) PixelRatio = 2;
    UHTScreen.width = Math.floor(rememberedWindowWidth * PixelRatio);
    UHTScreen.height = Math.floor(rememberedWindowHeight * PixelRatio);
    if (createjs.BrowserDetect.isIOS) {
        document.body.style.width = rememberedWindowWidth + "px";
        if (UHT_UA_INFO.browser.name == "Chrome") {
            renderCanvas.style.width =
                rememberedWindowWidth + "px";
            renderCanvas.style.height = rememberedWindowHeight + "px"
        }
    }
    canvasSizeDirty = false
};
Renderer.prototype.init = function() {
    renderCanvas = document.createElement("canvas");
    renderCanvas.style.width = "100%";
    renderCanvas.style.height = "100%";
    this.checkWindowSize();
    this.resizeUHTScreen();
    var mustPreserveDrawingBuffer = false;
    var forceCanvas = navigator.userAgent.indexOf("forceCanvas") > -1;
    var parser = new UAParser2;
    var device = parser.getDevice();
    if (device.vendor != undefined && device.model != undefined) {
        var vendor = device.vendor;
        var model = device.model;
        if (vendor != "Apple") mustPreserveDrawingBuffer = true;
        for (var j =
                0; j < FORCE_CANVAS_LIST.length; j++)
            if (vendor.toUpperCase().indexOf(FORCE_CANVAS_LIST[j].vendor.toUpperCase()) == 0)
                if (model.toUpperCase().indexOf(FORCE_CANVAS_LIST[j].model.toUpperCase()) == 0) forceCanvas = true
    }
    var renderOptions = {
        view: renderCanvas,
        resolution: 1,
        antialias: false,
        forceFXAA: false,
        autoResize: false,
        transparent: true,
        backgroundColor: 0,
        clearBeforeRender: false,
        preserveDrawingBuffer: mustPreserveDrawingBuffer
    };
    if (IS_UCBROWSER) PIXI.SPRITE_BATCH_SIZE = 200;
    this.renderer = PIXI.autoDetectRenderer(UHTScreen.width,
        UHTScreen.height, renderOptions, forceCanvas);
    Renderer.IsWebGL = this.renderer instanceof PIXI.WebGLRenderer;
    console.log("[Init] Screen size: (" + UHTScreen.width + "x" + UHTScreen.height + ")");
    document.body.appendChild(this.renderer.view);
    var fpsTextStyle = {
        font: "30px Arial",
        fill: "#000000",
        stroke: "#FFFFFF",
        strokeThickness: 5
    };
    this.fpsCounter = new PIXI.Text("urs", fpsTextStyle);
    var debugTextStyle = {
        font: "100px Arial",
        fill: "#FFFFFF",
        stroke: "#000000",
        strokeThickness: 25
    };
    this.debugText = new PIXI.Text("dbg", debugTextStyle)
};
Renderer.prototype.initMaskTextures = function() {
    this.RTunder = new PIXI.RenderTexture(this.renderer, this.renderer.width, this.renderer.height);
    this.RTmask = new PIXI.RenderTexture(this.renderer, this.renderer.width * this.MaskResize, this.renderer.height * this.MaskResize);
    this.RTclipped = new PIXI.RenderTexture(this.renderer, this.renderer.width, this.renderer.height);
    this.RTfinal = new PIXI.RenderTexture(this.renderer, this.renderer.width, this.renderer.height);
    this.clipMaskFilter = new CLIPMASKFilter(this.RTunder, this.RTmask);
    this.initMaskSprites()
};
Renderer.prototype.initMaskSprites = function() {
    this.rtUnderSprite = new PIXI.Sprite(this.RTunder);
    this.rtUnderSprite.worldAlpha = 1;
    this.rtCameraSprite = new PIXI.Sprite(this.RTclipped);
    this.rtCameraSprite.worldAlpha = 1;
    this.rtCameraSprite.filters = [this.clipMaskFilter];
    this.rtFinalSprite = new PIXI.Sprite(this.RTfinal);
    this.rtFinalSprite.worldAlpha = 1
};
Renderer.prototype.doFrame = function() {
    PIXI.SpriteRenderer.SRVBidx = 0;
    CachedFrameCount = Time.frameCount;
    var dirtyStage = false;
    if (this.renderer.view.width != UHTScreen.width || this.renderer.view.height != UHTScreen.height) {
        this.renderer.resize(UHTScreen.width, UHTScreen.height);
        if (this.hasMaskedCameras) {
            this.RTunder.resize(UHTScreen.width, UHTScreen.height, true);
            this.RTfinal.resize(UHTScreen.width, UHTScreen.height, true);
            this.RTmask.resize(UHTScreen.width * this.MaskResize, UHTScreen.height * this.MaskResize, true);
            this.RTclipped.resize(UHTScreen.width, UHTScreen.height, true);
            this.initMaskSprites()
        }
        dirtyStage = true;
        console.log("[Resized] Screen size: (" + UHTScreen.width + "x" + UHTScreen.height + ")")
    }
    this.orderedCameras = [];
    this.foundCameras = [];
    this.foundPanels = [];
    this.foundZOrderedObjects = [];
    this.ParseRenderableComponents();
    this.orderedCameras = this.foundCameras.sort(function(a, b) {
        return a.depth - b.depth
    });
    for (var idxPanel = 0; idxPanel < this.foundPanels.length; idxPanel++)
        if (this.foundPanels[idxPanel].container.children.length >
            0) this.registerPanel(this.foundPanels[idxPanel]);
    for (var j = 0; j < this.orderedCameras.length; j++) SortPixiChildren(this.orderedCameras[j].container);
    this.addZOrderedObjects();
    if (this.stage == null) this.stage = new PIXI.Container;
    if (dirtyStage) this.stage.dirtyWT = true;
    this.stage.children = [];
    this.stage.dirtyChildren = true;
    for (var ic = 0; ic < this.orderedCameras.length; ic++) {
        var cam = this.orderedCameras[ic];
        if (!cam.HasClippingMask()) {
            if (cam.container.children.length > 0) this.stage.addChild(cam.container)
        } else {
            if (!this.hasMaskedCameras) {
                this.hasMaskedCameras =
                    true;
                this.initMaskTextures()
            }
            this.RTunder.render(this.stage);
            this.stage.children = [];
            this.stage.dirtyChildren = true;
            this.stage.addChild(this.rtUnderSprite);
            this.stage.addChild(cam.container);
            this.RTclipped.render(this.stage);
            this.stage.children = [];
            this.stage.dirtyChildren = true;
            var osX = cam.clipMaskContainer.scale.x;
            var osY = cam.clipMaskContainer.scale.y;
            var opX = cam.clipMaskContainer.position.x;
            var opY = cam.clipMaskContainer.position.y;
            this.stage.addChild(cam.clipMaskContainer);
            cam.clipMaskContainer.scale.x *=
                this.MaskResize;
            cam.clipMaskContainer.scale.y *= this.MaskResize;
            cam.clipMaskContainer.position.x *= this.MaskResize;
            cam.clipMaskContainer.position.y *= this.MaskResize;
            this.RTmask.clear();
            this.RTmask.render(this.stage);
            cam.clipMaskContainer.scale.x = osX;
            cam.clipMaskContainer.scale.y = osY;
            cam.clipMaskContainer.position.x = opX;
            cam.clipMaskContainer.position.y = opY;
            this.stage.children = [];
            this.stage.dirtyChildren = true;
            this.stage.addChild(this.rtCameraSprite);
            this.RTfinal.render(this.stage);
            this.stage.children = [];
            this.stage.dirtyChildren = true;
            this.stage.addChild(this.rtFinalSprite)
        }
    }
    if (UHT_DEBUG) this.stage.addChild(this.fpsCounter);
    if (window["UHT_DEBUG_TEXT"] != null) {
        this.debugText.text = UHT_DEBUG_TEXT;
        this.stage.addChild(this.debugText)
    }
    globalColliderInputManager.pixiObject.dirtyWT = true;
    this.stage.addChild(globalColliderInputManager.pixiObject);
    this.renderer.render(this.stage);
    Camera.allCameras = this.orderedCameras;
    UIAtlas.CheckUsageAndClean();
    UILabel.CheckUsageAndClean()
};
Renderer.prototype.ParseRenderableComponents = function() {
    var list = globalRuntime.onWillRenderList.components;
    for (var i = 0; i < list.length; i++) {
        var cur = list[i];
        if (cur == null) continue;
        if ((cur instanceof UISprite || cur instanceof UILabel || cur instanceof MovieController || cur instanceof SpineController) && cur.pixiObject != null) {
            if (cur.panel != null) RegisterPixiChild(cur.panel.container, cur.pixiObject, cur.depth)
        } else if (cur instanceof UIPanel) this.foundPanels.push(cur);
        else if (cur instanceof Camera) {
            cur.container.children = [];
            cur.clipMaskContainer.children = [];
            this.foundCameras.push(cur)
        } else if (cur["pixiZOrderedContainer"] != undefined) this.foundZOrderedObjects.push(cur);
        if (cur["OnUpdateRenderTexture"] != undefined) cur.OnUpdateRenderTexture()
    }
    for (var j = 0; j < this.foundPanels.length; j++) SortPixiChildren(this.foundPanels[j].container)
};
Renderer.prototype.registerPanel = function(panel) {
    var pLayer = panel.gameObject.layer;
    var camContainer = this.cachedCameraContainersPerLayer[pLayer];
    if (camContainer) RegisterPixiChild(camContainer, panel.container, panel.depth);
    else {
        var cameraIndex = this.getCameraIndexForLayer(pLayer);
        if (cameraIndex >= 0) {
            camContainer = this.orderedCameras[cameraIndex].container;
            RegisterPixiChild(camContainer, panel.container, panel.depth);
            this.cachedCameraContainersPerLayer[pLayer] = camContainer
        }
    }
    camContainer = this.cachedMaskCameraContainersPerLayer[pLayer];
    if (camContainer) RegisterPixiChild(camContainer, panel.container, panel.depth);
    else {
        var cameraClipMaskIndex = this.getCameraClipMaskIndexForLayer(pLayer);
        if (cameraClipMaskIndex >= 0) {
            camContainer = this.orderedCameras[cameraClipMaskIndex].clipMaskContainer;
            RegisterPixiChild(camContainer, panel.container, panel.depth);
            this.cachedMaskCameraContainersPerLayer[pLayer] = camContainer
        }
    }
};
Renderer.prototype.getCameraIndexForLayer = function(layer) {
    for (var i = 0; i < this.orderedCameras.length; i++) {
        var mask = this.orderedCameras[i].cullingMask;
        if (1 << layer == mask) return i
    }
    return -1
};
Renderer.prototype.getCameraClipMaskIndexForLayer = function(layer) {
    for (var i = 0; i < this.orderedCameras.length; i++) {
        var mask = this.orderedCameras[i].clipMaskLayer;
        if (1 << layer == mask) return i
    }
    return -1
};
Renderer.prototype.addZOrderedObjects = function() {
    if (this.foundZOrderedObjects.length == 0) return;
    var zOrderedArr = new Array(this.orderedCameras.length);
    for (var j = 0; j < this.foundZOrderedObjects.length; j++) {
        var cur = this.foundZOrderedObjects[j];
        var camIndex = this.getCameraIndexForLayer(cur.gameObject.layer);
        if (zOrderedArr[camIndex] == undefined) zOrderedArr[camIndex] = [];
        zOrderedArr[camIndex].push(cur)
    }
    for (var k = 0; k < zOrderedArr.length; k++)
        if (zOrderedArr[k] != undefined) {
            var arr = zOrderedArr[k];
            arr.sort(function(a,
                b) {
                return a.gameObject.transform._dangerous_get_position().z > b.gameObject.transform._dangerous_get_position().z
            });
            var indexInCamera = 0;
            var camChildren = this.orderedCameras[k].container.children;
            for (var p = 0; p < camChildren.length; p++)
                if (camChildren[p][uhtDepth] < 0) indexInCamera++;
            for (var m = arr.length - 1; m >= 0; m--) {
                arr[m].pixiZOrderedContainer.dirtyWT = true;
                this.orderedCameras[k].container.addChildAt(arr[m].pixiZOrderedContainer, indexInCamera)
            }
            this.orderedCameras[k].container.dirtyChildren = true
        }
};
Renderer.prototype.setFPSCount = function(newfps) {
    if (this.fpsCounter != null && UHT_DEBUG) {
        var build = [UHT_REVISION.common, UHT_REVISION.desktop, UHT_REVISION.mobile, UHT_BUILD_PATH].join(", ");
        build = [" (", build, ")"].join("");
        var configs = [" (configs: ", ServerOptions.configs || "-", ")"].join("");
        var rendererType = Renderer.IsWebGL ? "webgl" : "canvas";
        var parser = new UAParser2;
        var device = parser.getDevice();
        var browser = parser.getBrowser();
        var vendor_model = "";
        if (device.vendor != undefined && device.model != undefined && browser.name !=
            undefined) {
            var vendor = device.vendor;
            var model = device.model;
            vendor_model = "[" + vendor + ":" + model + ":" + browser.name + "] ";
            for (var i = 0; i < PRESERVE_RB_LIST.length; i++)
                if (vendor.toUpperCase().indexOf(PRESERVE_RB_LIST[i].vendor.toUpperCase()) == 0)
                    if (model.toUpperCase().indexOf(PRESERVE_RB_LIST[i].model.toUpperCase()) == 0) vendor_model = "[" + vendor + ":" + model + "(PRB)] "
        }
        this.fpsCounter.text = Number(newfps).toFixed(1) + " fps (" + rendererType + ") " + vendor_model + build + configs
    }
};
var uhtDepth = "uht_depth";
var uhtFC = "uht_fc";

function SortPixiChildren(container) {
    container.children.sort(SortByUhtDepth)
}

function SortByUhtDepth(a, b) {
    return a[uhtDepth] - b[uhtDepth]
}

function RegisterPixiChild(parent, child, depth) {
    if (!child.visible) return;
    if (child[uhtFC] != CachedFrameCount - 1) child.dirtyWT = true;
    child[uhtDepth] = depth;
    child.parent = parent;
    if (child.dirtyWT != false || child.dirtyChildren == true) parent.dirtyChildren = true;
    child[uhtFC] = CachedFrameCount;
    parent.children.push(child)
}
CLIPMASKFilter.prototype = Object.create(PIXI.AbstractFilter.prototype);
CLIPMASKFilter.prototype.constructor = CLIPMASKFilter;

function CLIPMASKFilter(underTexture, maskTexture) {
    PIXI.AbstractFilter.call(this, null, ["#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "#else", "precision mediump float;", "#endif", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "uniform sampler2D UnderMap;", "uniform sampler2D MaskMap;", "void main(void)", "{", "vec3 col = texture2D(uSampler, vTextureCoord).rgb * vColor.rgb;", "vec3 under = texture2D(UnderMap, vTextureCoord).rgb;", "vec4 mask = texture2D(MaskMap, vTextureCoord);",
        "vec3 clipped = col * mask.rgb;", "gl_FragColor = vec4(mix(under, clipped, mask.a), 1);", "} "
    ].join("\n"), {
        UnderMap: {
            type: "sampler2D",
            value: underTexture
        },
        MaskMap: {
            type: "sampler2D",
            value: maskTexture
        }
    })
}
goog.provide("UHT.UIUtils");

function FindPanel(transform) {
    var tr = transform;
    while (tr != null) {
        var panel = tr.gameObject.GetComponent(UIPanel);
        if (panel != null) return panel;
        else tr = tr.parent
    }
    console.error("Panel not found for " + transform.gameObject.name);
    return null
}
var AnnouncementAPI = {};
AnnouncementAPI.Keys = {
    error: "error",
    announcements: "announcements",
    typeId: "typeId",
    message: "message"
};
AnnouncementAPI.ErrorCode = {
    Undefined: -1,
    None: 0,
    InvalidParameter: 1,
    AuthenticationError: 2,
    ServiceError: 100
};
AnnouncementAPI.AnnouncementType = {
    Undefined: 0,
    CommunityJackpotWin: 1,
    TournamentCoinsWin: 2,
    TournamentGiftWin: 3,
    TournamentBetMultiplierWin: 4,
    TournamentFRNWin: 5,
    TournamentFRTWin: 6
};
AnnouncementAPI.AnnouncementTypeConverter = {};
AnnouncementAPI.AnnouncementTypeConverter.types = ["Undefined", "WCJP", "WTC", "WTG", "WTBM", "WTFR", "WTFRT"];
AnnouncementAPI.AnnouncementTypeConverter.Convert = function(type) {
    var idx = AnnouncementAPI.AnnouncementTypeConverter.types.indexOf(type);
    return idx > -1 ? idx : AnnouncementAPI.AnnouncementType.Undefined
};
AnnouncementAPI.Announcement = function() {
    this.type = AnnouncementAPI.AnnouncementType.Undefined;
    this.message = "";
    this.extraWin = 0
};
AnnouncementAPI.Response = function(response) {
    this.error = AnnouncementAPI.ErrorCode.Undefined;
    this.dictionary = null;
    if (response != undefined) this.error = response.error
};
AnnouncementAPI.UnreadResponse = function(response) {
    AnnouncementAPI.Response.call(this, response);
    this.announcements = null
};
AnnouncementAPI.UnreadResponse.prototype = Object.create(AnnouncementAPI.Response.prototype);
AnnouncementAPI.UnreadResponse.prototype.constructor = AnnouncementAPI.UnreadResponse;
AnnouncementAPI.Parser = {};
AnnouncementAPI.Parser.formatOptions = null;
AnnouncementAPI.Parser.ParseResponse = function(json) {
    if (_string.IsNullOrEmpty(json)) return null;
    var Keys = AnnouncementAPI.Keys;
    var ErrorCode = AnnouncementAPI.ErrorCode;
    var Response = AnnouncementAPI.Response;
    var dict = _JSON.TryParse(json);
    if (dict == null || dict[Keys.error] == undefined) return null;
    var res = new Response;
    res.dictionary = dict;
    var error = Number(dict[Keys.error]);
    for (var key in ErrorCode)
        if (ErrorCode.hasOwnProperty(key) && ErrorCode[key] == error) {
            res.error = ErrorCode[key];
            break
        }
    if (res.error != ErrorCode.None) return null;
    return res
};
AnnouncementAPI.Parser.ParseUnreadResponse = function(json) {
    var Parser = AnnouncementAPI.Parser;
    var Keys = AnnouncementAPI.Keys;
    var UnreadResponse = AnnouncementAPI.UnreadResponse;
    var response = Parser.ParseResponse(json);
    if (response == null) return null;
    var dict = response.dictionary;
    if (dict[Keys.announcements] == undefined) return null;
    var res = new UnreadResponse(response);
    res.announcements = Parser.ParseAnnouncements(dict[Keys.announcements]);
    return res
};
AnnouncementAPI.Parser.ParseAnnouncements = function(list) {
    if (list == null) return null;
    var Keys = AnnouncementAPI.Keys;
    var Announcement = AnnouncementAPI.Announcement;
    var AnnouncementTypeConverter = AnnouncementAPI.AnnouncementTypeConverter;
    var res = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null || dict[Keys.typeId] == undefined || dict[Keys.message] == undefined) continue;
        var item = new Announcement;
        item.type = AnnouncementTypeConverter.Convert(String(dict[Keys.typeId]));
        item.message = AnnouncementAPI.Parser.ParseAnnouncementMessage(String(dict[Keys.message]),
            item);
        res.push(item)
    }
    return res
};
AnnouncementAPI.Parser.ParseAnnouncementMessage = function(value, item) {
    var regex = new RegExp("(\\[(.*?)\\])");
    var match = value.match(regex);
    while (match != null) {
        if (match.length > 2) {
            item.extraWin = _number.otod(match[2]);
            value = value.replace(match[1], LocaleManager.FormatValue(item.extraWin, AnnouncementAPI.Parser.formatOptions))
        }
        match = value.match(regex)
    }
    return value.replace(new RegExp("<br/>", "g"), "\n")
};
var AnnouncementVars = {
    Announcement: "Announcement",
    Evt_Internal_ShowAnnouncement: "Evt_Internal_ShowAnnouncement",
    Evt_Internal_AnnouncementHandled: "Evt_Internal_AnnouncementHandled",
    Evt_DataToCode_AnnouncementShown: "Evt_DataToCode_AnnouncementShown",
    Evt_Internal_AnnouncementsShown: "Evt_Internal_AnnouncementsShown"
};

function AnnouncementConnection() {
    this.isInit = false;
    this.unreadUrl = "/gs2c/announcements/unread/";
    this.unreadInterval = 120;
    this.unreadTimer = 120;
    this.isReloadindUnread = false;
    this.unreadReloadedHandler = new EventHandler(this, this.OnUnreadReloaded);
    this.resultLoopStartsPriority = -999;
    this.resultQueue = null;
    this.announcements = []
}
AnnouncementConnection.prototype.Init = function() {
    this.isInit = true;
    var args = _array.create(2);
    args[0] = GameProtocolDictionary.symbol + "=" + ServerOptions.gameSymbol;
    args[1] = GameProtocolDictionary.mgckey + "=" + ServerOptions.mgckey;
    var query = args.join("&");
    this.unreadUrl = ServerOptions.serverUrl + this.unreadUrl;
    this.unreadUrl += this.QueryPrefix(this.unreadUrl) + query;
    AnnouncementAPI.Parser.formatOptions = new FormatOptions;
    XT.RegisterCallbackEvent(Vars.Evt_Internal_InjectRQIOnResultDisplayerLoopStarts, this.OnInjectResultLoopStarts,
        this, this.resultLoopStartsPriority);
    XT.RegisterCallbackEvent(AnnouncementVars.Evt_Internal_AnnouncementHandled, this.OnAnnouncementHandled, this);
    XT.RegisterCallbackEvent(AnnouncementVars.Evt_DataToCode_AnnouncementShown, this.NextAnnouncement, this)
};
AnnouncementConnection.prototype.OnInjectResultLoopStarts = function() {
    if (this.announcements.length == 0) return;
    var respinData = XT.GetObject(Vars.RespinData);
    if (!(respinData == null || respinData.IsDone)) return;
    var freeSpinData = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (freeSpinData != null && freeSpinData.IsFreeSpin) return;
    if (this.resultQueue == null) this.resultQueue = XT.GetObject(Vars.RQManagerObject);
    this.resultQueue.AddRoutineQueueItem(new RQITriggerCallback(this.OnResultLoopStarts, null, this));
    this.resultQueue.AddRoutineQueueItem(new RQIWaitForXTEvent(AnnouncementVars.Evt_Internal_AnnouncementsShown))
};
AnnouncementConnection.prototype.OnResultLoopStarts = function(param) {
    this.NextAnnouncement()
};
AnnouncementConnection.prototype.NextAnnouncement = function() {
    if (this.announcements.length == 0) {
        XT.TriggerEvent(AnnouncementVars.Evt_Internal_AnnouncementsShown);
        return
    }
    var count = this.announcements.length;
    XT.SetObject(AnnouncementVars.Announcement, this.announcements[0]);
    XT.TriggerEvent(AnnouncementVars.Evt_Internal_ShowAnnouncement);
    if (count == this.announcements.length) {
        this.OnAnnouncementHandled();
        this.NextAnnouncement()
    }
};
AnnouncementConnection.prototype.OnAnnouncementHandled = function() {
    this.announcements.splice(0, 1)
};
AnnouncementConnection.prototype.QueryPrefix = function(url) {
    return url.indexOf("?") > -1 ? "&" : "?"
};
AnnouncementConnection.prototype.ReloadUnread = function() {
    var req = new ServerRequest;
    req.Url = this.unreadUrl;
    req.Handler = this.unreadReloadedHandler;
    req.Method = "GET";
    RequestManager.AddRequest(req)
};
AnnouncementConnection.prototype.OnUnreadReloaded = function(param, statusCode) {
    this.unreadTimer = 0;
    this.isReloadindUnread = false;
    var response = AnnouncementAPI.Parser.ParseUnreadResponse(param);
    if (response == null) return;
    _array.AddRange(this.announcements, response.announcements)
};
AnnouncementConnection.prototype.Update = function() {
    if (!this.isInit) return;
    if (this.unreadTimer > this.unreadInterval && !this.isReloadindUnread) {
        this.isReloadindUnread = true;
        this.ReloadUnread()
    }
    this.unreadTimer += Time.deltaTime
};
goog.require("UHT.Component");
CATButton.prototype = Object.create(Component.prototype);
CATButton.prototype.constructor = CATButton;

function CATButton() {
    Component.call(this);
    this.catEventPress = null;
    this.catEventRelease = null;
    this.catEventClick = null;
    this.catEventHoverOn = null;
    this.catEventHoverOff = null;
    this.holdTimer = 1;
    this.catEventHold = null;
    this.holdTriggerDelay = 0;
    this.isHeld = false;
    this.wasHoldEvent = false;
    this.wasHover = false
}
CATButton.prototype.OnDisable = function() {
    this.OnPress(false)
};
CATButton.prototype.OnClick = function() {
    if (!this.wasHoldEvent && this.catEventClick != null && this.catEventClick.cat != null) {
        if (this.catEventClick.cat.IsEventRunning(this.catEventClick.id)) return;
        var cd = this.gameObject.GetComponent(ClickDelay);
        if (cd == null || cd.CanClick()) this.catEventClick.Start()
    }
};
CATButton.prototype.OnHover = function(isOver) {
    if (isOver) {
        if (this.catEventHoverOn != null && this.catEventHoverOn.cat != null) {
            if (this.catEventHoverOn.cat.IsEventRunning(this.catEventHoverOn.id)) return;
            this.catEventHoverOn.Start()
        }
        this.wasHover = true
    } else {
        if (this.catEventHoverOff != null && this.catEventHoverOff.cat != null) {
            if (this.catEventHoverOff.cat.IsEventRunning(this.catEventHoverOff.id)) return;
            this.catEventHoverOff.Start()
        }
        this.wasHover = false
    }
};
CATButton.prototype.OnPress = function(isPressed) {
    if (isPressed) {
        if (this.catEventPress != null && this.catEventPress.cat != null && !this.catEventPress.cat.IsEventRunning(this.catEventPress.id)) this.catEventPress.Start();
        if (this.catEventHold != null && this.catEventHold.cat != null && !this.catEventHold.cat.IsEventRunning(this.catEventHold.id)) {
            this.isHeld = true;
            this.wasHoldEvent = false;
            this.holdTriggerDelay = this.holdTimer
        }
    } else {
        this.isHeld = false;
        if (this.catEventRelease != null && this.catEventRelease.cat != null && !this.catEventRelease.cat.IsEventRunning(this.catEventRelease.id)) this.catEventRelease.Start();
        if (this.wasHover) this.OnHover(false)
    }
};
CATButton.prototype.Update = function() {
    if (this.isHeld)
        if (this.holdTriggerDelay > 0) this.holdTriggerDelay -= Time.deltaTime;
        else {
            this.catEventHold.Start();
            this.isHeld = false;
            this.wasHoldEvent = true
        }
};

function CATLink() {
    this.id = 0;
    this.cat = null
}
CATLink.prototype.Start = function() {
    if (this.cat != null) this.cat.StartEvent(this.id)
};
CATLink.prototype.Stop = function() {
    if (this.cat != null) this.cat.StopEvent(this.id)
};
CATLink.prototype.IsRunning = function() {
    if (this.cat != null) return this.cat.IsEventRunning(this.id);
    else return false
};
CATLink.prototype.RegisterCallback = function(newCallback, object) {
    if (this.cat != null) this.cat.RegisterCallback(this.id, newCallback, object)
};
CATLink.prototype.UnregisterCallback = function(toRemoveCallback, object) {
    if (this.cat != null) this.cat.UnregisterCallback(this.id, toRemoveCallback, object)
};
goog.require("UHT.Component");
CAT_Infector.prototype = Object.create(Component.prototype);
CAT_Infector.prototype.constructor = CAT_Infector;

function CAT_Infector() {
    Component.call(this);
    this.infections = []
}
CAT_Infector.prototype.Awake = function() {
    this.SpreadInfectionInScene()
};
CAT_Infector.prototype.SpreadInfectionInScene = function() {
    for (var i = 0; i < this.infections.length; i++) {
        var evtInfection = this.infections[i];
        var catGO = globalRuntime.sceneRoots[1].transform.Find(evtInfection.hostCATPath.slice((globalRuntime.sceneRoots[1].name + "/").length));
        var cat = null;
        if (catGO != null) cat = catGO.GetComponent(CAT_Container);
        if (cat != null) this.Infect(evtInfection, cat)
    }
};
CAT_Infector.prototype.Infect = function(evtInfection, hostCat) {
    if (evtInfection.parasiteLink != null && evtInfection.parasiteLink.cat != null && evtInfection.parasiteLink.cat.GetEventByID(evtInfection.parasiteLink.id) != null)
        for (var i = 0; i < hostCat.events.length; i++)
            if (hostCat.events[i].id == evtInfection.hostCATEventID) {
                hostCat.events[i].actions.push(evtInfection.AsCatAction());
                evtInfection.infectedHost = hostCat;
                break
            }
};

function EventInfection() {
    this.hostCATPath = "";
    this.hostCATEventID = 0;
    this.infectedHost = null;
    this.parasiteLink = null
}
EventInfection.prototype.AsCatAction = function() {
    var actionCATLink = new CAT_Action_CATLink;
    actionCATLink.actionType = CAT_Action_CATLink.ActionType.StartEvent_NoWait;
    actionCATLink.eventId = this.parasiteLink;
    return actionCATLink
};
goog.provide("UHT.CAT_Event");

function CAT_Event() {
    this.id = 0;
    this.userFriendlyName = "";
    this.actions = [];
    this.playAutomatically = false;
    this.timeScaleID = "";
    this.startTime = -1;
    this.curTime = -1;
    this.callback = [];
    this.isRunning = false;
    this.parent = null;
    this.isEnabled = true
}
CAT_Event.prototype.Start = function() {
    if (!this.isEnabled) return;
    if (this.isRunning) {
        console.log("xCAT: Trying to start an event twice! Aborting! (name = '" + this.userFriendlyName + "', running_time = " + (this.curTime - this.startTime) + ")");
        return
    }
    var finishedCount = 0;
    for (var i in this.actions) {
        var a = this.actions[i];
        if (a.isEnabled)
            if (a.delay <= .001) {
                a.ChangeState(CATState.Running);
                if (a.GetState() == CATState.Finished) finishedCount++
            } else a.ChangeState(CATState.Waiting);
        else {
            a.ChangeState(CATState.Finished);
            finishedCount++
        }
    }
    this.startTime =
        this.curTime = Time.time;
    this.isRunning = true;
    this.parent.AddRunningEvent(this);
    this.InternalUpdateRunningState(finishedCount)
};
CAT_Event.prototype.Stop = function() {
    var finishedCount = 0;
    for (var i in this.actions) {
        var a = this.actions[i];
        if (a.GetState() == CATState.Running) {
            a.ChangeState(CATState.Stopping);
            if (a.GetState() == CATState.Finished) finishedCount++
        } else if (a.GetState() == CATState.Waiting) {
            a.ChangeState(CATState.Finished);
            finishedCount++
        } else if (a.GetState() == CATState.Finished) finishedCount++
    }
    this.InternalUpdateRunningState(finishedCount)
};
CAT_Event.prototype.Update = function() {
    var finishedCount = 0;
    this.curTime += TimeScaler.GetDeltaTime(this.timeScaleID);
    for (var i in this.actions) {
        var a = this.actions[i];
        switch (a.GetState()) {
            case CATState.Waiting:
                if (this.curTime > a.delay + this.startTime) a.ChangeState(CATState.Running);
                break;
            case CATState.Running:
            case CATState.Stopping:
                a.CATUpdate();
                break;
            case CATState.Finished:
                finishedCount++;
                break;
            case CATState.Stopped:
            default:
                break
        }
    }
    this.InternalUpdateRunningState(finishedCount)
};
CAT_Event.prototype.InternalUpdateRunningState = function(finishedActionsCount) {
    if (finishedActionsCount == this.actions.length) {
        for (var i in this.actions) this.actions[i].ChangeState(CATState.Stopped);
        for (var i = 0; i < this.callback.length; ++i) {
            var cb = this.callback[i];
            cb.callback.call(cb.object, CAT_Event.CallbackType.EndOfEvent, this)
        }
        this.isRunning = false;
        this.parent.RemoveRunningEvent(this)
    }
};
CAT_Event.prototype.RegisterCallback = function(newCallback, object) {
    this.callback.push({
        object: object,
        callback: newCallback
    })
};
CAT_Event.prototype.UnregisterCallback = function(toRemoveCallback, object) {
    for (var i = 0; i < this.callback.length; ++i) {
        var cb = this.callback[i];
        if (cb.object == object && cb.callback == toRemoveCallback) {
            this.callback.splice(i, 1);
            return
        }
    }
};
CAT_Event.CallbackType = {
    EndOfEvent: 0
};
CAT_Event.prototype.SetParent = function(parent) {
    this.parent = parent
};
goog.require("UHT.CAT_Event");
goog.provide("UHT.CAT_Action");
var CATState = {
    Waiting: 0,
    Running: 1,
    Finished: 2,
    Stopping: 3,
    Stopped: 4
};

function CAT_Action() {
    this.delay = 0;
    this.isExpanded = true;
    this.isEnabled = true;
    this.debugBreak = false;
    this.internalState = CATState.Stopped
}
CAT_Action.prototype.GetState = function() {
    return this.internalState
};
CAT_Action.prototype.ChangeState = function(newState) {
    if (this.internalState == newState) {
        console.log("xCAT: Trying to change state twice! Investigate!");
        return
    }
    this.internalState = newState;
    switch (newState) {
        case CATState.Waiting:
            break;
        case CATState.Running:
            this.OnStateChanged_Running();
            break;
        case CATState.Finished:
            break;
        case CATState.Stopping:
            this.OnStateChanged_Stopping();
            break;
        case CATState.Stopped:
            break;
        default:
            console.log("xCAT: Wait, what? How did i get here?");
            break
    }
};
CAT_Action.prototype.OnStateChanged_Running = function() {
    this.ChangeState(CATState.Finished)
};
CAT_Action.prototype.OnStateChanged_Stopping = function() {
    this.ChangeState(CATState.Finished)
};
CAT_Action.prototype.CATUpdate = function() {};
goog.require("UHT.CAT_Action");
CAT_Action_CATLink.prototype = Object.create(CAT_Action.prototype);
CAT_Action_CATLink.prototype.constructor = CAT_Action_CATLink;

function CAT_Action_CATLink() {
    CAT_Action.call(this);
    this.actionType = CAT_Action_CATLink.ActionType.StartEvent;
    this.eventId = null
}
CAT_Action_CATLink.prototype.OnStateChanged_Running = function() {
    var target = this.eventId.cat;
    if (target != null) switch (this.actionType) {
        case CAT_Action_CATLink.ActionType.StartEvent:
            target.RegisterCallback(this.eventId.id, this.Callback_EventEnded, this);
            target.StartEvent(this.eventId.id);
            break;
        case CAT_Action_CATLink.ActionType.StopEvent:
            target.StopEvent(this.eventId.id);
            this.ChangeState(CATState.Finished);
            break;
        case CAT_Action_CATLink.ActionType.StopAll:
            target.StopAllRunningEvents();
            this.ChangeState(CATState.Finished);
            break;
        case CAT_Action_CATLink.ActionType.StartEvent_NoWait:
            target.StartEvent(this.eventId.id);
            this.ChangeState(CATState.Finished);
            break
    } else this.ChangeState(CATState.Finished)
};
CAT_Action_CATLink.prototype.OnStateChanged_Stopping = function() {
    var target = this.eventId.cat;
    if (target != null && this.actionType == CAT_Action_CATLink.ActionType.StartEvent) {
        target.UnregisterCallback(this.eventId.id, this.Callback_EventEnded, this);
        target.StopEvent(this.eventId.id)
    }
    this.ChangeState(CATState.Finished)
};
CAT_Action_CATLink.prototype.Callback_EventEnded = function(type, data) {
    var target = this.eventId.cat;
    if (type == CAT_Event.CallbackType.EndOfEvent && this.actionType == CAT_Action_CATLink.ActionType.StartEvent) {
        target.UnregisterCallback(this.eventId.id, this.Callback_EventEnded, this);
        this.ChangeState(CATState.Finished)
    }
};
CAT_Action_CATLink.ActionType = {
    StartEvent: 0,
    StopEvent: 1,
    StopAll: 2,
    StartEvent_NoWait: 3
};
goog.require("UHT.CAT_Action");
CAT_Action_MusicController.prototype = Object.create(CAT_Action.prototype);
CAT_Action_MusicController.prototype.constructor = CAT_Action_MusicController;

function CAT_Action_MusicController() {
    CAT_Action.call(this);
    this.clipName = CAT_Action_MusicController.noClip;
    this.actionType = CAT_Action_MusicController.ActionType.PlayMusicClip;
    this.useFading = false;
    this.fadeInDuration = .5;
    this.fadeOutDuration = .5;
    this.duckingStep = 0;
    this.autoUnduck = false;
    this.delayToAutoUnduck = -1
}
CAT_Action_MusicController.noClip = "*none*";
CAT_Action_MusicController.ActionType = {
    PlayMusicClip: 0,
    StopMusicClip: 1,
    MuteMusicClip: 2,
    UnmuteMusicClip: 3,
    DuckMusicClip: 4,
    UnduckMusicClip: 5,
    MuteAllMusic: 6,
    UnmuteAllMusic: 7,
    MuteAllSoundFX: 8,
    UnmuteAllSoundFX: 9
};
CAT_Action_MusicController.prototype.OnStateChanged_Running = function() {
    var musicLogic = XT.GetObject(Vars.MusicLogicObject);
    if (this.HasValidClip() && musicLogic != null) switch (this.actionType) {
        case CAT_Action_MusicController.ActionType.PlayMusicClip:
            musicLogic.PlayMusicClip(this.clipName, this.useFading ? this.fadeInDuration : -1);
            break;
        case CAT_Action_MusicController.ActionType.StopMusicClip:
            musicLogic.StopMusicClip(this.clipName, this.useFading ? this.fadeOutDuration : -1);
            break;
        case CAT_Action_MusicController.ActionType.MuteMusicClip:
            musicLogic.MuteMusicClip(this.clipName,
                this.useFading ? this.fadeOutDuration : -1);
            break;
        case CAT_Action_MusicController.ActionType.UnmuteMusicClip:
            musicLogic.UnmuteMusicClip(this.clipName, this.useFading ? this.fadeInDuration : -1);
            break;
        case CAT_Action_MusicController.ActionType.DuckMusicClip:
            var duckFadeIn = this.useFading ? this.fadeInDuration : -1;
            var duckFadeOut = this.useFading ? this.fadeOutDuration : -1;
            musicLogic.DuckMusicClip(this.clipName, this.duckingStep, this.autoUnduck ? this.delayToAutoUnduck : -1, duckFadeIn, duckFadeOut);
            break;
        case CAT_Action_MusicController.ActionType.UnduckMusicClip:
            musicLogic.UnduckMusicClip(this.clipName,
                this.duckingStep, this.useFading ? this.fadeOutDuration : -1);
            break;
        case CAT_Action_MusicController.ActionType.MuteAllMusic:
            musicLogic.MuteMusic(true);
            break;
        case CAT_Action_MusicController.ActionType.UnmuteAllMusic:
            musicLogic.MuteMusic(false);
            break;
        case CAT_Action_MusicController.ActionType.MuteAllSoundFX:
            musicLogic.MuteSoundFX(true);
            break;
        case CAT_Action_MusicController.ActionType.UnmuteAllSoundFX:
            musicLogic.MuteSoundFX(false);
            break
    }
    this.ChangeState(CATState.Finished)
};
CAT_Action_MusicController.prototype.HasValidClip = function() {
    return !_string.IsNullOrEmpty(this.clipName) && this.clipName != CAT_Action_MusicController.noClip
};
goog.require("UHT.CAT_Action");
CAT_Action_ObjActivate.prototype = Object.create(CAT_Action.prototype);
CAT_Action_ObjActivate.prototype.constructor = CAT_Action_ObjActivate;

function CAT_Action_ObjActivate() {
    CAT_Action.call(this);
    this.ToEnableList = [];
    this.ToDisableList = []
}
CAT_Action_ObjActivate.prototype.OnStateChanged_Running = function() {
    for (var i in this.ToEnableList)
        if (this.ToEnableList[i] != null) this.ToEnableList[i].SetActive(true);
    for (var j in this.ToDisableList)
        if (this.ToDisableList[j] != null) this.ToDisableList[j].SetActive(false);
    this.ChangeState(CATState.Finished)
};
goog.require("UHT.CAT_Action");
goog.require("UHT.AudioClip");
CAT_Action_PlayAudioClip.prototype = Object.create(CAT_Action.prototype);
CAT_Action_PlayAudioClip.prototype.constructor = CAT_Action_PlayAudioClip;

function CAT_Action_PlayAudioClip() {
    CAT_Action.call(this);
    this.audioClip = null
}
CAT_Action_PlayAudioClip.prototype.OnStateChanged_Running = function() {
    var mgr = XT.GetObject(Vars.SoundManagerObject);
    mgr.PlaySimple(this.audioClip);
    this.ChangeState(CATState.Finished)
};
goog.require("UHT.CAT_Action");
CAT_Action_SetTransform.prototype = Object.create(CAT_Action.prototype);
CAT_Action_SetTransform.prototype.constructor = CAT_Action_SetTransform;

function CAT_Action_SetTransform() {
    CAT_Action.call(this);
    this.objects = [];
    this.setLocalPosition = false;
    this.newLocalPosition = new UHTMath.Vector3(0, 0, 0);
    this.setLocalRotation = false;
    this.newLocalRotation = new UHTMath.Vector3(0, 0, 0);
    this.setLocalScale = false;
    this.newLocalScale = new UHTMath.Vector3(1, 1, 1)
}
CAT_Action_SetTransform.prototype.OnStateChanged_Running = function() {
    for (var i = 0; i < this.objects.length; i++) {
        if (this.setLocalPosition) this.objects[i].localPosition(this.newLocalPosition);
        if (this.setLocalRotation) this.objects[i].localRotation(UHTMath.Quaternion.euler(this.newLocalRotation));
        if (this.setLocalScale) this.objects[i].localScale(this.newLocalScale)
    }
    this.ChangeState(CATState.Finished)
};
goog.require("UHT.CAT_Action");
CAT_Action_SetXTBool.prototype = Object.create(CAT_Action.prototype);
CAT_Action_SetXTBool.prototype.constructor = CAT_Action_SetXTBool;

function CAT_Action_SetXTBool() {
    CAT_Action.call(this);
    this.BoolToCode = null;
    this.val = false
}
CAT_Action_SetXTBool.prototype.OnStateChanged_Running = function() {
    XT.SetBool(this.BoolToCode.name, this.val);
    this.ChangeState(CATState.Finished)
};
goog.require("UHT.CAT_Action");
goog.require("UHT.AudioClip");
CAT_Action_StopAudioClip.prototype = Object.create(CAT_Action.prototype);
CAT_Action_StopAudioClip.prototype.constructor = CAT_Action_StopAudioClip;

function CAT_Action_StopAudioClip() {
    CAT_Action.call(this);
    this.audioClip = null
}
goog.require("UHT.CAT_Action");
CAT_Action_TriggerXTEvent.prototype = Object.create(CAT_Action.prototype);
CAT_Action_TriggerXTEvent.prototype.constructor = CAT_Action_TriggerXTEvent;

function CAT_Action_TriggerXTEvent() {
    CAT_Action.call(this);
    this.EventToCode = null
}
CAT_Action_TriggerXTEvent.prototype.OnStateChanged_Running = function() {
    XT.TriggerEvent(this.EventToCode.name);
    this.ChangeState(CATState.Finished)
};

function XTVar() {
    this.name = ""
}

function XT() {}
XT.RegisterAndInitDone = false;
XT.variablesBool = {};
XT.variablesInt = {};
XT.variablesFloat = {};
XT.variablesDouble = {};
XT.variablesString = {};
XT.variablesObject = {};
XT.variablesEvent = {};
XT.RegisterAndInit = function(go) {
    console.log("XT - InitElements root='" + go.name + "'", go);
    XT.variablesBool = {};
    XT.variablesInt = {};
    XT.variablesFloat = {};
    XT.variablesDouble = {};
    XT.variablesString = {};
    XT.variablesObject = {};
    XT.variablesEvent = {};
    var ges = go.GetComponentsInChildren(XTLink, true);
    var i;
    for (i = 0; i < ges.length; ++i) ges[i].XTRegisterCallbacksBase();
    EventManager.Trigger(GameEvents.evtXTRegisterCallbacks, null);
    for (i = 0; i < ges.length; ++i) ges[i].XTInitVariablesAndEvents();
    XT.RegisterAndInitDone = true
};
XT.UnregisterCallbackBool = function(callback, object, varName) {
    var cachedHandlers = object[xtCache_Bool + callback.xtCacheName];
    if (cachedHandlers != undefined) {
        var handler = cachedHandlers[varName];
        if (handler != undefined) handler.isEnabled = false;
        else
            for (var hKey in cachedHandlers) cachedHandlers[hKey].isEnabled = false
    }
};
XT.UnregisterCallbackInt = function(callback, object, varName) {
    var cachedHandlers = object[xtCache_Int + callback.xtCacheName];
    if (cachedHandlers != undefined) {
        var handler = cachedHandlers[varName];
        if (handler != undefined) handler.isEnabled = false;
        else
            for (var hKey in cachedHandlers) cachedHandlers[hKey].isEnabled = false
    }
};
XT.UnregisterCallbackFloat = function(callback, object, varName) {
    var cachedHandlers = object[xtCache_Float + callback.xtCacheName];
    if (cachedHandlers != undefined) {
        var handler = cachedHandlers[varName];
        if (handler != undefined) handler.isEnabled = false;
        else
            for (var hKey in cachedHandlers) cachedHandlers[hKey].isEnabled = false
    }
};
XT.UnregisterCallbackDouble = function(callback, object, varName) {
    var cachedHandlers = object[xtCache_Double + callback.xtCacheName];
    if (cachedHandlers != undefined) {
        var handler = cachedHandlers[varName];
        if (handler != undefined) handler.isEnabled = false;
        else
            for (var hKey in cachedHandlers) cachedHandlers[hKey].isEnabled = false
    }
};
XT.UnregisterCallbackString = function(callback, object, varName) {
    var cachedHandlers = object[xtCache_String + callback.xtCacheName];
    if (cachedHandlers != undefined) {
        var handler = cachedHandlers[varName];
        if (handler != undefined) handler.isEnabled = false;
        else
            for (var hKey in cachedHandlers) cachedHandlers[hKey].isEnabled = false
    }
};
XT.UnregisterCallbackObject = function(callback, object, varName) {
    var cachedHandlers = object[xtCache_Object + callback.xtCacheName];
    if (cachedHandlers != undefined) {
        var handler = cachedHandlers[varName];
        if (handler != undefined) handler.isEnabled = false;
        else
            for (var hKey in cachedHandlers) cachedHandlers[hKey].isEnabled = false
    }
};
XT.UnregisterCallbackEvent = function(callback, object, varName) {
    var cachedHandlers = object[xtCache_Event + callback.xtCacheName];
    if (cachedHandlers != undefined) {
        var handlers = cachedHandlers[varName];
        if (handlers != undefined)
            for (var hKey in handlers) handlers[hKey].isEnabled = false;
        else
            for (var hKey in cachedHandlers)
                for (var pKey in cachedHandlers[hKey]) cachedHandlers[hKey][pKey].isEnabled = false
    }
};
XT.RegisterCallbackBool = function(name, callback, object) {
    if (XT.variablesBool[name] == undefined) XT.variablesBool[name] = new XTVariableHolderBase;
    var handler;
    var cachedHandlers = object[xtCache_Bool + callback.xtCacheName];
    if (cachedHandlers != undefined) handler = cachedHandlers[name];
    if (handler == undefined) {
        handler = new EventHandler(object, callback);
        XT.variablesBool[name].OnValueChanged.push(handler);
        CacheXTData(object, callback, name, xtCache_Bool, handler)
    } else {
        if (handler.isEnabled) console.log("!!!THIS MISTAKE IS UNFORGIVABLE!!! " +
            callback.xtCacheName + "() is already registered on " + name);
        handler.isEnabled = true
    }
};
XT.RegisterCallbackInt = function(name, callback, object) {
    if (XT.variablesInt[name] == undefined) XT.variablesInt[name] = new XTVariableHolderBase;
    var handler;
    var cachedHandlers = object[xtCache_Int + callback.xtCacheName];
    if (cachedHandlers != undefined) handler = cachedHandlers[name];
    if (handler == undefined) {
        handler = new EventHandler(object, callback);
        XT.variablesInt[name].OnValueChanged.push(handler);
        CacheXTData(object, callback, name, xtCache_Int, handler)
    } else {
        if (handler.isEnabled) console.log("!!!THIS MISTAKE IS UNFORGIVABLE!!! " +
            callback.xtCacheName + "() is already registered on " + name);
        handler.isEnabled = true
    }
};
XT.RegisterCallbackFloat = function(name, callback, object) {
    if (XT.variablesFloat[name] == undefined) XT.variablesFloat[name] = new XTVariableHolderBase;
    var handler;
    var cachedHandlers = object[xtCache_Float + callback.xtCacheName];
    if (cachedHandlers != undefined) handler = cachedHandlers[name];
    if (handler == undefined) {
        handler = new EventHandler(object, callback);
        XT.variablesFloat[name].OnValueChanged.push(handler);
        CacheXTData(object, callback, name, xtCache_Float, handler)
    } else {
        if (handler.isEnabled) console.log("!!!THIS MISTAKE IS UNFORGIVABLE!!! " +
            callback.xtCacheName + "() is already registered on " + name);
        handler.isEnabled = true
    }
};
XT.RegisterCallbackDouble = function(name, callback, object) {
    if (XT.variablesDouble[name] == undefined) XT.variablesDouble[name] = new XTVariableHolderBase;
    var handler;
    var cachedHandlers = object[xtCache_Double + callback.xtCacheName];
    if (cachedHandlers != undefined) handler = cachedHandlers[name];
    if (handler == undefined) {
        handler = new EventHandler(object, callback);
        XT.variablesDouble[name].OnValueChanged.push(handler);
        CacheXTData(object, callback, name, xtCache_Double, handler)
    } else {
        if (handler.isEnabled) console.log("!!!THIS MISTAKE IS UNFORGIVABLE!!! " +
            callback.xtCacheName + "() is already registered on " + name);
        handler.isEnabled = true
    }
};
XT.RegisterCallbackString = function(name, callback, object) {
    if (XT.variablesString[name] == undefined) XT.variablesString[name] = new XTVariableHolderBase;
    var handler;
    var cachedHandlers = object[xtCache_String + callback.xtCacheName];
    if (cachedHandlers != undefined) handler = cachedHandlers[name];
    if (handler == undefined) {
        handler = new EventHandler(object, callback);
        XT.variablesString[name].OnValueChanged.push(handler);
        CacheXTData(object, callback, name, xtCache_String, handler)
    } else {
        if (handler.isEnabled) console.log("!!!THIS MISTAKE IS UNFORGIVABLE!!! " +
            callback.xtCacheName + "() is already registered on " + name);
        handler.isEnabled = true
    }
};
XT.RegisterCallbackObject = function(name, callback, object) {
    if (XT.variablesObject[name] == undefined) XT.variablesObject[name] = new XTVariableHolderBase;
    var handler;
    var cachedHandlers = object[xtCache_Object + callback.xtCacheName];
    if (cachedHandlers != undefined) handler = cachedHandlers[name];
    if (handler == undefined) {
        handler = new EventHandler(object, callback);
        XT.variablesObject[name].OnValueChanged.push(handler);
        CacheXTData(object, callback, name, xtCache_Object, handler)
    } else {
        if (handler.isEnabled) console.log("!!!THIS MISTAKE IS UNFORGIVABLE!!! " +
            callback.xtCacheName + "() is already registered on " + name);
        handler.isEnabled = true
    }
};

function CompareVariableHolderEventByPriority(a, b) {
    return a.priority - b.priority
}
XT.RegisterCallbackEvent = function(name, callback, object, priority) {
    if (priority == undefined) priority = 0;
    if (XT.variablesEvent[name] == undefined) XT.variablesEvent[name] = [];
    var tmp = null;
    for (var i = 0; i < XT.variablesEvent[name].length; ++i)
        if (XT.variablesEvent[name][i].priority == priority) tmp = XT.variablesEvent[name][i];
    if (tmp == null) {
        tmp = new XTVariableHolderEvent;
        tmp.priority = priority;
        XT.variablesEvent[name].push(tmp);
        XT.variablesEvent[name] = XT.variablesEvent[name].sort(CompareVariableHolderEventByPriority)
    }
    var handler;
    var cachedHandlers = object[xtCache_Event + callback.xtCacheName];
    if (cachedHandlers != undefined)
        if (cachedHandlers[name] != undefined) handler = cachedHandlers[name][priority];
    if (handler == undefined) {
        handler = new EventHandler(object, callback);
        tmp.OnValueChanged.push(handler);
        CacheXTData(object, callback, name, xtCache_Event, handler, priority)
    } else {
        if (handler.isEnabled) console.log("!!!THIS MISTAKE IS UNFORGIVABLE!!! " + callback.xtCacheName + "() is already registered on " + name);
        handler.isEnabled = true
    }
};
XT.GetBool = function(varName) {
    var rv = false;
    if (XT.variablesBool[varName] != undefined) rv = XT.variablesBool[varName].value;
    else console.error("XT - does not have a variable (Bool) named " + varName + " !");
    return rv
};
XT.GetInt = function(varName) {
    var rv = -1;
    if (XT.variablesInt[varName] != undefined) rv = XT.variablesInt[varName].value;
    else console.error("XT - does not have a variable (Int) named " + varName + " !");
    return rv
};
XT.GetFloat = function(varName) {
    var rv = NaN;
    if (XT.variablesFloat[varName] != undefined) rv = XT.variablesFloat[varName].value;
    else console.error("XT - does not have a variable (Float) named " + varName + " !");
    return rv
};
XT.GetDouble = function(varName) {
    var rv = NaN;
    if (XT.variablesDouble[varName] != undefined) rv = XT.variablesDouble[varName].value;
    else console.error("XT - does not have a variable (Double) named " + varName + " !");
    return rv
};
XT.GetString = function(varName) {
    var rv = "RABAZZ";
    if (XT.variablesString[varName] != undefined) rv = XT.variablesString[varName].value;
    else console.error("XT - does not have a variable (String) named " + varName + " !");
    return rv
};
XT.GetObject = function(varName) {
    var rv = null;
    if (XT.variablesObject[varName] != undefined) rv = XT.variablesObject[varName].value;
    else console.error("XT - does not have a variable (Object) named " + varName + " !");
    return rv
};
XT.SetBool = function(varName, val) {
    if (XT.variablesBool[varName] == undefined) XT.variablesBool[varName] = new XTVariableHolderBase;
    var variable = XT.variablesBool[varName];
    if (variable.value != val || variable.valueIsAssigned == false) {
        variable.valueIsAssigned = true;
        variable.value = val;
        var handlers = variable.OnValueChanged;
        if (handlers != null) XT.Invoke(handlers, variable.value)
    }
};
XT.SetInt = function(varName, val) {
    if (XT.variablesInt[varName] == undefined) XT.variablesInt[varName] = new XTVariableHolderBase;
    var variable = XT.variablesInt[varName];
    if (variable.value != val || variable.valueIsAssigned == false) {
        variable.valueIsAssigned = true;
        variable.value = val;
        var handlers = variable.OnValueChanged;
        if (handlers != null) XT.Invoke(handlers, variable.value)
    }
};
XT.SetFloat = function(varName, val) {
    if (XT.variablesFloat[varName] == undefined) XT.variablesFloat[varName] = new XTVariableHolderBase;
    var variable = XT.variablesFloat[varName];
    if (variable.value != val || variable.valueIsAssigned == false) {
        variable.valueIsAssigned = true;
        variable.value = val;
        var handlers = variable.OnValueChanged;
        if (handlers != null) XT.Invoke(handlers, variable.value)
    }
};
XT.SetDouble = function(varName, val) {
    if (XT.variablesDouble[varName] == undefined) XT.variablesDouble[varName] = new XTVariableHolderBase;
    var variable = XT.variablesDouble[varName];
    if (variable.value != val || variable.valueIsAssigned == false) {
        variable.valueIsAssigned = true;
        variable.value = val;
        var handlers = variable.OnValueChanged;
        if (handlers != null) XT.Invoke(handlers, variable.value)
    }
};
XT.SetString = function(varName, val) {
    if (XT.variablesString[varName] == undefined) XT.variablesString[varName] = new XTVariableHolderBase;
    var variable = XT.variablesString[varName];
    if (variable.value != val || variable.valueIsAssigned == false) {
        variable.valueIsAssigned = true;
        variable.value = val;
        var handlers = variable.OnValueChanged;
        if (handlers != null) XT.Invoke(handlers, variable.value)
    }
};
XT.SetObject = function(varName, val) {
    if (XT.variablesObject[varName] == undefined) XT.variablesObject[varName] = new XTVariableHolderBase;
    var variable = XT.variablesObject[varName];
    if (variable.value != val || variable.valueIsAssigned == false) {
        variable.valueIsAssigned = true;
        variable.value = val;
        var handlers = variable.OnValueChanged;
        if (handlers != null) XT.Invoke(handlers, variable.value)
    }
};
XT.TriggerEvent = function(eventName) {
    if (XT.variablesEvent[eventName] == undefined) XT.variablesEvent[eventName] = [];
    var tmp = XT.variablesEvent[eventName];
    for (var i = 0; i < tmp.length; ++i) {
        var handlers = tmp[i].OnValueChanged;
        if (handlers != null) XT.Invoke(handlers)
    }
};
XT.Invoke = function(list, args) {
    for (var i = 0; i < list.length; ++i) {
        var enabled = true;
        var xtl = list[i].object;
        if (xtl instanceof XTLink) enabled = xtl.xtEnabled;
        if (enabled) list[i].call(args)
    }
};
goog.require("UHT.EventHandler");

function XTVariableHolderBase() {
    this.OnValueChanged = [];
    this.valueIsAssigned = false;
    this.value = null
}
XTVariableHolderEvent.prototype = Object.create(XTVariableHolderBase.prototype);
XTVariableHolderEvent.prototype.constructor = XTVariableHolderEvent;

function XTVariableHolderEvent() {
    XTVariableHolderBase.call(this);
    this.priority = 0
}
var xtCache_Bool = "xtCache_Bool";
var xtCache_Int = "xtCache_Int";
var xtCache_Float = "xtCache_Float";
var xtCache_Double = "xtCache_Double";
var xtCache_String = "xtCache_String";
var xtCache_Object = "xtCache_Object";
var xtCache_Event = "xtCache_Event";
var xtCallbackCounter = 0;

function CacheXTData(obj, callback, varName, cacheName, handler, priority) {
    if (callback.xtCacheName == undefined) {
        callback.xtCacheName = "_Callback" + xtCallbackCounter;
        xtCallbackCounter++
    }
    var key = cacheName + callback.xtCacheName;
    var d = obj[key];
    if (d == undefined) {
        d = {};
        obj[key] = d
    }
    if (priority == undefined) d[varName] = handler;
    else {
        d[varName] = {};
        d[varName][priority] = handler
    }
}
goog.require("UHT.Component");
CameraDepthController.prototype = Object.create(Component.prototype);
CameraDepthController.prototype.constructor = CameraDepthController;

function CameraDepthController() {
    Component.call(this);
    this.targetCamera = null;
    this.initialDepth = -1
}
CameraDepthController.prototype.Start = function() {
    this.initialDepth = this.targetCamera.depth
};
CameraDepthController.prototype.SetCameraDepth = function(depth) {
    this.targetCamera.depth = _number.otod(depth)
};
CameraDepthController.prototype.ResetCameraDepth = function() {
    this.targetCamera.depth = this.initialDepth
};
goog.require("UHT.Component");
ExtraCameraSettings.prototype = Object.create(Component.prototype);
ExtraCameraSettings.prototype.constructor = ExtraCameraSettings;

function ExtraCameraSettings() {
    Component.call(this);
    this._clipUp = -1;
    this._clipDown = -1;
    this._clipLeft = -1;
    this._clipRight = -1;
    this.dirtyFlag = false;
    this.clipInput = false;
    this.clipMaskLayer = 0;
    this.combineClips = false
}
ExtraCameraSettings.prototype.clipUp = -1;
ExtraCameraSettings.prototype.clipDown = -1;
ExtraCameraSettings.prototype.clipLeft = -1;
ExtraCameraSettings.prototype.clipRight = -1;
Object.defineProperties(ExtraCameraSettings.prototype, {
    clipUp: {
        get: function() {
            return this._clipUp
        },
        set: function(value) {
            if (value != this._clipUp) {
                this._clipUp = value;
                this.dirtyFlag = true
            }
        }
    },
    clipDown: {
        get: function() {
            return this._clipDown
        },
        set: function(value) {
            if (value != this._clipDown) {
                this._clipDown = value;
                this.dirtyFlag = true
            }
        }
    },
    "clipLeft": {
        get: function() {
            return this._clipLeft
        },
        set: function(value) {
            if (value != this._clipLeft) {
                this._clipLeft = value;
                this.dirtyFlag = true
            }
        }
    },
    clipRight: {
        get: function() {
            return this._clipRight
        },
        set: function(value) {
            if (value != this._clipRight) {
                this._clipRight = value;
                this.dirtyFlag = true
            }
        }
    }
});
goog.require("UHT.UHTEngine");

function ExtraCameraSettingsAnchorsHolder() {
    this.anchorUpLeft = null;
    this.anchorDownRight = null
}
ExtraCameraSettingsAnchors.prototype = Object.create(Component.prototype);
ExtraCameraSettingsAnchors.prototype.constructor = ExtraCameraSettingsAnchors;

function ExtraCameraSettingsAnchors() {
    Component.call(this);
    this.extraCameraSettings = null;
    this.anchorUpLeft = null;
    this.anchorDownRight = null;
    this.anchors = null;
    this.prevUL = null;
    this.prevDR = null;
    this.prevPos = null
}
ExtraCameraSettingsAnchors.prototype.Update = function() {
    var UL = this.anchorUpLeft.position();
    var DR = this.anchorDownRight.position();
    var pos = this.transform.position();
    if (this.prevUL == null || !this.prevUL.equals(UL) || this.prevDR == null || !this.prevDR.equals(DR) || this.prevPos == null || !this.prevPos.equals(pos)) {
        var ULI = this.transform.inverseTransformPoint(UL);
        var DRI = this.transform.inverseTransformPoint(DR);
        this.extraCameraSettings.clipUp = ULI.y;
        this.extraCameraSettings.clipDown = -DRI.y;
        this.extraCameraSettings.clipLeft = -ULI.x;
        this.extraCameraSettings.clipRight = DRI.x;
        this.prevUL = UL;
        this.prevDR = DR;
        this.prevPos = pos
    }
};
ExtraCameraSettingsAnchors.prototype.SwitchToAnchors = function(index) {
    index = Number(index);
    this.anchorUpLeft = this.anchors[index].anchorUpLeft;
    this.anchorDownRight = this.anchors[index].anchorDownRight;
    this.Update()
};
goog.require("UHT.UHTEngine");
ExtraCameraSettingsAnchorsProxy.prototype = Object.create(Component.prototype);
ExtraCameraSettingsAnchorsProxy.prototype.constructor = ExtraCameraSettingsAnchorsProxy;

function ExtraCameraSettingsAnchorsProxy() {
    Component.call(this);
    this.anchors = null;
    this.settings = null;
    this.anchorsIndex = 0
}
ExtraCameraSettingsAnchorsProxy.prototype.SwitchToAnchors = function(index) {
    if (this.settings == null) {
        var camera = Globals.GetCameraForObject(this.gameObject);
        this.settings = camera.GetComponent(ExtraCameraSettingsAnchors);
        var list = this.settings.anchors;
        this.anchorsIndex = list.length;
        for (var i = 0; i < this.anchors.length; ++i) list.push(this.anchors[i])
    }
    this.settings.SwitchToAnchors(this.anchorsIndex + index)
};
var LMVars = {
    Evt_Internal_SwitchToLandscapeLayout: "Evt_Internal_SwitchToLandscapeLayout",
    Evt_Internal_SwitchToLandscapeLayoutWide: "Evt_Internal_SwitchToLandscapeLayoutWide",
    Evt_Internal_SwitchToLandscapeLayoutWideFull: "Evt_Internal_SwitchToLandscapeLayoutWideFull",
    Evt_Internal_SwitchToPortraitLayout: "Evt_Internal_SwitchToPortraitLayout",
    Evt_Internal_SwitchToPortraitLayoutIPhone: "Evt_Internal_SwitchToPortraitLayoutIPhone",
    Evt_Internal_SwitchToPortraitLayoutIPad: "Evt_Internal_SwitchToPortraitLayoutIPad"
};
goog.provide("UHT.ModificationsManager_XChange");
goog.require("UHTMath.Vector3");

function AtlasChange() {
    this.Target = null;
    this.NewAtlas = null;
    this.extraPayloads = null;
    this.oldPath = "";
    this.isSet = false;
    this.currentPayload = -1
}

function TransformInfo() {
    this.Position = null;
    this.Scale = null;
    this.Rotation = 0;
    this.isNull = false;
    this.currentPayload = -1
}
TransformInfo.prototype.SetPosition = function(_pos) {
    this.Position = new UHTMath.Vector3(_pos.x, _pos.y, _pos.z)
};
TransformInfo.prototype.SetScale = function(_scale) {
    this.Scale = new UHTMath.Vector3(_scale.x, _scale.y, _scale.z)
};
TransformInfo.prototype.SetRotation = function(_rot) {
    this.Rotation = _rot
};

function TransformChange() {
    this.Target = null;
    this.path = "";
    this.TransformData = null;
    this.extraPayloads = null;
    this.isSet = false;
    this.active = true;
    this.currentPayload = -1
}
TransformChange.prototype.SetValuesToElement = function(editmode) {
    if (!this.isSet) return;
    var copyFrom = this.TransformData[0];
    if (this.currentPayload != -1 && this.extraPayloads != null && this.extraPayloads.length > this.currentPayload && this.extraPayloads[this.currentPayload] != null) copyFrom = this.extraPayloads[this.currentPayload];
    if (!copyFrom.isNull) {
        this.Target.localPosition(new UHTMath.Vector3(copyFrom.Position.x, copyFrom.Position.y, copyFrom.Position.z));
        this.Target.localScale(new UHTMath.Vector3(copyFrom.Scale.x,
            copyFrom.Scale.y, copyFrom.Scale.z));
        this.Target.localRotation(UHTMath.Quaternion.euler(this.Target.localEulerAngles().x, this.Target.localEulerAngles().y, copyFrom.Rotation));
        this.Target.gameObject.SetActive(this.active)
    }
};

function LabelChange() {
    this.Target = null;
    this.path = "";
    this.newContent = null;
    this.extraPayloads = null;
    this.oldContent = "";
    this.hasDynamicContent = false;
    this.isSet = false;
    this.hasCustomEffects = true
}
LabelChange.prototype.SetValuesToLabel = function() {
    if (!this.isSet || this.Target == null) return;
    var label = this.Target.GetComponent(UILabel);
    if (label != null) this.SetValues(label)
};
LabelChange.prototype.SetValues = function(label) {
    var copyFrom = this.newContent;
    if (this.currentPayload != -1 && this.extraPayloads != null && this.extraPayloads.length > this.currentPayload && this.extraPayloads[this.currentPayload] != null) copyFrom = this.extraPayloads[this.currentPayload].label;
    ModificationsManager.CopyFromLabelToLabel(copyFrom, label, !this.hasDynamicContent, this.hasCustomEffects)
};
LabelChange.prototype.ReadValues = function(label) {};
LabelChange.prototype.RevertValue = function() {
    this.newContent.text = "<<<<<<" + this.oldContent
};

function ExtraLabelPayload(l, nC) {
    this.label = l;
    this.cachedDefaultContent = nC
}

function SpineChangePayload() {
    this.NewSkeletonData = null;
    this.Atlases = null
}

function SpineChange() {
    this.Target = null;
    this.NewSkeletonData = null;
    this.Atlases = null;
    this.extraPayloads = null;
    this.oldPath = "";
    this.isSet = false;
    this.currentPayload = -1
}
goog.require("UHT.Component");
RoutineQueue.prototype = Object.create(Component.prototype);
RoutineQueue.prototype.constructor = RoutineQueue;

function RoutineQueue() {
    Component.call(this);
    this.rqiList = [];
    this.isStarted = false
}
RoutineQueue.prototype.AddRoutineQueueItem = function(rqi) {
    this.rqiList.push(rqi)
};
RoutineQueue.prototype.Update = function() {
    if (this.isStarted)
        if (this.rqiList.length > 0)
            while (!this.rqiList[0].RQIUpdate()) {
                this.rqiList[0].RQIStop();
                this.rqiList.splice(0, 1);
                if (this.rqiList.length > 0) this.rqiList[0].RQIStart();
                else break
            }
};
RoutineQueue.prototype.StartRoutines = function() {
    if (this.rqiList.length > 0) {
        this.rqiList[0].RQIStart();
        this.isStarted = true
    } else console.error("RoutineQueue - Trying to start and empty Routine Queue")
};
RoutineQueue.prototype.StopRoutines = function() {
    if (this.rqiList.length > 0) this.rqiList[0].RQIStop();
    this.rqiList = [];
    this.isStarted = false
};
goog.provide("UHT.RoutineQueueItem");

function RoutineQueueItem() {}
RoutineQueueItem.prototype.RQIStart = function() {};
RoutineQueueItem.prototype.RQIUpdate = function() {
    return false
};
RoutineQueueItem.prototype.RQIStop = function() {};
goog.require("UHT.RoutineQueueItem");
RQICatLinkStarter.prototype = Object.create(RoutineQueueItem.prototype);
RQICatLinkStarter.prototype.constructor = RQICatLinkStarter;

function RQICatLinkStarter(catLink, _waitForCAT) {
    RoutineQueueItem.call(this);
    if (_waitForCAT == undefined) _waitForCAT = false;
    this.catLink = catLink;
    this.waitForCAT = _waitForCAT
}
RQICatLinkStarter.prototype.RQIStart = function() {
    this.catLink.Start()
};
RQICatLinkStarter.prototype.RQIUpdate = function() {
    return this.waitForCAT && this.catLink.IsRunning()
};
RQICatLinkStarter.prototype.RQIStop = function() {};
goog.require("UHT.RoutineQueueItem");
RQIMarker.prototype = Object.create(RoutineQueueItem.prototype);
RQIMarker.prototype.constructor = RQIMarker;

function RQIMarker(t) {
    RoutineQueueItem.call(this);
    this.type = t
}
RQIMarker.MarkerType = {
    StartLineByLine: 0,
    EndLineByLine: 1
};
RQIMarker.prototype.RQIStart = function() {};
RQIMarker.prototype.RQIUpdate = function() {
    return false
};
RQIMarker.prototype.RQIStop = function() {};
goog.require("UHT.RoutineQueueItem");
RQITriggerCallback.prototype = Object.create(RoutineQueueItem.prototype);
RQITriggerCallback.prototype.constructor = RQITriggerCallback;

function RQITriggerCallback(_callback, _param, _object) {
    RoutineQueueItem.call(this);
    this.callback = _callback;
    this.param = _param;
    this.object = _object
}
RQITriggerCallback.prototype.RQIStart = function() {
    this.callback.call(this.object, this.param)
};
RQITriggerCallback.prototype.RQIUpdate = function() {
    return false
};
RQITriggerCallback.prototype.RQIStop = function() {};
goog.require("UHT.RoutineQueueItem");
RQITriggerEvent.prototype = Object.create(RoutineQueueItem.prototype);
RQITriggerEvent.prototype.constructor = RQITriggerEvent;

function RQITriggerEvent(eventToTrigger) {
    RoutineQueueItem.call(this);
    this.eventName = eventToTrigger
}
RQITriggerEvent.prototype.RQIStart = function() {
    XT.TriggerEvent(this.eventName)
};
RQITriggerEvent.prototype.RQIUpdate = function() {
    return false
};
RQITriggerEvent.prototype.RQIStop = function() {};
goog.require("UHT.RoutineQueueItem");
RQIWaitForLastWinCount.prototype = Object.create(RoutineQueueItem.prototype);
RQIWaitForLastWinCount.prototype.constructor = RQIWaitForLastWinCount;

function RQIWaitForLastWinCount() {
    RoutineQueueItem.call(this)
}
RQIWaitForLastWinCount.prototype.RQIStart = function() {};
RQIWaitForLastWinCount.prototype.RQIUpdate = function() {
    return XT.GetBool(Vars.LastWinIsCounting)
};
RQIWaitForLastWinCount.prototype.RQIStop = function() {};
goog.require("UHT.RoutineQueueItem");
RQIWaitForSeconds.prototype = Object.create(RoutineQueueItem.prototype);
RQIWaitForSeconds.prototype.constructor = RQIWaitForSeconds;

function RQIWaitForSeconds(timeToWait, timeScaleID) {
    RoutineQueueItem.call(this);
    this.waitTime = timeToWait;
    this.curTime = 0;
    this.timeScaleID = timeScaleID == undefined ? "" : timeScaleID
}
RQIWaitForSeconds.prototype.RQIStart = function() {
    this.curTime = 0
};
RQIWaitForSeconds.prototype.RQIUpdate = function() {
    var firstUpdate = this.curTime == 0;
    this.curTime += TimeScaler.GetDeltaTime(this.timeScaleID);
    if (this.curTime > this.waitTime - .001 && !firstUpdate) return false;
    return true
};
RQIWaitForSeconds.prototype.RQIStop = function() {};
goog.require("UHT.RoutineQueueItem");
RQIWaitForXTEvent.prototype = Object.create(RoutineQueueItem.prototype);
RQIWaitForXTEvent.prototype.constructor = RQIWaitForXTEvent;

function RQIWaitForXTEvent(eventToWaitFor) {
    RoutineQueueItem.call(this);
    this.eventName = eventToWaitFor;
    this.eventReceived = false
}
RQIWaitForXTEvent.prototype.RQIStart = function() {
    this.eventReceived = false;
    XT.RegisterCallbackEvent(this.eventName, this.OnEventTriggered, this)
};
RQIWaitForXTEvent.prototype.RQIUpdate = function() {
    if (this.eventReceived == true) return false;
    return true
};
RQIWaitForXTEvent.prototype.RQIStop = function() {
    XT.UnregisterCallbackEvent(this.OnEventTriggered, this)
};
RQIWaitForXTEvent.prototype.OnEventTriggered = function() {
    this.eventReceived = true
};
goog.require("UHT.RoutineQueueItem");
RQIWaitForXTEventWithCallback.prototype = Object.create(RoutineQueueItem.prototype);
RQIWaitForXTEventWithCallback.prototype.constructor = RQIWaitForXTEventWithCallback;

function RQIWaitForXTEventWithCallback(eventToWaitFor, eventToCallOnStart) {
    RoutineQueueItem.call(this);
    this.eventName = eventToWaitFor;
    this.eventCallback = eventToCallOnStart;
    this.eventReceived = false
}
RQIWaitForXTEventWithCallback.prototype.RQIStart = function() {
    this.eventReceived = false;
    XT.RegisterCallbackEvent(this.eventName, this.OnEventTriggered, this);
    XT.TriggerEvent(this.eventCallback)
};
RQIWaitForXTEventWithCallback.prototype.RQIUpdate = function() {
    if (this.eventReceived == true) return false;
    return true
};
RQIWaitForXTEventWithCallback.prototype.RQIStop = function() {
    XT.UnregisterCallbackEvent(this.OnEventTriggered, this)
};
RQIWaitForXTEventWithCallback.prototype.OnEventTriggered = function() {
    this.eventReceived = true
};
goog.provide("UHT.BalanceData");

function BalanceData(balance, bonusbalance, time) {
    var b;
    var bb;
    var t;
    if (balance instanceof BalanceData) {
        b = balance.Balance;
        bb = balance.BonusBalance;
        t = balance.Time
    } else {
        if (typeof balance == "number") b = balance;
        if (typeof bonusbalance == "number") bb = bonusbalance;
        if (typeof time == "number") t = time
    }
    this.Balance = b || 0;
    this.BonusBalance = bb || 0;
    this.Time = t || 0
}
goog.provide("UHT.BaseDataStructures");
var Cloneable = function() {};
Cloneable.prototype.Clone = function() {};

function CasinoSoundState() {
    this.state = 0
}
CasinoSoundState.GlobalSoundOff = -1;
CasinoSoundState.SoundOff = 0;
CasinoSoundState.SoundOn = 1;
goog.require("UHT.BaseDataStructures");

function GameSettings(settings) {
    this.GameId = "";
    this.Error = false;
    var s;
    switch (typeof settings) {
        case "object":
            s = settings;
            break;
        case "string":
            s = this.FromString(settings);
            break
    }
    this.Settings = s || {}
}
GameSettings.prototype.FromString = function(settings) {
    this.Settings = this.BuildDictionaryFromString(settings, ";", "=")
};
GameSettings.prototype.ToString = function() {
    return this.DictionaryToString(this.Settings, ";", "=")
};
GameSettings.prototype.DictionaryToString = function(dict, pairSeparator, fieldSeparator) {
    var rv = [];
    for (var key in dict) rv.push([key, dict[key]].join(fieldSeparator));
    return rv.join(pairSeparator)
};
GameSettings.prototype.Clone = function() {
    var clone = new GameSettings;
    clone.GameId = this.GameId;
    clone.Error = this.Error;
    for (var key in this.Settings) clone.Settings[key] = this.Settings[key];
    return clone
};
GameSettings.prototype.BuildDictionaryFromString = function(str, pairSeparator, fieldSeparator) {
    var rv = {};
    if (!_string.IsNullOrEmpty(str)) {
        var pairs = str.split(pairSeparator);
        for (var i = 0; i < pairs.length; ++i) {
            var fields = pairs[i].split(fieldSeparator);
            if (fields.length == 2) rv[fields[0]] = fields[1]
        }
    }
    return rv
};
var GambleV2Protocol = {};
GambleV2Protocol.GambleResult = function() {
    this.level = -1;
    this.selectedIndex = -1;
    this.winIndex = -1;
    this.winAmount = 0;
    this.winMultiplier = 0;
    this.isWin = false;
    this.isEnd = false
};
GambleV2Protocol.GambleData = function() {
    this.riskAmount = 0;
    this.options = null;
    this.optionIndex = -1;
    this.result = null;
    this.totalWin = 0
};
GambleV2Protocol.Parser = {};
GambleV2Protocol.Parser.data = null;
GambleV2Protocol.Parser.ParseGambleData = function(dict) {
    var data = GambleV2Protocol.Parser.data;
    var key = "g_ra";
    if (dict[key] == undefined) {
        GambleV2Protocol.Parser.data = null;
        return null
    }
    if (data == null) data = GambleV2Protocol.Parser.data = new GambleV2Protocol.GambleData;
    data.riskAmount = _number.otod(dict[key]);
    key = "tw";
    if (dict[key] != undefined) data.totalWin = _number.otod(dict[key]);
    var collected = true;
    key = "go_i";
    if (dict[key] != undefined) {
        collected = false;
        data.options = _array.ConvertAll(dict[key].split(","), _number.otod)
    }
    key =
        "g_o";
    if (dict[key] != undefined) {
        collected = false;
        data.optionIndex = _number.otoi(dict[key])
    }
    data.result = GambleV2Protocol.Parser.ParseResult(dict);
    if (data.result != null) collected = false;
    else {
        var actions = ["g", "go"];
        key = "na";
        if (dict[key] != undefined && actions.indexOf(dict[key]) < 0) collected = true
    }
    if (collected) {
        data.options = null;
        data.optionIndex = -1;
        data.result = null
    }
    return data
};
GambleV2Protocol.Parser.ParseResult = function(dict) {
    var key = "g_w";
    if (dict[key] == undefined) return null;
    var ret = new GambleV2Protocol.GambleResult;
    ret.winAmount = _number.otod(dict[key]);
    ret.winIndex = _number.otoi(dict["g_wi"]);
    ret.winMultiplier = _number.otod(dict["g_mul"]);
    ret.level = _number.otoi(dict["g_l"]);
    ret.isWin = dict["g_r"] == "1";
    ret.isEnd = dict["g_end"] == "1";
    key = "g_si";
    if (dict[key] != undefined) ret.selectedIndex = _number.otoi(dict[key]);
    return ret
};
goog.require("UHT.BaseDataStructures");

function VsGamblingButtonState(gamblingSpinWin, gamblingFreeSpinWin, gamblingBonusWin) {
    this.GamblingOnSpinAvailable = gamblingSpinWin;
    this.GamblingOnFreespinWinAvailable = gamblingFreeSpinWin;
    this.GamblingOnBonusWinAvailable = gamblingBonusWin
}
VsGamblingButtonState.prototype.ToString = function() {
    return ["[VsGamblingButtonState gamblingSpinWin=", this.GamblingOnSpinAvailable, ", gamblingFreeSpinWin=", this.GamblingOnFreespinWinAvailable, ", gamblingBonusWin=", this.GamblingOnBonusWinAvailable, "]"].join("")
};
VsGamblingButtonState.prototype.Clone = function() {
    return new VsGamblingButtonState(this.GamblingOnSpinAvailable, this.GamblingOnFreespinWinAvailable, this.GamblingOnBonusWinAvailable)
};
goog.require("UHT.BaseDataStructures");

function VsGamblingHistory(winAmount) {
    this.History = [];
    this.WinAmount = typeof winAmount == "number" ? winAmount : 0
}
VsGamblingHistory.prototype.AddHistoryItem = function(item) {
    this.History.push(item)
};
VsGamblingHistory.prototype.Clone = function() {
    var cloned = new VsGamblingHistory;
    cloned.WinAmount = this.WinAmount;
    cloned.History = [];
    for (var i = 0; i < this.History.length; ++i) cloned.History[i] = this.History[i].Clone();
    return cloned
};

function VsGamblingRequest() {
    this.Choice = VsGamblingRequest.GamblingChoices.None
}
VsGamblingRequest.prototype.GetTypeOfChoice = function() {
    switch (this.Choice) {
        case VsGamblingRequest.GamblingChoices.Red:
            return GamblingType.CardColor;
        case VsGamblingRequest.GamblingChoices.Black:
            return GamblingType.CardColor;
        case VsGamblingRequest.GamblingChoices.Clubs:
            return GamblingType.Suit;
        case VsGamblingRequest.GamblingChoices.Spades:
            return GamblingType.Suit;
        case VsGamblingRequest.GamblingChoices.Diamond:
            return GamblingType.Suit;
        case VsGamblingRequest.GamblingChoices.Heart:
            return GamblingType.Suit;
        case VsGamblingRequest.GamblingChoices.Dices:
            return GamblingType.Dices
    }
    return GamblingType.None
};
VsGamblingRequest.GamblingChoices = {
    Red: 0,
    Black: 1,
    Clubs: 2,
    Spades: 3,
    Diamond: 4,
    Heart: 5,
    Dices: 6,
    None: -1
};
goog.require("UHT.BaseDataStructures");
var GamblingType = {
    CardColor: 0,
    Suit: 1,
    Dices: 2,
    None: 3
};
var GamblingState = {
    Lose: 0,
    Win: 1,
    WinLimit: 2
};

function VsGamblingResponse() {
    this.GamblingType = GamblingType.None;
    this.Card = -1;
    this.Dice1 = 0;
    this.Dice2 = 0;
    this.Balance = 0;
    this.State = GamblingState.Lose;
    this.NoMoney = false
}
VsGamblingResponse.prototype.GetGamblingType = function() {
    return this.GamblingType
};
VsGamblingResponse.prototype.SetGamblingType = function(gamblingType) {
    this.GamblingType = gamblingType
};
VsGamblingResponse.prototype.GetCard = function() {
    return this.Card
};
VsGamblingResponse.prototype.SetCard = function(card) {
    this.Card = card
};
VsGamblingResponse.prototype.GetDice1 = function() {
    return this.Dice1
};
VsGamblingResponse.prototype.SetDice1 = function(dice) {
    this.Dice1 = dice
};
VsGamblingResponse.prototype.GetDice2 = function() {
    return this.Dice2
};
VsGamblingResponse.prototype.SetDice2 = function(dice) {
    this.Dice2 = dice
};
VsGamblingResponse.prototype.GetBalance = function() {
    return this.Balance
};
VsGamblingResponse.prototype.SetBalance = function(balance) {
    this.Balance = balance
};
VsGamblingResponse.prototype.GetState = function() {
    return this.State
};
VsGamblingResponse.prototype.SetState = function(state) {
    this.State = state
};
VsGamblingResponse.prototype.IsNoMoney = function() {
    return this.NoMoney
};
VsGamblingResponse.prototype.SetNoMoney = function(isNoMoney) {
    this.NoMoney = isNoMoney
};
VsGamblingResponse.prototype.Clone = function() {
    var clone = new VsGamblingResponse;
    clone.GamblingType = this.GamblingType;
    clone.Card = this.Card;
    clone.Dice1 = this.Dice1;
    clone.Dice2 = this.Dice2;
    clone.Balance = this.Balance;
    clone.State = this.State;
    clone.NoMoney = this.NoMoney;
    return clone
};
goog.require("UHT.BaseDataStructures");
var GamblingOccasions = {
    Spin: 0,
    FreeSpin: 1,
    Bonus: 2
};

function VsGamblingSettings() {
    this.occasionsMap = {};
    this.GamblingSettings = {};
    this.SkipGambleOnInit = false;
    this.InitGamblingOccasion = GamblingOccasions.Spin
}
VsGamblingSettings.prototype.GetGamblingSettings = function(type) {
    if (this.GamblingSettings[type]) return this.GamblingSettings[type];
    return null
};
VsGamblingSettings.prototype.SetGamblingSettings = function(type, multiplier) {
    this.GamblingSettings[type] = multiplier
};
VsGamblingSettings.prototype.SetOccasionStatus = function(occasion, enable) {
    this.occasionsMap[occasion] = enable
};
VsGamblingSettings.prototype.IsOccasionEnable = function(occasion) {
    if (this.occasionsMap[occasion]) return this.occasionsMap[occasion];
    return false
};
VsGamblingSettings.prototype.Clone = function() {
    var cloned = new VsGamblingSettings;
    cloned.SkipGambleOnInit = this.SkipGambleOnInit;
    cloned.InitGamblingOccasion = this.InitGamblingOccasion;
    cloned.occasionsMap = {};
    for (var o in this.occasionsMap) cloned.occasionsMap[o] = this.occasionsMap[o];
    cloned.GamblingSettings = {};
    for (var s in this.GamblingSettings) cloned.GamblingSettings[s] = this.GamblingSettings[s];
    return cloned
};
goog.require("UHT.BaseDataStructures");

function VsBetLevel() {
    this.betLevelIndex = 0;
    this.betLevelScale = [];
    this.paytables = []
}
VsBetLevel.prototype.Clone = function() {
    var cloned = new VsBetLevel;
    cloned.betLevelIndex = this.betLevelIndex;
    cloned.betLevelScale = this.betLevelScale.slice();
    cloned.paytables = this.paytables.slice();
    return cloned
};
goog.require("UHT.BaseDataStructures");

function VsBonusGameData() {
    this.Level = -1;
    this.Life = -1;
    this.WinPoints = 0;
    this.RealWin = 0;
    this.Coef = 0;
    this.GameOver = false;
    this.IWins = null;
    this.BonusTable = new VsBonusGameDataTable;
    this.MultipliersTable = new VsBonusGameDataTable;
    this.MultiplierStep = false;
    this.numberOfLevels = -1;
    this.lifeWins = null;
    this.currentBonusRespin = 0;
    this.maxBonusRespins = 0;
    this.respinSymbols = null;
    this.winSymbols = null;
    this.initialized = false;
    this.PremultipliedWin = 0;
    this.RespinsTotalMultiplier = -1;
    this.ExtraRespinsWon = -1;
    this.ExtraRetriggersWon = -1;
    this.MultipliedSymbolPositions = null;
    this.id = -1;
    this.type = -1;
    this.wheelOfFortune = null;
    this.map = null
}
VsBonusGameData.prototype.Clone = function() {
    var cloned = new VsBonusGameData;
    cloned.Level = this.Level;
    cloned.Life = this.Life;
    cloned.WinPoints = this.WinPoints;
    cloned.RealWin = this.RealWin;
    cloned.Coef = this.Coef;
    cloned.GameOver = this.GameOver;
    cloned.MultiplierStep = this.MultiplierStep;
    cloned.currentBonusRespin = this.currentBonusRespin;
    cloned.maxBonusRespins = this.maxBonusRespins;
    cloned.PremultipliedWin = this.PremultipliedWin;
    cloned.RespinsTotalMultiplier = this.RespinsTotalMultiplier;
    cloned.ExtraRespinsWon = this.ExtraRespinsWon;
    cloned.ExtraRetriggersWon = this.ExtraRetriggersWon;
    if (this.MultipliedSymbolPositions != null) {
        cloned.MultipliedSymbolPositions = [];
        for (var i = 0; i < this.MultipliedSymbolPositions.length; i++) cloned.MultipliedSymbolPositions.push(this.MultipliedSymbolPositions[i])
    }
    if (this.BonusTable != null) cloned.BonusTable = this.BonusTable.Clone();
    if (this.MultipliersTable != null) cloned.MultipliersTable = this.MultipliersTable.Clone();
    if (this.IWins != null) cloned.IWins = this.IWins.slice();
    if (this.lifeWins != null) cloned.lifeWins = this.lifeWins.slice();
    if (this.respinSymbols != null) cloned.respinSymbols = this.respinSymbols.slice();
    if (this.winSymbols != null) {
        cloned.winSymbols = [];
        for (var i = 0; i < this.winSymbols.length; ++i) cloned.winSymbols.push(this.winSymbols[i].slice())
    }
    return cloned
};
VsBonusGameData.WheelOfFortune = function() {
    this.items = null;
    this.itemsStatus = null;
    this.stopPosition = -1;
    this.spinsLeft = -1;
    this.multiplier = -1;
    this.initialWin = -1
};
VsBonusGameData.WheelOfFortune.Item = function() {
    this.amount = 0;
    this.spinsNumber = 0;
    this.status = -1;
    this.selectedAtLevel = -1
};
VsBonusGameData.Map = function() {
    this.WOF_MultiplierIndex = -1;
    this.WOF_StopPosition = -1;
    this.WOF_Values = null;
    this.WOF_Mask = null;
    this.WOF_Map = null
};
goog.require("UHT.BaseDataStructures");

function VsBonusGameDataTable() {
    this.Status = null;
    this.Markers = null;
    this.Wins = null;
    this.WinsMask = null;
    this.BGItemValues = null;
    this.BGItemMasks = null
}
VsBonusGameDataTable.prototype.Clone = function() {
    var cloned = new VsBonusGameDataTable;
    cloned.Status = [];
    cloned.Markers = null;
    cloned.Wins = [];
    cloned.WinsMask = null;
    if (this.Status != null) cloned.Status = this.Status.slice();
    if (this.Wins != null) cloned.Wins = this.Wins.slice();
    if (this.Markers != null) cloned.Markers = this.Markers.slice();
    if (this.WinsMask != null) cloned.WinsMask = this.WinsMask.slice();
    if (this.BGItemValues != null) cloned.BGItemValues = this.BGItemValues.slice();
    if (this.BGItemMasks != null) cloned.BGItemMasks = this.BGItemMasks.slice();
    return cloned
};

function VsBonusGamePlayerChoice(index) {
    this.Index = index;
    this.PickType = 0
}

function VsExpandingSymbolData() {
    this.ExpandingSymbolId = 0;
    this.SourcePositions = [];
    this.TargetPositions = []
}
VsExpandingSymbolData.prototype.Clone = function() {
    var clone = new VsExpandingSymbolData;
    clone.ExpandingSymbolId = this.ExpandingSymbolId;
    clone.SourcePositions = this.SourcePositions.slice();
    clone.TargetPositions = this.TargetPositions.slice();
    return clone
};
VsExpandingSymbolData.prototype.CloneHelper = function() {
    return this.Clone()
};

function VsFreeRound() {
    this.RoundsLeft = 0;
    this.TotalWin = 0;
    this.Type = VsFreeRound.RoundType.Spins;
    this.BonusCode = ""
}
VsFreeRound.RoundType = {
    Spins: 0,
    Timed: 1,
    BonusBoost: 2
};
VsFreeRound.prototype.ToString = function() {
    return "{RoundType:" + this.Type + ", RoundsLeft:" + this.RoundsLeft + ", TotalWin:" + this.TotalWin + "}"
};
VsFreeRound.prototype.Clone = function() {
    var clone = new VsFreeRound;
    clone.RoundsLeft = this.RoundsLeft;
    clone.TotalWin = this.TotalWin;
    clone.Type = this.Type;
    clone.BonusCode = this.BonusCode;
    return clone
};
VsFreeRound.prototype.CloneHelper = function() {
    return this.Clone()
};

function VsFreeRoundEvent() {
    this.Type = VsFreeRoundEvent.EventType.Start;
    this.Bet = 0;
    this.Lines = 0;
    this.RoundsLeft = 0;
    this.TurboSpinMode = false;
    this.PlayLaterAvailable = false;
    this.EndDateTimestamp = -1;
    this.IsFreeRoundPending = false;
    this.PromoLocalizedName = "";
    this.PromoType = ""
}
VsFreeRoundEvent.EventType = {
    Start: 0,
    Finish: 1,
    Error: 2
};
VsFreeRoundEvent.prototype.ToString = function() {
    return "{Type:" + this.Type + ", Bet:" + this.Bet + ", Lines:" + this.Lines + ", RoundsLeft:" + this.RoundsLeft + ", TurboSpinMode:" + this.TurboSpinMode + ", PlayLaterAvailable:" + this.PlayLaterAvailable + ", EndDateTimestamp:" + this.EndDateTimestamp + ", IsFreeRoundPending:" + this.IsFreeRoundPending + ", PromoLocalizedName:" + this.PromoLocalizedName + ", PromoType:" + this.PromoType + "}"
};
VsFreeRoundEvent.prototype.Clone = function() {
    var clone = new VsFreeRoundEvent;
    clone.Type = this.Type;
    clone.Bet = this.Bet;
    clone.Lines = this.Lines;
    clone.RoundsLeft = this.RoundsLeft;
    clone.TurboSpinMode = this.TurboSpinMode;
    clone.PlayLaterAvailable = this.PlayLaterAvailable;
    clone.EndDateTimestamp = this.EndDateTimestamp;
    clone.IsFreeRoundPending = this.IsFreeRoundPending;
    clone.PromoLocalizedName = this.PromoLocalizedName;
    clone.PromoType = this.PromoType;
    return clone
};
VsFreeRoundEvent.prototype.CloneHelper = function() {
    return this.Clone()
};
goog.provide("UHT.VsFreeSpinBonusGame");
goog.require("UHT.BaseDataStructures");

function VsFreeSpinBonusGame() {
    this.BonusItems = [];
    this.GameOver = false;
    this.Level = 0;
    this.Lifes = -1;
    this.SpinsWin = 0;
    this.MultipliersWin = 0
}
VsFreeSpinBonusGame.prototype.Clone = function() {
    var cloned = new VsFreeSpinBonusGame;
    cloned.GameOver = this.GameOver;
    cloned.Level = this.Level;
    cloned.Lifes = this.Lifes;
    cloned.SpinsWin = this.SpinsWin;
    cloned.MultipliersWin = this.MultipliersWin;
    if (this.BonusItems != null) cloned.BonusItems = this.BonusItems.slice();
    return cloned
};
VsFreeSpinBonusGame.BonusItem = function(value, status, type) {
    this.Value = value;
    this.Status = status;
    this.Type = type
};
VsFreeSpinBonusGame.BonusItem.BonusItemStatus = {
    Available: 0,
    Selected: 1
};
VsFreeSpinBonusGame.BonusItem.BonusItemType = {
    Spin: 0,
    Multiplier: 1
};
VsFreeSpinBonusGame.BonusItem.prototype.ToString = function() {
    return "BonusItem {" + "Status=" + this.Status + ", Type=" + this.Type + ", Value=" + this.Value + "}"
};
goog.require("UHT.VsFreeSpinBonusGame");
goog.require("UHT.BaseDataStructures");

function VsFreeSpin() {
    this._currentNumber = 0;
    this._maxNumber = 0;
    this._totalNumber = 0;
    this._currentWin = 0;
    this._totalWin = 0;
    this._totalMultipl = 0;
    this._currentWinMultiplied = 0;
    this._totalWinMultiplied = 0;
    this.PickedOptionIndex = -1;
    this.BonusGame = null;
    this._mysteryScatter = [];
    this._needGetMysteryScatter = false;
    this.fstype = -1
}
VsFreeSpin.prototype.SetCurrentNumber = function(currentNumber) {
    this._currentNumber = currentNumber
};
VsFreeSpin.prototype.GetCurrentNumber = function() {
    return this._currentNumber
};
VsFreeSpin.prototype.SetMaxNumber = function(maxNumber) {
    this._maxNumber = maxNumber
};
VsFreeSpin.prototype.GetMaxNumber = function() {
    return this._maxNumber
};
VsFreeSpin.prototype.SetTotalNumber = function(totalNumber) {
    this._totalNumber = totalNumber
};
VsFreeSpin.prototype.GetTotalNumber = function() {
    return this._totalNumber
};
VsFreeSpin.prototype.SetTotalWin = function(totalWin) {
    this._totalWin = totalWin
};
VsFreeSpin.prototype.GetTotalWin = function() {
    return this._totalWin
};
VsFreeSpin.prototype.SetTotalMultipl = function(totalMultipl) {
    this._totalMultipl = totalMultipl
};
VsFreeSpin.prototype.GetTotalMultipl = function() {
    return this._totalMultipl
};
VsFreeSpin.prototype.IsLastFreeSpin = function() {
    return this._totalNumber > 0
};
VsFreeSpin.prototype.IsFirstFreeSpin = function() {
    return this._currentNumber == 1
};
VsFreeSpin.prototype.GetCurrentWin = function() {
    return this._currentWin
};
VsFreeSpin.prototype.SetCurrentWin = function(currentWin) {
    this._currentWin = currentWin
};
VsFreeSpin.prototype.GetCurrentWinMultiplied = function() {
    return this._currentWinMultiplied
};
VsFreeSpin.prototype.SetCurrentWinMultiplied = function(value) {
    this._currentWinMultiplied = value
};
VsFreeSpin.prototype.SetTotalWinMultiplied = function(value) {
    this._totalWinMultiplied = value
};
VsFreeSpin.prototype.GetTotalWinMultiplied = function() {
    return this._totalWinMultiplied
};
VsFreeSpin.prototype.GetMysteryScatter = function() {
    return this._mysteryScatter
};
VsFreeSpin.prototype.SetMysteryScatter = function(mysteryScatter) {
    this._mysteryScatter = mysteryScatter
};
VsFreeSpin.prototype.IsNeedGetMysteryScatter = function() {
    return this._needGetMysteryScatter
};
VsFreeSpin.prototype.SetNeedGetMysteryScatter = function(needGetMysteryScatter) {
    this._needGetMysteryScatter = needGetMysteryScatter
};
VsFreeSpin.prototype.Clone = function() {
    var cloned = new VsFreeSpin;
    cloned._currentNumber = this._currentNumber;
    cloned._maxNumber = this._maxNumber;
    cloned._totalNumber = this._totalNumber;
    cloned._currentWin = this._currentWin;
    cloned._totalWin = this._totalWin;
    cloned._totalMultipl = this._totalMultipl;
    cloned._currentWinMultiplied = this._currentWinMultiplied;
    cloned._totalWinMultiplied = this._totalWinMultiplied;
    cloned.PickedOptionIndex = this.PickedOptionIndex;
    cloned._mysteryScatter = this._mysteryScatter.slice();
    cloned._needGetMysteryScatter =
        this._needGetMysteryScatter;
    if (this.BonusGame != null) cloned.BonusGame = this.BonusGame.Clone();
    return cloned
};

function VsFreeSpinOption() {
    this.FreeSpinsCount = 0;
    this.FreeSpinsMultiplier = 0;
    this.FreeSpinsStartingMultiplier = 0;
    this.FreeSpinsStackedSymbol = 0;
    this.WildSymbolIndex = -1;
    this.SpecialFeatureName = "";
    this.ReelSymbolsToBeReplaced = [];
    this.RSTBSymbolId = -1;
    this.TriggerSymbolRandomMultiplier = -1;
    this.TSRandomMultipliers = [];
    this.WildWinMultipliers = []
}
VsFreeSpinOption.prototype.Clone = function() {
    var clone = new VsFreeSpinOption;
    clone.FreeSpinsCount = this.FreeSpinsCount;
    clone.FreeSpinsMultiplier = this.FreeSpinsMultiplier;
    clone.FreeSpinsStartingMultiplier = this.FreeSpinsStartingMultiplier;
    clone.FreeSpinsStackedSymbol = this.FreeSpinsStackedSymbol;
    clone.WildSymbolIndex = this.WildSymbolIndex;
    clone.SpecialFeatureName = this.SpecialFeatureName;
    clone.WildWinMultipliers = [];
    for (var i = 0; i < this.WildWinMultipliers.length; ++i) clone.WildWinMultipliers.push(this.WildWinMultipliers[i]);
    clone.ReelSymbolsToBeReplaced = [];
    for (var i = 0; i < this.ReelSymbolsToBeReplaced.length; ++i) clone.ReelSymbolsToBeReplaced.push(this.ReelSymbolsToBeReplaced[i]);
    clone.RSTBSymbolId = this.RSTBSymbolId;
    clone.TriggerSymbolRandomMultiplier = this.TriggerSymbolRandomMultiplier;
    clone.TSRandomMultipliers = [];
    for (var i = 0; i < this.TSRandomMultipliers.length; ++i) clone.TSRandomMultipliers.push(this.TSRandomMultipliers[i]);
    return clone
};
VsFreeSpinOption.prototype.CloneHelper = function() {
    return this.Clone()
};

function VsFreeSpinsChainData() {
    this.FSCSpins = [];
    this.FSCMultipliers = [];
    this.FSCSpinsTotal = [];
    this.FSCMultipliersTotal = [];
    this.FSCWinsTotal = [];
    this.FSCMultipliedWinsTotal = [];
    this.FSCSessionsWonThisSpin = 0;
    this.FSCSessionsWonSymbolsCount = []
}
VsFreeSpinsChainData.prototype.HasChainInformation = function() {
    return this.HasNextChainInformation() || this.HasPreviousChainInformation()
};
VsFreeSpinsChainData.prototype.HasNextChainInformation = function() {
    return this.FSCSpins != null || this.FSCMultipliers != null || this.FSCSessionsWonSymbolsCount != null || this.FSCSessionsWonThisSpin > 0
};
VsFreeSpinsChainData.prototype.HasPreviousChainInformation = function() {
    return this.FSCSpinsTotal != null && this.FSCMultipliersTotal != null && this.FSCWinsTotal != null && this.FSCMultipliedWinsTotal != null
};
VsFreeSpinsChainData.prototype.Clone = function() {
    var cloned = new VsFreeSpinsChainData;
    if (this.FSCSpins != null) cloned.FSCSpins = this.FSCSpins.slice();
    if (this.FSCMultipliers != null) cloned.FSCMultipliers = this.FSCMultipliers.slice();
    if (this.FSCSpinsTotal != null) cloned.FSCSpinsTotal = this.FSCSpinsTotal.slice();
    if (this.FSCMultipliersTotal != null) cloned.FSCMultipliersTotal = this.FSCMultipliersTotal.slice();
    if (this.FSCWinsTotal != null) cloned.FSCWinsTotal = this.FSCWinsTotal.slice();
    if (this.FSCMultipliedWinsTotal != null) cloned.FSCMultipliedWinsTotal =
        this.FSCMultipliedWinsTotal.slice();
    cloned.FSCSessionsWonThisSpin = this.FSCSessionsWonThisSpin;
    if (this.FSCSessionsWonSymbolsCount != null) cloned.FSCSessionsWonSymbolsCount = this.FSCSessionsWonSymbolsCount.slice();
    return cloned
};
VsFreeSpinsChainData.prototype.CloneHelper = function() {
    return this.Clone()
};
goog.require("UHT.BaseDataStructures");

function VsFSPurchaseData() {
    this.freeSpinsBought = 0
}
VsFSPurchaseData.prototype.Clone = function() {
    var cloned = new VsFSPurchaseData;
    cloned.freeSpinsBought = this.freeSpinsBought;
    return cloned
};

function VsFSPurchaseConfig() {
    this.purchaseOptions = [];
    this.optionIndex = -2
}
VsFSPurchaseConfig.PurchaseOption = function() {
    this.bet = 0;
    this.fsCount = 0;
    this.betLevel = 0
};
VsFSPurchaseConfig.prototype.Clone = function() {
    var cloned = new VsFSPurchaseConfig;
    cloned.optionIndex = this.optionIndex;
    cloned.purchaseOptions = [];
    for (var i = 0; i < this.purchaseOptions.length; i++) {
        cloned.purchaseOptions.push(new VsFSPurchaseConfig.PurchaseOption);
        cloned.purchaseOptions[i].bet = this.purchaseOptions[i].bet;
        cloned.purchaseOptions[i].fsCount = this.purchaseOptions[i].fsCount;
        cloned.purchaseOptions[i].betLevel = this.purchaseOptions[i].betLevel
    }
    return cloned
};

function VsGoldSymbol() {
    this.reels = null;
    this.symbols = null;
    this.awards = null
}
VsGoldSymbol.prototype.Clone = function() {
    var cloned = new VsGoldSymbol;
    if (this.reels != null) cloned.reels = this.reels.slice();
    if (this.symbols != null) cloned.symbols = this.symbols.slice();
    if (this.awards != null) cloned.awards = this.awards.slice();
    return cloned
};
goog.require("UHT.BaseDataStructures");

function VsInitData() {
    this.Bets = [];
    this._reelSymbols = [];
    this.ReelSets = null;
    this.NextReelSymbols = [];
    this.Bet = 0;
    this.DefaultBet = 0;
    this.ExplicitMaxTotalBet = -1;
    this.Line = 0;
    this.Scatters = null;
    this.Paytable = null;
    this.Wilds = null;
    this.WildScatters = null;
    this.Bonuses = null;
    this.GamblingSettings = null;
    this.GamblingHistory = null;
    this.WildRandomLineMpConfig = null;
    this.RandomAwardConfig = null;
    this.ProgressiveConfig = null;
    this.MoneySymbolConfig = null;
    this.BetLevelSettings = null;
    this.FreeSpinsPurchaseConfig = null;
    this.ReelSetIndex = -1;
    this.ReelSetIndexCurrent = -1;
    this.StackedSymbolIndex = -1;
    this.StackedSymbolIndexCurrent = -1;
    this.InitialMysterySymbolId = null;
    this.BGItemValues = [];
    this.BGItemMasks = [];
    this.naSymbolId = -1
}
Object.defineProperties(VsInitData.prototype, {
    ReelSymbols: {
        set: function(value) {
            this._reelSymbols = value
        },
        get: function() {
            if (this.ReelSets != null) {
                if (this.ReelSetIndexCurrent >= 0) return this.ReelSets[this.ReelSetIndexCurrent];
                return this.ReelSets[this.ReelSetIndex]
            }
            return this._reelSymbols
        }
    }
});
VsInitData.prototype.CombinePaytable = function() {
    if (this.Paytable != null) {
        var i;
        if (this.Scatters != null)
            if (this.Scatters[0].Pays != null) {
                this.Paytable[1] = [];
                for (i = 0; i < this.Scatters[0].Pays.length; i++) this.Paytable[1].push(this.Scatters[0].Pays[i])
            }
        if (this.Wilds != null)
            if (this.Wilds[0].Pays != null) {
                this.Paytable[2] = [];
                for (i = 0; i < this.Wilds[0].Pays.length; i++) this.Paytable[2].push(this.Wilds[0].Pays[i])
            }
    }
};
VsInitData.prototype.Clone = function() {
    var cloned = new VsInitData;
    cloned.Bet = this.Bet;
    cloned.DefaultBet = this.DefaultBet;
    cloned.ExplicitMaxTotalBet = this.ExplicitMaxTotalBet;
    cloned.Line = this.Line;
    cloned.ReelSetIndex = this.ReelSetIndex;
    cloned.ReelSetIndexCurrent = this.ReelSetIndexCurrent;
    cloned.StackedSymbolIndex = this.StackedSymbolIndex;
    cloned.StackedSymbolIndexCurrent = this.StackedSymbolIndexCurrent;
    if (this.InitialMysterySymbolId != null) cloned.InitialMysterySymbolId = this.InitialMysterySymbolId.slice();
    if (this.Bets !=
        null) cloned.Bets = this.Bets.slice();
    var i;
    if (this._reelSymbols != null) {
        cloned._reelSymbols = [];
        for (i = 0; i < this._reelSymbols.length; ++i) cloned._reelSymbols[i] = this._reelSymbols[i].slice()
    }
    if (this.ReelSets != null) {
        cloned.ReelSets = [];
        for (i = 0; i < this.ReelSets.length; i++) {
            cloned.ReelSets[i] = [];
            for (var j = 0; j < this.ReelSets[i].length; j++) cloned.ReelSets[i][j] = this.ReelSets[i][j].slice()
        }
    }
    if (this.NextReelSymbols != null) {
        cloned.NextReelSymbols = [];
        for (i = 0; i < this.NextReelSymbols.length; ++i) cloned.NextReelSymbols[i] =
            this.NextReelSymbols[i].slice()
    }
    if (this.Scatters != null) {
        cloned.Scatters = [];
        for (i = 0; i < this.Scatters.length; ++i) cloned.Scatters[i] = this.Scatters[i].Clone()
    }
    if (this.Paytable != null) {
        cloned.Paytable = [];
        for (i = 0; i < this.Paytable.length; ++i) cloned.Paytable[i] = this.Paytable[i].slice()
    }
    if (this.Wilds != null) {
        cloned.Wilds = [];
        for (i = 0; i < this.Wilds.length; ++i) cloned.Wilds[i] = this.Wilds[i].Clone()
    }
    if (this.WildScatters != null) {
        cloned.WildScatters = [];
        for (i = 0; i < this.WildScatters.length; ++i) cloned.WildScatters[i] = this.WildScatters[i].Clone()
    }
    if (this.Bonuses !=
        null) cloned.Bonuses = this.Bonuses.slice();
    if (this.GamblingSettings != null) cloned.GamblingSettings = this.GamblingSettings.Clone();
    if (this.GamblingHistory != null) cloned.GamblingHistory = this.GamblingHistory.Clone();
    if (this.RandomAwardConfig != null) cloned.RandomAwardConfig = this.RandomAwardConfig.Clone();
    if (this.ProgressiveConfig != null) cloned.ProgressiveConfig = this.ProgressiveConfig.CloneHelper();
    if (this.MoneySymbolConfig != null) cloned.MoneySymbolConfig = this.MoneySymbolConfig.Clone();
    if (this.BetLevelSettings !=
        null) cloned.BetLevelSettings = this.BetLevelSettings.Clone();
    if (this.FreeSpinsPurchaseConfig != null) cloned.FreeSpinsPurchaseConfig = this.FreeSpinsPurchaseConfig.Clone();
    return cloned
};
goog.require("UHT.BaseDataStructures");

function VsJackpotConfiguration() {
    this.LineCombinationToWin = [];
    this.MinBetToWin = 0;
    this.MinLineNumberToWin = 0
}
VsJackpotConfiguration.prototype.Clone = function() {
    var clone = new VsJackpotConfiguration;
    clone.MinBetToWin = this.MinBetToWin;
    clone.MinLineNumberToWin = this.MinLineNumberToWin;
    if (this.LineCombinationToWin != null) clone.LineCombinationToWin = this.LineCombinationToWin.slice();
    return clone
};
goog.require("UHT.BaseDataStructures");

function VsJackpotData(data) {
    this.IsActive = false;
    this.JackpotID = 0;
    this.JackpotOrder = 0;
    this.WinJackpotAmount = 0;
    this.jackpotType = VsJackpotData.Type.Undefined;
    this.jackpotStatus = VsJackpotData.Status.Undefined;
    this.jackpotShutdown = false;
    this.jackpotMiniGameEnabled = false;
    this.jackpotNotWon = false;
    this.wonJackpotInstances = null;
    if (data != undefined) {
        this.IsActive = data.IsActive;
        this.JackpotID = data.JackpotID;
        this.JackpotOrder = data.JackpotOrder;
        this.WinJackpotAmount = data.WinJackpotAmount;
        this.jackpotType = data.jackpotType;
        this.jackpotStatus = data.jackpotStatus;
        this.jackpotShutdown = data.jackpotShutdown;
        this.jackpotMiniGameEnabled = data.jackpotMiniGameEnabled;
        this.jackpotNotWon = data.jackpotNotWon;
        var wonInstances = data.wonJackpotInstances;
        if (wonInstances != null) {
            this.wonJackpotInstances = [];
            for (var i = 0; i < wonInstances.length; ++i) this.wonJackpotInstances.push(new VsJackpotData.WonInstance(wonInstances[i]))
        }
    }
    Object.defineProperty(this, "IsWin", {
        get: function() {
            return this.WinJackpotAmount > 0
        }
    })
}
VsJackpotData.Type = {
    Undefined: 0,
    Random: 1,
    TwoSteps: 2
};
VsJackpotData.Status = {
    Undefined: 0,
    Obtained: 1,
    Used: 2
};
VsJackpotData.WonInstance = function(data) {
    this.type = VsJackpotData.WonInstance.Type.Undefined;
    this.jackpotId = 0;
    this.jackpotInstance = 0;
    this.amount = 0;
    this.multiplier = 1;
    this.autoDrawing = false;
    if (data != undefined) {
        this.type = data.type;
        this.jackpotId = data.jackpotId;
        this.jackpotInstance = data.jackpotInstance;
        this.amount = data.amount;
        this.multiplier = data.multiplier;
        this.autoDrawing = data.autoDrawing
    }
};
VsJackpotData.WonInstance.Type = {
    Undefined: 0,
    Progressive: 1,
    NonProgressive: 2
};
VsJackpotData.prototype.IsWin = false;
VsJackpotData.prototype.Clone = function() {
    return new VsJackpotData(this)
};

function VsJackpotVisualization() {
    this.jpvType = VsJackpotVisualization.JpType.badges;
    this.positions = null
}
VsJackpotVisualization.JpType = {
    badges: 0
};
VsJackpotVisualization.prototype.Clone = function() {
    var cloned = new VsJackpotVisualization;
    cloned.jpvType = this.jpvType;
    if (this.positions != null) cloned.positions = this.positions.slice();
    return cloned
};

function VsMergingSymbol() {
    this.mergingPosition = -1;
    this.mergedSymbolId = -1
}
VsMergingSymbol.prototype.Clone = function() {
    var cloned = new VsMergingSymbol;
    cloned.mergingPosition = this.mergingPosition;
    cloned.mergedSymbolId = this.mergedSymbolId;
    return cloned
};
VsMergingSymbol.prototype.CloneHelper = function() {
    return this.Clone()
};

function VsMoneySymbolConfig() {
    this.symbolID = -1;
    this.possibleValues = null;
    this.jackpotValues = null;
    this.jackpotMasks = null
}
VsMoneySymbolConfig.prototype.Clone = function() {
    var cloned = new VsMoneySymbolConfig;
    cloned.symbolID = this.symbolID;
    if (this.possibleValues != null) cloned.possibleValues = this.possibleValues.slice();
    if (this.jackpotValues != null) cloned.jackpotValues = this.jackpotValues.slice();
    if (this.jackpotMasks != null) cloned.jackpotMasks = this.jackpotMasks.slice();
    return cloned
};

function VsMoneySymbolData() {
    this.currentValues = null;
    this.currentSymbolsLook = null;
    this.totalWin = -1
}
VsMoneySymbolData.prototype.Clone = function() {
    var cloned = new VsMoneySymbolData;
    if (this.currentValues != null) cloned.currentValues = this.currentValues.slice();
    if (this.currentSymbolsLook != null) cloned.currentSymbolsLook = this.currentSymbolsLook.slice();
    cloned.totalWin = this.totalWin;
    return cloned
};
goog.require("UHT.BaseDataStructures");

function VsNudgedSymbolsData(reelID, startingSymbolsIDs, nudgedSymbolsIDs, nudgedStopPosition, nudgeDirection) {
    this.reelID = reelID;
    this.startingSymbolsIDs = startingSymbolsIDs;
    this.nudgedSymbolsIDs = nudgedSymbolsIDs;
    this.nudgedStopPosition = nudgedStopPosition;
    this.nudgeDirection = nudgeDirection
}
VsNudgedSymbolsData.prototype.Clone = function() {
    var cloned = new VsNudgedSymbolsData(this.reelID, this.startingSymbolsIDs, this.nudgedSymbolsIDs, this.nudgedStopPosition, this.nudgeDirection);
    if (this.startingSymbolsIDs != null) cloned.startingSymbolsIDs = this.startingSymbolsIDs.slice();
    if (this.nudgedSymbolsIDs != null) cloned.nudgedSymbolsIDs = this.nudgedSymbolsIDs.slice();
    return cloned
};

function VsOpeningSymbolsData() {
    this.Positions = [];
    this.OSFreeSpinsWon = 0;
    this.OSMultiplierWon = 0
}
VsOpeningSymbolsData.prototype.Clone = function() {
    var cloned = new VsOpeningSymbolsData;
    if (this.Positions != null) cloned.Positions = this.Positions.slice();
    cloned.OSFreeSpinsWon = this.OSFreeSpinsWon;
    cloned.OSMultiplierWon = this.OSMultiplierWon;
    return cloned
};
VsOpeningSymbolsData.prototype.CloneHelper = function() {
    return this.Clone()
};

function VsPossibleRandomSymbolMultipliers() {
    this.symbolId = -1;
    this.symbolMultipliers = []
}
VsPossibleRandomSymbolMultipliers.prototype.Clone = function() {
    var clone = new VsPossibleRandomSymbolMultipliers;
    clone.symbolId = this.symbolId;
    for (var i = 0; i < this.symbolMultipliers.length; i++) clone.symbolMultipliers.push(this.symbolMultipliers[i]);
    return clone
};
VsPossibleRandomSymbolMultipliers.prototype.CloneHelper = function() {
    return this.Clone()
};

function VSProgressiveFeatureConfig() {
    this.pickedSymbolPosition = -1;
    this.progressSymbolIDs = null
}
VSProgressiveFeatureConfig.prototype.CloneHelper = function() {
    return this.Clone()
};
VSProgressiveFeatureConfig.prototype.Clone = function() {
    var cloned = new VSProgressiveFeatureConfig;
    cloned.pickedSymbolPosition = this.pickedSymbolPosition;
    if (this.progressSymbolIDs != null) cloned.progressSymbolIDs = this.progressSymbolIDs.slice();
    return cloned
};

function VsProgressiveFeatureData() {
    this.needsReset = false;
    this.level = 0;
    this.progress = 0;
    this.targetProgress = 0;
    this.currentAttempt = 0;
    this.attempts = 0;
    this.accumulatedWin = 0;
    this.prizeWin = 0;
    this.prizeMultiplier = 0;
    this.winMultiplier = 0
}
VsProgressiveFeatureData.prototype.Clone = function() {
    var cloned = new VsProgressiveFeatureData;
    cloned.needsReset = this.needsReset;
    cloned.level = this.level;
    cloned.progress = this.progress;
    cloned.targetProgress = this.targetProgress;
    cloned.currentAttempt = this.currentAttempt;
    cloned.attempts = this.attempts;
    cloned.accumulatedWin = this.accumulatedWin;
    cloned.prizeWin = this.prizeWin;
    cloned.prizeMultiplier = this.prizeMultiplier;
    cloned.winMultiplier = this.winMultiplier;
    return cloned
};
VsProgressiveFeatureData.prototype.CloneHelper = function() {
    return this.Clone()
};

function VsRandomAwardConfig() {
    this.awardReelsCount = 0;
    this.awardReels = null;
    this.awardSymbolsNormal = null;
    this.awardSymbolsFreeSpins = null;
    this.possibleAwards = null
}
VsRandomAwardConfig.prototype.GetAwardIndex = function(award) {
    for (var i = 0; i < this.possibleAwards.length; i++)
        if (award.Type == this.possibleAwards[i].Type && award.Value == this.possibleAwards[i].Value) return i;
    return -1
};
VsRandomAwardConfig.prototype.GetAwardAtIndex = function(index) {
    return this.possibleAwards[index]
};
VsRandomAwardConfig.prototype.GetSmallestAwardOnReel = function(reelIdx) {
    var min = this.GetAwardIndex(this.awardReels[reelIdx][0]);
    for (var i = 0; i < this.awardReels[reelIdx].length; i++)
        if (min > this.GetAwardIndex(this.awardReels[reelIdx][i])) min = this.GetAwardIndex(this.awardReels[reelIdx][i]);
    return min
};
VsRandomAwardConfig.prototype.ProcessPossibleAwards = function() {
    var i;
    var j;
    var tmp;
    this.possibleAwards = [];
    for (i = 0; i < this.awardReelsCount; i++)
        for (j = 0; j < this.awardReels[i].length; j++)
            if (!this.ListContains(this.possibleAwards, this.awardReels[i][j])) this.possibleAwards.push(this.awardReels[i][j]);
    for (i = 0; i < this.possibleAwards.length; i++)
        for (j = 0; j < this.possibleAwards.length - 1; j++)
            if (this.possibleAwards[j].Type == VsRandomAward.AwardType.Multiplier && this.possibleAwards[j + 1].Type == VsRandomAward.AwardType.Multiplier) {
                if (this.possibleAwards[j +
                        1].Value < this.possibleAwards[j].Value) {
                    tmp = this.possibleAwards[j];
                    this.possibleAwards[j] = this.possibleAwards[j + 1];
                    this.possibleAwards[j + 1] = tmp
                }
            } else if (this.possibleAwards[j].Type == VsRandomAward.AwardType.Trigger && this.possibleAwards[j + 1].Type == VsRandomAward.AwardType.Multiplier) {
        tmp = this.possibleAwards[j];
        this.possibleAwards[j] = this.possibleAwards[j + 1];
        this.possibleAwards[j + 1] = tmp
    }
};
VsRandomAwardConfig.prototype.ListContains = function(_list, award) {
    for (var i = 0; i < _list.length; i++)
        if (_list[i].Type == award.Type && _list[i].Value == award.Value) return true;
    return false
};
VsRandomAwardConfig.prototype.Clone = function() {
    var clone = new VsRandomAwardConfig;
    clone.awardReelsCount = this.awardReelsCount;
    if (this.awardReels != null) {
        clone.awardReels = [];
        for (var i = 0; i < this.awardReels.length; i++) clone.awardReels.push(this.awardReels[i].slice())
    }
    if (this.awardSymbolsNormal != null) clone.awardSymbolsNormal = this.awardSymbolsNormal.slice();
    if (this.awardSymbolsFreeSpins != null) clone.awardSymbolsFreeSpins = this.awardSymbolsFreeSpins.slice();
    if (this.possibleAwards != null) clone.possibleAwards = this.possibleAwards.slice();
    return clone
};

function VsRandomAward() {
    this.Type = VsRandomAward.AwardType.None;
    this.Value = 0;
    this.FeatureID = -1
}
VsRandomAward.AwardType = {
    None: 0,
    Trigger: 1,
    Multiplier: 2,
    FeatureTrigger: 3
};

function VsRandomSymbolMultiplier() {
    this.symbolId = -1;
    this.symbolPositions = [];
    this.multiplierValue = -1
}
VsRandomSymbolMultiplier.prototype.Clone = function() {
    var clone = new VsRandomSymbolMultiplier;
    clone.symbolId = this.symbolId;
    for (var i = 0; i < this.symbolPositions.length; i++) clone.symbolPositions.push(this.symbolPositions[i]);
    clone.multiplierValue = this.multiplierValue;
    return clone
};
VsRandomSymbolMultiplier.prototype.CloneHelper = function() {
    return this.Clone()
};

function VsRandomWildsData() {
    this.RandomSymbolID = 0;
    this.TargetPositions = null
}
VsRandomWildsData.prototype.Clone = function() {
    var cloned = new VsRandomWildsData;
    cloned.RandomSymbolID = this.RandomSymbolID;
    cloned.TargetPositions = null;
    if (this.TargetPositions != null) {
        cloned.TargetPositions = [];
        for (var i = 0; i < this.TargetPositions.length; i++) cloned.TargetPositions.push(this.TargetPositions[i])
    }
    return cloned
};
VsRandomWildsData.prototype.CloneHelper = function() {
    return this.Clone()
};
goog.require("UHT.BaseDataStructures");

function VsRequest() {
    this.Bet = 0;
    this.Line = 0;
    this.Symbol = "";
    this.BonusGameChoice = "";
    this.TryMeOnce = false;
    this.ProgressPick = -1
}
VsRequest.prototype.Clone = function() {
    var clone = new VsRequest;
    clone.Bet = this.Bet;
    clone.Line = this.Line;
    clone.Symbol = this.Symbol;
    clone.BonusGameChoice = this.BonusGameChoice;
    clone.TryMeOnce = this.TryMeOnce;
    clone.ProgressPick = this.ProgressPick;
    return clone
};

function VsRespinLine() {
    this.id = 0;
    this.respinsCount = 0;
    this.positions = null
}

function VsRespin() {
    this.RespinType = "";
    this.Indices = [];
    this.CurrentRespin = -1;
    this.MaxRespins = -1;
    this.TotalRespins = -1;
    this.IsDone = false;
    this.RespinsPlayed = -1;
    this.RespinsAdded = -1;
    this.Lines = null
}
VsRespin.prototype.Clone = function() {
    var cloned = new VsRespin;
    cloned.RespinType = this.RespinType;
    if (this.Indices != null) {
        cloned.Indices = [];
        for (var i = 0; i < this.Indices.length; ++i) cloned.Indices[i] = this.Indices[i].slice()
    }
    cloned.CurrentRespin = this.CurrentRespin;
    cloned.MaxRespins = this.MaxRespins;
    cloned.TotalRespins = this.TotalRespins;
    cloned.IsDone = this.IsDone;
    cloned.RespinsPlayed = this.RespinsPlayed;
    cloned.RespinsAdded = this.RespinsAdded;
    cloned.Lines = this.Lines;
    return cloned
};
VsRespin.prototype.CloneHelper = function() {
    return this.Clone()
};
goog.require("UHT.BaseDataStructures");
var NextGameAction = {
    None: 0,
    Spin: 1,
    Collect: 2,
    Gamble: 3,
    Bonus: 4,
    CollectBonus: 5,
    FSOption: 6,
    MysteryScatter: 7,
    FSBonus: 8,
    GambleCollect: 9,
    JackpotCollect: 10,
    GambleOption: 11,
    PlayJackpot: 12
};

function VsResponse() {
    this.SlotHeight = 3;
    this.SlotLines = 0;
    this.Balance = 0;
    this.BonusBalance = 0;
    this.Win = 0;
    this.ExtraAwardWin = 0;
    this.RespinCycleWin = 0;
    this.RandomWildsData = null;
    this.UpSymbols = null;
    this.ExpandingSymbolsData = null;
    this.SymbolsBeforeExpanding = [];
    this.WinScreenSymbols = [];
    this.ReelPositions = [];
    this.VsWinLines = [];
    this.VsBonusGame = null;
    this.FreeSpinsOptions = null;
    this.WildRandomMultipliers = null;
    this.VsFreeSpin = null;
    this.FreeRound = null;
    this.FreeRoundEvents = null;
    this.VsInitData = null;
    this.JackpotVisualisation =
        null;
    this.GoldSymbol = null;
    this.SymbolReplacementData = null;
    this.WRLMResponse = null;
    this.WRLMCurrentSets = null;
    this.VsGamblingButtonState = new VsGamblingButtonState(false, false, false);
    this.VsJackpotData = null;
    this.Respin = null;
    this.ProgressiveData = null;
    this.MoneySymbolData = null;
    this.StickySymbols = null;
    this.MergingSymbols = null;
    this.RandomAwardResponse = null;
    this.RandomSymbolMultipliers = null;
    this.PossibleRandomSymbolMultipliers = null;
    this.FreeSpinsChainData = null;
    this.TruncatedVsFreeSpin = null;
    this.OpeningSymbolsData =
        null;
    this.SpinOneReelData = null;
    this.TumblingData = null;
    this.FreeSpinsPurchaseData = null;
    this.RandomMysterySymbolId = null;
    this.PatternedMysterySymbols = null;
    this.SymbolsAbove = null;
    this.SymbolsBelow = null;
    this.NextReelsSymbolsList = null;
    this.NextGameActions = null;
    this.SpinCycleWin = 0;
    this.ReturnToPlayer = -1;
    this.ReturnToPlayerMin = -1;
    this.TumblingWin = 0;
    this.ReelSetIndex = -1;
    this.ReelSetIndexCurrent = -1;
    this.StackedSymbolIndex = -1;
    this.StackedSymbolIndexCurrent = -1;
    this.gambleV2Data = null;
    this.NudgedSymbolsData = null
}
VsResponse.prototype.GetVsFreeSpin = function() {
    return this.VsFreeSpin
};
VsResponse.prototype.SetVsFreeSpin = function(vsFreeSpin) {
    this.VsFreeSpin = vsFreeSpin
};
VsResponse.prototype.SetVsJackpotData = function(vsJackpotData) {
    this.VsJackpotData = vsJackpotData
};
VsResponse.prototype.SetVsBonusGameData = function(vsBonusGame) {
    this.VsBonusGame = vsBonusGame
};
VsResponse.prototype.GetVsBonusGameData = function() {
    return this.VsBonusGame
};
VsResponse.prototype.HasExpandingSymbols = function() {
    return this.ExpandingSymbolsData != null && this.ExpandingSymbolsData.length > 0
};
VsResponse.prototype.IsWin = function() {
    return this.Win > 0
};
VsResponse.prototype.IsBonus = function() {
    return this.VsBonusGame != null
};
VsResponse.prototype.IsBonusGameOver = function() {
    return this.VsBonusGame != null && this.VsBonusGame.GameOver == true
};
VsResponse.prototype.IsBonusRespin = function() {
    if (this.VsBonusGame != undefined) return this.VsBonusGame.maxBonusRespins > 0;
    else return false
};
VsResponse.prototype.BonusDoesNotNeedInit = function() {
    if (this.VsBonusGame != null) {
        var bgIds = XT.GetObject(Vars.NoInitBonusGameTypes);
        return bgIds.indexOf(this.VsBonusGame.type) >= 0
    } else return false
};
VsResponse.prototype.BonusIdDoesNotNeedInit = function() {
    if (this.VsBonusGame != null) {
        var bgIds = XT.GetObject(Vars.NoInitBonusGameIds);
        return bgIds.indexOf(this.VsBonusGame.id) >= 0
    } else return false
};
VsResponse.prototype.IsBonusFSPick = function() {
    if (this.VsBonusGame != null) return this.VsBonusGame.MultipliedSymbolPositions != null;
    else return false
};
VsResponse.prototype.IsBonusOptions = function() {
    if (this.VsBonusGame != null && this.VsBonusGame.BonusTable != null) return this.VsBonusGame.BonusTable.WinsMask != null;
    return false
};
VsResponse.prototype.IsOpeningSymbols = function() {
    return XT.GetObject(Vars.OpeningSymbolsData) != null
};
VsResponse.prototype.HasFreeSpinOptions = function() {
    return this.FreeSpinsOptions != null
};
VsResponse.prototype.IsFreeSpins = function() {
    return this.VsFreeSpin != null
};
VsResponse.prototype.IsFreeSpinBonusGame = function() {
    return this.VsFreeSpin != null && this.VsFreeSpin.BonusGame != null
};
VsResponse.prototype.IsInit = function() {
    return this.VsInitData != null
};
VsResponse.prototype.WasDoBonus = function() {
    if (!this.IsBonus()) return false;
    return this.VsBonusGame.initialized
};
VsResponse.prototype.WasDoFSBonus = function() {
    if (!this.IsFreeSpinBonusGame()) return false;
    return this.VsFreeSpin.BonusGame.Level > 0
};
VsResponse.prototype.IsJackpotWin = function() {
    return this.VsJackpotData != null && this.VsJackpotData.IsWin
};
VsResponse.prototype.IsJackpotEnable = function() {
    return this.VsJackpotData != null && this.VsJackpotData.IsActive
};
VsResponse.prototype.IsRespin = function() {
    return this.Respin != null
};
VsResponse.prototype.Clone = function() {
    var cloned = new VsResponse;
    cloned.SlotHeight = this.SlotHeight;
    cloned.SlotLines = this.SlotLines;
    cloned.Balance = this.Balance;
    cloned.BonusBalance = this.BonusBalance;
    cloned.Win = this.Win;
    cloned.TumblingWin = this.TumblingWin;
    cloned.ReelSetIndex = this.ReelSetIndex;
    cloned.ReelSetIndexCurrent = this.ReelSetIndexCurrent;
    cloned.StackedSymbolIndex = this.StackedSymbolIndex;
    cloned.StackedSymbolIndexCurrent = this.StackedSymbolIndexCurrent;
    var i;
    cloned.RandomWildsData = null;
    if (this.RandomWildsData !=
        null) {
        cloned.RandomWildsData = [];
        for (i = 0; i < this.RandomWildsData.length; i++) cloned.RandomWildsData.push(this.RandomWildsData[i].CloneHelper())
    }
    cloned.UpSymbols = null;
    if (this.UpSymbols != null) {
        cloned.UpSymbols = [];
        for (i = 0; i < this.UpSymbols.length; i++) cloned.UpSymbols.push(this.UpSymbols[i])
    }
    cloned.ExpandingSymbolsData = null;
    if (this.ExpandingSymbolsData != null) {
        cloned.ExpandingSymbolsData = [];
        for (i = 0; i < this.ExpandingSymbolsData.length; i++) cloned.ExpandingSymbolsData.push(this.ExpandingSymbolsData[i].CloneHelper())
    }
    cloned.SymbolsBeforeExpanding = [];
    for (i = 0; i < this.SymbolsBeforeExpanding.length; ++i) cloned.SymbolsBeforeExpanding[i] = this.SymbolsBeforeExpanding[i].slice();
    cloned.WinScreenSymbols = [];
    for (i = 0; i < this.WinScreenSymbols.length; ++i) cloned.WinScreenSymbols[i] = this.WinScreenSymbols[i].slice();
    cloned.ReelPositions = this.ReelPositions == null ? [] : this.ReelPositions.slice();
    cloned.VsWinLines = [];
    for (i = 0; i < this.VsWinLines.length; ++i) cloned.VsWinLines[i] = this.VsWinLines[i].Clone();
    if (this.VsBonusGame != null) cloned.VsBonusGame = this.VsBonusGame.Clone();
    if (this.VsFreeSpin != null) cloned.VsFreeSpin = this.VsFreeSpin.Clone();
    if (this.TruncatedVsFreeSpin != null) cloned.TruncatedVsFreeSpin = this.TruncatedVsFreeSpin.Clone();
    if (this.VsInitData != null) cloned.VsInitData = this.VsInitData.Clone();
    if (this.VsJackpotData != null) cloned.VsJackpotData = this.VsJackpotData.Clone();
    cloned.VsGamblingButtonState = this.VsGamblingButtonState.Clone();
    cloned.FreeSpinsOptions = null;
    if (this.FreeSpinsOptions != null) {
        cloned.FreeSpinsOptions = [];
        for (i = 0; i < this.FreeSpinsOptions.length; i++) cloned.FreeSpinsOptions.push(this.FreeSpinsOptions[i].CloneHelper())
    }
    cloned.FreeRound =
        null;
    if (this.FreeRound != null) cloned.FreeRound = this.FreeRound.CloneHelper();
    cloned.FreeRoundEvents = null;
    if (this.FreeRoundEvents != null) {
        cloned.FreeRoundEvents = [];
        for (var j = 0; j < this.FreeRoundEvents.length; j++) cloned.FreeRoundEvents.push(this.FreeRoundEvents[j].CloneHelper())
    }
    if (this.RandomAwardResponse != null) cloned.RandomAwardResponse = this.RandomAwardResponse.Clone();
    if (this.RandomSymbolMultipliers != null) cloned.RandomSymbolMultipliers = this.RandomSymbolMultipliers.slice();
    if (this.PossibleRandomSymbolMultipliers !=
        null) {
        cloned.PossibleRandomSymbolMultipliers = [];
        for (i = 0; i < this.PossibleRandomSymbolMultipliers.length; i++) cloned.PossibleRandomSymbolMultipliers.push(this.PossibleRandomSymbolMultipliers[i].Clone())
    }
    if (this.FreeSpinsChainData != null) cloned.FreeSpinsChainData = this.FreeSpinsChainData.Clone();
    if (this.OpeningSymbolsData != null) cloned.OpeningSymbolsData = this.OpeningSymbolsData.Clone();
    if (this.SpinOneReelData != null) cloned.SpinOneReelData = this.SpinOneReelData.Clone();
    if (this.TumblingData != null) cloned.TumblingData =
        this.TumblingData.Clone();
    if (this.FreeSpinsPurchaseData != null) cloned.FreeSpinsPurchaseData = this.FreeSpinsPurchaseData.Clone();
    if (this.RandomMysterySymbolId != null) cloned.RandomMysterySymbolId = this.RandomMysterySymbolId.slice();
    cloned.PatternedMysterySymbols = null;
    if (this.PatternedMysterySymbols != null) {
        cloned.PatternedMysterySymbols = [];
        for (i = 0; i < this.PatternedMysterySymbols.length; i++) cloned.PatternedMysterySymbols.push(this.PatternedMysterySymbols[i])
    }
    if (this.SymbolsAbove != null) cloned.SymbolsAbove =
        this.SymbolsAbove.slice();
    if (this.SymbolsBelow != null) cloned.SymbolsBelow = this.SymbolsBelow.slice();
    if (this.NextReelsSymbolsList != null) cloned.NextReelsSymbolsList = this.NextReelsSymbolsList.slice();
    if (this.MoneySymbolData != null) cloned.MoneySymbolData = this.MoneySymbolData.Clone();
    if (this.NudgedSymbolsData != null) {
        cloned.NudgedSymbolsData = [];
        for (i = 0; i < this.NudgedSymbolsData.length; i++) cloned.NudgedSymbolsData.push(this.NudgedSymbolsData[i].Clone())
    }
    return cloned
};
VsResponse.prototype.ToString = function() {
    return "VsResponse { SlotHeight = " + this.SlotHeight + ", IsWin = " + this.IsWin() + ", IsBonus = " + this.IsBonus() + ", IsBonusRespin = " + this.IsBonusRespin() + ", IsFreeSpins = " + this.IsFreeSpins() + (this.IsFreeSpins() ? ", IsLastFreeSpin = " + this.VsFreeSpin.IsLastFreeSpin() : "") + ", IsFreeSpinBonusGame = " + this.IsFreeSpinBonusGame() + "}"
};
VsResponse.prototype.HasFreeRoundEvents = function() {
    return this.FreeRoundEvents != null
};
VsResponse.prototype.IsFreeRounds = function() {
    return this.FreeRound != null
};
VsResponse.prototype.isGambleV2 = function() {
    return this.gambleV2Data != null && this.gambleV2Data.optionIndex > -1
};
goog.require("UHT.BaseDataStructures");

function VsScatterData(symbol, pays, freespins, multipliers) {
    this.Symbol = symbol;
    this.Pays = pays;
    this.Freespins = freespins;
    this.Multipliers = multipliers
}
VsScatterData.prototype.Clone = function() {
    var cloned = new VsScatterData(this.Symbol, this.Pays, this.Freespins, this.Multipliers);
    if (this.Pays != null) cloned.Pays = this.Pays.slice();
    if (this.Freespins != null) cloned.Freespins = this.Freespins.slice();
    if (this.Multipliers != null) cloned.Multipliers = this.Multipliers.slice();
    return cloned
};
goog.require("UHT.BaseDataStructures");

function VSSpinOneReelSymbolsData(reelID, reelsToBeSpun, reelCoefs) {
    this.reelID = reelID;
    this.reelsToBeSpun = reelsToBeSpun;
    this.reelCoefs = reelCoefs
}
VSSpinOneReelSymbolsData.prototype.Clone = function() {
    var cloned = new VSSpinOneReelSymbolsData(this.reelID, this.reelsToBeSpun, this.reelCoefs);
    if (this.reelsToBeSpun != null) cloned.reelsToBeSpun = this.reelsToBeSpun.slice();
    if (this.reelCoefs != null) cloned.reelCoefs = this.reelCoefs.slice();
    return cloned
};

function VsStickySymbol() {
    this.currentPosition = -1;
    this.endPosition = -1
}
VsStickySymbol.prototype.Clone = function() {
    var cloned = new VsStickySymbol;
    cloned.currentPosition = this.currentPosition;
    cloned.endPosition = this.endPosition;
    return cloned
};
VsStickySymbol.prototype.CloneHelper = function() {
    return this.Clone()
};
VsStickySymbol.prototype.IsMoving = function() {
    return this.currentPosition != this.endPosition && this.endPosition >= 0
};
VsStickySymbol.prototype.IsSticky = function() {
    return this.currentPosition == this.endPosition
};
VsStickySymbol.prototype.WillDisappear = function() {
    return this.endPosition < 0
};

function VsSymbolReplacement() {
    this.FromSymbolId = -1;
    this.ToSymbolId = -1;
    this.ReplacementPositions = [];
    this.intermediateSymbolIDs = null
}
VsSymbolReplacement.prototype.Clone = function() {
    var cloned = new VsSymbolReplacement;
    cloned.FromSymbolId = this.FromSymbolId;
    cloned.ToSymbolId = this.ToSymbolId;
    if (this.ReplacementPositions != null) cloned.ReplacementPositions = this.ReplacementPositions.slice();
    if (this.intermediateSymbolIDs != null) cloned.intermediateSymbolIDs = this.intermediateSymbolIDs.slice();
    return cloned
};

function VsTumblingData() {
    this.tumblingSymbols = []
}
VsTumblingData.TumblingSymbol = function() {
    this.id = 0;
    this.position = 0
};
VsTumblingData.prototype.Clone = function() {
    var cloned = new VsTumblingData;
    cloned.tumblingSymbols = [];
    for (var i = 0; i < this.tumblingSymbols.length; i++) {
        cloned.tumblingSymbols.push(new VsTumblingData.TumblingSymbol);
        cloned.tumblingSymbols[i].id = this.tumblingSymbols[i].id;
        cloned.tumblingSymbols[i].position = this.tumblingSymbols[i].position
    }
    return cloned
};
VsTumblingData.prototype.CloneHelper = function() {
    return this.Clone()
};
goog.require("UHT.BaseDataStructures");

function VsWildData(symbol, pays, multipliers) {
    this.Symbol = symbol;
    this.Pays = pays;
    this.Multipliers = multipliers
}
VsWildData.prototype.Clone = function() {
    var cloned = new VsWildData(this.Symbol, this.Pays, this.Multipliers);
    if (this.Pays != null) cloned.Pays = this.Pays.slice();
    if (this.Multipliers != null) cloned.Multipliers = this.Multipliers.slice();
    return cloned
};

function MultiplierSet() {
    this.setIndex = 0;
    this.multipliers = null
}
MultiplierSet.prototype.Clone = function() {
    var clone = new MultiplierSet;
    clone.setIndex = this.setIndex;
    if (this.multipliers != null) clone.multipliers = this.multipliers.slice();
    return clone
};

function VsWildRandomLineMultiplier() {}
VsWildRandomLineMultiplier.Configuration = function() {
    this.wildSymbolId = 0;
    this.multiplierSets = null
};
VsWildRandomLineMultiplier.Configuration.prototype.GetCurrentSet = function(_setIndex) {
    for (var i = 0; i < this.multiplierSets.length; i++)
        if (this.multiplierSets[i].setIndex == _setIndex) return this.multiplierSets[i].multipliers;
    return null
};
VsWildRandomLineMultiplier.Configuration.prototype.Clone = function() {
    var clone = new VsWildRandomLineMultiplier.Configuration;
    clone.wildSymbolId = this.wildSymbolId;
    if (this.multiplierSets != null) {
        clone.multiplierSets = [];
        for (var i = 0; i < this.multiplierSets.length; i++) clone.multiplierSets.push(this.multiplierSets[i].Clone())
    }
    return clone
};
VsWildRandomLineMultiplier.SpinResponse = function() {
    this.wildSymbolId = 0;
    this.multiplier = 0;
    this.positions = null
};
VsWildRandomLineMultiplier.SpinResponse.prototype.Clone = function() {
    var clone = new VsWildRandomLineMultiplier.SpinResponse;
    clone.wildSymbolId = this.wildSymbolId;
    clone.multiplier = this.multiplier;
    if (this.positions != null) clone.positions = this.positions.slice();
    return clone
};
VsWildRandomLineMultiplier.CurrentSet = function() {
    this.wildSymbolId = 0;
    this.currentSetIndex = 0
};
VsWildRandomLineMultiplier.CurrentSet.prototype.Clone = function() {
    var clone = new VsWildRandomLineMultiplier.CurrentSet;
    clone.wildSymbolId = this.wildSymbolId;
    clone.currentSetIndex = this.currentSetIndex;
    return clone
};

function VsWildRandomMultiplier() {
    this.SymbolIndex = 0;
    this.Position = 0;
    this.Multiplier = 1
}
VsWildRandomMultiplier.prototype.Clone = function() {
    var clone = new VsWildRandomMultiplier;
    clone.SymbolIndex = this.SymbolIndex;
    clone.Position = this.Position;
    clone.Multiplier = this.Multiplier;
    return clone
};
VsFreeSpinOption.prototype.CloneHelper = function() {
    return this.Clone()
};
goog.require("UHT.BaseDataStructures");

function VsWinLine() {
    this.LineNumber = 0;
    this.WinAmount = 0;
    this.WinPositions = [];
    this.Combination = -1;
    this.Multiplier = 1;
    this.isWinWaysGroup = false;
    this.symbolId = -1;
    this.waysCount = -1;
    this.waysLength = -1;
    this.payingDirection = ""
}
VsWinLine.prototype.Clone = function() {
    var cloned = new VsWinLine;
    cloned.LineNumber = this.LineNumber;
    cloned.WinAmount = this.WinAmount;
    cloned.WinPositions = this.WinPositions.slice();
    cloned.Combination = this.Combination;
    cloned.Multiplier = this.Multiplier;
    cloned.isWinWaysGroup = this.isWinWaysGroup;
    cloned.symbolId = this.symbolId;
    cloned.waysCount = this.waysCount;
    cloned.waysLength = this.waysLength;
    cloned.payingDirection = this.payingDirection;
    return cloned
};
var AdapterEvents = {
    evtCloseGame: "EVT_CLOSE_GAME",
    evtCloseGameCancel: "EVT_CLOSE_GAME_CANCEL",
    evtGameStatus: "EVT_GAME_STATUS",
    evtSound: "EVT_SOUND",
    evtGameLoadComplited: "EVT_GAME_LOAD_COMPLITED",
    evtServerRequest: "EVT_SERVER_REQUEST",
    evtUpdateBalance: "EVT_UPDATE_BALANCE",
    evtUpdateConnectionQuality: "EVT_UPDATE_CONNECTION_QUALITY",
    evtOpenCashier: "EVT_OPEN_CASHIER",
    evtSetTickerPromo: "EVT_SET_TICKER_PROMO",
    evtGetConfiguration: "EVT_GET_CONFIGURATION",
    evtUpdateLoadingProgress: "EVT_UPDATE_LOADING_PROGRESS",
    evtPlayForReal: "EVT_PLAY_FOR_REAL",
    evtChatMessage: "EVT_CHAT_MESSAGE",
    evtChatInit: "EVT_CHAT_INIT",
    evtChatState: "EVT_CHAT_STATE",
    evtGetGameMenu: "EVT_GET_GAME_MENU",
    evtSetGameMenu: "EVT_SET_GAME_MENU",
    evtGameMenuItemSelected: "EVT_GAME_MENU_ITEM_SELECTED",
    evtLogoff: "EVT_LOGOFF",
    evtLogoffOk: "EVT_LOGOFF_OK",
    evtReload: "EVT_RELOAD",
    evtMaximumTabsReached: "EVT_MAXIMUM_TABS_REACHED",
    evtAutoLogout: "EVT_AUTO_LOGOUT",
    evtAutoLogoutUserResponse: "EVT_AUTO_LOGOUT_USER_RESPONSE",
    evtDownloadCasinoClient: "EVT_DOWNLOAD_CLIENT",
    evtClientScreenMode: "EVT_CLIENT_SCREEN_MODE",
    evtUpdateJackpot: "EVT_UPDATE_JACKPOT",
    evtCloseExternalGame: "EVT_CLOSE_EXTERNAL_GAME",
    evtJackpotAmountToFlash: "EVT_NEW_JACKPOT_AMOUNT",
    evtRealityCheck: "EVT_REALITY_CHECK_MESSAGE",
    evtRealityLogoff: "EVT_REALITY_LOGOFF",
    evtRealityClose: "EVT_REALITY_CLOSE",
    evtGameReady: "EVT_UNITY_GAME_READY",
    evtServerResponse: "EVT_HTTP_RESPONSE",
    evtMessageOpened: "EVT_MESSAGE_OPENED",
    evtMessageClosed: "EVT_MESSAGE_CLOSED",
    evtFullscreenOverlayShown: "EVT_FULLSCREEN_OVERLAY_SHOWN",
    evtFullscreenOverlayHidden: "EVT_FULLSCREEN_OVERLAY_HIDDEN",
    evtShowMessage: "EVT_SHOW_MESSAGE"
};
var AdapterParameters = {
    Notify: "common",
    Arguments: "args",
    GameSymbol: "symbol",
    GameActive: "active",
    MethodType: "type",
    Balance: "balance",
    BalanceUpdateTime: "stime",
    ConnectionQuality: "level",
    TickerMessage: "message",
    TickerStyle: "style",
    TabName: "tabName",
    Config: "config",
    Progress: "progress",
    SoundState: "sound",
    ChatMessages: "history",
    ChatInit: "init",
    ChatState: "state",
    ReloadLink: "link",
    MaxTabsCount: "maxcount",
    AutoLogout: "autologout",
    ClientScreenMode: "clientScreenMode",
    JackpotTotalAmount: "totaljackpot",
    Jackpots: "jackpots",
    JackpotAmountToFlash: "newJackpotAmount",
    RealityTime: "time",
    RealitySumm: "summ",
    RealityBalance: "balance",
    ResponseData: "data",
    ResponseStatusCode: "httpCode",
    messageType: "message",
    type: "type",
    unity: "unity",
    sendToAdapterMethod: "sendToAdapter",
    gameActionParameter: "action",
    sendToWrapperEvent: "unityToWrapperMsg"
};
var AdapterMessages = {
    settingsNotSaved: "ALERT_CANT_SAVE_SETTINGS",
    connectionLost: "ALERT_CONNECTION_LOST"
};
var FrameworkConfiguration = {
    resourceUri: "RESOURCES",
    menuUri: "MENU",
    wakeupUri: "WAKEUP",
    getSessionUri: "RETRIEVESESSION",
    settingsUri: "SETTINGS",
    gameServiceUri: "GAMESERVICE",
    clientLogUri: "CLIENTLOG",
    clientLogLevel: "CLIENTLOGLEVEL",
    loginUri: "LOGIN",
    logoutUri: "LOGOUT",
    sessionTimeout: "sessionTimeout",
    facebookUri: "FACEBOOK",
    external: "EXTERNAL",
    casinoName: "CASINONAME",
    externalChat: "EXTERNALCHAT",
    mobileAuthorize: "MOBILE_AUTHORIZE",
    externalAuthorize: "EXTERNAL_AUTHORIZE",
    chatServerPort: "CHAT_PORT",
    isSecure: "SECURE",
    stylename: "STYLENAME",
    currency: "CURRENCY",
    demoMode: "demoMode",
    isDefaultBrand: "DEFAULTC",
    shortcutName: "SHORTCUT_NAME",
    shortcutLink: "SHORTCUT_LINK",
    shortcutIconName: "SHORTCUT_ICON_NAME",
    shortcutUrlToCasinoRes: "SHORTCUT_URL_TO_RES",
    cacheAutorizeName: "CACHE_NAME",
    bundleDomain: "BUNDLE_DOMAIN",
    cacheAutorizeSize: "CACHE_SIZE",
    cacheAutorizeExpiration: "CACHE_EXPIRATION",
    cacheAutorizeSignature: "CACHE_SIGNATURE",
    reloadBalanceUri: "RELOAD_BALANCE",
    reloadJackpotUri: "RELOAD_JACKPOT",
    appVersion: "VERSION",
    applicationStoreUrl: "STORE_URL",
    locale: "LANGUAGE",
    gameSymbol: "GAME_SYMBOL",
    versionInfo: "VERSION_INFO",
    updateAndroidApp: "UPDATE_ANDROID_APP",
    updateAndroidProp: "UPDATE_ANDROID_PROP",
    webLobbyUrl: "WEB_LOBBY",
    extWebLobbyUrl: "EXT_WEB_LOBBY",
    displayClockInFullScreen: "DISPLAY_CLOCK_FULL_MODE",
    gameUrl: "GAME_URL",
    mgckey: "MAGIC_KEY",
    noRating: "NO_RATING",
    gameHistory: "HISTORY",
    gameVerificationUrl: "VERIFY",
    jurisdiction: "jurisdiction",
    jurisdictionRequirements: "jurisdictionRequirements",
    brandRequirements: "brandRequirements",
    promotionurl: "promotionurl",
    rcSettings: "rcSettings",
    amountType: "amountType"
};
var DefaultValues = {
    LanguageSettings: {
        defaultLanguage: "en"
    },
    CurrencySettings: {
        defaultCurrency: "USD"
    },
    DefaultParameters: {
        defaultStylename: "premiumgames",
        defaultGameSymbol: "LobbyComponent"
    },
    ServerProtocol: {
        Login: {
            loginResult: "log",
            loginResultSuccess: "1",
            loginResultFail: "0",
            responseURL: "Url",
            accountType: "acctype",
            memberID: "memberID",
            errorMsg: "msg",
            accountTypeFun: "F",
            accountTypeReal: "R",
            aid: "aid",
            authStatusOk: "OK",
            authStatusUnlogged: "UNLOGGED"
        },
        InitSession: {
            language: "lang",
            type: "type",
            unityType: "UnityClient",
            sessionID: "sessionid"
        },
        SessionManagement: {
            unloggedResponse: "unlogged",
            newSessionResponse: "new session"
        }
    },
    GameParams: {
        gameRequestTimeout: 15,
        gamePnowRequestDelay: 3,
        gameRequestDelay: 2,
        gameConnectionTimeout: 120,
        resourceBrandPath: "brands/",
        resourceGamePath: "games/"
    },
    RetryParams: {
        disableRetry: 0,
        unlimitedRetryCount: -1,
        retryTimeout: 15,
        resRetryTimeout: 3
    },
    NoNetwork: {
        retryCountToShowText: 2,
        wakeUpFailInRow: 2
    },
    ResourceManagerCfg: {
        resourceInfoFileNameSuffix: ".ResInfo.xml",
        componentInfoFileName: "component.info",
        componentStringList: "string.list",
        componentFolder: "components/",
        sharedComponentName: "shared",
        packageExtention: ".zip"
    },
    PackageInfoCfg: {
        packageTypeCommon: "common",
        packageTypeLocalized: "localized",
        sharedComponent: "shared"
    },
    ComponentInfoFormat: {
        componentName: "name",
        componentLocalization: "localization",
        componentDefaultLanguage: "default",
        componentLanguageList: "languages",
        componentPackagesList: "packages",
        componentPackageName: "name",
        componentPackageType: "type"
    },
    Resources: {
        bundlesInfoHead: "languages",
        bundlesLanuageTitle: "language",
        bundlesHead: "bundles",
        bundleName: "name",
        bundleVersion: "version",
        bundlesCommon: "common",
        defaultLanguage: "",
        locolizationFileName: "localization.info",
        resourceInfoFileName: "packages.info",
        versionsInfoFileName: "versions.info",
        versionsInfoHead: "versions"
    },
    StringListFormat: {
        languageID: "language",
        keys: "keys"
    },
    AuthServicesPath: {
        facebook: "/facebook.do"
    },
    AuthServicesDefines: {
        language: "lang",
        action: "method",
        login: "login",
        id: "id",
        token: "token",
        guestId: "gid",
        Facebook: {
            tokenParam: "token",
            successResult: "ok",
            failedResult: "failed"
        }
    },
    UnityGameObjects: {
        casinoSDK: "Casino SDK",
        FBBridgeObject: "FBBridgeObject"
    },
    FBPluginConstants: {
        androidFBPluginClassName: "com.igs.fbplugin.FBPlugin",
        androidFBPluginFunction: "FacebookConnect"
    },
    Settings: {
        settingsPath: "/saveSettings.do",
        action: "method",
        load: "load",
        idParam: "id",
        settingsParam: "settings",
        symbolKey: "symbol",
        settingsKey: "settings"
    },
    ApplicationSettings: {
        settingSeparator: "\n",
        settingIDSeparator: "\t",
        gameSettingsFilename: "game.settings",
        clientSettingsFilename: "client.settings"
    },
    UnityVars: {
        language: "lang",
        gameSymbol: "gs",
        session: "sp",
        styleName: "sn",
        configurationUri: "conf",
        currency: "currency",
        accountType: "accountType",
        gameServerDomain: "gsd",
        bundleVersion: "ver"
    },
    FrameworkConfigurationXml: {
        items: "items",
        authStatus: "/root/auth_status",
        aid: "/root/member/aid",
        type: "/root/member/type",
        item: "item",
        key: "key",
        value: "value"
    },
    LogTransferSetting: {
        defaultTimerDelaySeconds: 5
    },
    Chat: {
        maxMessageLength: 250,
        pingDelay: 5,
        malDelay: 3,
        ImmidiatlyAfterLoginRetryLogic: {
            timeToLostConnect: 10,
            timeToLostConnectShow: 10
        },
        ChatInProcessRetryLogic: {
            timeToLimitedFunctionality: 10
        }
    },
    GameMenu: {
        ItemId: {
            reports: "reports",
            withdraw: "withdraw",
            language: "language"
        }
    },
    Socket: {
        endOfCommand: "\x00",
        bufferLength: 256,
        readTimeout: 500
    },
    ScreenMode: {
        fullScreenMode: "fullScreenMode",
        windowMode: "windowMode"
    },
    TokenInfo: {
        tokenKey: "token",
        domainKey: "domain",
        gameIdKey: "gameId",
        expiresKey: "expires",
        externalLinkKey: "extLink",
        externalKey: "ext",
        tokenFile: "info.dat",
        tokenCookieName: "AUTHTOKEN",
        tokenExpDateCookieName: "AUTHTOKEN_STORE_PERIOD"
    },
    ExternalDataProtocol: {
        tokenKey: "token",
        domainKey: "domain",
        ticketKey: "PathAndQuery",
        protocolKey: "protocol",
        gameIdKey: "symbol",
        protocol: "fungame",
        deviceId: "id",
        uriDelimeter: "?",
        paramSeparator: ":",
        pairSeparator: "&",
        backToLobby: "btl",
        mobileLobbyCategory: "mlc",
        defaultMobileLobbyCategory: "1"
    },
    JackpotXml: {
        jackpot_list: "/jackpot_list",
        list_total_amount: "total_amount",
        jackpot_item: "jackpot",
        jackpotId: "id",
        jackpotAmount: "amount",
        jackpotStyle: "style",
        jackpotGames: "gsymbols"
    },
    JackpotGamesListXml: {
        jackpot_list: "/casino",
        jackpotItem: "jackpot",
        jackpotId: "jackpotid",
        jackpotName: "name",
        gameItem: "game",
        newgame: "newgame",
        premiumgame: "premiumgame",
        gamename: "name",
        gamepic: "pic",
        gamelink: "link"
    },
    BalanceXml: {
        cash: "/CASH",
        balance: "BALANCE"
    },
    JackpotGamesRequest: {
        action: "method",
        actionType: "jackpotList",
        actionParam: "categorySymbol",
        actionParamValue: "jp"
    },
    Timing: {
        wakeupRequestDelayInSeconds: 15,
        wakeupRequestDelayInMiliseconds: 15E3,
        wakeupServiceTotalWorkInMinutes: 10
    },
    ShortcutRes: {
        path: "",
        iconName: ""
    },
    ClientSettingNames: {
        shortcutSettings: "shortcutSettings"
    },
    PossibleOpenGames: {
        maxOpenedCount: 2
    },
    PlayOnRealMoney: {
        paramName: "msg_code",
        allow: "1",
        denied: "0"
    },
    UpdateVersion: {
        updateFolder: "updates/",
        appVersionKey: "version",
        updateImportanceKey: "importance",
        configAppVersionKey: "apk",
        updateFileKey: "file",
        updateInfoFileName: "UpdateInfo.dat"
    },
    GuestId: {
        guestIdFile: "gid.info",
        guestIdKey: "guestId",
        guestIdCookieKey: "GID"
    },
    InbuildDomain: {
        notUse: "default"
    },
    LogTransfer: {
        tmpSwapFile: "tmpLog.log",
        cashFile: "unsent.log",
        sendDataLimit: 1E4
    }
};
DefaultValues.Resources.defaultLanguage = DefaultValues.LanguageSettings.defaultLanguage;
goog.require("UHT.EventHandler");
goog.provide("UHT.EventManager");
var GameEvents = {
    evtConnectionReady: "evtConnectionReady",
    evtInitResponse: "evtInitResponse",
    evtSpinResponse: "evtSpinResponse",
    evtNoMoneySpinResponse: "evtNoMoneySpinResponse",
    evtConfigSwitchedResponse: "evtConfigSwitchedResponse",
    evtInitRequest: "evtInitRequest",
    evtSpinRequest: "evtSpinRequest",
    evtFreespinsFinished: "evtFreespinsFinished",
    evtGambleRequest: "evtGambleRequest",
    evtGambleClose: "evtGambleClose",
    evtGambleResponse: "evtGambleResponse",
    evtMustPlayJackpot: "evtMustPlayJackpot",
    evtPlayJackpotRequest: "evtPlayJackpotRequest",
    evtPlayJackpotResponse: "evtPlayJackpotResponse",
    evtBonusInitResponse: "evtBonusInitResponse",
    evtBonusPickRequest: "evtBonusPickRequest",
    evtBonusPickResponse: "evtBonusPickResponse",
    evtBonusRespinRequest: "evtBonusRespinRequest",
    evtBonusRespinResponse: "evtBonusRespinResponse",
    evtBonusFinishRequest: "evtBonusFinishRequest",
    evtSoundState: "evtSoundState",
    evtGetSettingsRequest: "evtGetSettingsRequest",
    evtUpdateSettingsRequest: "evtUpdateSettingsRequest",
    evtSettingsUpdated: "evtSettingsUpdated",
    evtSettingsNotSaved: "evtSettingsNotSaved",
    evtGameStatus: "evtGameStatus",
    evtFSBGInitRequest: "evtFSBGInitRequest",
    evtFSBGInitResponse: "evtFSBGInitResponse",
    evtFSBGPickRequest: "evtFSBGPickRequest",
    evtFSBGPickResponse: "evtFSBGPickResponse",
    evtMysteryScatterRequest: "evtMysteryScatterRequest",
    evtMysteryScatterResponse: "evtMysteryScatterResponse",
    evtCreateConnectionRequest: "evtCreateConnectionRequest",
    evtFreeRoundsUpdate: "evtFreeRoundsUpdate",
    evtFSOptionsUpdate: "evtFSOptionsUpdate",
    evtFSOptionPickRequest: "evtFSOptionPickRequest",
    evtServerTimeUpdate: "evtServerTimeUpdate",
    evtXTRegisterCallbacks: "evtXTRegisterCallbacks"
};
var ApplicationEvents = {
    evtRequestInitApplication: "evtRequestInitApplication",
    evtRequestAppConfiguration: "evtRequestAppConfiguration",
    evtAppConfigurationReceived: "evtAppConfigurationReceived",
    evtServerOptionsParsed: "evtServerOptionsParsed",
    evtFlashRPCRequest: "evtFlashRPCRequest",
    evtGameLoadingFinished: "evtGameLoadingFinished",
    evtFlashWrapperRPCRequest: "evtFlashWrapperRPCRequest",
    evtServerResponse: "evtServerResponse"
};
var EventManager = {
    handlers: {},
    queuedEvts: [],
    queuedArgs: [],
    Init: function() {},
    AddHandler: function(eventName, callback, object) {
        if (EventManager.handlers[eventName] == undefined) EventManager.handlers[eventName] = [];
        EventManager.handlers[eventName].push(new EventHandler(object, callback))
    },
    ClearCallback: function(callback, object) {
        for (var eventName in EventManager.handlers) {
            if (!EventManager.handlers.hasOwnProperty(eventName)) continue;
            for (var i = 0; i < EventManager.handlers[eventName].length; ++i)
                if (EventManager.handlers[eventName][i].equals(object,
                        callback)) EventManager.handlers[eventName].splice(i, 1)
        }
    },
    optionalEvents: ["EVT_UHT_UPDATE", "EVT_UHT_BEFOREUPDATE"],
    Trigger: function(eventName, param) {
        if (EventManager.optionalEvents.indexOf(eventName) < 0) console.log("Trigger", eventName, param);
        if (EventManager.handlers[eventName] != undefined)
            for (var i = 0; i < EventManager.handlers[eventName].length; ++i) EventManager.handlers[eventName][i].call(param)
    },
    Queue: function(eventName, param) {
        EventManager.queuedEvts.push(eventName);
        EventManager.queuedArgs.push(param)
    },
    TriggerQueued: function() {
        for (var i = 0; i < EventManager.queuedEvts.length; ++i) EventManager.Trigger(EventManager.queuedEvts[i], EventManager.queuedArgs[i]);
        EventManager.queuedEvts.splice(0);
        EventManager.queuedArgs.splice(0)
    }
};
goog.provide("UHT.JackpotHelpers");
var JackpotEvents = {
    evtJackpotStateChanged: "evtJackpotStateChanged",
    evtJackpotsUpdated: "evtJackpotsUpdated"
};
var JackpotDictionary = {
    jackpotAmount: "amount",
    jackpotAmountUSD: "amountUSD",
    jackpotName: "name",
    jackpotId: "jackpotID",
    jackpotOrder: "order",
    jackpotGroupType: "groupKind",
    jackpotStatus: "status",
    jackpotMinBet: "minBet",
    jackpotMinBetUSD: "minBetUSD",
    jackpotRTP: "rtp",
    jackpotInstance: "jackpotInstance",
    jackpotMultipliers: "multipliers",
    communityFeatureDetails: "communityFeatureDetails",
    multipliersRTP: "multipliersRTP",
    prevWonAmount: "prevWonAmount",
    prevWonAmountUSD: "prevWonAmountUSD",
    nextSeedAmount: "nextSeedAmount",
    nextSeedAmountUSD: "nextSeedAmountUSD",
    contributePercent: "contributePercent",
    babyContributeInitialPercent: "babyContributeInitialPercent",
    babyContributePercent: "babyContributePercent",
    babyAmount: "jackpotBabyAmount",
    babyAmountUSD: "jackpotBabyAmountUSD",
    startNextFromSeed: "startNextFromSeed",
    CommunityDetails: {
        winnerAmount: "winnerAmount",
        winnerAmountUSD: "winnerAmountUSD",
        shareAmount: "shareAmount",
        shareAmountUSD: "shareAmountUSD",
        sharedPercentage: "sharedPercentage",
        minWinLimit: "minWinLimit",
        minWinLimitUSD: "minWinLimitUSD",
        detectingPeriodInSec: "detectingPeriodInSec",
        distributionType: "distributionType",
        maxPrizesNumber: "maxPrizesNumber",
        minBet: "minBet",
        minBetUSD: "minBetUSD",
        minTotalBet: "minTotalBet",
        minTotalBetUSD: "minTotalBetUSD"
    }
};
goog.require("UHT.JackpotHelpers");
goog.provide("UHT.JackpotsManager");

function JackpotsManager() {
    this.jackpots = null;
    this.prevJackpots = null;
    this.reloadJpResponse = "";
    this.reloadJpResponseParam = "jackpotReload";
    this.reloadJpInterval = 10;
    this.reloadJpTimer = 0;
    this.hasActiveJp = false;
    this.requestInProgress = false;
    this.percentFormat = "{0}%";
    this.gameJpInfoUpdatedFrame = -1;
    this.statuses = null;
    this.statusIDs = null;
    this.statusRequests = null;
    this.statusRequestIDs = null;
    this.statusRequestURI = "/gs2c/jackpot/status?mgckey={0}&jackpotID={1}&jackpotInstance={2}";
    this.statusResponseHandler = new EventHandler(this,
        this.OnJackpotStatusResponse)
}
JackpotsManager.I = null;
JackpotsManager.prototype.Init = function() {
    JackpotsManager.I = this;
    EventManager.AddHandler(JackpotEvents.evtJackpotStateChanged, this.OnJackpotStateChanged, this);
    if (XT.RegisterAndInitDone) this.OnXTRegisterCallbacks(null);
    else EventManager.AddHandler(GameEvents.evtXTRegisterCallbacks, this.OnXTRegisterCallbacks, this)
};
JackpotsManager.prototype.OnXTRegisterCallbacks = function(param) {
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_RequestSpin, this.OnRequestSpin, this, -1);
    XT.RegisterCallbackEvent(GameInfoVars.Evt_Internal_GameInfoChanged, this.OnGameInfoChanged, this);
    if (ServerOptions.isReplay) {
        XT.RegisterCallbackEvent(ReplaySessionVars.ReplayDirector_Start, this.ReplayReloadJackpot, this);
        XT.RegisterCallbackEvent(ReplaySessionVars.PrepareScenario, this.ReplayReloadJackpot, this)
    }
};
JackpotsManager.prototype.OnRequestSpin = function() {
    if (!_string.IsNullOrEmpty(this.reloadJpResponse)) GameConnection.I.AddRequestExtraParameter(this.reloadJpResponseParam, this.reloadJpResponse)
};
JackpotsManager.prototype.ReplayReloadJackpot = function() {
    var dict = RequestProvider.Instance.GetNextReplayRequestParams();
    if (dict[this.reloadJpResponseParam] != undefined) this.JackpotReloadCallback(dict[this.reloadJpResponseParam], 200)
};
JackpotsManager.prototype.OnJackpotStateChanged = function(jpData) {
    if (jpData == null) {
        this.hasActiveJp = false;
        return
    }
    if (!this.hasActiveJp && jpData.IsActive) this.reloadJpTimer = this.reloadJpInterval;
    this.hasActiveJp = jpData.IsActive;
    if (!this.hasActiveJp) {
        this.prevJackpots = this.jackpots;
        this.jackpots = null;
        this.ReloadStatuses();
        this.QueueJackpotsUpdated()
    }
};
JackpotsManager.prototype.Update = function() {
    if (!this.hasActiveJp || ServerOptions.isReplay) return;
    this.reloadJpTimer += Time.deltaTime;
    if (!this.requestInProgress)
        if (this.reloadJpTimer > this.reloadJpInterval) {
            this.requestInProgress = true;
            ServerHelpers.ReloadJackpot(ServerOptions.gameSymbol, new EventHandler(this, this.JackpotReloadCallback))
        }
};
JackpotsManager.prototype.JackpotReloadCallback = function(response, statusCode) {
    this.prevJackpots = this.jackpots;
    this.jackpots = this.ParseJackpots(response);
    if (this.jackpots == null) this.hasActiveJp = false;
    else this.reloadJpResponse = response;
    this.reloadJpTimer = 0;
    this.requestInProgress = false;
    this.ReloadStatuses();
    this.QueueJackpotsUpdated();
    this.UpdateGameJackpotsInfo()
};
JackpotsManager.prototype.ParseJackpots = function(param) {
    if (_string.IsNullOrEmpty(param)) return null;
    var objList = null;
    try {
        objList = JSON.parse(param)
    } catch (e) {}
    if (objList == null) {
        console.error("JPManager::ParseJackpots - cannot parse jp list");
        return null
    }
    var jpList = [];
    for (var i = 0; i < objList.length; ++i) {
        var dict = objList[i];
        if (dict[JackpotDictionary.jackpotId] == undefined) {
            console.error("JPManager::ParseJackpots - cannot parse jp id");
            continue
        }
        if (dict[JackpotDictionary.jackpotAmount] == undefined) {
            console.error("JPManager::ParseJackpots - cannot parse jp amount");
            continue
        }
        if (dict[JackpotDictionary.jackpotName] == undefined) {
            console.error("JPManager::ParseJackpots - cannot parse jp name");
            continue
        }
        if (dict[JackpotDictionary.jackpotStatus] == undefined) {
            console.error("JPManager::ParseJackpots - cannot parse jp status");
            continue
        }
        var jp = new JackpotInformation;
        jp.JackpotID = Number(dict[JackpotDictionary.jackpotId]);
        jp.JackpotOrder = Number(dict[JackpotDictionary.jackpotOrder]);
        jp.JackpotAmount = Number(dict[JackpotDictionary.jackpotAmount]);
        jp.JackpotName = String(dict[JackpotDictionary.jackpotName]);
        jp.JackpotStatus = String(dict[JackpotDictionary.jackpotStatus]);
        if (dict[JackpotDictionary.jackpotGroupType] != undefined) jp.JackpotGroupType = String(dict[JackpotDictionary.jackpotGroupType]);
        if (dict[JackpotDictionary.jackpotMinBet] != undefined) jp.JackpotMinBet = Number(dict[JackpotDictionary.jackpotMinBet]);
        if (dict[JackpotDictionary.jackpotMinBetUSD] != undefined) jp.JackpotMinBetUSD = Number(dict[JackpotDictionary.jackpotMinBetUSD]);
        if (dict[JackpotDictionary.jackpotRTP] != undefined) jp.JackpotRTP = Number(dict[JackpotDictionary.jackpotRTP]);
        if (dict[JackpotDictionary.jackpotAmountUSD] != undefined) jp.JackpotAmountUSD = Number(dict[JackpotDictionary.jackpotAmountUSD]);
        if (dict[JackpotDictionary.jackpotInstance] != undefined) jp.JackpotInstance = Number(dict[JackpotDictionary.jackpotInstance]);
        if (dict[JackpotDictionary.multipliersRTP] != undefined) jp.multipliersRTP = _number.otod(dict[JackpotDictionary.multipliersRTP]);
        if (dict[JackpotDictionary.prevWonAmount] != undefined) jp.prevWonAmount = _number.otod(dict[JackpotDictionary.prevWonAmount]);
        if (dict[JackpotDictionary.prevWonAmountUSD] !=
            undefined) jp.prevWonAmountUSD = _number.otod(dict[JackpotDictionary.prevWonAmountUSD]);
        if (dict[JackpotDictionary.nextSeedAmount] != undefined) jp.nextSeedAmount = _number.otod(dict[JackpotDictionary.nextSeedAmount]);
        if (dict[JackpotDictionary.nextSeedAmountUSD] != undefined) jp.nextSeedAmountUSD = _number.otod(dict[JackpotDictionary.nextSeedAmountUSD]);
        if (dict[JackpotDictionary.contributePercent] != undefined) jp.contributePercent = _number.otod(dict[JackpotDictionary.contributePercent]);
        if (dict[JackpotDictionary.babyContributeInitialPercent] !=
            undefined) jp.babyContributeInitialPercent = _number.otod(dict[JackpotDictionary.babyContributeInitialPercent]);
        if (dict[JackpotDictionary.babyContributePercent] != undefined) jp.babyContributePercent = _number.otod(dict[JackpotDictionary.babyContributePercent]);
        if (dict[JackpotDictionary.babyAmount] != undefined) jp.babyAmount = _number.otod(dict[JackpotDictionary.babyAmount]);
        if (dict[JackpotDictionary.babyAmountUSD] != undefined) jp.babyAmountUSD = _number.otod(dict[JackpotDictionary.babyAmountUSD]);
        if (dict[JackpotDictionary.startNextFromSeed] !=
            undefined) jp.startNextFromSeed = _bool.Parse(dict[JackpotDictionary.startNextFromSeed]);
        if (dict[JackpotDictionary.jackpotMultipliers] != undefined) {
            var list = dict[JackpotDictionary.jackpotMultipliers];
            if (list != null && list.length > 0) {
                jp.JackpotMultipliers = [];
                for (var j = 0; j < list.length; ++j) jp.JackpotMultipliers.push(Number(list[j]))
            }
        }
        if (dict[JackpotDictionary.communityFeatureDetails] != undefined) {
            var data = dict[JackpotDictionary.communityFeatureDetails];
            var details = jp.JackpotCommunityDetails = new JackpotInformation.CommunityDetails;
            if (data[JackpotDictionary.CommunityDetails.shareAmount] != undefined) details.shareAmount = _number.otod(data[JackpotDictionary.CommunityDetails.shareAmount]);
            if (data[JackpotDictionary.CommunityDetails.shareAmountUSD] != undefined) details.shareAmountUSD = _number.otod(data[JackpotDictionary.CommunityDetails.shareAmountUSD]);
            if (data[JackpotDictionary.CommunityDetails.sharedPercentage] != undefined) details.sharedPercentage = _number.otod(data[JackpotDictionary.CommunityDetails.sharedPercentage]);
            if (data[JackpotDictionary.CommunityDetails.winnerAmount] !=
                undefined) details.winnerAmount = _number.otod(data[JackpotDictionary.CommunityDetails.winnerAmount]);
            if (data[JackpotDictionary.CommunityDetails.winnerAmountUSD] != undefined) details.winnerAmountUSD = _number.otod(data[JackpotDictionary.CommunityDetails.winnerAmountUSD]);
            if (data[JackpotDictionary.CommunityDetails.minWinLimit] != undefined) details.minWinLimit = _number.otod(data[JackpotDictionary.CommunityDetails.minWinLimit]);
            if (data[JackpotDictionary.CommunityDetails.minWinLimitUSD] != undefined) details.minWinLimitUSD =
                _number.otod(data[JackpotDictionary.CommunityDetails.minWinLimitUSD]);
            if (data[JackpotDictionary.CommunityDetails.detectingPeriodInSec] != undefined) details.detectingPeriodInSec = _number.otoi(data[JackpotDictionary.CommunityDetails.detectingPeriodInSec]);
            if (data[JackpotDictionary.CommunityDetails.distributionType] != undefined) details.distributionType = String(data[JackpotDictionary.CommunityDetails.distributionType]);
            if (data[JackpotDictionary.CommunityDetails.minBet] != undefined) details.minBet = _number.otod(data[JackpotDictionary.CommunityDetails.minBet]);
            if (data[JackpotDictionary.CommunityDetails.minBetUSD] != undefined) details.minBetUSD = _number.otod(data[JackpotDictionary.CommunityDetails.minBetUSD]);
            if (data[JackpotDictionary.CommunityDetails.minTotalBet] != undefined) details.minTotalBet = _number.otod(data[JackpotDictionary.CommunityDetails.minTotalBet]);
            if (data[JackpotDictionary.CommunityDetails.minTotalBetUSD] != undefined) details.minTotalBetUSD = _number.otod(data[JackpotDictionary.CommunityDetails.minTotalBetUSD])
        }
        jpList.push(jp)
    }
    return jpList
};
JackpotsManager.prototype.QueueJackpotsUpdated = function() {
    if (this.statusRequests == null || this.statusRequests.length == 0) EventManager.Queue(JackpotEvents.evtJackpotsUpdated, this.jackpots)
};
JackpotsManager.prototype.ReloadStatuses = function() {
    if (this.prevJackpots == null || ServerOptions.isReplay) return;
    for (var i = 0; i < this.prevJackpots.length; ++i) {
        var prevInfo = this.prevJackpots[i];
        var info = this.GetJackpotInfo(prevInfo.JackpotID);
        var id = prevInfo.JackpotID;
        var instance = info != null ? info.JackpotInstance : prevInfo.JackpotInstance;
        if (info == null || info.JackpotAmount < prevInfo.JackpotAmount) this.ReloadStatus(id, instance)
    }
};
JackpotsManager.prototype.ReloadStatus = function(id, instance) {
    if (this.statuses == null) {
        this.statuses = [];
        this.statusIDs = [];
        this.statusRequests = [];
        this.statusRequestIDs = []
    }
    var request = new ServerRequest;
    request.responseHandler = this.statusResponseHandler;
    request.Url = ServerOptions.serverUrl + this.statusRequestURI.replace("{0}", ServerOptions.mgckey).replace("{1}", id.toString()).replace("{2}", instance.toString());
    this.statusRequestIDs.push(id);
    this.statusRequests.push(request);
    RequestManager.AddRequest(request)
};
JackpotsManager.prototype.OnJackpotStatusResponse = function(param, statusCode, request) {
    var requestIdx = this.statusRequests.indexOf(request);
    if (requestIdx < 0) return;
    var id = this.statusRequestIDs[requestIdx];
    var status = this.ParseJackpotStatus(param);
    var statusIdx = this.statusIDs.indexOf(id);
    if (statusIdx < 0) {
        this.statusIDs.push(id);
        this.statuses.push(status)
    } else this.statuses[statusIdx] = status;
    this.statusRequests.splice(requestIdx, 1);
    this.statusRequestIDs.splice(requestIdx, 1);
    this.QueueJackpotsUpdated()
};
JackpotsManager.prototype.ParseJackpotStatus = function(param) {
    if (_string.IsNullOrEmpty(param)) return null;
    var dict = _JSON.TryParse(param);
    if (dict == null) return null;
    var ret = new JackpotStatus;
    var key = "status";
    if (dict[key] != undefined) ret.status = dict[key];
    key = "amount";
    if (dict[key] != undefined) ret.amount = _number.otod(dict[key]);
    key = "prevWonAmount";
    if (dict[key] != undefined) ret.prevWonAmount = _number.otod(dict[key]);
    key = "nextSeedAmount";
    if (dict[key] != undefined) ret.nextSeedAmount = _number.otod(dict[key]);
    key = "jackpotBabyAmount";
    if (dict[key] != undefined) ret.jackpotBabyAmount = _number.otod(dict[key]);
    return ret
};
JackpotsManager.prototype.GetJackpotInfo = function(id) {
    if (this.jackpots != null)
        for (var i = 0; i < this.jackpots.length; ++i)
            if (this.jackpots[i].JackpotID == id) return this.jackpots[i];
    return null
};
JackpotsManager.prototype.GetJackpotStatus = function(id) {
    var statusIdx = this.statusIDs == null ? -1 : this.statusIDs.indexOf(id);
    return statusIdx < 0 ? null : this.statuses[statusIdx]
};
JackpotsManager.prototype.OnGameInfoChanged = function() {
    if (this.gameJpInfoUpdatedFrame < Time.frameCount) this.UpdateGameJackpotsInfo()
};
JackpotsManager.prototype.UpdateGameJackpotsInfo = function() {
    if (this.jackpots == null || JackpotVisualManager.I == null) return;
    var gameInfo = XT.GetObject(GameInfoVars.GameInfo);
    if (gameInfo == null) gameInfo = {};
    for (var i = 0; i < this.jackpots.length; ++i) this.UpdateGameJackpotInfo(gameInfo, this.jackpots[i]);
    this.gameJpInfoUpdatedFrame = Time.frameCount;
    XT.SetObject(GameInfoVars.GameInfo, gameInfo);
    XT.TriggerEvent(GameInfoVars.Evt_Internal_GameInfoChanged)
};
JackpotsManager.prototype.UpdateGameJackpotInfo = function(gameInfo, jpInfo) {
    var key = "jpInfo" + jpInfo.JackpotOrder;
    if (gameInfo[key] == undefined) gameInfo[key] = {};
    var minTotalBet = XT.GetDouble(Vars.MinTotalBetFromServer);
    var currency = ServerOptions.currency;
    var value = gameInfo[key];
    value["contributePercent"] = this.FormatPercent(jpInfo.contributePercent);
    value["nextSeedAmount"] = LocaleManager.FormatValueWithCustomCurrency(jpInfo.nextSeedAmount, currency);
    value["babyContributeInitialPercent"] = this.FormatPercent(jpInfo.babyContributeInitialPercent);
    value["babyContributePercent"] = this.FormatPercent(jpInfo.babyContributePercent);
    value["minTotalBet"] = LocaleManager.FormatValueWithCustomCurrency(jpInfo.JackpotMinBet > 0 ? jpInfo.JackpotMinBet : minTotalBet, currency);
    var community = jpInfo.JackpotCommunityDetails;
    if (community != null) {
        value["minWinLimit"] = LocaleManager.FormatValueWithCustomCurrency(community.minWinLimit, currency);
        value["sharedPercentage"] = this.FormatPercent(community.sharedPercentage);
        value["shareAmount"] = LocaleManager.FormatValueWithCustomCurrency(community.shareAmount,
            currency);
        value["detectingPeriodInSeconds"] = JackpotVisualManager.I.FormatSeconds(community.detectingPeriodInSec);
        value["communityMinTotalBet"] = LocaleManager.FormatValueWithCustomCurrency(community.minTotalBet > 0 ? community.minTotalBet : minTotalBet, currency)
    }
};
JackpotsManager.prototype.FormatPercent = function(value) {
    return this.percentFormat.replace("{0}", value.toString())
};
var GameProtocolBonusGameParser = {};
GameProtocolBonusGameParser.ParseBonusGame = function(nameValues) {
    if (nameValues[GameProtocolDictionary.BonusGame.bonusGameExists] == undefined && nameValues[GameProtocolDictionary.BonusGame.level] == undefined && nameValues[GameProtocolDictionary.BonusGame.currentBonusRespin] == undefined && nameValues[GameProtocolDictionary.BonusGame.status] == undefined && nameValues[GameProtocolDictionary.BonusGame.winsMask] == undefined && nameValues["wof_status"] == undefined) return null;
    var level = GameProtocolCommonParser.ParseNulableInt(nameValues,
        GameProtocolDictionary.BonusGame.level);
    var bonusType = GameProtocolCommonParser.ParseNulableInt(nameValues, GameProtocolDictionary.BonusGame.bonusGameType);
    var result = new VsBonusGameData;
    result.BonusTable.Status = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.BonusGame.status);
    result.BonusTable.Wins = GameProtocolCommonParser.ParseDoubleList(nameValues, GameProtocolDictionary.BonusGame.wins);
    result.BonusTable.WinsMask = GameProtocolBonusGameParser.ParseWinsMask(nameValues, GameProtocolDictionary.BonusGame.winsMask);
    result.BonusTable.BGItemValues = GameProtocolCommonParser.ParseDoubleList(nameValues, GameProtocolDictionary.BonusGame.BGItemValues);
    result.BonusTable.BGItemMask = GameProtocolCommonParser.ParseStringList(nameValues, GameProtocolDictionary.BonusGame.BGItemMasks);
    if (level == null) result.Level = -1;
    else result.Level = level;
    result.Life = GameProtocolCommonParser.ParseNulableInt(nameValues, GameProtocolDictionary.BonusGame.life);
    result.WinPoints = GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.BonusGame.winPoints);
    result.RealWin = GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.BonusGame.realWin);
    result.Coef = GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.BonusGame.coef);
    result.GameOver = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.BonusGame.gameOver) == 1;
    result.BonusTable.Markers = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.BonusGame.markers);
    result.lifeWins = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.BonusGame.lWins);
    result.currentBonusRespin = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.BonusGame.currentBonusRespin);
    result.maxBonusRespins = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.BonusGame.maxBonusRespins);
    result.respinSymbols = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.BonusGame.respinSymbols);
    var slotHeight = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.slotHeight);
    if (slotHeight == 0) slotHeight = GameConnection.prototype.SlotHeight;
    result.winSymbols = VSProtocolParser.ParseWinScreenSymbols(nameValues, slotHeight, GameProtocolDictionary.BonusGame.respinWinSymbols);
    result.PremultipliedWin = GameProtocolBonusGameParser.ParsePremultipliedWin(nameValues, GameProtocolDictionary.BonusGame.premultipliedWinData);
    result.MultipliedSymbolPositions = GameProtocolBonusGameParser.ParseMultiplierSymbolPositions(nameValues, GameProtocolDictionary.BonusGame.premultipliedWinData);
    var respinsTotalMultiplier = GameProtocolCommonParser.ParseNulableInt(nameValues,
        GameProtocolDictionary.BonusGame.respinsTotalMultiplier);
    result.RespinsTotalMultiplier = respinsTotalMultiplier == null ? -1 : respinsTotalMultiplier;
    var extraRespinsWon = GameProtocolCommonParser.ParseNulableInt(nameValues, GameProtocolDictionary.BonusGame.extraRespinsWon);
    result.ExtraRespinsWon = extraRespinsWon == null ? -1 : extraRespinsWon;
    var extraRetriggersWon = GameProtocolCommonParser.ParseNulableInt(nameValues, GameProtocolDictionary.BonusGame.extraRetriggersWon);
    result.ExtraRetriggersWon = extraRetriggersWon ==
        null ? -1 : extraRetriggersWon;
    var iWins = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.BonusGame.iWins);
    if (iWins != null && iWins.length > 0)
        if (result.BonusTable.Markers == null || result.BonusTable.Markers.length <= 0) iWins = GameProtocolCommonParser.SortIntList(iWins);
        else {
            var lengthOfLevel = GameProtocolCommonParser.FindElementPositionsIgnoreSign(1, result.BonusTable.Markers).length;
            result.numberOfLevels = iWins.length / lengthOfLevel;
            for (var i = 0; i < result.numberOfLevels; i++) iWins = GameProtocolCommonParser.SortIntList(iWins,
                i * lengthOfLevel, lengthOfLevel)
        }
    result.IWins = iWins;
    if (bonusType == 6) {
        result.Level = Math.floor(level / 2);
        result.MultiplierStep = level % 2 == 0;
        result.MultipliersTable.Status = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.BonusGame.Multipliers.status);
        result.MultipliersTable.Markers = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.BonusGame.Multipliers.markers);
        result.MultipliersTable.Wins = GameProtocolCommonParser.ParseDoubleList(nameValues, GameProtocolDictionary.BonusGame.Multipliers.wins)
    }
    var key =
        "bgid";
    if (nameValues[key] != undefined) result.id = _number.otoi(nameValues[key]);
    key = "bgt";
    if (nameValues[key] != undefined) result.type = _number.otoi(nameValues[key]);
    result.wheelOfFortune = GameProtocolBonusGameParser.ParseWheelOfFortune(nameValues);
    result.initialized = nameValues[GameProtocolDictionary.BonusGame.realWin] != undefined;
    result.map = GameProtocolBonusGameParser.ParseMap(nameValues);
    return result
};
GameProtocolBonusGameParser.ParsePremultipliedWin = function(nameValues, key) {
    var result = 0;
    var buf = nameValues[key];
    if (buf != undefined) {
        var data = buf.split("~");
        if (data.length > 0 && !_string.IsNullOrEmpty(data[0])) result = _number.otod(data[0])
    }
    return result
};
GameProtocolBonusGameParser.ParseMultiplierSymbolPositions = function(nameValues, key) {
    var result = null;
    var buf = nameValues[key];
    if (buf != undefined) {
        var data = buf.split("~");
        if (data.length > 1 && !_string.IsNullOrEmpty(data[1])) {
            result = [];
            var values = data[1].split(",");
            for (var i = 0; i < values.length; i++) result.push(_number.otoi(values[i]))
        }
    }
    return result
};
GameProtocolBonusGameParser.ParseWinsMask = function(nameValues, key) {
    if (nameValues[key] == undefined) return null;
    var buf = nameValues[key];
    var values = buf.split(",");
    var result = [];
    for (var i = 0; i < values.length; i++)
        if (!_string.IsNullOrEmpty(values[i])) {
            values[i] = values[i].replace("_fn", "");
            result.push(GameProtocolBonusGameParser.ParseWinMask(values[i]))
        }
    return result
};
GameProtocolBonusGameParser.ParseWinMask = function(value) {
    var masks = [];
    masks[0] = "w";
    masks[1] = "swf";
    masks[2] = "rwf";
    masks[3] = "l";
    masks[4] = "nff";
    masks[5] = "sff";
    masks[6] = "pf";
    masks[7] = "m";
    masks[8] = "ms";
    masks[9] = "prf";
    masks[10] = "psf";
    masks[11] = "rs";
    masks[12] = "wof";
    masks[13] = "rrf";
    masks[14] = "msf";
    masks[15] = "nlf";
    masks[16] = "oswr";
    masks[17] = "cmp";
    masks[18] = "srww";
    masks[19] = "gsf";
    masks[20] = "psm";
    masks[21] = "mbf";
    masks[22] = "pbf";
    masks[23] = "stp";
    masks[24] = "fss";
    masks[25] = "aph";
    masks[26] = "rsb";
    masks[27] = "prfm";
    masks[28] = "rwf_s1";
    masks[29] = "rwf_s1_mul";
    masks[30] = "rwf_s0";
    masks[31] = "rwf_s0_es";
    return masks.indexOf(value)
};
GameProtocolBonusGameParser.ParseWheelOfFortune = function(dict) {
    var ret = new VsBonusGameData.WheelOfFortune;
    var key = "wof_set";
    if (dict[key] == undefined) return null;
    var itemsSplit = dict[key].split(",");
    key = "wof_mask";
    if (dict[key] == undefined) return null;
    var masksSplit = dict[key].split(",");
    ret.items = [];
    var i = 0;
    for (i = 0; i < itemsSplit.length; ++i) {
        var itemSplit = itemsSplit[i].split("~");
        var item = new VsBonusGameData.WheelOfFortune.Item;
        switch (masksSplit[i]) {
            case "w":
                item.amount = _number.otod(itemSplit[0]);
                break;
            case "wrs":
                item.amount = _number.otod(itemSplit[0]);
                item.spinsNumber = _number.otoi(itemSplit[1]);
                break;
            case "m":
                item.status = 1;
                break;
            case "go":
                item.status = 0;
                break
        }
        ret.items.push(item)
    }
    key = "wof_status";
    if (dict[key] != undefined) {
        var statusSplit = dict[key].split(",");
        var itemsStatus = [];
        for (i = 0; i < ret.items.length; ++i) itemsStatus.push(_number.otoi(statusSplit[i]));
        ret.itemsStatus = itemsStatus
    }
    key = "wof_wi";
    if (dict[key] != undefined) ret.stopPosition = _number.otoi(dict[key]);
    key = "lifes";
    if (dict[key] != undefined) ret.spinsLeft =
        _number.otoi(dict[key]);
    key = "iw";
    if (dict[key] != undefined) ret.initialWin = GameProtocolCommonParser.ParseDouble(dict, key);
    key = "wm";
    if (dict[key] != undefined) ret.multiplier = _number.otoi(dict[key]);
    return ret
};
GameProtocolBonusGameParser.ParseMap = function(dict) {
    var ret = new VsBonusGameData.Map;
    var wof_set = GameProtocolCommonParser.ParseIfExist(dict, "wof_set");
    var wof_mask = GameProtocolCommonParser.ParseIfExist(dict, "wof_mask");
    var wof_mi = GameProtocolCommonParser.ParseIfExist(dict, "wof_mi");
    var wof_p = GameProtocolCommonParser.ParseIfExist(dict, "wof_p");
    var wof_map = GameProtocolCommonParser.ParseIfExist(dict, "wof_map");
    ret.WOF_Values = [];
    ret.WOF_Mask = [];
    ret.WOF_Map = [];
    if (!_string.IsNullOrEmpty(wof_mi))
        if (wof_mi.length >
            0) ret.WOF_MultiplierIndex = _number.otoi(wof_mi);
    if (!_string.IsNullOrEmpty(wof_p))
        if (wof_p.length > 0) ret.WOF_StopPosition = _number.otoi(wof_p);
    if (!_string.IsNullOrEmpty(wof_set)) {
        wof_set = _string.Trim(wof_set);
        if (wof_set.length > 0) {
            var temp = wof_set.split(",");
            for (var i = 0; i < temp.length; i++) ret.WOF_Values.push(temp[i])
        }
    }
    if (!_string.IsNullOrEmpty(wof_mask)) {
        wof_mask = _string.Trim(wof_mask);
        if (wof_mask.length > 0) {
            var temp = wof_mask.split(",");
            for (var i = 0; i < temp.length; i++) ret.WOF_Mask.push(temp[i])
        }
    }
    if (!_string.IsNullOrEmpty(wof_map)) {
        wof_map =
            _string.Trim(wof_map);
        if (wof_map.length > 0) {
            var temp = wof_map.split(",");
            for (var i = 0; i < temp.length; i++) ret.WOF_Map.push(_number.otoi(temp[i]))
        }
    }
    return ret
};
var GameProtocolCommonParser = {};
GameProtocolCommonParser.SplitResponseContent = function(nameValues) {
    var mapNameValues = {};
    for (var i = 0; i < nameValues.length; ++i) {
        var nameValueSplitted = nameValues[i].split("=", 2);
        if (nameValueSplitted.length == 2)
            if (mapNameValues[nameValueSplitted[0]] == undefined) mapNameValues[nameValueSplitted[0]] = nameValueSplitted[1]
    }
    return mapNameValues
};
GameProtocolCommonParser.ParseDouble = function(nameValues, paramName) {
    return _number.otod(nameValues[paramName])
};
GameProtocolCommonParser.ParseDoubleIfExists = function(nameValues, paramName) {
    if (nameValues[paramName] == undefined) return -1;
    return _number.otod(nameValues[paramName])
};
GameProtocolCommonParser.ParseNulableDouble = function(nameValues, paramName) {
    var result = null;
    var buf = nameValues[paramName];
    if (buf != undefined)
        if (_string.Trim(buf).length > 0 && buf != "null") result = _number.otod(buf);
    return result
};
GameProtocolCommonParser.ParseInt = function(nameValues, paramName) {
    return _number.otoi(nameValues[paramName])
};
GameProtocolCommonParser.ParseUInt = function(nameValues, paramName) {
    return _number.otoui(nameValues[paramName])
};
GameProtocolCommonParser.ParseLong = function(nameValues, paramName) {
    return GameProtocolCommonParser.ParseInt(nameValues, paramName)
};
GameProtocolCommonParser.ParseNulableFloat = function(nameValues, paramName) {
    return GameProtocolCommonParser.ParseNulableDouble(nameValues, paramName)
};
GameProtocolCommonParser.ParseNulableInt = function(nameValues, paramName) {
    var result = null;
    var tmp = parseInt(nameValues[paramName], 10);
    if (isFinite(tmp) && !isNaN(tmp)) result = tmp;
    return result
};
GameProtocolCommonParser.ParseIntList = function(nameValues, key, delimiter) {
    var buf = nameValues[key];
    if (buf == undefined) return null;
    if (delimiter == undefined) delimiter = ",";
    var values = buf.split(delimiter);
    var result = [];
    for (var i = 0; i < values.length; ++i) {
        var tmp = parseInt(values[i], 10);
        if (isFinite(tmp) && !isNaN(tmp)) result.push(tmp)
    }
    return result
};
GameProtocolCommonParser.ParseDoubleList = function(nameValues, key, delimiter) {
    var buf = nameValues[key];
    if (buf == undefined) return null;
    if (delimiter == undefined) delimiter = ",";
    var values = buf.split(delimiter);
    var result = [];
    for (var i = 0; i < values.length; ++i) {
        var tmp = parseFloat(values[i]);
        if (isFinite(tmp) && !isNaN(tmp)) result.push(tmp)
    }
    return result
};
GameProtocolCommonParser.ParseStringList = function(nameValues, key) {
    var buf = nameValues[key];
    if (buf == undefined) return null;
    return buf.split(",")
};
GameProtocolCommonParser.ParseText = function(response, key) {
    var result = null;
    if (_string.IsNullOrEmpty(response)) return result;
    var mapNameValues = {};
    var nameValues = response.split("&");
    for (var i = 0; i < nameValues.length; ++i) {
        var nameValueSplitted = nameValues[i].split("=");
        if (nameValueSplitted.length == 2)
            if (mapNameValues[nameValueSplitted[0]] == undefined) mapNameValues[nameValueSplitted[0]] = nameValueSplitted[1]
    }
    if (mapNameValues[key] != undefined) result = mapNameValues[key];
    return result
};
GameProtocolCommonParser.ParseIfExist = function(nameValues, key) {
    if (nameValues[key] != undefined) return nameValues[key];
    return null
};
GameProtocolCommonParser.ParseBalance = function(nameValues) {
    var data = null;
    if (nameValues[GameProtocolDictionary.balance] != undefined) {
        data = new BalanceData;
        if (nameValues[GameProtocolDictionary.bonusBalance] != undefined && XT.GetBool(Vars.Jurisdiction_SplitBalance)) {
            data.Balance = _number.otod(nameValues[GameProtocolDictionary.cashBalance]);
            data.BonusBalance = _number.otod(nameValues[GameProtocolDictionary.bonusBalance])
        } else data.Balance = _number.otod(nameValues[GameProtocolDictionary.balance]);
        if (nameValues[GameProtocolDictionary.time] !=
            undefined) data.Time = _number.otod(nameValues[GameProtocolDictionary.time]);
        else if (BalanceManager.I != null && BalanceManager.I.data != null) data.Time = BalanceManager.I.data.Time + 1
    }
    return data
};
GameProtocolCommonParser.BuildBalanceData = function(value, bonusvalue, time) {
    var data = new BalanceData;
    data.Balance = value;
    data.BonusBalance = bonusvalue;
    data.Time = time;
    return data
};
GameProtocolCommonParser.SortAscCompare = function(a, b) {
    return a - b
};
GameProtocolCommonParser.SortIntList = function(unsortedList, startPos, count) {
    if (startPos != undefined && count != undefined) {
        var tmpList = unsortedList.slice(startPos, startPos + count);
        tmpList.sort(GameProtocolCommonParser.SortAscCompare);
        for (var i = 0; i < count; ++i) unsortedList[startPos + i] = tmpList[i];
        return unsortedList
    } else {
        unsortedList.sort(GameProtocolCommonParser.SortAscCompare);
        return unsortedList
    }
};
GameProtocolCommonParser.FindElementPositionsIgnoreSign = function(element, theList) {
    var rv = [];
    for (var i = 0; i < theList.length; ++i)
        if (Math.abs(theList[i]) == element) rv.push(i);
    return rv
};
GameProtocolCommonParser.StringToIntList = function(inputString, delimiter) {
    if (delimiter == undefined) delimiter = ",";
    var values = inputString.split(delimiter);
    var result = [];
    for (var i = 0; i < values.length; i++)
        if (!_string.IsNullOrEmpty(values[i])) result.push(_number.otoi(values[i]));
    return result
};
var GameProtocolDictionary = {
    line: "l",
    winWayGroups: "wlc_v",
    coin: "c",
    defaultBet: "defc",
    coinID: "cid",
    tryMeOnceCoin: "tmc",
    tryMeOnceLine: "tml",
    winAmountShort: "w",
    extraAwardWin: "e_aw",
    randomWildsData: "rwd",
    upSymbols: "ups",
    expandingSymbolsData: "ep",
    symbolsBeforeExpanding: "is",
    winSymbols: "s",
    balance: "balance",
    cashBalance: "balance_cash",
    bonusBalance: "balance_bonus",
    time: "stime",
    reelsPosition: "pos",
    index: "index",
    counter: "counter",
    repeat: "repeat",
    respin: "rs",
    respinCycleWin: "rs_win",
    currentRespin: "rs_c",
    maxRespins: "rs_m",
    totalRespins: "rs_t",
    progressiveFeature: "progressive",
    stickySymbols: "sty",
    mergingSymbols: "mrg",
    freeSpinsOptions: "fs_opt",
    freeSpinsOptionsMask: "fs_opt_mask",
    randomWildWinSymbolId: "rws",
    freeSpinsPickedOptionIndex: "fsopt_i",
    freeSpinCurrentNumber: "fs",
    freeSpinMaxNumber: "fsmax",
    freeSpinTotalNumber: "fs_total",
    freeSpinCurrentWin: "fswin",
    freeSpinTotalWin: "fswin_total",
    freeSpinCurrentMultiplier: "fsmul",
    freeSpinTotalMultipl: "fsmul_total",
    bets: "sc",
    paytable: "paytable",
    scatters: "scatters",
    wilds: "wilds",
    bonuses: "bonuses",
    symbol: "symbol",
    clientVersion: "cver",
    freeSpinCurrentWinMultiplied: "fsres",
    freeSpinTotalWinMultiplied: "fsres_total",
    mgckey: "mgckey",
    noRating: "noRating",
    stackedSymbolIndex: "n_rss",
    stackedSymbolIndexCurrent: "rss",
    reelSetIndex: "n_reel_set",
    reelSetIndexCurrent: "reel_set",
    numberOfReelSets: "reel_set_size",
    wildRandomMultipliers: "wdrm_v",
    wildRandomMultiplierMask: "wdrm_m",
    randomSymbolMultiplier: "rmul",
    randomMysterySymbol: "msr",
    initialMysterySymbol: "msi",
    patternedMysterySymbols: "msi_p",
    possibleRandomSymbolMultipliers: "prm",
    naSymbolId: "nas",
    nudgedSymbols: "sn",
    symbolReplacementData: "srf",
    ReelsAllowedToRotateSeparately: "sor_ra",
    ReelsCoeficients: "sor_coefs",
    ReelToBeSpun: "sor_ri",
    TumblingWin: "tmb_win",
    Tumbling: "tmb",
    NextReelsSymbolsList: "n_rsl",
    FeaturePurchaseParam: "pur",
    mysteryExpandingSymbols: "mes",
    mysteryExpandingPositions: "me",
    FreeSpinsPurchase: {
        purchaseOptions: "fspps",
        purchaseOptionsMask: "fspps_mask",
        optionIndex: "fsp",
        fsBought: "fs_bought"
    },
    BetLevel: {
        betLevelScale: "bls",
        betLevelIndex: "bl",
        betLevelPaytable: "bl_paytable"
    },
    OpeningSymbols: {
        positions: "i_pos",
        freeSpinsWon: "win_fs",
        multiplierWon: "win_mul"
    },
    TopBottomSymbols: {
        symbolsAbove: "sa",
        symbolsBelow: "sb"
    },
    FreeSpinsChain: {
        spins: "fscs",
        multipliers: "fscm",
        spinsTotal: "fsc_total",
        multipliersTotal: "fsc_mul_total",
        winsTotal: "fsc_win_total",
        multipliedWinTotal: "fsc_res_total",
        sessionsWonThisSpin: "fsc_sw",
        sessionsWonSymbolsCount: "fsc_sessions"
    },
    winLines: function(i) {
        return "l" + i
    },
    reel: function(i) {
        return "reel" + i
    },
    n_reel: function(i) {
        return "n_reel" + i
    },
    reelSet: function(i) {
        return "reel_set" +
            i
    },
    frozen: "frozen",
    techbreak: "techbreak",
    noMoney: "nomoney",
    reload: "reload",
    link: "link",
    pnow: "pnow=1",
    winAmountLong: "win",
    mysteryScatterGame: "mb",
    mysteryScatterSymbol: "ms",
    mysteryScatterSymbolGameHistory: "msgh",
    wildScatters: "msc",
    slotHeight: "sh",
    undefined: "undefined",
    unlogged: "unlogged",
    configs: "cfgs",
    spinCycleWin: "tw",
    returnToPlayer: "rtp",
    WildRandomLineMultiplier: {
        configuration: "wrlm_sets",
        response: "wrlm_res",
        currentSet: "wrlm_cs"
    },
    RandomAward: {
        Configuration: {
            normal: "base_aw",
            freeSpins: "fs_aw",
            reelConfigCount: "aw_reel_count",
            reelConfig: "aw_reel",
            nextReelConfig: "n_aw_reel"
        },
        Type: {
            trigger: "t",
            multiplier: "m",
            featureTrigger: "tt"
        },
        index: "aw",
        awardPosition: "aw_p"
    },
    ProgressiveFeature: {
        progressivePick: "prg_i",
        Status: {
            stateValues: "prg",
            stateMasks: "prg_m"
        },
        Config: {
            configValues: "prg_cfg",
            configMasks: "prg_cfg_m"
        }
    },
    MoneySymbol: {
        symbolID: "mo_s",
        possibleValues: "mo_v",
        symbolsValues: "mo",
        symbolsTypes: "mo_t",
        totalWin: "mo_tw",
        jackpotValues: "mo_jp",
        jackpotMasks: "mo_jp_mask",
        MOSymbolTypes: {
            regular: "r",
            instantValue: "v",
            multiplierValue: "m",
            retriggerSymbol: "rt",
            jp1: "jp1",
            jp2: "jp2",
            jp3: "jp3",
            jp4: "jp4",
            jpb: "jpb",
            mo1: "mo1",
            mo2: "mo2",
            extraCredit: "ea",
            collectMultiply: "ma"
        }
    },
    BonusGame: {
        status: "status",
        wins: "wins",
        winsMask: "wins_mask",
        level: "level",
        life: "lifes",
        winPoints: "wp",
        realWin: "rw",
        coef: "coef",
        bonusGameExists: "bw",
        bonusGameType: "bt",
        gameOver: "end",
        bonusGameChoice: "ind",
        iWins: "i_wins",
        markers: "markers",
        lWins: "lWins",
        lInd: "lInd",
        currentBonusRespin: "rsb_c",
        maxBonusRespins: "rsb_m",
        respinSymbols: "rsb_s",
        respinWinSymbols: "rs_s",
        premultipliedWinData: "rwm",
        extraRespinsWon: "rsb_more",
        extraRetriggersWon: "rsb_rt",
        respinsTotalMultiplier: "rsb_mu",
        BGItemValues: "bg_i",
        BGItemMasks: "bg_i_mask",
        Multipliers: {
            status: "mstatus",
            markers: "mmarkers",
            wins: "mwins"
        }
    },
    FreeSpinBonusGame: {
        gameExsist: "fsb_bw",
        status: "fsb_status",
        wins: "fsb_wins",
        multiplierMarkers: "fsb_mm",
        level: "fsb_level",
        life: "fsb_lives",
        gameOver: "fsb_end",
        totalSpinsWins: "fsb_s",
        totalMultiplilersWins: "fsb_m"
    },
    Gambling: {
        gambling: "gmb",
        history: "gmbhist",
        result: "gmbr",
        state: "gmbs",
        win: "gmbw",
        skipGamble: "gmbskip",
        currentGambleOccasion: "gmbp",
        option: "opt"
    },
    Actions: {
        action: "action",
        doInit: "doInit",
        doSpin: "doSpin",
        doCollect: "doCollect",
        doBonus: "doBonus",
        doFSOption: "doFSOption",
        doFSBonus: "doFSBonus",
        doMysteryScatter: "doMysteryScatter",
        doCollectBonus: "doCollectBonus",
        doGamble: "doGamble",
        doGambleCollect: "doGambleCollect",
        doJackpotCollect: "doJackpotCollect",
        doPlayJackpot: "doPlayJackpot"
    },
    NextActions: {
        nextAction: "na",
        Spin: "s",
        Collect: "c",
        Gamble: "g",
        Bonus: "b",
        CollectBonus: "cb",
        FSOption: "fso",
        MysteryScatter: "m",
        FSBonus: "fsb",
        GambleCollect: "gc",
        JackpotCollect: "cj",
        PlayJackpot: "pj"
    },
    Jakpot: {
        jackpotActive: "jp",
        jackpotWinID: "jwid",
        jackpotWinOrder: "jwo",
        jackpotWinAmount: "jw",
        jackpotType: "jpt",
        jackpotStatus: "jptss",
        jackpotShutdown: "jpshd",
        jackpotMiniGameEnabled: "jpmg",
        jackpotNotWon: "jpnw",
        jackpotWonInstances: "jptsi",
        Type: {
            random: "r",
            twoSteps: "ts"
        },
        Status: {
            obtained: "o",
            used: "u"
        },
        WonInstance: {
            type: "jpit",
            jackpotId: "jpid",
            jackpotInstance: "jpiid",
            amount: "jpw",
            multiplier: "jpm",
            autoDrawing: "jpad",
            Type: {
                progressive: "p",
                nonProgressive: "np"
            }
        }
    },
    FreeRound: {
        Events: "ev",
        RoundsLeft: "frn",
        TotalWin: "fra",
        RoundType: "frt",
        TurboSpinMode: "tsm",
        BonusCode: "frbc",
        BonusCodeParam: "bonus_code",
        Event: {
            Start: "FR0",
            Finish: "FR1",
            Error: "FR2"
        }
    },
    JackpotVisualization: {
        JPVMask: "jpv_m",
        JPVValues: "jpv_v",
        JPVType: "t",
        JPVPositions: "p",
        Type: {
            badges: "b"
        }
    },
    GoldSymbol: {
        goldSymbolReels: "gsf_r",
        goldSymbols: "gsf",
        goldSymbolAwards: "gsf_a"
    },
    ClassicPaytable: {
        combinations: "com"
    }
};
var GameProtocolFreeSpinBonusGameParser = {};
GameProtocolFreeSpinBonusGameParser.ParseFreeSpinBonusGame = function(nameValues) {
    if (nameValues[GameProtocolDictionary.FreeSpinBonusGame.gameExsist] == undefined && nameValues[GameProtocolDictionary.FreeSpinBonusGame.wins] == undefined) return null;
    var result = new VsFreeSpinBonusGame;
    result.GameOver = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.FreeSpinBonusGame.gameOver) == 1;
    result.Level = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.FreeSpinBonusGame.level);
    result.Lifes =
        GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.FreeSpinBonusGame.life);
    result.SpinsWin = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.FreeSpinBonusGame.totalSpinsWins);
    result.MultipliersWin = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.FreeSpinBonusGame.totalMultiplilersWins);
    var multiplierMarkers = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.FreeSpinBonusGame.multiplierMarkers);
    var statuses = GameProtocolCommonParser.ParseIntList(nameValues,
        GameProtocolDictionary.FreeSpinBonusGame.status);
    var wins = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.FreeSpinBonusGame.wins);
    if (multiplierMarkers != null && statuses != null && wins != null && multiplierMarkers.length > 0 && multiplierMarkers.length == statuses.length && statuses.length == wins.length) {
        var bonusItems = [];
        for (var i = 0; i < wins.length; i++) {
            var selected = statuses[i] != 0;
            bonusItems.push(new VsFreeSpinBonusGame.BonusItem(selected || result.GameOver ? wins[i] : 0, selected ? VsFreeSpinBonusGame.BonusItem.BonusItemStatus.Selected :
                VsFreeSpinBonusGame.BonusItem.BonusItemStatus.Available, multiplierMarkers[i] == 0 ? VsFreeSpinBonusGame.BonusItem.BonusItemType.Spin : VsFreeSpinBonusGame.BonusItem.BonusItemType.Multiplier))
        }
        result.BonusItems = bonusItems
    }
    return result
};
var GameProtocolGamblingParser = {};
GameProtocolGamblingParser.ParseVsGamblingResponse = function(nameValue) {
    var result = new VsGamblingResponse;
    if (nameValue[GameProtocolDictionary.noMoney] != undefined) {
        result.NoMoney = true;
        return result
    }
    result.Balance = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.Gambling.win);
    result.State = GameProtocolGamblingParser.ParseState(GameProtocolCommonParser.ParseInt(nameValue, GameProtocolDictionary.Gambling.state));
    GameProtocolGamblingParser.Populate(result, nameValue[GameProtocolDictionary.Gambling.result]);
    return result
};
GameProtocolGamblingParser.ParseGamblingSettings = function(nameValue) {
    var settings = new VsGamblingSettings;
    settings.SkipGambleOnInit = GameProtocolCommonParser.ParseInt(nameValue, GameProtocolDictionary.Gambling.skipGamble) == 1;
    settings.InitGamblingOccasion = GameProtocolGamblingParser.ParseCurrentGamblingOccasion(GameProtocolCommonParser.ParseIfExist(nameValue, GameProtocolDictionary.Gambling.currentGambleOccasion));
    var gambling = GameProtocolCommonParser.ParseIfExist(nameValue, GameProtocolDictionary.Gambling.gambling);
    if (gambling ==
        null) return settings;
    var settingSplit = gambling.split("~");
    var occassionsSplit = settingSplit[0].split(",");
    settings.SetOccasionStatus(GamblingOccasions.Spin, occassionsSplit[0] == "1");
    settings.SetOccasionStatus(GamblingOccasions.Bonus, occassionsSplit[1] == "1");
    settings.SetOccasionStatus(GamblingOccasions.FreeSpin, occassionsSplit[2] == "1");
    for (var i = 1; i < settingSplit.length; i++) {
        var typeMultiplierPair = settingSplit[i].split(",");
        if (typeMultiplierPair.length != 2) continue;
        settings.SetGamblingSettings(GameProtocolGamblingParser.ParseType(_number.otoi(typeMultiplierPair[0])),
            _number.otod(typeMultiplierPair[1]))
    }
    return settings
};
GameProtocolGamblingParser.ParseGamblingHistory = function(history, win) {
    var gamblingHistory = null;
    if (history != null) {
        gamblingHistory = new VsGamblingHistory(win);
        var historySplit = history.split("~");
        for (var i = 0; i < historySplit.length; i++) {
            var response = new VsGamblingResponse;
            GameProtocolGamblingParser.Populate(response, historySplit[i]);
            gamblingHistory.AddHistoryItem(response)
        }
    }
    return gamblingHistory
};
GameProtocolGamblingParser.ParseState = function(state) {
    switch (state) {
        case 2:
            return GamblingState.WinLimit;
        case 1:
            return GamblingState.Win;
        default:
            return GamblingState.Lose
    }
};
GameProtocolGamblingParser.ParseType = function(type) {
    switch (type) {
        case 2:
            return GamblingType.Dices;
        case 1:
            return GamblingType.Suit;
        default:
            return GamblingType.CardColor
    }
};
GameProtocolGamblingParser.ParseCurrentGamblingOccasion = function(symbol) {
    switch (symbol) {
        case "b":
            return GamblingOccasions.Bonus;
        case "f":
            return GamblingOccasions.FreeSpin;
        default:
            return GamblingOccasions.Spin
    }
};
GameProtocolGamblingParser.ParseResult = function(gameResult) {
    var result = [];
    var split = gameResult.split(";");
    if (split.length != 2) return null;
    result.push(_number.otoi(split[0]));
    if (GamblingType.Dices == GameProtocolGamblingParser.ParseType(result[0])) {
        var tmpSplit = split[1].split(",");
        if (tmpSplit.length != 2) return null;
        result.push(_number.otoi(tmpSplit[0]));
        result.push(_number.otoi(tmpSplit[1]))
    } else result.push(_number.otoi(split[1]));
    return result
};
GameProtocolGamblingParser.Populate = function(response, result) {
    var gamblingResult = GameProtocolGamblingParser.ParseResult(result);
    if (gamblingResult == null) return;
    var type = GameProtocolGamblingParser.ParseType(gamblingResult[0]);
    response.GamblingType = type;
    if (type == GamblingType.Dices) {
        response.Dice1 = gamblingResult[1];
        response.Dice2 = gamblingResult[2]
    } else response.Card = gamblingResult[1]
};

function ServerGameResponse() {
    this.Index = 0;
    this.Counter = 0;
    this.Repeat = 0;
    this.DoSpin = false;
    this.DoCollect = false;
    this.ValuesMap = null;
    this.NextGameActions = null;
    this.ServerTime = -1
}
var GameProtocolParser = {};
GameProtocolParser.lastCounter = -1;
GameProtocolParser.ParseResponse = function(nameValues) {
    var serverGameResponse = new ServerGameResponse;
    if (nameValues.length == 0) return serverGameResponse;
    var mapNameValues = GameProtocolCommonParser.SplitResponseContent(nameValues);
    serverGameResponse.Index = GameProtocolCommonParser.ParseInt(mapNameValues, GameProtocolDictionary.index);
    serverGameResponse.Counter = GameProtocolCommonParser.ParseInt(mapNameValues, GameProtocolDictionary.counter);
    if (serverGameResponse.Counter == 0) serverGameResponse.Counter = GameProtocolParser.lastCounter +
        2;
    GameProtocolParser.lastCounter = serverGameResponse.Counter;
    var action = "";
    if (mapNameValues["action"] != undefined) action = mapNameValues["action"];
    serverGameResponse.DoSpin = action == "doSpin";
    serverGameResponse.DoCollect = action == "doCollect";
    serverGameResponse.ValuesMap = mapNameValues;
    serverGameResponse.NextGameActions = GameProtocolParser.ParseNextGameActions(mapNameValues);
    if (mapNameValues[GameProtocolDictionary.time] != undefined) serverGameResponse.ServerTime = _number.otoi(mapNameValues[GameProtocolDictionary.time]);
    return serverGameResponse
};
GameProtocolParser.ParseNextGameActions = function(nameValues) {
    if (nameValues[GameProtocolDictionary.NextActions.nextAction] != undefined) {
        var na = [];
        var str_na = nameValues[GameProtocolDictionary.NextActions.nextAction].split(",");
        for (var i = 0; i < str_na.length; ++i)
            if (str_na[i] == GameProtocolDictionary.NextActions.Bonus) na.push(NextGameAction.Bonus);
            else if (str_na[i] == GameProtocolDictionary.NextActions.Collect) na.push(NextGameAction.Collect);
        else if (str_na[i] == GameProtocolDictionary.NextActions.CollectBonus) na.push(NextGameAction.CollectBonus);
        else if (str_na[i] ==
            GameProtocolDictionary.NextActions.FSOption) na.push(NextGameAction.FSOption);
        else if (str_na[i] == GameProtocolDictionary.NextActions.Gamble) na.push(NextGameAction.Gamble);
        else if (str_na[i] == "go") na.push(NextGameAction.GambleOption);
        else if (str_na[i] == GameProtocolDictionary.NextActions.Spin) na.push(NextGameAction.Spin);
        else if (str_na[i] == GameProtocolDictionary.NextActions.MysteryScatter) na.push(NextGameAction.MysteryScatter);
        else if (str_na[i] == GameProtocolDictionary.NextActions.FSBonus) na.push(NextGameAction.FSBonus);
        else if (str_na[i] == GameProtocolDictionary.NextActions.GambleCollect) na.push(NextGameAction.GambleCollect);
        else if (str_na[i] == GameProtocolDictionary.NextActions.JackpotCollect) na.push(NextGameAction.JackpotCollect);
        else if (str_na[i] == GameProtocolDictionary.NextActions.PlayJackpot) na.push(NextGameAction.PlayJackpot);
        else na.push(NextGameAction.None);
        return na
    }
    return null
};
var VSProtocolParser = {};
VSProtocolParser.ParseResponse = function(response) {
    var serverGameResponse = new ServerGameResponse;
    if (_string.IsNullOrEmpty(response)) return serverGameResponse;
    var hasDoSpin = false;
    var hasDoCollect = false;
    var mapNameValues = {};
    var nameValues = response.split("&");
    for (var i = 0; i < nameValues.length; ++i) {
        var nameValueSplitted = nameValues[i].split("=");
        if (nameValueSplitted.length == 2) {
            if (nameValueSplitted[0] == "action")
                if (nameValueSplitted[1] == "doCollect") hasDoCollect = true;
                else if (nameValueSplitted[1] == "doSpin") hasDoSpin =
                true;
            if (mapNameValues[nameValueSplitted[0]] == undefined) mapNameValues[nameValueSplitted[0]] = nameValueSplitted[1]
        }
    }
    serverGameResponse.Index = GameProtocolCommonParser.ParseInt(mapNameValues, GameProtocolDictionary.index);
    serverGameResponse.Counter = GameProtocolCommonParser.ParseInt(mapNameValues, GameProtocolDictionary.counter);
    serverGameResponse.DoSpin = hasDoSpin;
    serverGameResponse.DoCollect = hasDoCollect;
    return serverGameResponse
};
VSProtocolParser.ParseVsGamblingResponse = function(response) {
    var result = new VsGamblingResponse;
    if (_string.IsNullOrEmpty(response)) return result;
    var mapNameValues = {};
    var nameValues = response.split("&");
    for (var i = 0; i < nameValues.length; ++i) {
        var nameValueSplitted = nameValues[i].split("=");
        if (nameValueSplitted.length == 2)
            if (mapNameValues[nameValueSplitted[0]] == undefined) mapNameValues[nameValueSplitted[0]] = nameValueSplitted[1]
    }
    return GameProtocolGamblingParser.ParseVsGamblingResponse(mapNameValues)
};
VSProtocolParser.ParseVsInitData = function(nameValue) {
    var result = new VsInitData;
    result.Bets = GameProtocolCommonParser.ParseDoubleList(nameValue, GameProtocolDictionary.bets);
    result.Bet = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.coin);
    result.ExplicitMaxTotalBet = GameProtocolCommonParser.ParseDoubleIfExists(nameValue, "total_bet_max");
    result.DefaultBet = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.defaultBet);
    result.Line = GameProtocolCommonParser.ParseInt(nameValue,
        GameProtocolDictionary.line);
    result.ReelSymbols = VSProtocolParser.ParseReelsSymbols(nameValue);
    result.ReelSets = VSProtocolParser.ParseReelSets(nameValue);
    result.NextReelSymbols = VSProtocolParser.ParseNextReelsSymbols(nameValue);
    result.Paytable = VSProtocolParser.ParsePaytable(nameValue, GameProtocolDictionary.paytable);
    result.Scatters = VSProtocolParser.ParseScatters(nameValue);
    result.Bonuses = VSProtocolParser.ParseBonuses(nameValue);
    result.Wilds = VSProtocolParser.ParseWilds(nameValue, GameProtocolDictionary.wilds);
    result.WildScatters = VSProtocolParser.ParseWilds(nameValue, GameProtocolDictionary.wildScatters);
    result.InitialMysterySymbolId = GameProtocolCommonParser.ParseIntList(nameValue, GameProtocolDictionary.initialMysterySymbol, "~");
    result.BGItemValues = GameProtocolCommonParser.ParseDoubleList(nameValue, GameProtocolDictionary.BonusGame.BGItemValues);
    result.BGItemMasks = GameProtocolCommonParser.ParseStringList(nameValue, GameProtocolDictionary.BonusGame.BGItemMasks);
    result.CombinePaytable();
    var tryMeOnceLine = GameProtocolCommonParser.ParseNulableInt(nameValue,
        GameProtocolDictionary.tryMeOnceLine);
    var tryMeOnceBet = GameProtocolCommonParser.ParseNulableDouble(nameValue, GameProtocolDictionary.tryMeOnceCoin);
    var reelSetIndex = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.reelSetIndex);
    result.ReelSetIndex = reelSetIndex != null ? reelSetIndex : -1;
    var stackedSymbolIndex = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.stackedSymbolIndex);
    result.StackedSymbolIndex = stackedSymbolIndex != null ? stackedSymbolIndex : -1;
    var reelSetIndexCurrent =
        GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.reelSetIndexCurrent);
    result.ReelSetIndexCurrent = reelSetIndexCurrent != null ? reelSetIndexCurrent : -1;
    var stackedSymbolIndexCurrent = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.stackedSymbolIndexCurrent);
    result.StackedSymbolIndexCurrent = stackedSymbolIndexCurrent != null ? stackedSymbolIndexCurrent : -1;
    var naSymbolId = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.naSymbolId);
    result.naSymbolId =
        naSymbolId != null ? naSymbolId : -1;
    if (tryMeOnceLine != null && tryMeOnceBet != null && tryMeOnceLine > 0 && tryMeOnceBet > 0) {
        result.Bet = tryMeOnceBet;
        result.Line = tryMeOnceLine
    }
    result.GamblingSettings = GameProtocolGamblingParser.ParseGamblingSettings(nameValue);
    result.GamblingHistory = GameProtocolGamblingParser.ParseGamblingHistory(GameProtocolCommonParser.ParseIfExist(nameValue, GameProtocolDictionary.Gambling.history), GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.Gambling.win));
    result.WildRandomLineMpConfig =
        VSProtocolParser.ParseVsWildRandomLineMultiplier(nameValue);
    result.RandomAwardConfig = VSProtocolParser.ParseVsRandomAwardsConfig(nameValue);
    result.ProgressiveConfig = VSProtocolParser.ParseProgressiveFeatureConfig(nameValue);
    result.MoneySymbolConfig = VSProtocolParser.ParseMoneySymbolConfig(nameValue);
    result.FreeSpinsPurchaseConfig = VSProtocolParser.ParseFSPurchaseConfig(nameValue);
    result.BetLevelSettings = VSProtocolParser.ParseBetLevelSettings(nameValue);
    return result
};
VSProtocolParser.ParseVsResponse = function(nameValue) {
    var result = new VsResponse;
    result.SlotHeight = GameProtocolCommonParser.ParseInt(nameValue, GameProtocolDictionary.slotHeight);
    if (result.SlotHeight == 0) result.SlotHeight = GameConnection.prototype.SlotHeight;
    if (nameValue[GameProtocolDictionary.bonusBalance] == undefined || !XT.GetBool(Vars.Jurisdiction_SplitBalance)) {
        result.Balance = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.balance);
        result.BonusBalance = 0
    } else {
        result.Balance = GameProtocolCommonParser.ParseDouble(nameValue,
            GameProtocolDictionary.cashBalance);
        result.BonusBalance = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.bonusBalance)
    }
    result.Win = VSProtocolParser.ParseWinAmountShort(nameValue);
    result.ExtraAwardWin = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.extraAwardWin);
    result.RespinCycleWin = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.respinCycleWin);
    result.ReelPositions = GameProtocolCommonParser.ParseIntList(nameValue, GameProtocolDictionary.reelsPosition);
    result.ExpandingSymbolsData = VSProtocolParser.ParseExpandingSymbolsData(nameValue);
    result.SymbolsBeforeExpanding = VSProtocolParser.ParseWinScreenSymbols(nameValue, result.SlotHeight, GameProtocolDictionary.symbolsBeforeExpanding);
    result.RandomWildsData = VSProtocolParser.ParseRandomWildsData(nameValue, result.SlotHeight);
    result.UpSymbols = VSProtocolParser.ParseUpSymbols(nameValue);
    result.WinScreenSymbols = VSProtocolParser.ParseWinScreenSymbols(nameValue, result.SlotHeight, GameProtocolDictionary.winSymbols);
    result.SymbolsAbove = GameProtocolCommonParser.ParseIntList(nameValue, GameProtocolDictionary.TopBottomSymbols.symbolsAbove);
    result.SymbolsBelow = GameProtocolCommonParser.ParseIntList(nameValue, GameProtocolDictionary.TopBottomSymbols.symbolsBelow);
    result.NextReelsSymbolsList = GameProtocolCommonParser.ParseIntList(nameValue, GameProtocolDictionary.NextReelsSymbolsList);
    result.VsWinLines = VSProtocolParser.ParseWinLines(nameValue);
    result.SetVsBonusGameData(GameProtocolBonusGameParser.ParseBonusGame(nameValue));
    result.FreeSpinsOptions = VSProtocolParser.ParseFreeSpinsOptions(nameValue);
    result.WildRandomMultipliers = VSProtocolParser.ParseWildRandomMultipliers(nameValue);
    result.Respin = VSProtocolParser.ParseRespin(nameValue);
    if (XT.GetBool(Vars.TruncateFSResponseDuringRespin) && result.Respin != null && result.Respin.TotalRespins == null) result.TruncatedVsFreeSpin = VSProtocolParser.ParseVsFreeSpin(nameValue);
    else result.SetVsFreeSpin(VSProtocolParser.ParseVsFreeSpin(nameValue));
    result.VsInitData = VSProtocolParser.ParseVsInitData(nameValue);
    result.VsJackpotData = VSProtocolParser.ParseVsJackpotData(nameValue);
    result.JackpotVisualisation = VSProtocolParser.ParseJPVisualization(nameValue);
    result.GoldSymbol = VSProtocolParser.ParseGoldSymbol(nameValue);
    result.SymbolReplacementData = VSProtocolParser.ParseSymbolReplacementData(nameValue);
    result.SpinOneReelData = VSProtocolParser.ParseSpinOneReelData(nameValue);
    result.TumblingWin = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.TumblingWin);
    result.TumblingData = VSProtocolParser.ParseTumblingData(nameValue);
    result.NudgedSymbolsData = VSProtocolParser.ParseNudgedSymbolsData(nameValue);
    result.FreeRoundEvents = VSProtocolParser.ParseVsFreeRoundEvents(nameValue);
    result.FreeRound = VSProtocolParser.ParseVsFreeRound(nameValue);
    result.ProgressiveData = VSProtocolParser.ParseProgressiveFeatureData(nameValue);
    result.MoneySymbolData = VSProtocolParser.ParseMoneySymbolData(nameValue);
    result.StickySymbols = VSProtocolParser.ParseStickySymbols(nameValue);
    result.MergingSymbols = VSProtocolParser.ParseMergingSymbols(nameValue);
    result.WRLMResponse = VSProtocolParser.ParseWRLMResponse(nameValue);
    result.WRLMCurrentSets = VSProtocolParser.ParseWRLMCurrentSets(nameValue);
    result.RandomAwardResponse = VSProtocolParser.ParseRandomAwardsResponse(nameValue);
    result.RandomSymbolMultipliers = VSProtocolParser.ParseRandomSymbolMultipliers(nameValue);
    result.PossibleRandomSymbolMultipliers = VSProtocolParser.ParsePossibleRandomSymbolMultipliers(nameValue);
    result.FreeSpinsChainData = VSProtocolParser.ParseFreeSpinsChainedData(nameValue);
    result.OpeningSymbolsData =
        VSProtocolParser.ParseOpeningSymbolsData(nameValue);
    result.FreeSpinsPurchaseData = VSProtocolParser.ParseFSPurchaseData(nameValue);
    result.RandomMysterySymbolId = GameProtocolCommonParser.ParseIntList(nameValue, GameProtocolDictionary.randomMysterySymbol, "~");
    result.PatternedMysterySymbols = VSProtocolParser.ParsePatternedMysterySymbols(nameValue);
    result.SpinCycleWin = GameProtocolCommonParser.ParseDoubleIfExists(nameValue, GameProtocolDictionary.spinCycleWin);
    var rtp = GameProtocolCommonParser.ParseDoubleList(nameValue,
        GameProtocolDictionary.returnToPlayer);
    if (rtp != null)
        if (rtp.length > 1) {
            rtp.sort();
            result.ReturnToPlayerMin = rtp[0];
            result.ReturnToPlayer = rtp[rtp.length - 1]
        } else result.ReturnToPlayer = rtp[0];
    var reelSetIndex = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.reelSetIndex);
    result.ReelSetIndex = reelSetIndex != null ? reelSetIndex : -1;
    var stackedSymbolIndex = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.stackedSymbolIndex);
    result.StackedSymbolIndex = stackedSymbolIndex !=
        null ? stackedSymbolIndex : -1;
    var reelSetIndexCurrent = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.reelSetIndexCurrent);
    result.ReelSetIndexCurrent = reelSetIndexCurrent != null ? reelSetIndexCurrent : -1;
    var stackedSymbolIndexCurrent = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.stackedSymbolIndexCurrent);
    result.StackedSymbolIndexCurrent = stackedSymbolIndexCurrent != null ? stackedSymbolIndexCurrent : -1;
    result.gambleV2Data = GambleV2Protocol.Parser.ParseGambleData(nameValue);
    XT.SetBool(Vars.OpenFSBGForMysteryScatter, nameValue[GameProtocolDictionary.mysteryScatterGame] != undefined && XT.GetBool(Vars.SendSeparateMysteryScatter));
    return result
};
VSProtocolParser.ParseWinAmountShort = function(nameValues) {
    if (nameValues[GameProtocolDictionary.winAmountShort] != undefined) return GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.winAmountShort);
    else return -1
};
VSProtocolParser.ParseVsFreeSpin = function(nameValues) {
    if (nameValues[GameProtocolDictionary.freeSpinCurrentNumber] == undefined && nameValues[GameProtocolDictionary.freeSpinTotalNumber] == undefined && nameValues[GameProtocolDictionary.FreeSpinBonusGame.gameExsist] == undefined && nameValues[GameProtocolDictionary.FreeSpinBonusGame.wins] == undefined && nameValues[GameProtocolDictionary.mysteryScatterSymbol] == undefined && nameValues[GameProtocolDictionary.mysteryScatterSymbolGameHistory] == undefined) return null;
    var result =
        new VsFreeSpin;
    result.SetCurrentNumber(GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.freeSpinCurrentNumber));
    result.SetMaxNumber(GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.freeSpinMaxNumber));
    result.SetTotalNumber(GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.freeSpinTotalNumber));
    result.SetTotalWin(GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.freeSpinTotalWin));
    result.SetTotalWinMultiplied(GameProtocolCommonParser.ParseDouble(nameValues,
        GameProtocolDictionary.freeSpinTotalWinMultiplied));
    var ppoi = GameProtocolCommonParser.ParseIfExist(nameValues, GameProtocolDictionary.freeSpinsPickedOptionIndex);
    if (!_string.IsNullOrEmpty(ppoi)) result.PickedOptionIndex = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.freeSpinsPickedOptionIndex);
    else result.PickedOptionIndex = -1;
    if (nameValues[GameProtocolDictionary.freeSpinCurrentMultiplier] != undefined) result.SetTotalMultipl(GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.freeSpinCurrentMultiplier));
    else result.SetTotalMultipl(GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.freeSpinTotalMultipl));
    if (nameValues[GameProtocolDictionary.freeSpinCurrentWin] != undefined) {
        var currentWin = GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.freeSpinCurrentWin);
        currentWin = Math.round(currentWin * 100) / 100;
        result.SetCurrentWin(currentWin)
    } else result.SetCurrentWin(result.GetTotalWin());
    result.SetCurrentWinMultiplied(nameValues[GameProtocolDictionary.freeSpinCurrentWinMultiplied] !=
        undefined ? GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.freeSpinCurrentWinMultiplied) : result.GetTotalWinMultiplied());
    result.BonusGame = GameProtocolFreeSpinBonusGameParser.ParseFreeSpinBonusGame(nameValues);
    var mysteryScatterSymbol = null;
    var mysteryScatterSymbolGameHistory = null;
    if (nameValues[GameProtocolDictionary.mysteryScatterSymbol] != undefined) mysteryScatterSymbol = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.mysteryScatterSymbol);
    if (nameValues[GameProtocolDictionary.mysteryScatterSymbolGameHistory] !=
        undefined) mysteryScatterSymbolGameHistory = GameProtocolCommonParser.ParseNulableInt(nameValues, GameProtocolDictionary.mysteryScatterSymbolGameHistory);
    if (mysteryScatterSymbol == null) {
        mysteryScatterSymbol = [];
        if (mysteryScatterSymbolGameHistory != null && mysteryScatterSymbolGameHistory != -1) mysteryScatterSymbol.push(mysteryScatterSymbolGameHistory)
    }
    result.SetMysteryScatter(mysteryScatterSymbol);
    result.SetNeedGetMysteryScatter(nameValues[GameProtocolDictionary.mysteryScatterGame] != undefined && result.GetMysteryScatter().length ==
        0);
    var key = "fstype";
    if (nameValues[key] != undefined) result.fstype = GameProtocolBonusGameParser.ParseWinMask(nameValues[key]);
    return result
};
VSProtocolParser.ParseRespin = function(source) {
    var result = null;
    var data = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.respin);
    var currentRespin = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.currentRespin);
    var totalRespins = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.totalRespins);
    var isTriggeredType = data == "t";
    var untilWinType = data == "uw";
    var multiCaseType = data == "mc";
    if (!isTriggeredType && !untilWinType && !multiCaseType && !_string.IsNullOrEmpty(data)) {
        data =
            _string.Trim(data);
        if (data.length > 0) {
            var dataSplit = data.split("~");
            result = new VsRespin;
            result.RespinType = dataSplit[0];
            result.Indices = [];
            if (result.RespinType == "l") {
                var lines = [];
                for (var i = 1; i < dataSplit.length; ++i) {
                    var lineSplit = dataSplit[i].split(";");
                    if (lineSplit.length > 2) {
                        var line = new VsRespinLine;
                        line.respinsCount = _number.otoi(lineSplit[0]);
                        line.id = _number.otoi(lineSplit[1]);
                        line.positions = _array.ConvertAll(lineSplit[2].split(","), _number.otoi);
                        lines.push(line)
                    }
                }
                result.Lines = lines.length > 0 ? lines :
                    null
            } else if (dataSplit.length > 1) {
                var indicesLists = dataSplit[1].split(";");
                for (var i = 0; i < indicesLists.length; i++) {
                    result.Indices[i] = [];
                    var indices = indicesLists[i].split(",");
                    for (var j = 0; j < indices.length; j++) result.Indices[i].push(_number.otoi(indices[j]))
                }
            }
        }
    }
    if (!_string.IsNullOrEmpty(currentRespin) || !_string.IsNullOrEmpty(totalRespins)) {
        if (result == null) result = new VsRespin;
        result.CurrentRespin = GameProtocolCommonParser.ParseNulableInt(source, GameProtocolDictionary.currentRespin);
        result.MaxRespins = GameProtocolCommonParser.ParseNulableInt(source,
            GameProtocolDictionary.maxRespins);
        result.TotalRespins = GameProtocolCommonParser.ParseNulableInt(source, GameProtocolDictionary.totalRespins)
    }
    if (source["rs_p"] != undefined) result.RespinsPlayed = _number.otoi(source["rs_p"]);
    if (source["rs_more"] != undefined) result.RespinsAdded = _number.otoi(source["rs_more"]);
    return result
};
VSProtocolParser.ParseProgressiveFeatureConfig = function(dict) {
    var result = null;
    var cfg_masks_string = GameProtocolCommonParser.ParseIfExist(dict, GameProtocolDictionary.ProgressiveFeature.Config.configMasks);
    if (!_string.IsNullOrEmpty(cfg_masks_string)) {
        result = new VSProgressiveFeatureConfig;
        var pickedSymbolPos = GameProtocolCommonParser.ParseNulableInt(dict, GameProtocolDictionary.ProgressiveFeature.progressivePick);
        result.pickedSymbolPosition = pickedSymbolPos === null ? -1 : pickedSymbolPos;
        var cfg_masks = cfg_masks_string.split(",");
        var cfg_vals = GameProtocolCommonParser.ParseIntList(dict, GameProtocolDictionary.ProgressiveFeature.Config.configValues);
        result.progressSymbolIDs = [];
        for (var i = 0; i < cfg_masks.length; i++)
            if (cfg_masks[i] == "s") result.progressSymbolIDs.push(cfg_vals[i])
    }
    return result
};
VSProtocolParser.ParseProgressiveFeatureData = function(source) {
    var result = null;
    var data = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.progressiveFeature);
    if (!_string.IsNullOrEmpty(data)) {
        var splitData = data.split(",");
        var lvlStr = splitData[0].split(":")[1];
        var progStr = splitData[1].split(":")[1];
        var attemptsStr = splitData[2].split(":")[1];
        if (_string.IsNullOrEmpty(lvlStr) || _string.IsNullOrEmpty(progStr) || _string.IsNullOrEmpty(attemptsStr)) return null;
        result = new VsProgressiveFeatureData;
        result.level = _number.otoi(lvlStr);
        result.progress = _number.otoi(progStr);
        result.attempts = _number.otoi(attemptsStr)
    } else {
        var prg_m_string = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.ProgressiveFeature.Status.stateMasks);
        if (!_string.IsNullOrEmpty(prg_m_string)) {
            result = new VsProgressiveFeatureData;
            var prg_m = prg_m_string.split(",");
            var prg_v = String(source[GameProtocolDictionary.ProgressiveFeature.Status.stateValues]).split(",");
            for (var i = 0; i < prg_m.length; i++)
                if (prg_m[i] == "ca") result.currentAttempt =
                    _number.otoi(prg_v[i]);
                else if (prg_m[i] == "ta") result.attempts = _number.otoi(prg_v[i]);
            else if (prg_m[i] == "cp") result.progress = _number.otoi(prg_v[i]);
            else if (prg_m[i] == "tp") result.targetProgress = _number.otoi(prg_v[i]);
            else if (prg_m[i] == "lvl") result.level = _number.otoi(prg_v[i]);
            else if (prg_m[i] == "r") result.needsReset = _number.otoi(prg_v[i]) == 1;
            else if (prg_m[i] == "acw") result.accumulatedWin = _number.otod(prg_v[i]);
            else if (prg_m[i] == "pp") result.prizeWin = _number.otod(prg_v[i]);
            else if (prg_m[i] == "pm") result.prizeMultiplier =
                _number.otoi(prg_v[i]);
            else if (prg_m[i] == "wm") result.winMultiplier = _number.otoi(prg_v[i])
        }
    }
    return result
};
VSProtocolParser.ParseMoneySymbolConfig = function(source) {
    var result = null;
    if (source[GameProtocolDictionary.MoneySymbol.symbolID] != undefined) {
        result = new VsMoneySymbolConfig;
        result.symbolID = GameProtocolCommonParser.ParseInt(source, GameProtocolDictionary.MoneySymbol.symbolID);
        result.possibleValues = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.MoneySymbol.possibleValues);
        var jpData = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.MoneySymbol.jackpotValues);
        var i;
        if (!_string.IsNullOrEmpty(jpData)) {
            var jpVals = jpData.split(";");
            result.jackpotValues = [];
            for (i = 0; i < jpVals.length; i++) result.jackpotValues.push(_number.otoi(jpVals[i]))
        }
        jpData = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.MoneySymbol.jackpotMasks);
        if (!_string.IsNullOrEmpty(jpData)) result.jackpotMasks = jpData.split(";")
    }
    return result
};
VSProtocolParser.ParseMoneySymbolData = function(source) {
    var result = null;
    if (source[GameProtocolDictionary.MoneySymbol.symbolsValues] != undefined) {
        result = new VsMoneySymbolData;
        result.currentValues = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.MoneySymbol.symbolsValues);
        result.currentSymbolsLook = GameProtocolCommonParser.ParseStringList(source, GameProtocolDictionary.MoneySymbol.symbolsTypes);
        result.totalWin = GameProtocolCommonParser.ParseDoubleIfExists(source, GameProtocolDictionary.MoneySymbol.totalWin)
    }
    return result
};
VSProtocolParser.ParseFSPurchaseConfig = function(source) {
    var cfg = null;
    var masks = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.FreeSpinsPurchase.purchaseOptionsMask);
    var options = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.FreeSpinsPurchase.purchaseOptions);
    if (!_string.IsNullOrEmpty(masks) && !_string.IsNullOrEmpty(options)) {
        cfg = new VsFSPurchaseConfig;
        var masksSplit = masks.split(";");
        var optionsSplit = options.split(";");
        for (var i = 0; i < masksSplit.length; i++) {
            cfg.purchaseOptions.push(new VsFSPurchaseConfig.PurchaseOption);
            var mask = masksSplit[i].split("~");
            var option = optionsSplit[i].split("~");
            for (var j = 0; j < mask.length; j++) switch (mask[j]) {
                case "bet":
                    cfg.purchaseOptions[i].bet = _number.otoi(option[j]);
                    break;
                case "fs_count":
                    cfg.purchaseOptions[i].fsCount = _number.otoi(option[j]);
                    break;
                case "bet_level":
                    cfg.purchaseOptions[i].betLevel = _number.otoi(option[j]);
                    break;
                default:
                    break
            }
        }
    }
    return cfg
};
VSProtocolParser.ParseBetLevelSettings = function(source) {
    var settings = null;
    var betLevelScale = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.BetLevel.betLevelScale);
    if (betLevelScale != null) {
        settings = new VsBetLevel;
        settings.betLevelIndex = GameProtocolCommonParser.ParseInt(source, GameProtocolDictionary.BetLevel.betLevelIndex);
        settings.betLevelScale = betLevelScale;
        for (var i = 0; i < settings.betLevelScale.length; i++) {
            var blPaytable = VSProtocolParser.ParsePaytable(source, GameProtocolDictionary.BetLevel.betLevelPaytable +
                i.toString());
            if (blPaytable != null) settings.paytables.push(blPaytable)
        }
    }
    return settings
};
VSProtocolParser.ParseStickySymbols = function(source) {
    var result = null;
    var data = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.stickySymbols);
    if (!_string.IsNullOrEmpty(data)) {
        data = _string.Trim(data);
        if (data.length > 0) {
            result = [];
            var stickySymbols = data.split("~");
            for (var ssIndex = 0; ssIndex < stickySymbols.length; ssIndex++) {
                var positions = stickySymbols[ssIndex].split(",");
                var _symbol = new VsStickySymbol;
                _symbol.currentPosition = _number.otoi(positions[0]);
                _symbol.endPosition = _number.otoi(positions[1]);
                result.push(_symbol)
            }
        }
    }
    return result
};
VSProtocolParser.ParseMergingSymbols = function(source) {
    var result = null;
    var data = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.mergingSymbols);
    if (!_string.IsNullOrEmpty(data)) {
        data = _string.Trim(data);
        if (data.length > 0) {
            result = [];
            var mergingSymbols = data.split(",");
            for (var ssIndex = 0; ssIndex < mergingSymbols.length; ssIndex++) {
                var mergingInfo = mergingSymbols[ssIndex].split("~");
                var _mergingSymbol = new VsMergingSymbol;
                _mergingSymbol.mergingPosition = _number.otoi(mergingInfo[0]);
                _mergingSymbol.mergedSymbolId =
                    _number.otoi(mergingInfo[1]);
                result.push(_mergingSymbol)
            }
        }
    }
    return result
};
VSProtocolParser.GetFreeSpinsOptions = function(source) {
    var result = null;
    var ws = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.freeSpinsOptions);
    if (!_string.IsNullOrEmpty(ws)) result = _string.Trim(ws).split("~");
    return result
};
VSProtocolParser.GetFreeSpinsOptionsMasks = function(source) {
    var result = null;
    var fsom = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.freeSpinsOptionsMask);
    if (!_string.IsNullOrEmpty(fsom)) {
        var maskPairs = _string.Trim(fsom).split(";");
        result = [];
        for (var i = 0; i < maskPairs.length; i++) result.push(maskPairs[i].split(","))
    }
    return result
};
VSProtocolParser.ParseFreeSpinsOptions = function(source) {
    var result = null;
    var freeSpinsOptions = VSProtocolParser.GetFreeSpinsOptions(source);
    if (freeSpinsOptions != null) {
        result = [];
        var _masks = VSProtocolParser.GetFreeSpinsOptionsMasks(source);
        for (var i = 0; i < freeSpinsOptions.length; i++) {
            var _data = freeSpinsOptions[i].split(",");
            var _freeSpinsOption = new VsFreeSpinOption;
            if (_masks == null) {
                _freeSpinsOption.FreeSpinsCount = _number.otoi(_data[0]);
                _freeSpinsOption.FreeSpinsMultiplier = _number.otoi(_data[1])
            } else {
                var _mIdx =
                    i;
                if (i >= _masks.length) _mIdx = 0;
                for (var j = 0; j < _masks[_mIdx].length; j++) switch (_masks[_mIdx][j]) {
                    case "fs":
                        _freeSpinsOption.FreeSpinsCount = _number.otoi(_data[j]);
                        break;
                    case "m":
                        _freeSpinsOption.FreeSpinsMultiplier = _number.otoi(_data[j]);
                        break;
                    case "ss":
                        _freeSpinsOption.FreeSpinsStackedSymbol = _number.otoi(_data[j]);
                        break;
                    case "ws":
                        _freeSpinsOption.WildSymbolIndex = _number.otoi(_data[j]);
                        break;
                    case "wm":
                        _freeSpinsOption.WildWinMultipliers.push(_number.otoi(_data[j]));
                        break;
                    case "ftr":
                        _freeSpinsOption.SpecialFeatureName =
                            _data[j];
                        break;
                    case "ts":
                        _freeSpinsOption.TriggerSymbolRandomMultiplier = _number.otoi(_data[j]);
                        break;
                    case "rm":
                        var randomMultipliers = _data[j].split(";");
                        for (var rmIndex = 0; rmIndex < randomMultipliers.length; rmIndex++) _freeSpinsOption.TSRandomMultipliers.push(_number.otoi(randomMultipliers[rmIndex]));
                        break;
                    case "ptm":
                        _freeSpinsOption.FreeSpinsStartingMultiplier = _number.otoi(_data[j]);
                        break;
                    default:
                        break
                }
            }
            result.push(_freeSpinsOption)
        }
    }
    return result
};
VSProtocolParser.GetExpandingSymbolsData = function(source) {
    var result = null;
    var ws = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.expandingSymbolsData);
    if (!_string.IsNullOrEmpty(ws)) result = _string.Trim(ws).split(";");
    return result
};
VSProtocolParser.GetSymbolsBeforeExpanding = function(source) {
    var result = null;
    var ws = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.symbolsBeforeExpanding);
    if (!_string.IsNullOrEmpty(ws)) result = _string.Trim(ws).split(",");
    return result
};
VSProtocolParser.GetWinSymbols = function(source, parseKey) {
    var result = null;
    var ws = GameProtocolCommonParser.ParseIfExist(source, parseKey);
    if (!_string.IsNullOrEmpty(ws)) result = _string.Trim(ws).split(",");
    return result
};
VSProtocolParser.GetReelSet = function(source, reelSetIndex) {
    var result = null;
    var rs = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.reelSet(reelSetIndex));
    if (!_string.IsNullOrEmpty(rs)) result = _string.Trim(rs).split("~");
    return result
};
VSProtocolParser.ParseRandomWildsData = function(source, reelHeight) {
    var result = null;
    var rwd = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.randomWildsData);
    if (_string.IsNullOrEmpty(rwd)) return result;
    result = [];
    var splitByIDs = rwd.split(";");
    for (var i = 0; i < splitByIDs.length; i++) {
        var splitByComponents = splitByIDs[i].split("~");
        var rwdID = _number.otoi(splitByComponents[0]);
        var splitByPosition = splitByComponents[1].split(",");
        for (var j = 0; j < splitByPosition.length; j++) {
            if (j % reelHeight == 0) {
                var vsRWD =
                    new VsRandomWildsData;
                vsRWD.RandomSymbolID = rwdID;
                vsRWD.TargetPositions = [];
                result.push(vsRWD)
            }
            result[result.length - 1].TargetPositions.push(_number.otoi(splitByPosition[j]))
        }
    }
    return result
};
VSProtocolParser.ParseUpSymbols = function(source) {
    var result = null;
    var ups = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.upSymbols);
    if (_string.IsNullOrEmpty(ups)) return result;
    result = [];
    var splitByPosition = ups.split(",");
    for (var i = 0; i < splitByPosition.length; i++) result.push(_number.otoi(splitByPosition[i]));
    return result
};
VSProtocolParser.ParseExpandingSymbolsData = function(source) {
    var result = null;
    var expandingSymbolsData = VSProtocolParser.GetExpandingSymbolsData(source);
    if (expandingSymbolsData != null) {
        result = [];
        var j;
        for (var i = 0; i < expandingSymbolsData.length; i++) {
            var _data = expandingSymbolsData[i].split("~");
            var _expandingSymbolData = new VsExpandingSymbolData;
            _expandingSymbolData.ExpandingSymbolId = _number.otoi(_data[0]);
            _expandingSymbolData.SourcePositions = [];
            var sourcePositions = _data[1].split(",");
            for (j = 0; j < sourcePositions.length; j++) _expandingSymbolData.SourcePositions.push(_number.otoi(sourcePositions[j]));
            _expandingSymbolData.TargetPositions = [];
            var targetPositions = _data[2].split(",");
            for (j = 0; j < targetPositions.length; j++) _expandingSymbolData.TargetPositions.push(_number.otoi(targetPositions[j]));
            result.push(_expandingSymbolData)
        }
    }
    return result
};
VSProtocolParser.ParseWinScreenSymbols = function(source, slotHeight, parseKey) {
    var result = [];
    if (slotHeight > 0) {
        var winSymbols = VSProtocolParser.GetWinSymbols(source, parseKey);
        if (winSymbols != null)
            if (winSymbols.length % slotHeight == 0) {
                var lineSize = winSymbols.length / slotHeight;
                for (var i = 0; i < lineSize; ++i) {
                    var reelSymbols = [];
                    for (var j = 0; j < slotHeight; ++j) reelSymbols.unshift(_number.otoi(winSymbols[lineSize * j + i]));
                    result.push(reelSymbols)
                }
            } else;
    }
    return result
};
VSProtocolParser.ParseWinLines = function(nameValues) {
    if (nameValues[GameProtocolDictionary.winWayGroups] != undefined) return VSProtocolParser.ParseWinGroups(nameValues);
    var result = [];
    var combinations = [];
    var comb = GameProtocolCommonParser.ParseIfExist(nameValues, GameProtocolDictionary.ClassicPaytable.combinations);
    if (!_string.IsNullOrEmpty(comb)) {
        var combData = comb.split(",");
        for (var combDataIdx = 0; combDataIdx < combData.length; combDataIdx++) combinations.push(_number.otoi(combData[combDataIdx]))
    }
    for (var i =
            0; true; i++) {
        if (nameValues[GameProtocolDictionary.winLines(i)] == undefined) break;
        var buf = nameValues[GameProtocolDictionary.winLines(i)];
        if (_string.IsNullOrEmpty(buf)) continue;
        var params = buf.split("~");
        var winLine = new VsWinLine;
        var winPositions = [];
        if (params.length >= 2) {
            winLine.LineNumber = _number.otoi(params.shift());
            winLine.WinAmount = _number.otod(params.shift())
        }
        for (var j = 0; j < params.length; ++j) winPositions[j] = _number.otoi(params[j]);
        winLine.WinPositions = winPositions;
        if (combinations.length > 0 && i <= combinations.length -
            1) winLine.Combination = combinations[i];
        result[i] = winLine
    }
    return result
};
VSProtocolParser.ParseWinGroups = function(nameValues) {
    var result = [];
    var winGroupsData = GameProtocolCommonParser.ParseIfExist(nameValues, GameProtocolDictionary.winWayGroups);
    if (!_string.IsNullOrEmpty(winGroupsData)) {
        var winGroupsSplit = winGroupsData.split(";");
        for (var i = 0; i < winGroupsSplit.length; i++) {
            var groupData = winGroupsSplit[i].split("~");
            var wLine = new VsWinLine;
            wLine.isWinWaysGroup = true;
            wLine.symbolId = _number.otoi(groupData[0]);
            wLine.WinAmount = _number.otod(groupData[1]);
            wLine.waysCount = _number.otoi(groupData[2]);
            wLine.waysLength = _number.otoi(groupData[3]);
            wLine.payingDirection = groupData[5];
            var winPositionsData = groupData[4].split(",");
            var winPositions = [];
            for (var j = 0; j < winPositionsData.length; j++) winPositions.push(_number.otoi(winPositionsData[j]));
            wLine.WinPositions = winPositions;
            result.push(wLine)
        }
    }
    return result
};
VSProtocolParser.ParsePaytable = function(nameValues, key) {
    var buf = nameValues[key];
    if (buf == undefined) return null;
    var paytable = [];
    var symbolValues = buf.split(";");
    for (var i = 0; i < symbolValues.length; ++i) {
        var symbolPaytable = [];
        var symbolValue = symbolValues[i].split(",");
        for (var j = symbolValue.length - 1; j >= 0; --j) symbolPaytable.push(_number.otoi(symbolValue[j]));
        paytable[i] = symbolPaytable
    }
    VSProtocolParser.ParseClassicPaytable(nameValues, paytable);
    return paytable
};
VSProtocolParser.ParseClassicPaytable = function(dict, vsPaytable) {
    var key = "c_paytable";
    if (dict[key] == undefined) return;
    var paytable = dict[key].split(";");
    for (var i = 0; i < paytable.length; ++i) {
        var split = paytable[i].split("~");
        if (split.length > 3) {
            var id = _number.otoi(split[0]);
            var payout = _array.ConvertAll(split[3].split(","), _number.otoi);
            payout.reverse();
            while (vsPaytable.length <= id) vsPaytable.push([]);
            vsPaytable[id] = payout
        }
    }
};
VSProtocolParser.ParseScatters = function(nameValues) {
    var buf = nameValues[GameProtocolDictionary.scatters];
    if (buf == undefined) return null;
    var scatters = [];
    var scattersValues = buf.split(";");
    for (var i = 0; i < scattersValues.length; ++i) {
        var scatterValues = scattersValues[i].split("~");
        if (scatterValues.length != 4) return null;
        var symbolNumber = _number.otoi(scatterValues[0]);
        var j;
        var tmpValues = scatterValues[1].split(",");
        var pays = [];
        for (j = tmpValues.length - 1; j >= 0; --j) pays.push(_number.otoi(tmpValues[j]));
        tmpValues =
            scatterValues[2].split(",");
        var freespins = [];
        for (j = tmpValues.length - 1; j >= 0; --j) freespins.push(_number.otoi(tmpValues[j]));
        tmpValues = scatterValues[3].split(",");
        var multipliers = [];
        for (j = tmpValues.length - 1; j >= 0; --j) multipliers.push(_number.otoi(tmpValues[j]));
        scatters[i] = new VsScatterData(symbolNumber, pays, freespins, multipliers)
    }
    return scatters
};
VSProtocolParser.ParseWilds = function(nameValues, key) {
    var buf = nameValues[key];
    if (buf == undefined) return null;
    var wilds = [];
    var wildsValues = buf.split(";");
    for (var i = 0; i < wildsValues.length; i++) {
        var wildValues = wildsValues[i].split("~");
        if (wildValues.length < 2) return null;
        var wildSymbol = _number.otoi(wildValues[0]);
        var pays = null;
        var multipliers = null;
        var valuesSplit = wildValues[1].split(",");
        var j;
        if (wildValues.length == 3) {
            pays = [];
            for (j = valuesSplit.length - 1; j >= 0; j--) {
                var pay = _number.otoi(valuesSplit[j]);
                pays.push(pay)
            }
            valuesSplit =
                wildValues[2].split(",")
        }
        multipliers = [];
        for (j = valuesSplit.length - 1; j >= 0; j--) {
            var multiplier = _number.otoi(valuesSplit[j]);
            multipliers.push(multiplier)
        }
        var wild = new VsWildData(wildSymbol, pays, multipliers);
        wilds.push(wild)
    }
    if (wilds.length == 0) return null;
    return wilds
};
VSProtocolParser.ParseBonuses = function(nameValues) {
    var bonuses = [];
    var buf = nameValues[GameProtocolDictionary.bonuses];
    if (buf == undefined) return null;
    var bonusesValues = buf.split(";");
    for (var i = 0; i < bonusesValues.length; ++i) bonuses[i] = _number.otoi(bonusesValues[i]);
    return bonuses
};
VSProtocolParser.ParseReelsSymbols = function(nameValues) {
    if (nameValues[GameProtocolDictionary.reel(0)] == undefined) return null;
    var reels = [];
    for (var i = 0; true; i++) {
        var buf = nameValues[GameProtocolDictionary.reel(i)];
        if (buf == undefined) break;
        var values = buf.split(",");
        var reelSymbols = [];
        for (var j = 0; j < values.length; ++j) reelSymbols[j] = _number.otoi(values[j]);
        reels[i] = reelSymbols
    }
    return reels
};
VSProtocolParser.ParseNextReelsSymbols = function(nameValues) {
    if (nameValues[GameProtocolDictionary.n_reel(0)] == undefined) return null;
    var nextReels = [];
    for (var i = 0; true; i++) {
        var buf = nameValues[GameProtocolDictionary.n_reel(i)];
        if (buf == undefined) break;
        buf = buf.split("~")[1];
        var values = buf.split(",");
        var reelSymbols = [];
        for (var j = 0; j < values.length; ++j) reelSymbols[j] = _number.otoi(values[j]);
        nextReels[i] = reelSymbols
    }
    return nextReels
};
VSProtocolParser.ParseReelSets = function(nameValues) {
    var result = null;
    var numberOfSets = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.numberOfReelSets);
    if (numberOfSets > 0) {
        result = [];
        for (var reelSetsIndex = 0; reelSetsIndex < numberOfSets; reelSetsIndex++)
            for (var reelSetsIndex = 0; reelSetsIndex < numberOfSets; reelSetsIndex++) {
                result.push([]);
                var reels = VSProtocolParser.GetReelSet(nameValues, reelSetsIndex);
                for (var reelIndex = 0; reelIndex < reels.length; reelIndex++) {
                    result[reelSetsIndex].push([]);
                    var symbolIds = reels[reelIndex].split(",");
                    for (var symbolIdIndex = 0; symbolIdIndex < symbolIds.length; symbolIdIndex++) result[reelSetsIndex][reelIndex].push(_number.otoi(symbolIds[symbolIdIndex]))
                }
            }
    }
    return result
};
VSProtocolParser.ParseVsJackpotData = function(dict) {
    var data = new VsJackpotData;
    data.IsActive = "1" == GameProtocolCommonParser.ParseIfExist(dict, GameProtocolDictionary.Jakpot.jackpotActive);
    data.JackpotID = GameProtocolCommonParser.ParseUInt(dict, GameProtocolDictionary.Jakpot.jackpotWinID);
    data.JackpotOrder = GameProtocolCommonParser.ParseUInt(dict, GameProtocolDictionary.Jakpot.jackpotWinOrder);
    data.WinJackpotAmount = GameProtocolCommonParser.ParseDouble(dict, GameProtocolDictionary.Jakpot.jackpotWinAmount);
    var val = GameProtocolCommonParser.ParseIfExist(dict, GameProtocolDictionary.Jakpot.jackpotType);
    if (GameProtocolDictionary.Jakpot.Type.random == val) data.jackpotType = VsJackpotData.Type.Random;
    else if (GameProtocolDictionary.Jakpot.Type.twoSteps == val) data.jackpotType = VsJackpotData.Type.TwoSteps;
    val = GameProtocolCommonParser.ParseIfExist(dict, GameProtocolDictionary.Jakpot.jackpotStatus);
    if (GameProtocolDictionary.Jakpot.Status.obtained == val) {
        data.jackpotStatus = VsJackpotData.Status.Obtained;
        if (GameProtocolParser.ParseNextGameActions(dict).indexOf(NextGameAction.PlayJackpot) >
            -1) data.IsActive = true
    } else if (GameProtocolDictionary.Jakpot.Status.used == val) data.jackpotStatus = VsJackpotData.Status.Used;
    val = GameProtocolCommonParser.ParseIfExist(dict, GameProtocolDictionary.Jakpot.jackpotShutdown);
    data.jackpotShutdown = "1" == val;
    val = GameProtocolCommonParser.ParseIfExist(dict, GameProtocolDictionary.Jakpot.jackpotMiniGameEnabled);
    data.jackpotMiniGameEnabled = "1" == val;
    val = GameProtocolCommonParser.ParseIfExist(dict, GameProtocolDictionary.Jakpot.jackpotNotWon);
    data.jackpotNotWon = "1" == val;
    if (dict[GameProtocolDictionary.Jakpot.jackpotWonInstances] != undefined) {
        var list = JSON5.parse(dict[GameProtocolDictionary.Jakpot.jackpotWonInstances]);
        if (list != null && list.length > 0) {
            data.wonJackpotInstances = [];
            for (var i = 0; i < list.length; ++i) data.wonJackpotInstances.push(VSProtocolParser.ParseVsJackpotWonInstance(list[i]))
        }
    }
    return data
};
VSProtocolParser.ParseVsJackpotWonInstance = function(obj) {
    var ret = new VsJackpotData.WonInstance;
    if (obj[GameProtocolDictionary.Jakpot.WonInstance.type] != undefined) {
        var val = obj[GameProtocolDictionary.Jakpot.WonInstance.type];
        if (GameProtocolDictionary.Jakpot.WonInstance.Type.progressive == val) ret.type = VsJackpotData.WonInstance.Type.Progressive;
        else if (GameProtocolDictionary.Jakpot.WonInstance.Type.nonProgressive == val) ret.type = VsJackpotData.WonInstance.Type.NonProgressive
    }
    if (obj[GameProtocolDictionary.Jakpot.WonInstance.jackpotId] !=
        undefined) ret.jackpotId = obj[GameProtocolDictionary.Jakpot.WonInstance.jackpotId];
    if (obj[GameProtocolDictionary.Jakpot.WonInstance.jackpotInstance] != undefined) ret.jackpotInstance = obj[GameProtocolDictionary.Jakpot.WonInstance.jackpotInstance];
    if (obj[GameProtocolDictionary.Jakpot.WonInstance.amount] != undefined) ret.amount = _number.otod(obj[GameProtocolDictionary.Jakpot.WonInstance.amount]);
    if (obj[GameProtocolDictionary.Jakpot.WonInstance.multiplier] != undefined) ret.multiplier = obj[GameProtocolDictionary.Jakpot.WonInstance.multiplier];
    if (obj[GameProtocolDictionary.Jakpot.WonInstance.autoDrawing] != undefined) ret.autoDrawing = "1" == obj[GameProtocolDictionary.Jakpot.WonInstance.autoDrawing];
    return ret
};
VSProtocolParser.firstFRBparse = true;
VSProtocolParser.ParseVsFreeRoundEvents = function(nameValues) {
    var isFromInit = VSProtocolParser.firstFRBparse;
    if (nameValues[GameProtocolDictionary.FreeRound.Events] == undefined) return null;
    var evts = [];
    var items = nameValues[GameProtocolDictionary.FreeRound.Events].split(";");
    for (var i = 0; i < items.length; ++i) {
        var item = items[i].split("~");
        if (item.length > 1) {
            var type = item[0];
            var args = item[1].split(",");
            if (XT.GetBool(Vars.DontShowFRBEndWindowOnInit) && isFromInit && type == GameProtocolDictionary.FreeRound.Event.Finish) continue;
            if (type == GameProtocolDictionary.FreeRound.Event.Start || type == GameProtocolDictionary.FreeRound.Event.Finish || type == GameProtocolDictionary.FreeRound.Event.Error) {
                var e = new VsFreeRoundEvent;
                e.Bet = _number.otod(args[0]);
                e.Lines = _number.otoi(args[1]);
                switch (type) {
                    case GameProtocolDictionary.FreeRound.Event.Start:
                        e.Type = VsFreeRoundEvent.EventType.Start;
                        e.RoundsLeft = _number.otoi(args[2]);
                        e.TurboSpinMode = _number.otoi(args[3]) == 1 ? true : false;
                        e.PlayLaterAvailable = args.length > 4 && _number.otoi(args[4]) == 1 ? true :
                            false;
                        e.EndDateTimestamp = args.length > 5 ? _number.otod(args[5]) : -1;
                        e.IsFreeRoundPending = args.length > 6 && _number.otoi(args[6]) == 0 ? false : true;
                        e.PromoLocalizedName = args.length > 7 && args[7].length > 0 ? decodeURIComponent(atob(args[7]).split("").map(function(c) {
                            return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2)
                        }).join("")) : "";
                        e.PromoType = args.length > 8 && args[8].length > 0 ? args[8] : "";
                        break;
                    case GameProtocolDictionary.FreeRound.Event.Finish:
                        e.Type = VsFreeRoundEvent.EventType.Finish;
                        break;
                    case GameProtocolDictionary.FreeRound.Event.Error:
                        e.Type =
                            VsFreeRoundEvent.EventType.Error;
                        break
                }
                evts.push(e)
            }
        }
    }
    return evts.length > 0 ? evts : null
};
VSProtocolParser.ParseVsFreeRound = function(nameValues) {
    var isFromInit = VSProtocolParser.firstFRBparse;
    VSProtocolParser.firstFRBparse = false;
    var isFreeRoundEnd = false;
    if (XT.GetBool(Vars.DontShowFRBEndWindowOnInit)) {
        var evts = VSProtocolParser.ParseVsFreeRoundEvents(nameValues);
        if (evts != null && evts.length > 0) {
            var curEvt = evts[0];
            if (curEvt.Type == VsFreeRoundEvent.EventType.Finish && evts.length == 1) isFreeRoundEnd = true
        }
    }
    if (nameValues[GameProtocolDictionary.FreeRound.RoundsLeft] != undefined && nameValues[GameProtocolDictionary.FreeRound.TotalWin] !=
        undefined && !isFreeRoundEnd) {
        var res = new VsFreeRound;
        res.RoundsLeft = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.FreeRound.RoundsLeft);
        res.TotalWin = GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.FreeRound.TotalWin);
        if (isFromInit && XT.GetBool(Vars.DontShowFRBEndWindowOnInit)) res.TotalWin = 0;
        if (nameValues[GameProtocolDictionary.FreeRound.RoundType] != undefined) {
            var type = nameValues[GameProtocolDictionary.FreeRound.RoundType];
            switch (type) {
                case "N":
                    res.Type = VsFreeRound.RoundType.Spins;
                    break;
                case "T":
                    res.Type = VsFreeRound.RoundType.Timed;
                    break;
                case "F":
                    res.Type = VsFreeRound.RoundType.BonusBoost;
                    break;
                default:
                    break
            }
        }
        res.BonusCode = GameProtocolCommonParser.ParseIfExist(nameValues, GameProtocolDictionary.FreeRound.BonusCode);
        return res
    }
    return null
};
VSProtocolParser.ParseVsWildRandomLineMultiplier = function(dict) {
    var key = GameProtocolDictionary.WildRandomLineMultiplier.configuration;
    var cfgs = null;
    if (dict[key] != undefined) {
        cfgs = [];
        var pairs = dict[key].split(";");
        for (var i = 0; i < pairs.length; i++) {
            var wildConfig = new VsWildRandomLineMultiplier.Configuration;
            var values = pairs[i].split("~");
            wildConfig.wildSymbolId = _number.otoi(values[0]);
            wildConfig.multiplierSets = [];
            for (var j = 1; j < values.length; j += 2) {
                var set = new MultiplierSet;
                set.setIndex = _number.otoi(values[j]);
                set.multipliers = [];
                var multipliers = values[j + 1].split(",");
                for (var mIndex = 0; mIndex < multipliers.length; mIndex++) set.multipliers.push(_number.otoi(multipliers[mIndex]));
                wildConfig.multiplierSets.push(set)
            }
            cfgs.push(wildConfig)
        }
    }
    return cfgs
};
VSProtocolParser.ParseWRLMResponse = function(dict) {
    var key = GameProtocolDictionary.WildRandomLineMultiplier.response;
    var wrlmResponse = null;
    if (dict[key] != undefined) {
        wrlmResponse = [];
        var entries = dict[key].split(";");
        for (var i = 0; i < entries.length; i++) {
            var values = entries[i].split("~");
            var entry = new VsWildRandomLineMultiplier.SpinResponse;
            entry.wildSymbolId = _number.otoi(values[0]);
            entry.multiplier = _number.otoi(values[1]);
            if (values.length > 2) {
                entry.positions = [];
                var positions = values[2].split(",");
                for (var j = 0; j <
                    positions.length; j++) entry.positions.push(_number.otoi(positions[j]))
            }
            wrlmResponse.push(entry)
        }
    }
    return wrlmResponse
};
VSProtocolParser.ParseWRLMCurrentSets = function(dict) {
    var key = GameProtocolDictionary.WildRandomLineMultiplier.currentSet;
    var wrlmCurrentSets = null;
    if (dict[key] != undefined) {
        wrlmCurrentSets = [];
        var sets = dict[key].split(";");
        for (var i = 0; i < sets.length; i++) {
            var currentSet = new VsWildRandomLineMultiplier.CurrentSet;
            var values = sets[i].split("~");
            currentSet.wildSymbolId = _number.otoi(values[0]);
            currentSet.currentSetIndex = _number.otoi(values[1]);
            wrlmCurrentSets.push(currentSet)
        }
    }
    return wrlmCurrentSets
};
VSProtocolParser.ParseVsRandomAwardsSymbols = function(dict, key) {
    if (dict[key] == undefined) return null;
    var pairs = dict[key].split(";");
    var awards = [];
    for (var i = 0; i < pairs.length; ++i) {
        var pair = pairs[i].split("~");
        var award = new VsRandomAward;
        switch (pair[0]) {
            case GameProtocolDictionary.RandomAward.Type.multiplier:
                award.Type = VsRandomAward.AwardType.Multiplier;
                if (pair.length > 1) award.Value = _number.otod(pair[1]);
                break;
            case GameProtocolDictionary.RandomAward.Type.trigger:
                award.Type = VsRandomAward.AwardType.Trigger;
                break;
            case GameProtocolDictionary.RandomAward.Type.featureTrigger:
                award.Type = VsRandomAward.AwardType.FeatureTrigger;
                if (pair.length > 1) award.FeatureID = GameProtocolBonusGameParser.ParseWinMask(pair[1]);
                break
        }
        awards.push(award)
    }
    return awards
};
VSProtocolParser.ParseVsRandomAwardsConfig = function(dict) {
    var result = null;
    var normal = VSProtocolParser.ParseVsRandomAwardsSymbols(dict, GameProtocolDictionary.RandomAward.Configuration.normal);
    var freeSpins = VSProtocolParser.ParseVsRandomAwardsSymbols(dict, GameProtocolDictionary.RandomAward.Configuration.freeSpins);
    if (normal != null || freeSpins != null) {
        result = new VsRandomAwardConfig;
        result.awardSymbolsNormal = normal;
        result.awardSymbolsFreeSpins = freeSpins
    }
    if (result == null) {
        var reelsCount = GameProtocolCommonParser.ParseInt(dict,
            GameProtocolDictionary.RandomAward.Configuration.reelConfigCount);
        if (reelsCount > 0) {
            result = new VsRandomAwardConfig;
            result.awardReels = [];
            result.awardReelsCount = reelsCount;
            for (var i = 0; i < reelsCount; i++) {
                var reelConf = VSProtocolParser.ParseVsRandomAwardsSymbols(dict, GameProtocolDictionary.RandomAward.Configuration.reelConfig + i.toString());
                result.awardReels.push(reelConf)
            }
            result.ProcessPossibleAwards()
        }
    }
    return result
};
VSProtocolParser.ParseRandomAwardsResponse = function(dict) {
    var rar = null;
    var awIdx = GameProtocolCommonParser.ParseNulableInt(dict, GameProtocolDictionary.RandomAward.index);
    if (awIdx == null) awIdx = -1;
    var awPos = GameProtocolCommonParser.ParseNulableInt(dict, GameProtocolDictionary.RandomAward.awardPosition);
    if (awPos == null) awPos = -1;
    var reelIdx = GameProtocolCommonParser.ParseNulableInt(dict, GameProtocolDictionary.RandomAward.Configuration.reelConfig);
    if (reelIdx == null) reelIdx = -1;
    var nextReelIdx = GameProtocolCommonParser.ParseNulableInt(dict,
        GameProtocolDictionary.RandomAward.Configuration.nextReelConfig);
    if (nextReelIdx == null) nextReelIdx = -1;
    if (awIdx != -1 || awPos != -1) {
        rar = new RandomAwardsResponse;
        rar.awardIndex = awIdx;
        rar.awardPositionInReel = awPos;
        rar.currentReelIndex = reelIdx;
        rar.nextReelIndex = nextReelIdx
    }
    return rar
};
VSProtocolParser.ParseFSPurchaseData = function(dict) {
    var fspd = null;
    var fsBought = GameProtocolCommonParser.ParseInt(dict, GameProtocolDictionary.FreeSpinsPurchase.fsBought);
    if (fsBought > 0) {
        fspd = new VsFSPurchaseData;
        fspd.freeSpinsBought = fsBought
    }
    return fspd
};
VSProtocolParser.ParseRandomSymbolMultipliers = function(source) {
    var result = null;
    var rsmContent = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.randomSymbolMultiplier);
    if (!_string.IsNullOrEmpty(rsmContent)) {
        result = [];
        var splitRsmContent = rsmContent.split(";");
        for (var rsmIdx = 0; rsmIdx < splitRsmContent.length; rsmIdx++) {
            var rsm = new VsRandomSymbolMultiplier;
            var split = splitRsmContent[rsmIdx].split("~");
            rsm.symbolId = _number.otoi(split[0]);
            rsm.multiplierValue = _number.otoi(split[2]);
            var positions =
                split[1].split(",");
            for (var i = 0; i < positions.length; i++) rsm.symbolPositions.push(_number.otoi(positions[i]));
            result.push(rsm)
        }
    }
    return result
};
VSProtocolParser.ParsePossibleRandomSymbolMultipliers = function(source) {
    var result = null;
    var rsmContent = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.possibleRandomSymbolMultipliers);
    if (!_string.IsNullOrEmpty(rsmContent)) {
        result = [];
        var splitSet = rsmContent.split(";");
        for (var setIdx = 0; setIdx < splitSet.length; setIdx++) {
            var prm = new VsPossibleRandomSymbolMultipliers;
            var split = splitSet[setIdx].split("~");
            prm.symbolId = _number.otoi(split[0]);
            var positions = split[1].split(",");
            for (var i =
                    0; i < positions.length; i++) prm.symbolMultipliers.push(_number.otoi(positions[i]));
            result.push(prm)
        }
    }
    return result
};
VSProtocolParser.ParseFreeSpinsChainedData = function(source) {
    var fscd = new VsFreeSpinsChainData;
    fscd.FSCSpins = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.FreeSpinsChain.spins);
    fscd.FSCMultipliers = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.FreeSpinsChain.multipliers);
    fscd.FSCSpinsTotal = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.FreeSpinsChain.spinsTotal);
    fscd.FSCMultipliersTotal = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.FreeSpinsChain.multipliersTotal);
    fscd.FSCWinsTotal = GameProtocolCommonParser.ParseDoubleList(source, GameProtocolDictionary.FreeSpinsChain.winsTotal);
    fscd.FSCMultipliedWinsTotal = GameProtocolCommonParser.ParseDoubleList(source, GameProtocolDictionary.FreeSpinsChain.multipliedWinTotal);
    fscd.FSCSessionsWonThisSpin = GameProtocolCommonParser.ParseInt(source, GameProtocolDictionary.FreeSpinsChain.sessionsWonThisSpin);
    fscd.FSCSessionsWonSymbolsCount = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.FreeSpinsChain.sessionsWonSymbolsCount);
    if (fscd.HasChainInformation()) return fscd;
    return null
};
VSProtocolParser.ParseOpeningSymbolsData = function(source) {
    var osd = new VsOpeningSymbolsData;
    osd.Positions = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.OpeningSymbols.positions);
    osd.OSFreeSpinsWon = GameProtocolCommonParser.ParseNulableInt(source, GameProtocolDictionary.OpeningSymbols.freeSpinsWon);
    osd.OSMultiplierWon = GameProtocolCommonParser.ParseNulableInt(source, GameProtocolDictionary.OpeningSymbols.multiplierWon);
    if (osd.Positions != null || osd.OSFreeSpinsWon != null || osd.OSMultiplierWon !=
        null) return osd;
    return null
};
VSProtocolParser.GetWildRandomMultipliers = function(source) {
    var result = null;
    var wrValues = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.wildRandomMultipliers);
    if (!_string.IsNullOrEmpty(wrValues)) result = _string.Trim(wrValues).split(";");
    return result
};
VSProtocolParser.GetWildRandomMultipliersMasks = function(source) {
    var result = null;
    var wrMask = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.wildRandomMultiplierMask);
    if (!_string.IsNullOrEmpty(wrMask)) result = _string.Trim(wrMask).split("~");
    return result
};
VSProtocolParser.ParseWildRandomMultipliers = function(source) {
    var result = null;
    var wildRandomMultipliers = VSProtocolParser.GetWildRandomMultipliers(source);
    if (wildRandomMultipliers != null) {
        result = [];
        for (var i = 0; i < wildRandomMultipliers.length; i++) {
            var _data = wildRandomMultipliers[i].split("~");
            var _masks = VSProtocolParser.GetWildRandomMultipliersMasks(source);
            var _wildRandomMultiplier = new VsWildRandomMultiplier;
            for (var j = 0; j < _masks.length; j++) switch (_masks[j]) {
                case "s":
                    _wildRandomMultiplier.SymbolIndex =
                        _number.otoi(_data[j]);
                    break;
                case "p":
                    _wildRandomMultiplier.Position = _number.otoi(_data[j]);
                    break;
                case "m":
                    _wildRandomMultiplier.Multiplier = _number.otoi(_data[j]);
                    break;
                default:
                    break
            }
            result.push(_wildRandomMultiplier)
        }
    }
    return result
};
VSProtocolParser.ParsePatternedMysterySymbols = function(source) {
    var result = null;
    var pms = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.patternedMysterySymbols);
    if (!_string.IsNullOrEmpty(pms)) {
        var buf = pms.split(",");
        if (buf.length > 0) {
            result = new Array;
            for (var i = 0; i < buf.length; i++) result.push(_number.otoi(buf[i]))
        }
    }
    return result
};
VSProtocolParser.ParseJPVisualization = function(source) {
    var result = null;
    var jpMask = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.JackpotVisualization.JPVMask);
    var jpValues = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.JackpotVisualization.JPVValues);
    if (!_string.IsNullOrEmpty(jpMask)) {
        var bufM = jpMask.split("~");
        var bufV = jpValues.split("~");
        if (bufM.length > 0) {
            result = new VsJackpotVisualization;
            for (var i = 0; i < bufM.length; i++)
                if (bufM[i] == GameProtocolDictionary.JackpotVisualization.JPVType) {
                    if (bufV[i] ==
                        GameProtocolDictionary.JackpotVisualization.Type.badges) result.jpvType = VsJackpotVisualization.JpType.badges
                } else if (bufM[i] == GameProtocolDictionary.JackpotVisualization.JPVPositions) {
                var pos = bufV[i].split(",");
                if (pos.length > 0) {
                    result.positions = [];
                    for (var j = 0; j < pos.length; j++) result.positions.push(_number.otoi(pos[j]))
                }
            }
        }
    }
    return result
};
VSProtocolParser.ParseGoldSymbol = function(source) {
    var result = null;
    var gs = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.GoldSymbol.goldSymbols);
    var resultGSR = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.GoldSymbol.goldSymbolReels);
    var gsa = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.GoldSymbol.goldSymbolAwards);
    if (resultGSR != null || !_string.IsNullOrEmpty(gs)) {
        result = new VsGoldSymbol;
        result.reels = resultGSR
    }
    if (!_string.IsNullOrEmpty(gs)) {
        var bufGS =
            gs.split(";");
        if (bufGS.length > 0) {
            result.symbols = [];
            for (var i = 0; i < bufGS.length; i++) {
                var gsSplit = bufGS[i].split("~");
                result.symbols.push([]);
                result.symbols[i].push(_number.otoi(gsSplit[0]));
                result.symbols[i].push(_number.otoi(gsSplit[1]))
            }
        }
    }
    if (!_string.IsNullOrEmpty(gsa)) {
        var bufGSA = gsa.split(";");
        if (bufGSA.length > 0) {
            result.awards = [];
            for (var i = 0; i < bufGSA.length; i++) {
                var gsaSplit = bufGSA[i].split("~");
                result.awards.push([]);
                result.awards[i].push(_number.otoi(gsaSplit[0]));
                result.awards[i].push(_number.otoi(gsaSplit[1]))
            }
        }
    }
    return result
};
VSProtocolParser.ParseSymbolReplacementData = function(source) {
    var result = null;
    var srd = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.symbolReplacementData);
    if (!_string.IsNullOrEmpty(srd)) {
        result = [];
        var srdEntries = srd.split(";");
        for (var i = 0; i < srdEntries.length; i++) {
            var symbolData = new VsSymbolReplacement;
            var srdEntry = srdEntries[i].split("~");
            symbolData.FromSymbolId = _number.otoi(srdEntry[0]);
            symbolData.ToSymbolId = _number.otoi(srdEntry[1]);
            symbolData.ReplacementPositions = [];
            if (srdEntry.length >
                2 && !_string.IsNullOrEmpty(srdEntry[2])) {
                var replacementPosData = srdEntry[2].split(",");
                for (var j = 0; j < replacementPosData.length; j++) symbolData.ReplacementPositions.push(_number.otoi(replacementPosData[j]))
            }
            if (srdEntry.length > 3 && !_string.IsNullOrEmpty(srdEntry[3])) symbolData.intermediateSymbolIDs = _array.ConvertAll(srdEntry[3].split(","), _number.otoi);
            result.push(symbolData)
        }
    }
    return result
};
VSProtocolParser.ParseNudgedSymbolsData = function(source) {
    var result = null;
    var ns = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.nudgedSymbols);
    if (!_string.IsNullOrEmpty(ns)) {
        ns = _string.Trim(ns);
        var bufNS = ns.split(";");
        if (bufNS.length > 0) {
            result = [];
            var nudgeIndex = 0;
            for (nudgeIndex = 0; nudgeIndex < bufNS.length; nudgeIndex++) {
                var nudgePart = bufNS[nudgeIndex];
                var i = 0;
                var reelID = _number.otoi(nudgePart.split("~")[0]);
                var startingSymbolsIDs = [];
                var bufSSIDs = nudgePart.split("~")[1].split(",");
                for (i = 0; i < bufSSIDs.length; i++) startingSymbolsIDs.push(_number.otoi(bufSSIDs[i]));
                var nudgedSymbolsIDs = [];
                var bufNSIDs = nudgePart.split("~")[2].split(",");
                for (i = 0; i < bufNSIDs.length; i++) nudgedSymbolsIDs.push(_number.otoi(bufNSIDs[i]));
                var nudgedStopPosition = _number.otoi(nudgePart.split("~")[3]);
                var nudgeDirection = _number.otoi(nudgePart.split("~")[4]);
                var nudge = new VsNudgedSymbolsData(reelID, startingSymbolsIDs, nudgedSymbolsIDs, nudgedStopPosition, nudgeDirection);
                result.push(nudge)
            }
        }
    }
    return result
};
VSProtocolParser.ParseSpinOneReelData = function(source) {
    var result = null;
    var sor_ra = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.ReelsAllowedToRotateSeparately);
    var sor_coefs = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.ReelsCoeficients);
    var ReelsToBeSpun = [];
    var ReelsCoeficients = [];
    if (!_string.IsNullOrEmpty(sor_ra)) {
        sor_ra = _string.Trim(sor_ra);
        if (sor_ra.length > 0) {
            var temp = sor_ra.split(",");
            for (var i = 0; i < temp.length; i++) ReelsToBeSpun.push(_number.otod(temp[i]))
        }
    }
    if (!_string.IsNullOrEmpty(sor_coefs)) {
        sor_coefs =
            _string.Trim(sor_coefs);
        if (sor_coefs.length > 0) {
            var temp = sor_coefs.split(",");
            for (var i = 0; i < temp.length; i++) ReelsCoeficients.push(_number.otod(temp[i]))
        }
    }
    result = new VSSpinOneReelSymbolsData(0, ReelsToBeSpun, ReelsCoeficients);
    return result
};
VSProtocolParser.ParseTumblingData = function(source) {
    var result = null;
    var tmbData = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.Tumbling);
    if (!_string.IsNullOrEmpty(tmbData)) {
        result = new VsTumblingData;
        var tmbSymbols = tmbData.split("~");
        for (var i = 0; i < tmbSymbols.length; i++) {
            var symbolSplit = tmbSymbols[i].split(",");
            var symbol = new VsTumblingData.TumblingSymbol;
            symbol.position = _number.otoi(symbolSplit[0]);
            symbol.id = _number.otoi(symbolSplit[1]);
            result.tumblingSymbols.push(symbol)
        }
    }
    return result
};
goog.provide("UHT.ResourceHelpers");
var ResourceEvents = {
    evtRequestResources: "evtRequestResources",
    evtResourcesCompleted: "evtResourcesCompleted"
};

function AssetBundle() {
    this.mainAsset = null
}

function ResourceRequestInfo() {
    this.symbol = "";
    this.brand = "";
    this.locale = "";
    this.files = []
}

function BundlePack() {
    this.assetBundles = []
}

function RequestPack() {
    this.isDone = false;
    this.downloaders = [];
    this.progress = 0;
    this.componentName = ""
}
RequestPack.prototype.Update = function() {
    console.log("RequestPack::Update", this);
    this.isDone = true;
    this.progress = 0;
    for (var i = 0; i < this.downloaders.length; ++i)
        if (!this.downloaders[i].Done) {
            this.isDone = false;
            this.progress += this.downloaders[i].progress
        }
};
RequestPack.prototype.GetData = function() {
    var rv = new BundlePack;
    for (var i = 0; i < this.downloaders.length; ++i)
        if (_string.IsNullOrEmpty(this.downloaders[i].error)) {
            var ab = new AssetBundle;
            ab.mainAsset = jsonParse(this.downloaders[i].Data);
            rv.assetBundles.push(ab)
        }
    this.downloaders = [];
    return rv
};
goog.provide("UHT.ServerOptions");
var LogLevel = {
    None_Info: 0,
    Warn: 1,
    Debug: 2,
    Error: 3
};
var ServerOptions = {
    serverUrl: "https://studio.game-service.biz",
    resourcesUrl: "https://studio.game-service.biz",
    configUri: "/gs2c/configuration.do",
    loginUri: "/gs2c/login.do",
    logoutUri: "/gs2c/logout.do",
    sessionTimeout: "-1",
    menuUri: "/gs2c/menu.do",
    versionUri: "/gs2c/res/versions.info",
    resourceseUri: "/gs2c/res",
    gameServiceUri: "/gs2c/gameService",
    settingsUri: "/gs2c/saveSettings.do",
    reloadBalanceUri: "/gs2c/reloadBalance.do",
    reloadJackpotUri: "/gs2c/jackpot/reload.do",
    accountType: "R",
    language: "en",
    currency: "USD",
    realCurrency: "USD",
    resourceVersion: "200",
    styleName: "style",
    casinoName: "casino",
    isExternal: true,
    isDemoMode: false,
    logLevel: LogLevel.None_Info,
    gameSymbol: URLGameSymbol,
    userAgent: "Mozilla/5.0 (Windows NT 6.1, WOW64, rv:34.0) Gecko/20100101 Firefox/34.0",
    isOnline: false,
    isReplay: false,
    isSecure: true,
    packagesUri: "packages/",
    gameUrl: "",
    configs: null,
    mgckey: "",
    gameHistory: null,
    gameVerificationUrl: null,
    jurisdiction: null,
    jurisdictionRequirements: null,
    brandRequirements: null,
    promotionurl: null,
    rcSettings: null,
    amountType: null,
    TournamentURLs: {
        tournaments: "/gs2c/promo/active/",
        details: "/gs2c/promo/tournament/details/",
        leaderboards: "/gs2c/promo/tournament/v3/leaderboard/",
        raceDetails: "/gs2c/promo/race/details/",
        racePrizes: "/gs2c/promo/race/prizes/",
        raceOptIn: "/gs2c/promo/race/player/choice/OPTIN/",
        raceOptOut: "/gs2c/promo/race/player/choice/OPTOUT/",
        tournamentOptIn: "/gs2c/promo/tournament/player/choice/OPTIN/",
        tournamentOptOut: "/gs2c/promo/tournament/player/choice/OPTOUT/",
        tournamentScores: "/gs2c/promo/tournament/scores/"
    },
    SwedishRegulation: {
        notificationUrl: ""
    }
};
goog.provide("UHT.GameConnection");
goog.require("UHT.EventManager");
goog.require("UHT.ServerOptions");
goog.require("UHT.Tracking");
var RequestState = {
    Idle: 0,
    Init: 1,
    Spin: 2,
    Collect: 3,
    InitBonus: 4,
    BonusRespin: 5,
    PickBonus: 6,
    CollectBonus: 7,
    Gamble: 8,
    GambleCollect: 9,
    JackpotCollect: 10,
    PickFSOption: 11,
    InitFSBG: 12,
    PickFSBG: 13,
    GetMysteryScatter: 14,
    Block: 15,
    PlayJackpot: 16
};

function GameConnection() {
    this.index = 0;
    this.counter = 0;
    this.repeat = 0;
    this.repeatLimit = 3;
    this.symbol = "vs20cm";
    this.responseReceived = false;
    this.response = "";
    this.srvResponse = null;
    this.retryDelay = 15;
    this.retryTimer = 0;
    this.retryRequest = false;
    this.storedRequest = null;
    this.queuedRequest = null;
    this.queuedState = RequestState.Block;
    this.initData = null;
    this.requestState = RequestState.Idle;
    this.isRegulatoryError = false;
    this.mustStopSpin = false;
    this.mustPostGameRoundEndedOnCollect = false;
    this.reqExtraParams = null;
    GameConnection.I =
        this
}
GameConnection.I = null;
GameConnection.prototype.SlotHeight = -1;
GameConnection.noMoneyStopsSpin = false;
GameConnection.prototype.Init = function(gameSymbol) {
    this.index = 1;
    this.counter = 1;
    this.repeat = 0;
    this.symbol = gameSymbol;
    this.responseReceived = false;
    EventManager.AddHandler(GameEvents.evtInitRequest + this.symbol, this.SendInitRequest, this);
    EventManager.AddHandler(GameEvents.evtSpinRequest + this.symbol, this.SendSpinRequest, this);
    EventManager.AddHandler(GameEvents.evtFreespinsFinished + this.symbol, this.SendFSCollectRequest, this);
    EventManager.AddHandler(GameEvents.evtGambleRequest + this.symbol, this.SendGambleV2Request,
        this);
    EventManager.AddHandler(GameEvents.evtGambleClose + this.symbol, this.SendGambleCollectRequest, this);
    EventManager.AddHandler(GameEvents.evtBonusPickRequest + this.symbol, this.SendBonusRequest, this);
    EventManager.AddHandler(GameEvents.evtBonusRespinRequest + this.symbol, this.SendBonusRespinRequest, this);
    EventManager.AddHandler(GameEvents.evtBonusFinishRequest + this.symbol, this.SendBonusCollectRequest, this);
    EventManager.AddHandler(GameEvents.evtFSOptionPickRequest + this.symbol, this.SendFSOptionRequest,
        this);
    EventManager.AddHandler(GameEvents.evtFSBGPickRequest + this.symbol, this.SendFSBGRequest, this);
    EventManager.AddHandler(GameEvents.evtMysteryScatterRequest + this.symbol, this.SendMysteryScatterRequest, this);
    EventManager.AddHandler(GameEvents.evtPlayJackpotRequest + this.symbol, this.SendPlayJackpotRequest, this);
    EventManager.AddHandler(GameEvents.evtUpdateSettingsRequest + this.symbol, this.SaveSettingsRequest, this);
    EventManager.AddHandler(FOXVars.Evt_FOX_TriggerAfterEvent, this.TriggerFOXAfterEvent, this);
    EventManager.AddHandler(StageTransitionVars.Evt_StageTransition_SetWaitInTransition, this.SetWaitInTransition, this);
    if (XT.RegisterAndInitDone) this.OnXTRegisterCallbacks(null);
    else EventManager.AddHandler(GameEvents.evtXTRegisterCallbacks, this.OnXTRegisterCallbacks, this)
};
GameConnection.prototype.OnXTRegisterCallbacks = function(param) {
    XT.RegisterCallbackObject(Vars.ToServer_RequestExtraParams, this.OnRequestExtraParams, this)
};
GameConnection.prototype.OnRequestExtraParams = function(param) {
    var extraParams = param;
    if (extraParams == null || extraParams.dict == null) return;
    var dict = extraParams.dict;
    for (var key in dict) this.AddRequestExtraParameter(key, dict[key])
};
GameConnection.prototype.AddRequestExtraParameter = function(key, value) {
    if (this.reqExtraParams == null) this.reqExtraParams = {};
    if (this.reqExtraParams[key] != undefined) console.log("Overriding request extra parameter " + key);
    this.reqExtraParams[key] = value
};
GameConnection.prototype.AddRequestExtraParams = function(data) {
    if (this.reqExtraParams == null) return;
    for (var key in this.reqExtraParams) data.Fields[key] = this.reqExtraParams[key];
    this.reqExtraParams = null
};
GameConnection.prototype.Update = function() {
    EventManager.TriggerQueued();
    if (this.queuedRequest != null && this.requestState == RequestState.Idle) {
        if (this.CanRequest(this.queuedState)) {
            this.requestState = this.queuedState;
            this.queuedState = RequestState.Block;
            this.SendRequest(this.queuedRequest)
        } else console.warn("Request " + this.queuedState + " skipped");
        this.queuedRequest = null
    }
    if (this.responseReceived) {
        this.responseReceived = false;
        this.HandleResponse(this.response)
    }
    if (this.retryRequest)
        if (this.repeat < this.repeatLimit)
            if (this.retryTimer >
                this.retryDelay) {
                this.retryRequest = false;
                ++this.index;
                ++this.repeat;
                this.storedRequest.Fields[GameProtocolDictionary.counter] = String(this.counter);
                this.storedRequest.Fields[GameProtocolDictionary.repeat] = String(this.repeat);
                EventManager.Trigger(AdapterEvents.evtServerRequest, this.storedRequest);
                RequestManager.AddRequest(this.storedRequest);
                console.warn("Retry #" + this.repeat)
            } else this.retryTimer += Time.deltaTime;
    else {
        this.retryRequest = false;
        EventManager.Trigger(AdapterEvents.evtShowMessage, AdapterMessages.connectionLost)
    }
};
GameConnection.prototype.StoreResponse = function(param, statusCode) {
    if (statusCode == 200) {
        this.response = _string.Trim(param);
        this.responseReceived = true
    } else {
        this.retryTimer = 0;
        this.retryRequest = true
    }
};
GameConnection.prototype.HandleResponse = function(responseStr) {
    this.isRegulatoryError = false;
    this.mustStopSpin = false;
    if (_string.IsNullOrEmpty(responseStr)) {
        console.error("Response is empty!");
        this.requestState = RequestState.Block;
        return
    } else if (responseStr.indexOf("error_type=i") != -1) this.mustStopSpin = true;
    else if (responseStr.indexOf("ext_code=RegulatoryError") != -1 || responseStr.indexOf("ext_code=TemporaryUnavailableError") != -1) {
        this.isRegulatoryError = true;
        window["globalMustStopAutoplay"] = true
    } else if (responseStr.indexOf(GameProtocolDictionary.frozen) !=
        -1 || responseStr.indexOf("error_type=e") != -1) {
        console.error("Account is frozen! " + responseStr);
        this.requestState = RequestState.Block;
        return
    } else if (responseStr.indexOf(GameProtocolDictionary.techbreak) != -1) console.error("We may have techbreak " + responseStr);
    else if (responseStr.indexOf(GameProtocolDictionary.reload) != -1) {
        console.error("Couldn't open game " + responseStr);
        this.requestState = RequestState.Block;
        return
    } else if (responseStr.indexOf(GameProtocolDictionary.pnow) != -1) {
        console.error("Server is busy " +
            responseStr);
        this.retryTimer = 0;
        this.retryRequest = true;
        return
    } else if (responseStr.indexOf(GameProtocolDictionary.noMoney) != -1) console.error("The current bet may be greater than balance " + responseStr);
    else if (responseStr.indexOf(GameProtocolDictionary.undefined) != -1) {
        console.error("Sent wrong request " + responseStr);
        this.requestState = RequestState.Block;
        return
    } else if (responseStr.indexOf(GameProtocolDictionary.unlogged) != -1) {
        console.error("User logged out " + responseStr);
        this.requestState = RequestState.Block;
        return
    }
    var nameValues = responseStr.split("&");
    this.srvResponse = GameProtocolParser.ParseResponse(nameValues);
    ++this.index;
    this.counter = this.srvResponse.Counter + 1;
    this.repeat = this.srvResponse.Repeat;
    if (this.srvResponse.ServerTime > 0) EventManager.Trigger(GameEvents.evtServerTimeUpdate, this.srvResponse.ServerTime);
    XT.SetObject(FOXVars.FOX_Response, this.srvResponse.ValuesMap);
    switch (this.requestState) {
        case RequestState.Init:
            XT.TriggerEvent(FOXVars.Evt_FOX_InitReceived);
            this.HandleInitResponse(nameValues,
                this.srvResponse);
            if (!ServerOptions.isReplay) this.LoadSettingsRequest(null);
            else EventManager.Queue(GameEvents.evtSettingsUpdated + this.symbol, new GameSettings(""));
            break;
        case RequestState.Spin:
            XT.TriggerEvent(FOXVars.Evt_FOX_SpinReceived);
            this.HandleSpinResponse(nameValues, this.srvResponse);
            break;
        case RequestState.Collect:
            XT.TriggerEvent(FOXVars.Evt_FOX_CollectReceived);
            this.HandleCollectResponse(nameValues, this.srvResponse);
            break;
        case RequestState.InitBonus:
            XT.TriggerEvent(FOXVars.Evt_FOX_InitBonusReceived);
            this.HandleInitBonusResponse(nameValues, this.srvResponse);
            break;
        case RequestState.PickBonus:
            XT.TriggerEvent(FOXVars.Evt_FOX_PickBonusReceived);
            this.HandlePickBonusResponse(nameValues, this.srvResponse);
            break;
        case RequestState.BonusRespin:
            XT.TriggerEvent(FOXVars.Evt_FOX_BonusRespinReceived);
            this.HandleBonusRespinResponse(nameValues, this.srvResponse);
            break;
        case RequestState.CollectBonus:
            XT.TriggerEvent(FOXVars.Evt_FOX_CollectBonusReceived);
            this.HandleCollectBonusResponse(nameValues, this.srvResponse);
            break;
        case RequestState.Gamble:
            XT.TriggerEvent(FOXVars.Evt_FOX_GambleReceived);
            this.HandleGambleV2Response(nameValues, this.srvResponse);
            break;
        case RequestState.GambleCollect:
            XT.TriggerEvent(FOXVars.Evt_FOX_GambleCollectReceived);
            this.HandleGambleCollectResponse(nameValues, this.srvResponse);
            break;
        case RequestState.JackpotCollect:
            XT.TriggerEvent(FOXVars.Evt_FOX_JackpotCollectReceived);
            this.HandleJackpotCollectResponse(nameValues, this.srvResponse);
            break;
        case RequestState.PlayJackpot:
            XT.TriggerEvent(FOXVars.Evt_FOX_PlayJackpotReceived);
            this.HandlePlayJackpotResponse(nameValues, this.srvResponse);
            break;
        case RequestState.PickFSOption:
            XT.TriggerEvent(FOXVars.Evt_FOX_PickFSOptionReceived);
            this.HandlePickFSOptionResponse(nameValues, this.srvResponse);
            break;
        case RequestState.InitFSBG:
            XT.TriggerEvent(FOXVars.Evt_FOX_InitFSBGReceived);
            this.HandleInitFSBGResponse(nameValues, this.srvResponse);
            break;
        case RequestState.PickFSBG:
            XT.TriggerEvent(FOXVars.Evt_FOX_PickFSBGReceived);
            this.HandlePickFSBGResponse(nameValues, this.srvResponse);
            break;
        case RequestState.GetMysteryScatter:
            XT.TriggerEvent(FOXVars.Evt_FOX_GetMysteryScatterReceived);
            this.HandleMysteryScatterResponse(nameValues, this.srvResponse);
            break;
        default:
            console.error("Got response for unknown request state " + this.requestState);
            break
    }
};
var ActionSentAferLoadingWheel = false;
GameConnection.prototype.SendRequest = function(data) {
    if (!ActionSentAferLoadingWheel && LoadingWheelSentOnce) {
        globalTracking.SendEvent("uht_behaviour", "Loading_wheel_once_and_user_active", 1, "BehaviourTracker");
        ActionSentAferLoadingWheel = true
    }
    var request = new ServerRequest;
    request.Url = data.Url;
    request.Handler = new EventHandler(this, this.StoreResponse);
    request.Method = data.RequestMethod;
    request.KeepAlive = true;
    request.AllowRedirect = true;
    for (var tmp in data.Fields) request.Fields[tmp] = data.Fields[tmp];
    request.Fields[GameProtocolDictionary.index] =
        String(this.index);
    request.Fields[GameProtocolDictionary.counter] = String(this.counter);
    request.Fields[GameProtocolDictionary.repeat] = String(this.repeat);
    this.storedRequest = request;
    EventManager.Trigger(AdapterEvents.evtServerRequest, request);
    RequestManager.AddRequest(request)
};
GameConnection.prototype.SendCollectRequest = function() {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - Collect")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Collect) < 0) return;
    var data = new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doCollect;
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.Collect;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.Collect;
        this.SendRequest(data)
    }
};
GameConnection.prototype.SendFSCollectRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - FSCollect")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Collect) < 0) {
        console.warn("SendFSCollectRequest skipped");
        return
    }
    if (this.srvResponse.DoCollect) {
        console.warn("Attempt to collect FS again ... ignored");
        return
    }
    var data =
        new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doCollect;
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.Collect;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.Collect;
        this.SendRequest(data)
    }
};
GameConnection.prototype.SendInitRequest = function(param) {
    globalTracking.StartTimer("uht_loading", "_X_first_connection_duration", "LoadingTracker");
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - Init")
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doInit;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    if (!_string.IsNullOrEmpty(UHT_REVISION.common)) data.Fields[GameProtocolDictionary.clientVersion] = UHT_REVISION.common;
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.Init;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.Init;
        this.SendRequest(data)
    }
};
GameConnection.prototype.SendSpinRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - Spin")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Spin) < 0) {
        console.warn("SendSpinRequest delayed");
        var self = this;
        setTimeout(function() {
            self.SendSpinRequest(param)
        }, 250);
        return
    }
    var request = param;
    var data = new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doSpin;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields[GameProtocolDictionary.coin] = Number(request.Bet).toString();
    data.Fields[GameProtocolDictionary.line] = Number(request.Line).toString();
    this.AddRequestExtraParams(data);
    var ReelToBespun = XT.GetInt(Vars.ReelToBeSpun);
    if (ReelToBespun != -1) data.Fields[GameProtocolDictionary.ReelToBeSpun] =
        ReelToBespun;
    if (request.ProgressPick != -1) data.Fields[GameProtocolDictionary.ProgressiveFeature.progressivePick] = request.ProgressPick.toString();
    var betLevelSettings = XT.GetObject(Vars.BetLevelSettings);
    if (betLevelSettings != null) data.Fields[GameProtocolDictionary.BetLevel.betLevelIndex] = betLevelSettings.betLevelIndex.toString();
    var fsPurchaseConfig = XT.GetObject(Vars.FreeSpinsPurchaseConfig);
    if (fsPurchaseConfig != null && fsPurchaseConfig.optionIndex > -1) {
        data.Fields[GameProtocolDictionary.FreeSpinsPurchase.optionIndex] =
            fsPurchaseConfig.optionIndex.toString();
        fsPurchaseConfig.optionIndex = -2
    }
    var featurePurchaseData = XT.GetObject(Vars.FeaturePurchase);
    if (featurePurchaseData != null && featurePurchaseData.purchaseIndex > -1) {
        data.Fields[GameProtocolDictionary.FeaturePurchaseParam] = featurePurchaseData.purchaseIndex.toString();
        featurePurchaseData.purchaseIndex = -2
    }
    var brd = XT.GetObject(Vars.BonusRoundsData);
    if (brd != null && brd.Type == VsFreeRound.RoundType.Timed && XT.GetBool(Vars.TimedBonusRoundIsOngoing)) data.Fields[GameProtocolDictionary.FreeRound.BonusCodeParam] =
        brd.BonusCode;
    if (XT.GetBool(Vars.UserChoseToPlayLater)) {
        data.Fields["fr_play_later"] = "1";
        XT.SetBool(Vars.UserChoseToPlayLater, false)
    }
    if (XT.GetString(Vars.InitBonusCode).length > 0) {
        data.Fields["init_bonus_code"] = XT.GetString(Vars.InitBonusCode);
        XT.SetString(Vars.InitBonusCode, "")
    }
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.Spin;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.Spin;
        this.SendRequest(data)
    }
};
GameConnection.prototype.SendGambleRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - Gamble")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Gamble) < 0) {
        console.warn("SendGambleRequest skipped");
        return
    }
    var request = param;
    var data = new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doGamble;
    data.Fields[GameProtocolDictionary.Gambling.option] = Number(request.Choice).toString();
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.Gamble;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.Gamble;
        this.SendRequest(data)
    }
};
GameConnection.prototype.SendFSOptionRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - FSOption")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.FSOption) < 0) {
        console.warn("SendFSOptionRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doFSOption;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    if (param != null) data.Fields[GameProtocolDictionary.BonusGame.bonusGameChoice] = Number(param.Index).toString();
    if (this.requestState != RequestState.Idle) {
        if (this.requestState == RequestState.PickFSOption) {
            console.error("Tried to pick in fsOptions without waiting for result!");
            return
        }
        if (param != null) this.queuedState = RequestState.PickFSOption;
        else this.queuedState =
            RequestState.PickFSOption;
        this.queuedRequest = data
    } else {
        if (param != null) this.requestState = RequestState.PickFSOption;
        else this.requestState = RequestState.PickFSOption;
        this.SendRequest(data)
    }
};
GameConnection.prototype.SendFSBGRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - FSBG")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.FSBonus) < 0) {
        console.warn("SendFSBGRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.Actions.action] =
        GameProtocolDictionary.Actions.doFSBonus;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    if (param != null) data.Fields[GameProtocolDictionary.BonusGame.bonusGameChoice] = Number(param.Index).toString();
    if (this.requestState != RequestState.Idle) {
        if (this.requestState == RequestState.PickFSBG) {
            console.error("Tried to pick in fsbg without waiting for result!");
            return
        }
        if (param != null) this.queuedState = RequestState.PickFSBG;
        else this.queuedState = RequestState.InitFSBG;
        this.queuedRequest = data
    } else {
        if (param !=
            null) this.requestState = RequestState.PickFSBG;
        else this.requestState = RequestState.InitFSBG;
        this.SendRequest(data)
    }
};
GameConnection.prototype.SendMysteryScatterRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - MysteryScatter")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.MysteryScatter) < 0) {
        console.warn("SendMysteryScatterRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doMysteryScatter;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    this.AddRequestExtraParams(data);
    if (this.requestState != RequestState.Idle) {
        if (this.requestState == RequestState.GetMysteryScatter) {
            console.error("Tried to request mystery scatter second time!");
            return
        }
        this.queuedState = RequestState.GetMysteryScatter;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.GetMysteryScatter;
        this.SendRequest(data)
    }
};
GameConnection.prototype.SendGambleCollectRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - GambleCollect")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.GambleCollect) < 0) {
        console.warn("SendGambleCollectRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doGambleCollect;
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.GambleCollect;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.GambleCollect;
        this.SendRequest(data)
    }
};
GameConnection.prototype.SendJackpotCollectRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - JackpotCollect")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.JackpotCollect) < 0) {
        console.warn("SendJackpotCollectRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doJackpotCollect;
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.JackpotCollect;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.JackpotCollect;
        this.SendRequest(data)
    }
};
GameConnection.prototype.SendPlayJackpotRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - PlayJackpot")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.PlayJackpot) < 0) {
        console.warn("SendPlayJackpotRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doPlayJackpot;
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.PlayJackpot;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.PlayJackpot;
        this.SendRequest(data)
    }
};
GameConnection.prototype.SendBonusRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - Bonus")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Bonus) < 0) {
        console.warn("SendBonusRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.Actions.action] =
        GameProtocolDictionary.Actions.doBonus;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    if (param != null)
        if (param.PickType == 0) data.Fields[GameProtocolDictionary.BonusGame.bonusGameChoice] = Number(param.Index).toString();
        else {
            data.Fields[GameProtocolDictionary.BonusGame.lInd] = Number(param.Index).toString();
            data.Fields[GameProtocolDictionary.BonusGame.bonusGameChoice] = Number(param.PickType).toString()
        }
    else this.WaitInTransition(true);
    if (this.requestState != RequestState.Idle) {
        if (this.requestState ==
            RequestState.PickBonus) {
            console.error("Tried to pick in bonus without waiting for result!");
            return
        }
        if (param != null) this.queuedState = RequestState.PickBonus;
        else this.queuedState = RequestState.InitBonus;
        this.queuedRequest = data
    } else {
        if (param != null) this.requestState = RequestState.PickBonus;
        else this.requestState = RequestState.InitBonus;
        this.SendRequest(data)
    }
};
GameConnection.prototype.SendBonusRespinRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - Bonus")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Bonus) < 0) {
        console.warn("SendBonusRespinRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doBonus;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.BonusRespin;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.BonusRespin;
        this.SendRequest(data)
    }
};
GameConnection.prototype.SendBonusCollectRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - BonusCollect")
    }
    var action = GameProtocolDictionary.Actions.doCollectBonus;
    if (this.srvResponse.NextGameActions != null) {
        if (this.srvResponse.NextGameActions.indexOf(NextGameAction.Bonus) > -1) {
            this.SendBonusRequest(null);
            return
        }
        var collect = this.srvResponse.NextGameActions.indexOf(NextGameAction.Collect) >
            -1;
        var collectBonus = this.srvResponse.NextGameActions.indexOf(NextGameAction.CollectBonus) > -1;
        if (!collect && !collectBonus) {
            console.warn("SendBonusCollectRequest skipped");
            return
        }
        if (collect) action = GameProtocolDictionary.Actions.doCollect
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.Actions.action] = action;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    if (this.requestState != RequestState.Idle) {
        this.queuedState =
            RequestState.CollectBonus;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.CollectBonus;
        this.SendRequest(data)
    }
};
GameConnection.prototype.LoadSettingsRequest = function(param) {
    var request = new ServerRequest;
    var requestUrl = "";
    requestUrl += ServerOptions.serverUrl;
    requestUrl += ServerOptions.settingsUri;
    request.Url = requestUrl;
    request.Handler = new EventHandler(this, this.HandleSettingsLoaded);
    request.Method = "POST";
    request.Fields[DefaultValues.Settings.action] = DefaultValues.Settings.load;
    request.Fields[DefaultValues.Settings.idParam] = this.symbol;
    RequestManager.AddRequest(request)
};
GameConnection.prototype.SaveSettingsRequest = function(param) {
    var settings = param;
    var request = new ServerRequest;
    var requestUrl = "";
    requestUrl += ServerOptions.serverUrl;
    requestUrl += ServerOptions.settingsUri;
    request.Url = requestUrl;
    request.Handler = new EventHandler(this, this.HandleSettingSaved);
    request.Method = "POST";
    request.Fields[DefaultValues.Settings.idParam] = this.symbol;
    request.Fields[DefaultValues.Settings.settingsParam] = settings.ToString();
    RequestManager.AddRequest(request)
};
GameConnection.prototype.HandleInitResponse = function(nameValues, response) {
    LoaderProgress.InitConnection_Current = 1;
    globalTracking.StopTimerAndSend("uht_loading", "_X_first_connection_duration", "LoadingTracker");
    var data = response.ValuesMap;
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    GameConnection.prototype.SlotHeight = vsResponse.SlotHeight;
    vsResponse.NextGameActions = response.NextGameActions;
    this.initData = vsResponse.VsInitData.Clone();
    var configs = GameProtocolCommonParser.ParseIntList(data, GameProtocolDictionary.configs);
    if (configs != null) ServerOptions.configs = configs;
    this.AddGambleButtonState(vsResponse, true);
    EventManager.Trigger(GameEvents.evtInitResponse + this.symbol, vsResponse);
    this.requestState = RequestState.Idle;
    if (this.srvResponse.NextGameActions != null) {
        if (this.IsNextAction(NextGameAction.Collect)) this.SendCollectRequest();
        if (this.IsNextAction(NextGameAction.CollectBonus)) this.SendBonusCollectRequest(null);
        if (this.IsNextAction(NextGameAction.JackpotCollect)) this.SendJackpotCollectRequest(null);
        if (this.IsNextAction(NextGameAction.PlayJackpot)) EventManager.Trigger(GameEvents.evtMustPlayJackpot +
            this.symbol, null)
    } else {
        var needToCollect = !response.DoCollect && vsResponse.IsWin() && response.DoSpin;
        if (needToCollect && (vsResponse.IsFreeSpins() && !vsResponse.VsFreeSpin.IsFirstFreeSpin() && !vsResponse.IsFreeSpinBonusGame())) needToCollect = false;
        if (needToCollect)
            if (vsResponse.IsBonusRespin()) this.SendBonusCollectRequest(null);
            else this.SendCollectRequest()
    }
    EventManager.Trigger(JackpotEvents.evtJackpotStateChanged, vsResponse.VsJackpotData);
    if (vsResponse.IsJackpotWin()) this.SendJackpotCollectRequest(null);
    if (vsResponse.IsBonus())
        if (vsResponse.WasDoBonus() || vsResponse.IsBonusRespin() || vsResponse.IsBonusFSPick() || vsResponse.IsOpeningSymbols() || vsResponse.BonusDoesNotNeedInit() || vsResponse.BonusIdDoesNotNeedInit()) EventManager.Trigger(GameEvents.evtBonusInitResponse + this.symbol, vsResponse);
        else this.SendBonusRequest(null);
    if (vsResponse.IsFreeSpinBonusGame() && !vsResponse.VsFreeSpin.BonusGame.GameOver)
        if (vsResponse.WasDoFSBonus()) EventManager.Trigger(GameEvents.evtFSBGInitResponse + this.symbol, vsResponse);
        else this.SendFSBGRequest(null)
};
GameConnection.prototype.HandleSpinResponse = function(nameValues, response) {
    var data = response.ValuesMap;
    if (this.mustStopSpin) {
        EventManager.Queue(GameEvents.evtNoMoneySpinResponse, data);
        this.requestState = RequestState.Idle;
        return
    }
    if (this.NoMoney(data) || this.isRegulatoryError) {
        if (GameConnection.noMoneyStopsSpin) {
            EventManager.Queue(GameEvents.evtNoMoneySpinResponse, data);
            this.requestState = RequestState.Idle
        }
        return
    }
    var nameValuesDict = response.ValuesMap;
    var balanceData = GameProtocolCommonParser.ParseBalance(nameValuesDict);
    if (balanceData !=
        null) EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData);
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    var newInitData = vsResponse.VsInitData;
    var configSwitched = newInitData.ReelSymbols != null && newInitData.ReelSymbols.length > 0;
    if (configSwitched) this.initData.GamblingSettings = newInitData.GamblingSettings.Clone();
    this.AddGambleButtonState(vsResponse, false);
    if (configSwitched) EventManager.Queue(GameEvents.evtConfigSwitchedResponse +
        this.symbol, vsResponse);
    EventManager.Queue(GameEvents.evtSpinResponse + this.symbol, vsResponse);
    var needToCollect = true;
    if (this.srvResponse.NextGameActions == null) needToCollect = response.DoCollect || vsResponse.IsWin();
    if (needToCollect && (vsResponse.IsFreeSpins() && !vsResponse.VsFreeSpin.IsFirstFreeSpin() && !vsResponse.IsFreeSpinBonusGame())) needToCollect = false;
    this.requestState = RequestState.Idle;
    if (needToCollect) this.SendCollectRequest();
    if (vsResponse.IsJackpotWin()) this.SendJackpotCollectRequest(null);
    EventManager.Queue(JackpotEvents.evtJackpotStateChanged,
        vsResponse.VsJackpotData);
    if (vsResponse.IsBonus() && !vsResponse.IsBonusRespin() && !vsResponse.IsBonusFSPick() && !vsResponse.IsBonusOptions() && !vsResponse.IsBonusGameOver() && !vsResponse.BonusIdDoesNotNeedInit())
        if (vsResponse.GetVsBonusGameData().wheelOfFortune != null)
            if (vsResponse.GetVsBonusGameData().wheelOfFortune.stopPosition != -1) this.SendBonusRequest(null);
            else EventManager.Queue(GameEvents.evtBonusInitResponse + this.symbol, vsResponse);
    else this.SendBonusRequest(null);
    else EventManager.Queue(GameEvents.evtBonusInitResponse +
        this.symbol, vsResponse);
    if (vsResponse.IsFreeSpinBonusGame() && !vsResponse.VsFreeSpin.BonusGame.GameOver)
        if (vsResponse.WasDoFSBonus()) EventManager.Queue(GameEvents.evtFSBGInitResponse + this.symbol, vsResponse);
        else this.SendFSBGRequest(null);
    if (this.srvResponse.NextGameActions != null)
        if (this.IsNextAction(NextGameAction.PlayJackpot)) EventManager.Trigger(GameEvents.evtMustPlayJackpot + this.symbol, null)
};
GameConnection.prototype.AddGambleButtonState = function(response, isInit) {
    var spin = false;
    if (this.initData.GamblingSettings.IsOccasionEnable(GamblingOccasions.Spin) && response.IsWin() && !response.IsBonus() && !response.IsFreeSpins()) spin = isInit ? !this.initData.GamblingSettings.SkipGambleOnInit : true;
    var freespin = false;
    if (this.initData.GamblingSettings.IsOccasionEnable(GamblingOccasions.FreeSpin) && response.IsWin() && response.IsFreeSpins() && response.VsFreeSpin.IsLastFreeSpin()) freespin = isInit ? !this.initData.GamblingSettings.SkipGambleOnInit :
        true;
    var bonus = false;
    if (this.initData.GamblingSettings.IsOccasionEnable(GamblingOccasions.Bonus) && response.IsBonus()) bonus = isInit ? !this.initData.GamblingSettings.SkipGambleOnInit : true;
    response.VsGamblingButtonState = new VsGamblingButtonState(spin, freespin, bonus)
};
GameConnection.prototype.HandleCollectResponse = function(nameValues, response) {
    var nameValuesDict = response.ValuesMap;
    var balanceData = GameProtocolCommonParser.ParseBalance(nameValuesDict);
    if (balanceData != null) EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData);
    this.HandleFreeRoundsUpdateOnCollect(nameValuesDict);
    EventManager.Queue(FOXVars.Evt_FOX_TriggerAfterEvent, FOXVars.Evt_FOX_AfterCollectReceived);
    this.requestState = RequestState.Idle;
    if (this.mustPostGameRoundEndedOnCollect) {
        UHTInterfaceBOSS.PostMessage("gameRoundEnded");
        this.mustPostGameRoundEndedOnCollect = false
    }
};
GameConnection.prototype.HandleInitBonusResponse = function(nameValues, response) {
    var data = response.ValuesMap;
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    if (vsResponse.IsBonus()) {
        EventManager.Queue(GameEvents.evtBonusInitResponse + this.symbol, vsResponse);
        EventManager.Queue(StageTransitionVars.Evt_StageTransition_SetWaitInTransition, false)
    }
    this.requestState = RequestState.Idle
};
GameConnection.prototype.HandlePickBonusResponse = function(nameValues, response) {
    var data = response.ValuesMap;
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    EventManager.Queue(GameEvents.evtBonusPickResponse + this.symbol, vsResponse);
    this.requestState = RequestState.Idle
};
GameConnection.prototype.HandleBonusRespinResponse = function(nameValues, response) {
    var data = response.ValuesMap;
    if (response.NextGameActions.indexOf(NextGameAction.MysteryScatter) != -1 && data[GameProtocolDictionary.mysteryScatterGame] == undefined) data[GameProtocolDictionary.mysteryScatterGame] = "1";
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    EventManager.Queue(GameEvents.evtBonusRespinResponse + this.symbol, vsResponse);
    this.requestState = RequestState.Idle
};
GameConnection.prototype.HandleCollectBonusResponse = function(nameValues, response) {
    var nameValuesDict = response.ValuesMap;
    var balanceData = GameProtocolCommonParser.ParseBalance(nameValuesDict);
    if (balanceData != null) EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData);
    XT.TriggerEvent("PS_AnnounceResultShown");
    this.HandleFreeRoundsUpdateOnCollect(nameValuesDict);
    EventManager.Queue(FOXVars.Evt_FOX_TriggerAfterEvent, FOXVars.Evt_FOX_AfterCollectBonusReceived);
    this.requestState = RequestState.Idle
};
GameConnection.prototype.HandlePickFSOptionResponse = function(nameValues, response) {
    var data = response.ValuesMap;
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    EventManager.Queue(GameEvents.evtFSOptionsUpdate + this.symbol, vsResponse);
    this.requestState = RequestState.Idle
};
GameConnection.prototype.HandleInitFSBGResponse = function(nameValues, response) {
    var data = response.ValuesMap;
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    EventManager.Queue(GameEvents.evtFSBGInitResponse + this.symbol, vsResponse);
    this.requestState = RequestState.Idle
};
GameConnection.prototype.HandlePickFSBGResponse = function(nameValues, response) {
    var data = response.ValuesMap;
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    EventManager.Queue(GameEvents.evtFSBGPickResponse + this.symbol, vsResponse);
    this.requestState = RequestState.Idle
};
GameConnection.prototype.HandleMysteryScatterResponse = function(nameValues, response) {
    var data = response.ValuesMap;
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    EventManager.Queue(GameEvents.evtMysteryScatterResponse + this.symbol, vsResponse);
    this.requestState = RequestState.Idle
};
GameConnection.prototype.HandleGambleResponse = function(nameValues, response) {
    var data = response.ValuesMap;
    if (this.NoMoney(data)) return;
    var gambleResponse = GameProtocolGamblingParser.ParseVsGamblingResponse(data);
    EventManager.Queue(GameEvents.evtGambleResponse + this.symbol, gambleResponse);
    this.requestState = RequestState.Idle
};
GameConnection.prototype.HandleGambleCollectResponse = function(nameValues, response) {
    var nameValuesDict = response.ValuesMap;
    var balanceData = GameProtocolCommonParser.ParseBalance(nameValuesDict);
    if (balanceData != null) EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData);
    this.HandleFreeRoundsUpdateOnCollect(nameValuesDict);
    EventManager.Queue(FOXVars.Evt_FOX_TriggerAfterEvent, FOXVars.Evt_FOX_AfterGambleCollectReceived);
    this.requestState = RequestState.Idle
};
GameConnection.prototype.HandleJackpotCollectResponse = function(nameValues, response) {
    var nameValuesDict = response.ValuesMap;
    var balanceData = GameProtocolCommonParser.ParseBalance(nameValuesDict);
    if (balanceData != null) EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData);
    this.HandleFreeRoundsUpdateOnCollect(nameValuesDict);
    EventManager.Queue(FOXVars.Evt_FOX_TriggerAfterEvent, FOXVars.Evt_FOX_AfterJackpotCollectReceived);
    this.requestState = RequestState.Idle;
    if (this.srvResponse.NextGameActions !=
        null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Collect) != -1) this.SendCollectRequest()
};
GameConnection.prototype.HandlePlayJackpotResponse = function(nameValues, response) {
    var data = response.ValuesMap;
    var balanceData = GameProtocolCommonParser.ParseBalance(data);
    if (balanceData != null) EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData);
    EventManager.Queue(GameEvents.evtPlayJackpotResponse + this.symbol, VSProtocolParser.ParseVsJackpotData(data));
    this.requestState = RequestState.Idle;
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Collect) !=
        -1) this.SendCollectRequest()
};
GameConnection.prototype.HandleSettingsLoaded = function(param, statusCode) {
    console.info("HandleSettingsLoaded", param);
    var settings = new GameSettings;
    settings.FromString(param);
    console.log("HandleSettingsLoaded", GameEvents.evtSettingsUpdated + this.symbol);
    EventManager.Queue(GameEvents.evtSettingsUpdated + this.symbol, settings)
};
GameConnection.prototype.HandleSettingSaved = function(param, statusCode) {
    console.info("HandleSettingSaved " + param);
    var settings = new GameSettings;
    settings.FromString(param);
    if (settings.Settings["SoundState"] == undefined) {
        EventManager.Trigger(AdapterEvents.evtShowMessage, AdapterMessages.settingsNotSaved);
        EventManager.Queue(GameEvents.evtSettingsNotSaved, null)
    }
};
GameConnection.prototype.NoMoney = function(data) {
    if (data[GameProtocolDictionary.noMoney] != undefined) {
        console.error("You have no money beci!");
        return true
    }
    return false
};
GameConnection.prototype.HandleFreeRoundsUpdateOnCollect = function(nameValues) {
    var vsResponse = new VsResponse;
    vsResponse.FreeRound = VSProtocolParser.ParseVsFreeRound(nameValues);
    vsResponse.FreeRoundEvents = VSProtocolParser.ParseVsFreeRoundEvents(nameValues);
    EventManager.Queue(GameEvents.evtFreeRoundsUpdate, vsResponse)
};
GameConnection.prototype.HandleGambleV2Response = function(nameValues, response) {
    var data = response.ValuesMap;
    EventManager.Queue(GameEvents.evtGambleResponse + this.symbol, GambleV2Protocol.Parser.ParseGambleData(data));
    this.requestState = RequestState.Idle;
    if (this.srvResponse.NextGameActions != null) {
        if (this.srvResponse.NextGameActions.indexOf(NextGameAction.Collect) > -1) this.SendCollectRequest();
        if (this.srvResponse.NextGameActions.indexOf(NextGameAction.CollectBonus) > -1) this.SendBonusCollectRequest(null)
    }
};
GameConnection.prototype.SendGambleV2Request = function(index) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - Gamble")
    }
    if (this.srvResponse.NextGameActions == null) {
        console.warn("SendGambleV2Request skipped");
        return
    }
    var gamble = this.srvResponse.NextGameActions.indexOf(NextGameAction.Gamble) > -1;
    var gambleOption = this.srvResponse.NextGameActions.indexOf(NextGameAction.GambleOption) > -1;
    if (!(gamble ||
            gambleOption)) {
        console.warn("SendGambleV2Request skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = ServerOptions.serverUrl + ServerOptions.gameServiceUri;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields["g_a"] = index < 0 ? "stand" : "gamble";
    if (gamble) {
        data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doGamble;
        data.Fields["g_ind"] = String(index)
    } else {
        data.Fields[GameProtocolDictionary.Actions.action] = "doGambleOption";
        data.Fields["g_o_ind"] = String(index)
    }
    if (this.requestState !=
        RequestState.Idle) {
        this.queuedState = RequestState.Gamble;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.Gamble;
        this.SendRequest(data)
    }
};
GameConnection.prototype.CanRequest = function(reqState) {
    var can = true;
    if (this.srvResponse != null && this.srvResponse.NextGameActions != null) switch (reqState) {
        case RequestState.Collect:
            can = this.IsNextAction(NextGameAction.Collect);
            break;
        case RequestState.Spin:
            can = this.IsNextAction(NextGameAction.Spin);
            break;
        case RequestState.Gamble:
            can = this.IsNextAction(NextGameAction.Gamble) || this.IsNextAction(NextGameAction.GambleOption);
            break;
        case RequestState.PickFSOption:
            can = this.IsNextAction(NextGameAction.FSOption);
            break;
        case RequestState.InitFSBG:
        case RequestState.PickFSBG:
            can = this.IsNextAction(NextGameAction.FSBonus);
            break;
        case RequestState.GetMysteryScatter:
            can = this.IsNextAction(NextGameAction.MysteryScatter);
            break;
        case RequestState.GambleCollect:
            can = this.IsNextAction(NextGameAction.GambleCollect);
            break;
        case RequestState.JackpotCollect:
            can = this.IsNextAction(NextGameAction.JackpotCollect);
            break;
        case RequestState.InitBonus:
        case RequestState.PickBonus:
        case RequestState.BonusRespin:
            can = this.IsNextAction(NextGameAction.Bonus);
            break;
        case RequestState.CollectBonus:
            can = this.IsNextAction(NextGameAction.Collect) || this.IsNextAction(NextGameAction.CollectBonus);
            break
    }
    return can
};
GameConnection.prototype.IsNextAction = function(action) {
    return this.srvResponse != null && this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(action) > -1
};
GameConnection.prototype.TriggerFOXAfterEvent = function(param) {
    XT.TriggerEvent(param)
};
GameConnection.prototype.WaitInTransition = function(wait) {
    XT.SetBool(StageTransitionVars.StageTransition_WaitInTransition, wait)
};
GameConnection.prototype.SetWaitInTransition = function(param) {
    this.WaitInTransition(param)
};

function RequestExtraParams() {
    this.dict = {}
}
goog.require("UHT.ServerOptions");
goog.require("UHT.Component");
goog.require("UHT.ResourceRequest");
ResourceManager.prototype = Object.create(Component.prototype);
ResourceManager.prototype.constructor = ResourceManager;

function ResourceManager() {
    Component.call(this);
    this.downloadQueue = null;
    this.waitingQueue = null;
    this.packagesInfo = null;
    ResourceManager.instance = this
}
ResourceManager.prototype.Start = function() {
    this.downloadQueue = [];
    this.waitingQueue = [];
    EventManager.AddHandler(ResourceEvents.evtRequestResources, this.OnResourcesRequest, this)
};
ResourceManager.prototype.Update = function() {
    var i;
    if (this.waitingQueue.length > 0) {
        for (i = 0; i < this.waitingQueue.length; ++i) this.downloadQueue.push(this.waitingQueue[i]);
        this.waitingQueue = []
    }
    if (this.downloadQueue.length > 0)
        for (i = 0; i < this.downloadQueue.length; ++i) {
            this.downloadQueue[i].Update();
            if (this.downloadQueue[i].isDone) {
                EventManager.Queue(ResourceEvents.evtResourcesCompleted + this.downloadQueue[i].componentName, this.downloadQueue[i].GetData());
                this.downloadQueue.splice(i, 1)
            }
        }
};
ResourceManager.prototype.OnResourcesRequest = function(componentName) {
    if (UHT_RESOURCES == null) {
        if (this.packagesInfo == null) {
            var self = this;
            setTimeout(function() {
                self.OnResourcesRequest(componentName)
            }, 200)
        }
        return
    }
    globalTracking.StartTimer("uht_loading", "_X_apply_localization_packages", "LoadingTracker");
    this.packagesInfo = UHT_PACKAGES_INFO_OBJ;
    var bundlePack = new BundlePack;
    var currencyPatch = new AssetBundle;
    currencyPatch.mainAsset = jsonParse(UHT_RESOURCES.CURRENCY_PATCH);
    bundlePack.assetBundles.push(currencyPatch);
    for (var i = 0; i < UHT_RESOURCES.LOCALIZATIONS.length; ++i) {
        var bundle = new AssetBundle;
        try {
            bundle.mainAsset = jsonParse(UHT_RESOURCES.LOCALIZATIONS[i])
        } catch (e) {
            bundle.mainAsset = JSON.parse(UHT_RESOURCES.LOCALIZATIONS[i])
        }
        bundlePack.assetBundles.push(bundle)
    }
    EventManager.Queue(ResourceEvents.evtResourcesCompleted + componentName, bundlePack);
    globalTracking.StopTimerAndSend("uht_loading", "_X_apply_localization_packages", "LoadingTracker");
    UHT_RESOURCES = null
};
ResourceManager.prototype.RequestResources = function(request) {
    console.log("ResourceManager::RequestResources", request);
    var pack = new RequestPack;
    pack.componentName = request.symbol;
    for (var i = 0; i < request.files.length; ++i) pack.downloaders.push(new ResourceRequest({
        url: request.files[i]
    }));
    this.waitingQueue.push(pack)
};
ResourceManager.prototype.InstLoadLanguage = function(lang) {
    var dict = this.packagesInfo;
    if (dict["languages"] == undefined) {
        console.warn("ResourceManager - language bundles not found!");
        return
    }
    var info = new ResourceRequestInfo;
    info.symbol = lang;
    var languages = dict["languages"];
    var path = ServerOptions.gameUrl + ServerOptions.packagesUri;
    var suffix = (UHT_DEVICE_TYPE.MOBILE ? "_mobile" : "_desktop") + ".json";
    for (var i = 0; i < languages.length; ++i)
        if (languages[i]["language"] == lang) {
            console.info("found bundles for language " +
                languages[i]["language"]);
            var bundles = languages[i]["bundles"];
            for (var j = 0; j < bundles.length; ++j) info.files.push(path + bundles[j]["name"] + suffix)
        }
    this.RequestResources(info)
};
ResourceManager.instance = null;
ResourceManager.LoadLanguage = function(lang) {
    var rm = ResourceManager;
    var rmi = ResourceManager.instance;
    if (rmi == null || rmi.packagesInfo == null) {
        setTimeout(function() {
            ResourceManager.LoadLanguage(lang)
        }, 50);
        return
    }
    EventManager.AddHandler(ResourceEvents.evtResourcesCompleted + lang, rm.OnLanguageLoaded, rm);
    rmi.InstLoadLanguage(lang)
};
ResourceManager.OnLanguageLoaded = function(pack) {
    for (var i = 0; i < pack.assetBundles.length; ++i) {
        var go = UHTEngine.LoadAssetBundle(pack.assetBundles[i].mainAsset, ServerOptions.gameUrl + "packages/");
        var mm = go.GetComponent(ModificationsManager);
        if (mm != null) mm.Init()
    }
    pack.assetBundles = []
};
goog.require("UHT.ServerOptions");
goog.provide("UHT.ServerHelpers");
var ServerHelpers = {
    CookiesRequest: function(callback) {
        console.info("Sending request for sessionid from cookies");
        var req = new ServerRequest;
        req.Url = ServerOptions.serverUrl + "/gs2c/richcasino/index.jsp?lang=en";
        req.Handler = callback;
        req.Method = "HEAD";
        RequestManager.AddRequest(req)
    },
    RequestApplicationConfiguration: function(callback) {
        var request = new ServerRequest;
        request.Url = ServerOptions.serverUrl + ServerOptions.configUri;
        request.Handler = callback;
        request.Method = "POST";
        request.KeepAlive = true;
        request.AllowRedirect =
            true;
        RequestManager.AddRequest(request)
    },
    LoginRequest: function(uName, uPass, callback) {
        var request = new ServerRequest;
        var loginParams = "?method=login&nic=" + uName + "&pwd=" + uPass + "&acctype=R";
        request.Url = ServerOptions.serverUrl + ServerOptions.loginUri + loginParams;
        request.Handler = callback;
        request.Method = "POST";
        request.KeepAlive = true;
        request.AllowRedirect = true;
        RequestManager.AddRequest(request)
    },
    RequestGameConfiguration: function(gameSymbol, callback) {
        var request = new ServerRequest;
        request.Url = ServerOptions.serverUrl +
            ServerOptions.menuUri;
        request.Handler = callback;
        request.Method = "POST";
        request.KeepAlive = true;
        request.AllowRedirect = true;
        request.Fields["method"] = "gameInfo";
        request.Fields[GameProtocolDictionary.symbol] = gameSymbol;
        RequestManager.AddRequest(request)
    },
    RequestAcceptedVersions: function(callback) {
        var request = new ServerRequest;
        var requestUrl = "";
        requestUrl += ServerOptions.serverUrl;
        requestUrl += ServerOptions.versionUri;
        requestUrl += ServerHelpers.BuildGetParam(DefaultValues.UnityVars.bundleVersion, ServerOptions.resourceVersion);
        request.Url = requestUrl;
        request.Handler = callback;
        request.Method = "GET";
        RequestManager.AddRequest(request)
    },
    ReloadBalance: function(callback, force) {
        var request = new ServerRequest;
        var requestUrl = "";
        requestUrl += ServerOptions.serverUrl;
        requestUrl += ServerOptions.reloadBalanceUri;
        request.Url = requestUrl;
        request.Handler = callback;
        request.Method = "GET";
        if (force) request.Fields["force"] = "true";
        RequestManager.AddRequest(request)
    },
    ReloadJackpot: function(gameSymbol, callback) {
        var request = new ServerRequest;
        var requestUrl =
            "";
        requestUrl += ServerOptions.serverUrl;
        requestUrl += ServerOptions.reloadJackpotUri;
        request.Url = requestUrl;
        request.Handler = callback;
        request.Method = "POST";
        request.Fields[GameProtocolDictionary.symbol] = gameSymbol;
        RequestManager.AddRequest(request)
    },
    RequestRegulationNotification: function(callback) {
        var request = new ServerRequest;
        var requestUrl = "";
        requestUrl += ServerOptions.SwedishRegulation.notificationUrl + "?mgckey=" + ServerOptions.mgckey;
        request.Url = requestUrl;
        request.Handler = callback;
        request.Method = "GET";
        RequestManager.AddRequest(request)
    },
    BuildGetParam: function(name, value) {
        return "?" + name + "=" + value
    },
    BuildGetParams: function(dict) {
        var rv = [];
        for (var tmp in dict) rv.push([tmp, dict[tmp]].join("="));
        return "?" + rv.join("&")
    }
};
goog.provide("UHT.BalanceManager");
goog.require("UHT.ServerHelpers");
goog.require("UHT.EventManager");
goog.require("UHT.BalanceData");
var BalanceEvents = {
    evtBalanceUpdated: "evtBalanceUpdated",
    evtBalanceUpdateRequest: "evtBalanceUpdateRequest",
    evtBalanceUpdateFromAdapter: "evtBalanceUpdateFromAdapter",
    evtBalanceUpdateToAdapter: "evtBalanceUpdateToAdapter",
    evtUpdateBalance: "evtUpdateBalance",
    evtUpdateBalanceForced: "evtUpdateBalanceForced"
};

function BalanceManager() {
    this.data = null;
    this.maxBalanceDelay = 30;
    this.balanceRequestTimer = 0;
    this.requestInProgress = false
}
BalanceManager.I = null;
BalanceManager.prototype.Init = function() {
    BalanceManager.I = this;
    this.requestInProgress = false;
    EventManager.AddHandler(BalanceEvents.evtBalanceUpdateRequest, this.OnUpdateRequest, this);
    EventManager.AddHandler(BalanceEvents.evtBalanceUpdateFromAdapter, this.OnBalanceUpdateFromAdapter, this);
    EventManager.AddHandler(BalanceEvents.evtUpdateBalance, this.OnUpdateBalance, this);
    EventManager.AddHandler(BalanceEvents.evtUpdateBalanceForced, this.OnUpdateBalanceForced, this)
};
BalanceManager.prototype.OnUpdateRequest = function(param) {
    var newData = param;
    if (this.data == null || newData.Time > this.data.Time) {
        this.balanceRequestTimer = 0;
        this.data = newData;
        EventManager.Queue(BalanceEvents.evtBalanceUpdated, this.data);
        EventManager.Queue(BalanceEvents.evtBalanceUpdateToAdapter, this.data)
    }
};
BalanceManager.prototype.OnBalanceUpdateFromAdapter = function(param) {
    var newData = param;
    if (this.data == null || newData.Time > this.data.Time) {
        this.balanceRequestTimer = 0;
        this.data = newData;
        EventManager.Queue(BalanceEvents.evtBalanceUpdated, this.data)
    }
};
BalanceManager.prototype.Update = function() {
    this.balanceRequestTimer += Time.deltaTime;
    if (!this.requestInProgress)
        if (this.balanceRequestTimer > this.maxBalanceDelay) {
            this.requestInProgress = true;
            ServerHelpers.ReloadBalance(new EventHandler(this, this.BalanceReloadCallback), false)
        }
};
BalanceManager.prototype.BalanceReloadCallback = function(data, statusCode) {
    var nameValues = String(data).split("&");
    var nameValuesDict = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var balanceData = GameProtocolCommonParser.ParseBalance(nameValuesDict);
    if (balanceData != null) {
        this.requestInProgress = false;
        this.OnUpdateRequest(balanceData)
    }
};
BalanceManager.prototype.OnUpdateBalance = function() {
    ServerHelpers.ReloadBalance(new EventHandler(this, this.BalanceReloadCallback), false)
};
BalanceManager.prototype.OnUpdateBalanceForced = function() {
    ServerHelpers.ReloadBalance(new EventHandler(this, this.BalanceReloadCallback), true)
};
goog.require("UHT.SimpleWebRequest");

function RequestData() {
    this.RequestMethod = "POST";
    this.Url = "";
    this.Fields = {}
}

function ResponseData(statusCode, response) {
    this.StatusCode = statusCode;
    this.Response = response
}

function ServerRequest() {
    this.Handler = null;
    this.responseHandler = null;
    this.Fields = {};
    this.Url = "";
    this.Method = "GET";
    this.AllowRedirect = false;
    this.KeepAlive = false;
    this.PostData = "";
    this.ContentType = "application/x-www-form-urlencoded";
    this.request = null
}
ServerRequest.prototype.IsDone = function() {
    if (this.request == null) return false;
    else return this.request.Done
};
ServerRequest.prototype.Start = function() {
    if (_string.IsNullOrEmpty(this.PostData)) {
        var args = [];
        for (var name in this.Fields) args.push(name + "=" + this.Fields[name]);
        this.PostData = args.join("&")
    }
    this.request = RequestProvider.Instance.NewRequest({
        url: this.Url,
        method: this.Method,
        postData: this.PostData,
        contentType: this.ContentType
    })
};
ServerRequest.prototype.Finish = function() {
    console.log("ServerRequest::Finish", this.Handler);
    if (this.Handler != null) this.Handler.call(this.request.Data, this.request.statusCode);
    if (this.responseHandler != null) this.responseHandler.call(this.request.Data, this.request.statusCode, this);
    if (String(this.request.Data).indexOf(GameProtocolDictionary.unlogged) != -1) {
        console.error("User logged out" + this.request.Data);
        RequestManager.blockRequests = true
    }
    EventManager.Trigger(ApplicationEvents.evtServerResponse, new ResponseData(this.request.statusCode,
        this.request.Data))
};
goog.provide("UHT.SwedishRegulationManager");
goog.require("UHT.ServerHelpers");
goog.require("UHT.EventManager");

function SwedishRegulationManager() {
    this.regulationRequestInterval = -1;
    this.regulationRequestTimer = 0;
    this.requestInProgress = false;
    this.regulationTimerIsActive = false;
    this.elapsedTime = 0;
    this.elapsedTimeContainerLandscape = null;
    this.elapsedTimeContainerPortrait = null;
    this.initialTime = 0;
    this.initialElapsedTime = 0
}
SwedishRegulationManager.instance = null;
SwedishRegulationManager.prototype.Init = function() {
    SwedishRegulationManager.instance = this;
    this.requestInProgress = false;
    if (UHT_GAME_CONFIG["REGULATION_NOTIFICATION_INTERVAL"] != undefined)
        if (!isNaN(parseInt(UHT_GAME_CONFIG["REGULATION_NOTIFICATION_INTERVAL"], 10))) this.regulationRequestInterval = parseInt(UHT_GAME_CONFIG["REGULATION_NOTIFICATION_INTERVAL"], 10);
    var hasLogos = false;
    if (UHT_GAME_CONFIG["selftestUrl"] && UHT_GAME_CONFIG["pauseplayUrl"] && UHT_GAME_CONFIG["playlimitUrl"]) hasLogos = true;
    if (UHT_GAME_CONFIG["elapsedTime"]) {
        this.initialElapsedTime =
            parseInt(UHT_GAME_CONFIG["elapsedTime"], 10);
        this.regulationTimerIsActive = true
    }
    if (hasLogos || this.regulationTimerIsActive) {
        this.InjectRegulationContainers(hasLogos);
        EventManager.AddHandler("EVT_UHT_RESIZE", this.OnUHTResize, this);
        this.OnUHTResize(null)
    }
    this.elapsedTime = this.initialElapsedTime;
    this.initialTime = (new Date).getTime()
};
SwedishRegulationManager.prototype.Update = function() {
    if (this.regulationRequestInterval > 0) {
        this.regulationRequestTimer += Time.deltaTime;
        if (!this.requestInProgress)
            if (this.regulationRequestTimer > this.regulationRequestInterval) {
                this.requestInProgress = true;
                ServerHelpers.RequestRegulationNotification(new EventHandler(this, this.RegulationRequestCallback), false)
            }
    }
    if (this.regulationTimerIsActive) this.UpdateTimer()
};
SwedishRegulationManager.prototype.RegulationRequestCallback = function(data, statusCode) {
    if (data != null) {
        this.requestInProgress = false;
        this.regulationRequestTimer = 0
    }
};
SwedishRegulationManager.prototype.InjectRegulationContainers = function(hasLogos) {
    var htmlString = "";
    if (document.documentElement.id == "Mobile") htmlString = '<div class="RGSContainerActive" style="display: block;" data-height="25"><div id="RGSPortrait" style="margin-left: auto; margin-right: auto; width: 100%; display:block; white-space: nowrap;"> <a href="#" class="PausePlay" target="_blank" style="text-decoration: none;"> <img style="height:20px;" alt="Spelpaus" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTg0LjkgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTg0LjkgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6I0UyMEQxODt9PC9zdHlsZT48Zz48cmVjdCB4PSIwLjUiIHk9IjAuNSIgY2xhc3M9InN0MCIgd2lkdGg9IjE4My45IiBoZWlnaHQ9IjUyLjQiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTgzLjksMXY1MS40SDFWMUgxODMuOSBNMTg0LjksMEgwdjUzLjRoMTg0LjlWMEwxODQuOSwweiIvPjwvZz48cGF0aCBjbGFzcz0ic3QyIiBkPSJNNTMuMywyNi44QzUzLjMsMzguNSw0My44LDQ4LDMyLDQ4Yy0xMS43LDAtMjEuMy05LjUtMjEuMy0yMS4zQzEwLjgsMTUsMjAuMyw1LjUsMzIsNS41QzQzLjgsNS41LDUzLjMsMTUsNTMuMywyNi44eiIvPjxnPjxnPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik03Ny4xLDMwLjVjMCwwLjctMC4yLDEuNC0wLjUsMmMtMC4zLDAuNy0wLjgsMS4yLTEuMywxLjdjLTAuNiwwLjUtMS40LDAuOS0yLjIsMS4yYy0wLjgsMC4zLTEuOSwwLjQtMy4xLDAuNGMtMS4zLDAtMi40LTAuMS0zLjQtMC40Yy0xLTAuMi0yLjEtMC42LTMuMS0xLjF2LTNoMC4yYzAuOSwwLjcsMS45LDEuMywzLjEsMS43czIuMywwLjYsMy4zLDAuNmMxLjUsMCwyLjYtMC4zLDMuNC0wLjhjMC44LTAuNSwxLjItMS4zLDEuMi0yLjJjMC0wLjgtMC4yLTEuNC0wLjYtMS43cy0xLTAuNy0xLjgtMC45Yy0wLjYtMC4yLTEuMi0wLjMtMS45LTAuNHMtMS40LTAuMi0yLjItMC40Yy0xLjYtMC4zLTIuNy0wLjktMy41LTEuN2MtMC44LTAuOC0xLjEtMS45LTEuMS0zLjFjMC0xLjUsMC42LTIuNywxLjktMy42YzEuMy0wLjksMi44LTEuNCw0LjgtMS40YzEuMiwwLDIuNCwwLjEsMy40LDAuNGMxLDAuMiwyLDAuNSwyLjgsMC45djIuOGgtMC4yYy0wLjctMC42LTEuNi0xLTIuNy0xLjRjLTEuMS0wLjQtMi4yLTAuNi0zLjQtMC42Yy0xLjMsMC0yLjMsMC4zLTMsMC44Yy0wLjgsMC41LTEuMSwxLjItMS4xLDJjMCwwLjcsMC4yLDEuMywwLjYsMS43YzAuNCwwLjQsMS4xLDAuNywyLDFjMC41LDAuMSwxLjIsMC4yLDIuMiwwLjRjMC45LDAuMiwxLjcsMC4zLDIuNCwwLjVjMS4zLDAuMywyLjMsMC45LDMsMS42Qzc2LjcsMjguMiw3Ny4xLDI5LjIsNzcuMSwzMC41eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik05Mi42LDI4LjhjMCwxLjEtMC4yLDIuMS0wLjUsM2MtMC4zLDAuOS0wLjcsMS42LTEuMywyLjNjLTAuNSwwLjYtMS4xLDEtMS45LDEuNHMtMS41LDAuNS0yLjMsMC41Yy0wLjcsMC0xLjMtMC4xLTEuOS0wLjJjLTAuNi0wLjItMS4xLTAuNC0xLjctMC43djUuNmgtMi4yVjIyLjNoMi4ydjEuNGMwLjYtMC41LDEuMy0wLjksMi0xLjNjMC43LTAuMywxLjUtMC41LDIuNC0wLjVjMS42LDAsMi44LDAuNiwzLjcsMS44QzkyLjIsMjQuOSw5Mi42LDI2LjYsOTIuNiwyOC44eiBNOTAuMywyOC44YzAtMS42LTAuMy0yLjgtMC44LTMuNkM4OC45LDI0LjQsODguMSwyNCw4NywyNGMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0M4OS45LDMxLjcsOTAuMywzMC41LDkwLjMsMjguOHoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTA3LjUsMjkuMWgtOS44YzAsMC44LDAuMSwxLjUsMC40LDIuMWMwLjIsMC42LDAuNiwxLjEsMSwxLjVjMC40LDAuNCwwLjksMC43LDEuNSwwLjljMC42LDAuMiwxLjIsMC4zLDEuOSwwLjNjMC45LDAsMS44LTAuMiwyLjctMC41YzAuOS0wLjQsMS42LTAuNywyLTEuMWgwLjF2Mi40Yy0wLjgsMC4zLTEuNSwwLjYtMi4zLDAuOGMtMC44LDAuMi0xLjYsMC4zLTIuNSwwLjNjLTIuMiwwLTMuOS0wLjYtNS4yLTEuOHMtMS45LTIuOS0xLjktNS4xYzAtMi4yLDAuNi0zLjksMS44LTUuMmMxLjItMS4zLDIuNy0xLjksNC43LTEuOWMxLjgsMCwzLjIsMC41LDQuMSwxLjZjMSwxLDEuNSwyLjUsMS41LDQuNVYyOS4xeiBNMTA1LjMsMjcuNGMwLTEuMi0wLjMtMi4xLTAuOS0yLjdjLTAuNi0wLjYtMS41LTEtMi43LTFjLTEuMiwwLTIuMiwwLjQtMi45LDEuMWMtMC43LDAuNy0xLjEsMS42LTEuMiwyLjZIMTA1LjN6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTExMy4zLDM1LjZoLTIuMlYxN2gyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTI5LjcsMjguOGMwLDEuMS0wLjIsMi4xLTAuNSwzYy0wLjMsMC45LTAuNywxLjYtMS4zLDIuM2MtMC41LDAuNi0xLjEsMS0xLjksMS40cy0xLjUsMC41LTIuMywwLjVjLTAuNywwLTEuMy0wLjEtMS45LTAuMmMtMC42LTAuMi0xLjEtMC40LTEuNy0wLjd2NS42SDExOFYyMi4zaDIuMnYxLjRjMC42LTAuNSwxLjMtMC45LDItMS4zYzAuNy0wLjMsMS41LTAuNSwyLjQtMC41YzEuNiwwLDIuOCwwLjYsMy43LDEuOEMxMjkuMywyNC45LDEyOS43LDI2LjYsMTI5LjcsMjguOHogTTEyNy40LDI4LjhjMC0xLjYtMC4zLTIuOC0wLjgtMy42Yy0wLjUtMC44LTEuNC0xLjItMi41LTEuMmMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0MxMjcuMSwzMS43LDEyNy40LDMwLjUsMTI3LjQsMjguOHoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTQzLjgsMzUuNmgtMi4ydi0xLjRjLTAuMiwwLjEtMC41LDAuMy0wLjgsMC42Yy0wLjMsMC4yLTAuNywwLjQtMSwwLjZjLTAuNCwwLjItMC44LDAuMy0xLjMsMC41Yy0wLjUsMC4xLTEuMSwwLjItMS43LDAuMmMtMS4yLDAtMi4yLTAuNC0zLTEuMnMtMS4yLTEuOC0xLjItM2MwLTEsMC4yLTEuOCwwLjYtMi40YzAuNC0wLjYsMS0xLjEsMS44LTEuNWMwLjgtMC40LDEuOC0wLjYsMi45LTAuN2MxLjEtMC4xLDIuNC0wLjIsMy43LTAuM3YtMC4zYzAtMC41LTAuMS0wLjktMC4zLTEuM2MtMC4yLTAuMy0wLjQtMC42LTAuOC0wLjhjLTAuMy0wLjItMC43LTAuMy0xLjEtMC40cy0wLjktMC4xLTEuNC0wLjFjLTAuNiwwLTEuMiwwLjEtMiwwLjJzLTEuNSwwLjQtMi4yLDAuN2gtMC4xdi0yLjNjMC40LTAuMSwxLjEtMC4zLDEuOS0wLjRjMC44LTAuMSwxLjYtMC4yLDIuNC0wLjJjMC45LDAsMS44LDAuMSwyLjQsMC4yYzAuNywwLjIsMS4zLDAuNCwxLjgsMC44YzAuNSwwLjQsMC45LDAuOCwxLjEsMS40czAuNCwxLjMsMC40LDIuMlYzNS42eiBNMTQxLjUsMzIuM3YtMy43Yy0wLjcsMC0xLjUsMC4xLTIuNCwwLjJzLTEuNywwLjItMi4yLDAuM2MtMC42LDAuMi0xLjIsMC41LTEuNiwwLjlzLTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdzMS4yLDAuNiwyLjEsMC42YzAuOCwwLDEuNS0wLjIsMi4yLTAuNUMxNDAuNCwzMy4xLDE0MSwzMi43LDE0MS41LDMyLjN6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE1OS4zLDM1LjZoLTIuMnYtMS41Yy0wLjgsMC42LTEuNSwxLjEtMi4yLDEuNHMtMS41LDAuNS0yLjMsMC41Yy0xLjQsMC0yLjUtMC40LTMuMy0xLjNzLTEuMi0yLjEtMS4yLTMuOHYtOC42aDIuMnY3LjZjMCwwLjcsMCwxLjMsMC4xLDEuN2MwLjEsMC41LDAuMiwwLjksMC40LDEuMmMwLjIsMC4zLDAuNSwwLjYsMC44LDAuOGMwLjMsMC4yLDAuOCwwLjIsMS41LDAuMmMwLjYsMCwxLjItMC4yLDEuOS0wLjVjMC43LTAuMywxLjMtMC43LDEuOS0xLjJ2LTkuOWgyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTczLjUsMzEuN2MwLDEuMi0wLjUsMi4yLTEuNSwzcy0yLjQsMS4yLTQuMSwxLjJjLTEsMC0xLjktMC4xLTIuNy0wLjRjLTAuOC0wLjItMS41LTAuNS0yLjEtMC44di0yLjVoMC4xYzAuNywwLjUsMS41LDEsMi40LDEuM2MwLjksMC4zLDEuNywwLjUsMi41LDAuNWMxLDAsMS44LTAuMiwyLjMtMC41YzAuNi0wLjMsMC44LTAuOCwwLjgtMS41YzAtMC41LTAuMi0wLjktMC41LTEuMnMtMC45LTAuNS0xLjctMC43Yy0wLjMtMC4xLTAuNy0wLjItMS4yLTAuM2MtMC41LTAuMS0xLTAuMi0xLjQtMC4zYy0xLjItMC4zLTItMC44LTIuNS0xLjRjLTAuNS0wLjYtMC43LTEuMy0wLjctMi4yYzAtMC41LDAuMS0xLjEsMC4zLTEuNWMwLjItMC41LDAuNi0wLjksMS0xLjNjMC40LTAuNCwxLTAuNywxLjctMC45YzAuNy0wLjIsMS41LTAuMywyLjMtMC4zYzAuOCwwLDEuNiwwLjEsMi40LDAuM2MwLjgsMC4yLDEuNSwwLjQsMiwwLjd2Mi40aC0wLjFjLTAuNi0wLjQtMS4zLTAuOC0yLjEtMS4xYy0wLjgtMC4zLTEuNi0wLjQtMi40LTAuNGMtMC44LDAtMS41LDAuMi0yLjEsMC41Yy0wLjYsMC4zLTAuOCwwLjgtMC44LDEuNGMwLDAuNSwwLjIsMSwwLjUsMS4yYzAuMywwLjMsMC45LDAuNSwxLjYsMC43YzAuNCwwLjEsMC45LDAuMiwxLjQsMC4zczAuOSwwLjIsMS4zLDAuM2MxLDAuMiwxLjgsMC42LDIuNCwxLjJDMTczLjIsMzAsMTczLjUsMzAuOCwxNzMuNSwzMS43eiIvPjwvZz48L2c+PHBhdGggY2xhc3M9InN0MCIgZD0iTTI4LjcsMzcuNWgtNi4yYy0wLjUsMC0wLjktMC40LTAuOS0wLjlWMTYuOWMwLTAuNSwwLjQtMC45LDAuOS0wLjloNi4yYzAuNSwwLDAuOSwwLjQsMC45LDAuOXYxOS43QzI5LjYsMzcuMSwyOS4yLDM3LjUsMjguNywzNy41eiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MS41LDM3LjZoLTYuMmMtMC41LDAtMC45LTAuNC0wLjktMC45VjE2LjljMC0wLjUsMC40LTAuOSwwLjktMC45aDYuMmMwLjUsMCwwLjksMC40LDAuOSwwLjl2MTkuN0M0Mi40LDM3LjIsNDIsMzcuNiw0MS41LDM3LjZ6Ii8+PC9zdmc+"/> </a> <a href="#" class="SelfTest" target="_blank" style="text-decoration: none;"> <img style="height:20px;" alt="Sjlvtest" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTgwLjYgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTgwLjYgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6bm9uZTtzdHJva2U6dXJsKCNTVkdJRF8xXyk7c3Ryb2tlLXdpZHRoOjYuNzc0MjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9LnN0M3tmaWxsOiMxRTFFMUM7fTwvc3R5bGU+PGc+PHJlY3QgeD0iMC41IiB5PSIwLjUiIGNsYXNzPSJzdDAiIHdpZHRoPSIxNzkuNSIgaGVpZ2h0PSI1Mi40Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE3OS41LDF2NTEuNEgxVjFIMTc5LjUgTTE4MC42LDBIMHY1My40aDE4MC42VjBMMTgwLjYsMHoiLz48L2c+PGc+PHBhdGggY2xhc3M9InN0MCIgZD0iTTMxLjksNDcuOGMtNS41LTAuMS0xMC43LTIuMy0xNC42LTYuMmMtMy45LTQtNi05LjItNS45LTE0LjhjMC4xLTExLjMsOS40LTIwLjYsMjAuOC0yMC42bDAuMiwwYzUuNSwwLjEsMTAuNywyLjMsMTQuNiw2LjJjMy45LDQsNiw5LjIsNS45LDE0LjhjLTAuMSwxMS4zLTkuNCwyMC42LTIwLjgsMjAuNkwzMS45LDQ3Ljh6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTMyLjEsNS43djFsMC4yLDBjNS40LDAuMSwxMC41LDIuMiwxNC4zLDYuMWMzLjgsMy45LDUuOCw5LDUuOCwxNC40Yy0wLjEsMTEuMS05LjIsMjAuMS0yMC4zLDIwLjFsLTAuMiwwYy01LjQtMC4xLTEwLjUtMi4yLTE0LjMtNi4xYy0zLjgtMy45LTUuOC05LTUuOC0xNC40YzAuMS0xMS4xLDkuMi0yMC4xLDIwLjMtMjAuMUwzMi4xLDUuNyBNMzIuMSw1LjdjLTExLjYsMC0yMS4xLDkuNC0yMS4zLDIxYy0wLjEsMTEuNyw5LjMsMjEuNCwyMSwyMS41YzAuMSwwLDAuMSwwLDAuMiwwYzExLjYsMCwyMS4xLTkuNCwyMS4zLTIxYzAuMS0xMS43LTkuMy0yMS40LTIxLTIxLjVDMzIuMyw1LjcsMzIuMiw1LjcsMzIuMSw1LjdMMzIuMSw1Ljd6Ii8+PC9nPjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTMuMzkwNCIgeTE9Ii0zMDMuMjA3NyIgeDI9IjUwLjYwNDMiIHkyPSItMzAzLjIwNzciIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIC0xIDY0LjAwMDUgLTI4My41MzY1KSI+PHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0U0MTkxMyIvPjxzdG9wICBvZmZzZXQ9IjkuNzQ0MDIwZS0wMiIgc3R5bGU9InN0b3AtY29sb3I6I0VBNjUxNiIvPjxzdG9wICBvZmZzZXQ9IjAuMjE0OCIgc3R5bGU9InN0b3AtY29sb3I6I0YzQTUxOCIvPjxzdG9wICBvZmZzZXQ9IjAuMzEyMSIgc3R5bGU9InN0b3AtY29sb3I6I0Y5Q0QxQSIvPjxzdG9wICBvZmZzZXQ9IjAuMzg0IiBzdHlsZT0ic3RvcC1jb2xvcjojRkRFMzFBIi8+PHN0b3AgIG9mZnNldD0iMC40MjI4IiBzdHlsZT0ic3RvcC1jb2xvcjojRkVFQjFBIi8+PHN0b3AgIG9mZnNldD0iMC42MjMxIiBzdHlsZT0ic3RvcC1jb2xvcjojREZERTIwIi8+PHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6IzAwOTI0NSIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InN0MiIgZD0iTTQ3LjIsMjYuN2MtMi4yLTE4LjYtMjcuOC0xOS0zMC40LDAiLz48Zz48cGF0aCBjbGFzcz0ic3QzIiBkPSJNMjcuNywyNy4zbDguOC0xNS44bC0xLjgsMThjLTAuNiwxLjktMi43LDMtNC42LDIuNFMyNy4xLDI5LjIsMjcuNywyNy4zeiIvPjwvZz48Zz48Zz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNNzYuNSwzMC41YzAsMC43LTAuMiwxLjQtMC41LDJzLTAuOCwxLjItMS40LDEuN2MtMC42LDAuNS0xLjQsMC45LTIuMiwxLjJjLTAuOCwwLjMtMS45LDAuNC0zLjEsMC40Yy0xLjMsMC0yLjQtMC4xLTMuNC0wLjRjLTEtMC4yLTIuMS0wLjYtMy4xLTEuMXYtM0g2M2MwLjksMC43LDEuOSwxLjMsMy4xLDEuN2MxLjIsMC40LDIuMywwLjYsMy4zLDAuNmMxLjUsMCwyLjYtMC4zLDMuNC0wLjhjMC44LTAuNSwxLjItMS4zLDEuMi0yLjJjMC0wLjgtMC4yLTEuNC0wLjYtMS43cy0xLTAuNy0xLjgtMC45Yy0wLjYtMC4yLTEuMi0wLjMtMS45LTAuNGMtMC43LTAuMS0xLjQtMC4yLTIuMi0wLjRjLTEuNi0wLjMtMi43LTAuOS0zLjUtMS43Yy0wLjgtMC44LTEuMS0xLjktMS4xLTMuMWMwLTEuNSwwLjYtMi43LDEuOS0zLjZjMS4zLTAuOSwyLjgtMS40LDQuOC0xLjRjMS4yLDAsMi40LDAuMSwzLjQsMC40YzEsMC4yLDIsMC41LDIuOCwwLjl2Mi44aC0wLjJjLTAuNy0wLjYtMS42LTEtMi43LTEuNGMtMS4xLTAuNC0yLjItMC42LTMuNC0wLjZjLTEuMywwLTIuMywwLjMtMywwLjhjLTAuOCwwLjUtMS4xLDEuMi0xLjEsMmMwLDAuNywwLjIsMS4zLDAuNiwxLjdjMC40LDAuNCwxLjEsMC43LDIsMWMwLjUsMC4xLDEuMiwwLjIsMi4yLDAuNGMwLjksMC4yLDEuNywwLjMsMi40LDAuNWMxLjMsMC4zLDIuMywwLjksMywxLjZDNzYuMSwyOC4zLDc2LjUsMjkuMyw3Ni41LDMwLjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTg0LjMsMzUuOWMwLDEuNi0wLjQsMi43LTEuMiwzLjVzLTEuOSwxLjItMy4yLDEuMmMtMC4zLDAtMC43LDAtMS4zLTAuMWMtMC41LTAuMS0xLTAuMS0xLjMtMC4ydi0yLjFoMC4xYzAuMiwwLjEsMC41LDAuMiwwLjksMC4zYzAuNCwwLjEsMC43LDAuMiwxLjEsMC4yYzAuNiwwLDEtMC4xLDEuNC0wLjJjMC4zLTAuMiwwLjYtMC40LDAuOC0wLjdjMC4yLTAuMywwLjMtMC43LDAuMy0xLjFjMC4xLTAuNCwwLjEtMSwwLjEtMS42VjI0LjJoLTIuOHYtMS45aDVWMzUuOXogTTg0LjUsMjAuMWgtMi41di0yLjNoMi41VjIwLjF6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTk5LjMsMzUuNkg5N3YtMS40Yy0wLjIsMC4xLTAuNSwwLjMtMC44LDAuNnMtMC43LDAuNC0xLDAuNmMtMC40LDAuMi0wLjgsMC4zLTEuMywwLjVjLTAuNSwwLjEtMS4xLDAuMi0xLjcsMC4yYy0xLjIsMC0yLjItMC40LTMtMS4yQzg4LjQsMzQsODgsMzMsODgsMzEuN2MwLTEsMC4yLTEuOCwwLjYtMi40YzAuNC0wLjYsMS0xLjEsMS44LTEuNWMwLjgtMC40LDEuOC0wLjYsMi45LTAuN2MxLjEtMC4xLDIuNC0wLjIsMy43LTAuM3YtMC4zYzAtMC41LTAuMS0wLjktMC4zLTEuM3MtMC40LTAuNi0wLjgtMC44Yy0wLjMtMC4yLTAuNy0wLjMtMS4xLTAuNGMtMC40LTAuMS0wLjktMC4xLTEuNC0wLjFjLTAuNiwwLTEuMiwwLjEtMiwwLjJjLTAuNywwLjItMS41LDAuNC0yLjIsMC43aC0wLjF2LTIuM2MwLjQtMC4xLDEuMS0wLjMsMS45LTAuNGMwLjgtMC4xLDEuNi0wLjIsMi40LTAuMmMwLjksMCwxLjgsMC4xLDIuNCwwLjJjMC43LDAuMiwxLjMsMC40LDEuOCwwLjhjMC41LDAuNCwwLjksMC44LDEuMSwxLjRzMC40LDEuMywwLjQsMi4yVjM1LjZ6IE05NywzMi4zdi0zLjdjLTAuNywwLTEuNSwwLjEtMi40LDAuMlM5MywyOSw5Mi40LDI5LjFjLTAuNiwwLjItMS4yLDAuNS0xLjYsMC45Yy0wLjQsMC40LTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdjMC41LDAuNCwxLjIsMC42LDIuMSwwLjZjMC44LDAsMS41LTAuMiwyLjItMC41Qzk1LjksMzMuMSw5Ni41LDMyLjcsOTcsMzIuM3ogTTkyLjgsMjAuMWgtMi40di0yLjNoMi40VjIwLjF6IE05Ny44LDIwLjFoLTIuNHYtMi4zaDIuNFYyMC4xeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xMDYuMSwzNS42aC0yLjJWMTcuMWgyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTIyLjIsMjIuM2wtNS40LDEzLjNoLTIuMmwtNS4zLTEzLjNoMi40bDQuMSwxMC42bDQuMS0xMC42SDEyMi4yeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xMzIuMywzNS41Yy0wLjQsMC4xLTAuOSwwLjItMS40LDAuM2MtMC41LDAuMS0wLjksMC4xLTEuMywwLjFjLTEuNCwwLTIuNC0wLjQtMy4xLTEuMWMtMC43LTAuNy0xLjEtMS45LTEuMS0zLjV2LTcuMWgtMS41di0xLjloMS41di0zLjhoMi4ydjMuOGg0LjZ2MS45aC00LjZ2Ni4xYzAsMC43LDAsMS4yLDAsMS42YzAsMC40LDAuMSwwLjgsMC4zLDEuMWMwLjIsMC4zLDAuNCwwLjUsMC43LDAuN2MwLjMsMC4xLDAuOCwwLjIsMS40LDAuMmMwLjQsMCwwLjctMC4xLDEuMS0wLjJjMC40LTAuMSwwLjctMC4yLDAuOS0wLjNoMC4xVjM1LjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE0Ni40LDI5LjJoLTkuOGMwLDAuOCwwLjEsMS41LDAuNCwyLjFjMC4yLDAuNiwwLjYsMS4xLDEsMS41YzAuNCwwLjQsMC45LDAuNywxLjUsMC45YzAuNiwwLjIsMS4yLDAuMywxLjksMC4zYzAuOSwwLDEuOC0wLjIsMi43LTAuNWMwLjktMC40LDEuNi0wLjcsMi0xLjFoMC4xdjIuNGMtMC44LDAuMy0xLjUsMC42LTIuMywwLjhzLTEuNiwwLjMtMi41LDAuM2MtMi4yLDAtMy45LTAuNi01LjItMS44Yy0xLjItMS4yLTEuOS0yLjktMS45LTUuMWMwLTIuMiwwLjYtMy45LDEuOC01LjJjMS4yLTEuMywyLjctMS45LDQuNy0xLjljMS44LDAsMy4yLDAuNSw0LjEsMS42YzEsMSwxLjUsMi41LDEuNSw0LjVWMjkuMnogTTE0NC4yLDI3LjVjMC0xLjItMC4zLTIuMS0wLjktMi43cy0xLjUtMS0yLjctMWMtMS4yLDAtMi4yLDAuNC0yLjksMS4xYy0wLjcsMC43LTEuMSwxLjYtMS4yLDIuNkgxNDQuMnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTU5LjUsMzEuN2MwLDEuMi0wLjUsMi4yLTEuNSwzcy0yLjQsMS4yLTQuMSwxLjJjLTEsMC0xLjktMC4xLTIuNy0wLjRjLTAuOC0wLjItMS41LTAuNS0yLjEtMC44di0yLjVoMC4xYzAuNywwLjUsMS41LDEsMi40LDEuM3MxLjcsMC41LDIuNSwwLjVjMSwwLDEuOC0wLjIsMi4zLTAuNWMwLjYtMC4zLDAuOC0wLjgsMC44LTEuNWMwLTAuNS0wLjItMC45LTAuNS0xLjJzLTAuOS0wLjUtMS43LTAuN2MtMC4zLTAuMS0wLjctMC4yLTEuMi0wLjNjLTAuNS0wLjEtMS0wLjItMS40LTAuM2MtMS4yLTAuMy0yLTAuOC0yLjUtMS40Yy0wLjUtMC42LTAuNy0xLjMtMC43LTIuMmMwLTAuNSwwLjEtMS4xLDAuMy0xLjVjMC4yLTAuNSwwLjYtMC45LDEtMS4zYzAuNC0wLjQsMS0wLjcsMS43LTAuOWMwLjctMC4yLDEuNS0wLjMsMi4zLTAuM2MwLjgsMCwxLjYsMC4xLDIuNCwwLjNjMC44LDAuMiwxLjUsMC40LDIsMC43djIuNGgtMC4xYy0wLjYtMC40LTEuMy0wLjgtMi4xLTEuMWMtMC44LTAuMy0xLjYtMC40LTIuNC0wLjRjLTAuOCwwLTEuNSwwLjItMi4xLDAuNWMtMC42LDAuMy0wLjgsMC44LTAuOCwxLjRjMCwwLjUsMC4yLDEsMC41LDEuMmMwLjMsMC4zLDAuOSwwLjUsMS42LDAuN2MwLjQsMC4xLDAuOSwwLjIsMS40LDAuM2MwLjUsMC4xLDAuOSwwLjIsMS4zLDAuM2MxLDAuMiwxLjgsMC42LDIuNCwxLjJDMTU5LjIsMzAsMTU5LjUsMzAuOCwxNTkuNSwzMS43eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNjkuOSwzNS41Yy0wLjQsMC4xLTAuOSwwLjItMS40LDAuM2MtMC41LDAuMS0wLjksMC4xLTEuMywwLjFjLTEuNCwwLTIuNC0wLjQtMy4xLTEuMWMtMC43LTAuNy0xLjEtMS45LTEuMS0zLjV2LTcuMWgtMS41di0xLjloMS41di0zLjhoMi4ydjMuOGg0LjZ2MS45aC00LjZ2Ni4xYzAsMC43LDAsMS4yLDAsMS42YzAsMC40LDAuMSwwLjgsMC4zLDEuMWMwLjIsMC4zLDAuNCwwLjUsMC43LDAuN2MwLjMsMC4xLDAuOCwwLjIsMS40LDAuMmMwLjQsMCwwLjctMC4xLDEuMS0wLjJjMC40LTAuMSwwLjctMC4yLDAuOS0wLjNoMC4xVjM1LjV6Ii8+PC9nPjwvZz48L3N2Zz4="/> </a> <a href="#" class="PlayLimit" target="_blank" style="text-decoration: none;"> <img style="height:20px;" alt="Spelgrnser" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjE5LjYgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMjE5LjYgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6IzAwOTczOTt9LnN0M3tmaWxsOiNGRkZGRkY7c3Ryb2tlOiMwMDk3Mzk7c3Ryb2tlLXdpZHRoOjMuODcxO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO30uc3Q0e2ZpbGw6bm9uZTtzdHJva2U6IzAwOTczOTtzdHJva2Utd2lkdGg6MS45MzU1O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO308L3N0eWxlPjxnPjxyZWN0IHg9IjAuNSIgeT0iMC41IiBjbGFzcz0ic3QwIiB3aWR0aD0iMjE4LjUiIGhlaWdodD0iNTIuNCIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0yMTguNSwxdjUxLjRIMVYxSDIxOC41IE0yMTkuNiwwSDB2NTMuNGgyMTkuNlYwTDIxOS42LDB6Ii8+PC9nPjxnPjxnPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik03OC4yLDMwLjZjMCwwLjctMC4yLDEuNC0wLjUsMmMtMC4zLDAuNy0wLjgsMS4yLTEuNCwxLjdjLTAuNiwwLjUtMS40LDAuOS0yLjIsMS4yYy0wLjgsMC4zLTEuOSwwLjQtMy4xLDAuNGMtMS4zLDAtMi40LTAuMS0zLjQtMC40Yy0xLTAuMi0yLjEtMC42LTMuMS0xLjF2LTIuOWgwLjJjMC45LDAuNywxLjksMS4zLDMuMSwxLjdjMS4yLDAuNCwyLjMsMC42LDMuMywwLjZjMS41LDAsMi42LTAuMywzLjQtMC44YzAuOC0wLjUsMS4yLTEuMywxLjItMi4yYzAtMC44LTAuMi0xLjQtMC42LTEuN3MtMS0wLjctMS44LTAuOWMtMC42LTAuMi0xLjItMC4zLTEuOS0wLjRjLTAuNy0wLjEtMS40LTAuMi0yLjItMC40Yy0xLjYtMC4zLTIuNy0wLjktMy41LTEuN3MtMS4xLTEuOS0xLjEtMy4xYzAtMS41LDAuNi0yLjcsMS45LTMuNmMxLjMtMC45LDIuOC0xLjQsNC44LTEuNGMxLjIsMCwyLjQsMC4xLDMuNCwwLjRjMSwwLjIsMiwwLjUsMi44LDAuOXYyLjhoLTAuMmMtMC43LTAuNi0xLjYtMS0yLjctMS40Yy0xLjEtMC40LTIuMi0wLjYtMy40LTAuNmMtMS4zLDAtMi4zLDAuMy0zLDAuOHMtMS4xLDEuMi0xLjEsMmMwLDAuNywwLjIsMS4zLDAuNiwxLjdjMC40LDAuNCwxLjEsMC43LDIsMWMwLjUsMC4xLDEuMiwwLjIsMi4yLDAuNGMwLjksMC4yLDEuNywwLjMsMi40LDAuNWMxLjMsMC4zLDIuMywwLjksMywxLjZDNzcuOSwyOC4zLDc4LjIsMjkuMyw3OC4yLDMwLjZ6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTkzLjYsMjguOGMwLDEuMS0wLjIsMi4xLTAuNSwzYy0wLjMsMC45LTAuNywxLjYtMS4zLDIuM2MtMC41LDAuNi0xLjEsMS0xLjgsMS40Yy0wLjcsMC4zLTEuNSwwLjUtMi4zLDAuNWMtMC43LDAtMS4zLTAuMS0xLjktMC4yYy0wLjYtMC4yLTEuMS0wLjQtMS43LTAuN3Y1LjZoLTIuMlYyMi4zaDIuMnYxLjRjMC42LTAuNSwxLjMtMC45LDItMS4zYzAuNy0wLjMsMS41LTAuNSwyLjQtMC41YzEuNiwwLDIuOCwwLjYsMy43LDEuOEM5My4yLDI1LDkzLjYsMjYuNyw5My42LDI4Ljh6IE05MS4zLDI4LjljMC0xLjYtMC4zLTIuOC0wLjgtMy42Yy0wLjUtMC44LTEuNC0xLjItMi41LTEuMmMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0M5MSwzMS44LDkxLjMsMzAuNSw5MS4zLDI4Ljl6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTEwOC4zLDI5LjJoLTkuOGMwLDAuOCwwLjEsMS41LDAuNCwyLjFjMC4yLDAuNiwwLjYsMS4xLDEsMS41YzAuNCwwLjQsMC45LDAuNywxLjUsMC45czEuMiwwLjMsMS45LDAuM2MwLjksMCwxLjgtMC4yLDIuNy0wLjVjMC45LTAuNCwxLjYtMC43LDItMS4xaDAuMXYyLjRjLTAuOCwwLjMtMS41LDAuNi0yLjMsMC44cy0xLjYsMC4zLTIuNSwwLjNjLTIuMiwwLTMuOS0wLjYtNS4yLTEuOGMtMS4yLTEuMi0xLjktMi45LTEuOS01LjFjMC0yLjIsMC42LTMuOSwxLjgtNS4yYzEuMi0xLjMsMi43LTEuOSw0LjctMS45YzEuOCwwLDMuMiwwLjUsNC4xLDEuNmMxLDEsMS41LDIuNSwxLjUsNC41VjI5LjJ6IE0xMDYuMiwyNy41YzAtMS4yLTAuMy0yLjEtMC45LTIuN2MtMC42LTAuNi0xLjUtMS0yLjctMWMtMS4yLDAtMi4yLDAuNC0yLjksMS4xYy0wLjcsMC43LTEuMSwxLjYtMS4yLDIuNkgxMDYuMnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTE0LjEsMzUuNmgtMi4yVjE3LjFoMi4yVjM1LjZ6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTEyOS40LDM0LjFjMCwyLjMtMC41LDMuOS0xLjUsNWMtMSwxLjEtMi42LDEuNi00LjcsMS42Yy0wLjcsMC0xLjQsMC0yLjEtMC4xYy0wLjctMC4xLTEuMy0wLjItMi0wLjR2LTIuM2gwLjFjMC40LDAuMSwwLjksMC4zLDEuNywwLjVzMS42LDAuMywyLjQsMC4zYzAuOCwwLDEuNC0wLjEsMS45LTAuM2MwLjUtMC4yLDAuOS0wLjQsMS4yLTAuOGMwLjMtMC4zLDAuNS0wLjcsMC42LTEuMWMwLjEtMC40LDAuMi0wLjksMC4yLTEuNXYtMS4yYy0wLjcsMC41LTEuMywwLjktMS45LDEuMnMtMS40LDAuNC0yLjMsMC40Yy0xLjYsMC0yLjgtMC42LTMuOC0xLjdjLTAuOS0xLjEtMS40LTIuOC0xLjQtNC44YzAtMS4xLDAuMi0yLjEsMC41LTNjMC4zLTAuOCwwLjgtMS41LDEuMy0yLjFjMC41LTAuNiwxLjEtMSwxLjktMS4zYzAuNy0wLjMsMS41LTAuNSwyLjItMC41YzAuOCwwLDEuNCwwLjEsMS45LDAuMnMxLjEsMC40LDEuNiwwLjdsMC4xLTAuNmgyLjFWMzQuMXogTTEyNy4yLDMydi03LjJjLTAuNi0wLjMtMS4xLTAuNS0xLjctMC42Yy0wLjUtMC4xLTEtMC4yLTEuNS0wLjJjLTEuMiwwLTIuMiwwLjQtMi45LDEuMnMtMS4xLDItMS4xLDMuNmMwLDEuNSwwLjMsMi42LDAuOCwzLjRjMC41LDAuOCwxLjQsMS4yLDIuNiwxLjJjMC43LDAsMS4zLTAuMSwyLTAuNFMxMjYuNiwzMi40LDEyNy4yLDMyeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNDIuMiwyNC44aC0wLjFjLTAuMy0wLjEtMC43LTAuMS0xLTAuMmMtMC4zLDAtMC43LTAuMS0xLjEtMC4xYy0wLjcsMC0xLjQsMC4yLTIsMC41Yy0wLjYsMC4zLTEuMywwLjctMS45LDEuMnY5LjRIMTM0VjIyLjNoMi4ydjJjMC45LTAuNywxLjctMS4yLDIuMy0xLjVjMC43LTAuMywxLjQtMC40LDIuMS0wLjRjMC40LDAsMC43LDAsMC44LDBjMC4yLDAsMC40LDAuMSwwLjgsMC4xVjI0Ljh6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE1NC44LDM1LjZoLTIuMnYtMS40Yy0wLjIsMC4xLTAuNSwwLjMtMC44LDAuNnMtMC43LDAuNC0xLDAuNmMtMC40LDAuMi0wLjgsMC4zLTEuMywwLjVjLTAuNSwwLjEtMS4xLDAuMi0xLjcsMC4yYy0xLjIsMC0yLjItMC40LTMtMS4yYy0wLjgtMC44LTEuMi0xLjgtMS4yLTNjMC0xLDAuMi0xLjgsMC42LTIuNGMwLjQtMC42LDEtMS4xLDEuOC0xLjVjMC44LTAuNCwxLjgtMC42LDIuOS0wLjdzMi40LTAuMiwzLjctMC4zdi0wLjNjMC0wLjUtMC4xLTAuOS0wLjMtMS4zYy0wLjItMC4zLTAuNC0wLjYtMC44LTAuOGMtMC4zLTAuMi0wLjctMC4zLTEuMS0wLjRDMTUwLDI0LDE0OS41LDI0LDE0OSwyNGMtMC42LDAtMS4yLDAuMS0yLDAuMmMtMC43LDAuMi0xLjUsMC40LTIuMiwwLjdoLTAuMXYtMi4zYzAuNC0wLjEsMS4xLTAuMiwxLjktMC40YzAuOC0wLjEsMS42LTAuMiwyLjQtMC4yYzAuOSwwLDEuOCwwLjEsMi40LDAuMmMwLjcsMC4yLDEuMywwLjQsMS44LDAuOGMwLjUsMC40LDAuOSwwLjgsMS4xLDEuNGMwLjMsMC42LDAuNCwxLjMsMC40LDIuMlYzNS42eiBNMTUyLjYsMzIuM3YtMy43Yy0wLjcsMC0xLjUsMC4xLTIuNCwwLjJzLTEuNywwLjItMi4yLDAuM2MtMC42LDAuMi0xLjIsMC41LTEuNiwwLjlzLTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdzMS4yLDAuNiwyLjEsMC42YzAuOCwwLDEuNS0wLjIsMi4yLTAuNUMxNTEuNCwzMy4xLDE1MiwzMi44LDE1Mi42LDMyLjN6IE0xNDguNCwyMC4xSDE0NnYtMi4zaDIuNFYyMC4xeiBNMTUzLjMsMjAuMWgtMi40di0yLjNoMi40VjIwLjF6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE3MC4zLDM1LjZoLTIuMnYtNy42YzAtMC42LDAtMS4yLTAuMS0xLjdzLTAuMi0xLTAuNC0xLjNjLTAuMi0wLjMtMC41LTAuNi0wLjktMC43Yy0wLjQtMC4yLTAuOS0wLjItMS41LTAuMmMtMC42LDAtMS4yLDAuMi0xLjksMC41Yy0wLjcsMC4zLTEuMywwLjctMS45LDEuMnY5LjloLTIuMlYyMi4zaDIuMnYxLjVjMC43LTAuNiwxLjQtMSwyLjItMS40YzAuNy0wLjMsMS41LTAuNSwyLjMtMC41YzEuNCwwLDIuNSwwLjQsMy4zLDEuM2MwLjgsMC45LDEuMSwyLjEsMS4xLDMuN1YzNS42eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xODQuMywzMS44YzAsMS4yLTAuNSwyLjItMS41LDNjLTEsMC44LTIuNCwxLjItNC4xLDEuMmMtMSwwLTEuOS0wLjEtMi43LTAuNGMtMC44LTAuMi0xLjUtMC41LTIuMS0wLjh2LTIuNWgwLjFjMC43LDAuNSwxLjUsMSwyLjQsMS4zczEuNywwLjUsMi41LDAuNWMxLDAsMS44LTAuMiwyLjMtMC41YzAuNi0wLjMsMC44LTAuOCwwLjgtMS41YzAtMC41LTAuMi0wLjktMC41LTEuMnMtMC45LTAuNS0xLjctMC43Yy0wLjMtMC4xLTAuNy0wLjItMS4yLTAuM2MtMC41LTAuMS0xLTAuMi0xLjQtMC4zYy0xLjItMC4zLTItMC44LTIuNS0xLjRjLTAuNS0wLjYtMC43LTEuMy0wLjctMi4yYzAtMC41LDAuMS0xLjEsMC4zLTEuNWMwLjItMC41LDAuNi0wLjksMS0xLjNjMC40LTAuNCwxLTAuNywxLjctMC45YzAuNy0wLjIsMS41LTAuMywyLjMtMC4zYzAuOCwwLDEuNiwwLjEsMi40LDAuM2MwLjgsMC4yLDEuNSwwLjQsMiwwLjd2Mi40aC0wLjFjLTAuNi0wLjQtMS4zLTAuOC0yLjEtMS4xYy0wLjgtMC4zLTEuNi0wLjQtMi40LTAuNGMtMC44LDAtMS41LDAuMi0yLjEsMC41Yy0wLjYsMC4zLTAuOCwwLjgtMC44LDEuNGMwLDAuNSwwLjIsMSwwLjUsMS4yYzAuMywwLjMsMC45LDAuNSwxLjYsMC43YzAuNCwwLjEsMC45LDAuMiwxLjQsMC4zYzAuNSwwLjEsMC45LDAuMiwxLjMsMC4zYzEsMC4yLDEuOCwwLjYsMi40LDEuMkMxODQsMzAsMTg0LjMsMzAuOCwxODQuMywzMS44eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xOTguNywyOS4yaC05LjhjMCwwLjgsMC4xLDEuNSwwLjQsMi4xczAuNiwxLjEsMSwxLjVjMC40LDAuNCwwLjksMC43LDEuNSwwLjljMC42LDAuMiwxLjIsMC4zLDEuOSwwLjNjMC45LDAsMS44LTAuMiwyLjctMC41YzAuOS0wLjQsMS42LTAuNywyLTEuMWgwLjF2Mi40Yy0wLjgsMC4zLTEuNSwwLjYtMi4zLDAuOHMtMS42LDAuMy0yLjUsMC4zYy0yLjIsMC0zLjktMC42LTUuMi0xLjhjLTEuMi0xLjItMS45LTIuOS0xLjktNS4xYzAtMi4yLDAuNi0zLjksMS44LTUuMmMxLjItMS4zLDIuNy0xLjksNC43LTEuOWMxLjgsMCwzLjIsMC41LDQuMSwxLjZzMS41LDIuNSwxLjUsNC41VjI5LjJ6IE0xOTYuNSwyNy41YzAtMS4yLTAuMy0yLjEtMC45LTIuN3MtMS41LTEtMi43LTFjLTEuMiwwLTIuMiwwLjQtMi45LDEuMWMtMC43LDAuNy0xLjEsMS42LTEuMiwyLjZIMTk2LjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTIxMC41LDI0LjhoLTAuMWMtMC4zLTAuMS0wLjctMC4xLTEtMC4yYy0wLjMsMC0wLjctMC4xLTEuMS0wLjFjLTAuNywwLTEuNCwwLjItMiwwLjVjLTAuNiwwLjMtMS4zLDAuNy0xLjksMS4ydjkuNGgtMi4yVjIyLjNoMi4ydjJjMC45LTAuNywxLjctMS4yLDIuMy0xLjVjMC43LTAuMywxLjQtMC40LDIuMS0wLjRjMC40LDAsMC43LDAsMC44LDBjMC4yLDAsMC40LDAuMSwwLjgsMC4xVjI0Ljh6Ii8+PC9nPjwvZz48Zz48cGF0aCBjbGFzcz0ic3QwIiBkPSJNMzIuNSw0Ny4zYy0xMS4yLDAtMjAuMy05LjEtMjAuMy0yMC4zUzIxLjMsNi43LDMyLjUsNi43YzExLjIsMCwyMC4zLDkuMSwyMC4zLDIwLjNTNDMuNyw0Ny4zLDMyLjUsNDcuM3oiLz48cGF0aCBjbGFzcz0ic3QyIiBkPSJNMzIuNSw3LjdjMTAuNywwLDE5LjMsOC43LDE5LjMsMTkuM2MwLDEwLjctOC43LDE5LjMtMTkuMywxOS4zYy0xMC43LDAtMTkuMy04LjctMTkuMy0xOS4zQzEzLjIsMTYuMywyMS44LDcuNywzMi41LDcuNyBNMzIuNSw1LjdjLTExLjcsMC0yMS4zLDkuNS0yMS4zLDIxLjNjMCwxMS43LDkuNSwyMS4zLDIxLjMsMjEuM2MxMS43LDAsMjEuMy05LjUsMjEuMy0yMS4zQzUzLjcsMTUuMiw0NC4yLDUuNywzMi41LDUuN0wzMi41LDUuN3oiLz48L2c+PGxpbmUgY2xhc3M9InN0MyIgeDE9IjI2LjciIHkxPSIxNC4zIiB4Mj0iMzQuNCIgeTI9IjI2LjUiLz48bGluZSBjbGFzcz0ic3QzIiB4MT0iMjUuMyIgeTE9IjMzLjMiIHgyPSIzNC41IiB5Mj0iMjYuOSIvPjxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjQ4LjYiIGN5PSIzNi4yIiByPSIxMi45Ii8+PGc+PHBhdGggY2xhc3M9InN0MCIgZD0iTTQxLjMsMjkuOEg0NHY1LjRoMGw0LjItNS40aDMuNGwtNC44LDYuMWw1LDYuN2gtMy4zbC00LjUtNmgwdjZoLTIuN1YyOS44eiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik01NS4xLDM0LjJ2MS4yaDBjMC4yLTAuNCwwLjUtMC43LDAuOS0xYzAuMy0wLjIsMC42LTAuNCwwLjktMC40YzAuMiwwLDAuMywwLDAuNSwwdjIuN2MtMC4yLDAtMC40LTAuMS0wLjYtMC4xYy0wLjUsMC0wLjksMC4yLTEuMiwwLjVjLTAuMywwLjQtMC40LDAuOS0wLjQsMS41djMuN2gtMi41di04LjNINTUuMXoiLz48L2c+PGxpbmUgY2xhc3M9InN0NCIgeDE9IjE2IiB5MT0iMjciIHgyPSIxOC40IiB5Mj0iMjciLz48bGluZSBjbGFzcz0ic3Q0IiB4MT0iMzIuNyIgeTE9IjEyLjciIHgyPSIzMi43IiB5Mj0iMTAuMyIvPjxsaW5lIGNsYXNzPSJzdDQiIHgxPSIzMi41IiB5MT0iNDQuMiIgeDI9IjMyLjUiIHkyPSI0MS44Ii8+PC9zdmc+"/> </a><div id="InloggadPortrait" style="color:#fff; display:inline-block; float: right; font-size: 12px; padding-top: 4px;"></div></div><div id="RGSLandscape" style="margin-left: auto; margin-right: auto; width: 100%; display:none; white-space: nowrap;"> <a href="#" class="PausePlay" target="_blank" style="text-decoration: none;"> <img style="height:20px;" alt="Spelpaus" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTg0LjkgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTg0LjkgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6I0UyMEQxODt9PC9zdHlsZT48Zz48cmVjdCB4PSIwLjUiIHk9IjAuNSIgY2xhc3M9InN0MCIgd2lkdGg9IjE4My45IiBoZWlnaHQ9IjUyLjQiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTgzLjksMXY1MS40SDFWMUgxODMuOSBNMTg0LjksMEgwdjUzLjRoMTg0LjlWMEwxODQuOSwweiIvPjwvZz48cGF0aCBjbGFzcz0ic3QyIiBkPSJNNTMuMywyNi44QzUzLjMsMzguNSw0My44LDQ4LDMyLDQ4Yy0xMS43LDAtMjEuMy05LjUtMjEuMy0yMS4zQzEwLjgsMTUsMjAuMyw1LjUsMzIsNS41QzQzLjgsNS41LDUzLjMsMTUsNTMuMywyNi44eiIvPjxnPjxnPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik03Ny4xLDMwLjVjMCwwLjctMC4yLDEuNC0wLjUsMmMtMC4zLDAuNy0wLjgsMS4yLTEuMywxLjdjLTAuNiwwLjUtMS40LDAuOS0yLjIsMS4yYy0wLjgsMC4zLTEuOSwwLjQtMy4xLDAuNGMtMS4zLDAtMi40LTAuMS0zLjQtMC40Yy0xLTAuMi0yLjEtMC42LTMuMS0xLjF2LTNoMC4yYzAuOSwwLjcsMS45LDEuMywzLjEsMS43czIuMywwLjYsMy4zLDAuNmMxLjUsMCwyLjYtMC4zLDMuNC0wLjhjMC44LTAuNSwxLjItMS4zLDEuMi0yLjJjMC0wLjgtMC4yLTEuNC0wLjYtMS43cy0xLTAuNy0xLjgtMC45Yy0wLjYtMC4yLTEuMi0wLjMtMS45LTAuNHMtMS40LTAuMi0yLjItMC40Yy0xLjYtMC4zLTIuNy0wLjktMy41LTEuN2MtMC44LTAuOC0xLjEtMS45LTEuMS0zLjFjMC0xLjUsMC42LTIuNywxLjktMy42YzEuMy0wLjksMi44LTEuNCw0LjgtMS40YzEuMiwwLDIuNCwwLjEsMy40LDAuNGMxLDAuMiwyLDAuNSwyLjgsMC45djIuOGgtMC4yYy0wLjctMC42LTEuNi0xLTIuNy0xLjRjLTEuMS0wLjQtMi4yLTAuNi0zLjQtMC42Yy0xLjMsMC0yLjMsMC4zLTMsMC44Yy0wLjgsMC41LTEuMSwxLjItMS4xLDJjMCwwLjcsMC4yLDEuMywwLjYsMS43YzAuNCwwLjQsMS4xLDAuNywyLDFjMC41LDAuMSwxLjIsMC4yLDIuMiwwLjRjMC45LDAuMiwxLjcsMC4zLDIuNCwwLjVjMS4zLDAuMywyLjMsMC45LDMsMS42Qzc2LjcsMjguMiw3Ny4xLDI5LjIsNzcuMSwzMC41eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik05Mi42LDI4LjhjMCwxLjEtMC4yLDIuMS0wLjUsM2MtMC4zLDAuOS0wLjcsMS42LTEuMywyLjNjLTAuNSwwLjYtMS4xLDEtMS45LDEuNHMtMS41LDAuNS0yLjMsMC41Yy0wLjcsMC0xLjMtMC4xLTEuOS0wLjJjLTAuNi0wLjItMS4xLTAuNC0xLjctMC43djUuNmgtMi4yVjIyLjNoMi4ydjEuNGMwLjYtMC41LDEuMy0wLjksMi0xLjNjMC43LTAuMywxLjUtMC41LDIuNC0wLjVjMS42LDAsMi44LDAuNiwzLjcsMS44QzkyLjIsMjQuOSw5Mi42LDI2LjYsOTIuNiwyOC44eiBNOTAuMywyOC44YzAtMS42LTAuMy0yLjgtMC44LTMuNkM4OC45LDI0LjQsODguMSwyNCw4NywyNGMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0M4OS45LDMxLjcsOTAuMywzMC41LDkwLjMsMjguOHoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTA3LjUsMjkuMWgtOS44YzAsMC44LDAuMSwxLjUsMC40LDIuMWMwLjIsMC42LDAuNiwxLjEsMSwxLjVjMC40LDAuNCwwLjksMC43LDEuNSwwLjljMC42LDAuMiwxLjIsMC4zLDEuOSwwLjNjMC45LDAsMS44LTAuMiwyLjctMC41YzAuOS0wLjQsMS42LTAuNywyLTEuMWgwLjF2Mi40Yy0wLjgsMC4zLTEuNSwwLjYtMi4zLDAuOGMtMC44LDAuMi0xLjYsMC4zLTIuNSwwLjNjLTIuMiwwLTMuOS0wLjYtNS4yLTEuOHMtMS45LTIuOS0xLjktNS4xYzAtMi4yLDAuNi0zLjksMS44LTUuMmMxLjItMS4zLDIuNy0xLjksNC43LTEuOWMxLjgsMCwzLjIsMC41LDQuMSwxLjZjMSwxLDEuNSwyLjUsMS41LDQuNVYyOS4xeiBNMTA1LjMsMjcuNGMwLTEuMi0wLjMtMi4xLTAuOS0yLjdjLTAuNi0wLjYtMS41LTEtMi43LTFjLTEuMiwwLTIuMiwwLjQtMi45LDEuMWMtMC43LDAuNy0xLjEsMS42LTEuMiwyLjZIMTA1LjN6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTExMy4zLDM1LjZoLTIuMlYxN2gyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTI5LjcsMjguOGMwLDEuMS0wLjIsMi4xLTAuNSwzYy0wLjMsMC45LTAuNywxLjYtMS4zLDIuM2MtMC41LDAuNi0xLjEsMS0xLjksMS40cy0xLjUsMC41LTIuMywwLjVjLTAuNywwLTEuMy0wLjEtMS45LTAuMmMtMC42LTAuMi0xLjEtMC40LTEuNy0wLjd2NS42SDExOFYyMi4zaDIuMnYxLjRjMC42LTAuNSwxLjMtMC45LDItMS4zYzAuNy0wLjMsMS41LTAuNSwyLjQtMC41YzEuNiwwLDIuOCwwLjYsMy43LDEuOEMxMjkuMywyNC45LDEyOS43LDI2LjYsMTI5LjcsMjguOHogTTEyNy40LDI4LjhjMC0xLjYtMC4zLTIuOC0wLjgtMy42Yy0wLjUtMC44LTEuNC0xLjItMi41LTEuMmMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0MxMjcuMSwzMS43LDEyNy40LDMwLjUsMTI3LjQsMjguOHoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTQzLjgsMzUuNmgtMi4ydi0xLjRjLTAuMiwwLjEtMC41LDAuMy0wLjgsMC42Yy0wLjMsMC4yLTAuNywwLjQtMSwwLjZjLTAuNCwwLjItMC44LDAuMy0xLjMsMC41Yy0wLjUsMC4xLTEuMSwwLjItMS43LDAuMmMtMS4yLDAtMi4yLTAuNC0zLTEuMnMtMS4yLTEuOC0xLjItM2MwLTEsMC4yLTEuOCwwLjYtMi40YzAuNC0wLjYsMS0xLjEsMS44LTEuNWMwLjgtMC40LDEuOC0wLjYsMi45LTAuN2MxLjEtMC4xLDIuNC0wLjIsMy43LTAuM3YtMC4zYzAtMC41LTAuMS0wLjktMC4zLTEuM2MtMC4yLTAuMy0wLjQtMC42LTAuOC0wLjhjLTAuMy0wLjItMC43LTAuMy0xLjEtMC40cy0wLjktMC4xLTEuNC0wLjFjLTAuNiwwLTEuMiwwLjEtMiwwLjJzLTEuNSwwLjQtMi4yLDAuN2gtMC4xdi0yLjNjMC40LTAuMSwxLjEtMC4zLDEuOS0wLjRjMC44LTAuMSwxLjYtMC4yLDIuNC0wLjJjMC45LDAsMS44LDAuMSwyLjQsMC4yYzAuNywwLjIsMS4zLDAuNCwxLjgsMC44YzAuNSwwLjQsMC45LDAuOCwxLjEsMS40czAuNCwxLjMsMC40LDIuMlYzNS42eiBNMTQxLjUsMzIuM3YtMy43Yy0wLjcsMC0xLjUsMC4xLTIuNCwwLjJzLTEuNywwLjItMi4yLDAuM2MtMC42LDAuMi0xLjIsMC41LTEuNiwwLjlzLTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdzMS4yLDAuNiwyLjEsMC42YzAuOCwwLDEuNS0wLjIsMi4yLTAuNUMxNDAuNCwzMy4xLDE0MSwzMi43LDE0MS41LDMyLjN6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE1OS4zLDM1LjZoLTIuMnYtMS41Yy0wLjgsMC42LTEuNSwxLjEtMi4yLDEuNHMtMS41LDAuNS0yLjMsMC41Yy0xLjQsMC0yLjUtMC40LTMuMy0xLjNzLTEuMi0yLjEtMS4yLTMuOHYtOC42aDIuMnY3LjZjMCwwLjcsMCwxLjMsMC4xLDEuN2MwLjEsMC41LDAuMiwwLjksMC40LDEuMmMwLjIsMC4zLDAuNSwwLjYsMC44LDAuOGMwLjMsMC4yLDAuOCwwLjIsMS41LDAuMmMwLjYsMCwxLjItMC4yLDEuOS0wLjVjMC43LTAuMywxLjMtMC43LDEuOS0xLjJ2LTkuOWgyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTczLjUsMzEuN2MwLDEuMi0wLjUsMi4yLTEuNSwzcy0yLjQsMS4yLTQuMSwxLjJjLTEsMC0xLjktMC4xLTIuNy0wLjRjLTAuOC0wLjItMS41LTAuNS0yLjEtMC44di0yLjVoMC4xYzAuNywwLjUsMS41LDEsMi40LDEuM2MwLjksMC4zLDEuNywwLjUsMi41LDAuNWMxLDAsMS44LTAuMiwyLjMtMC41YzAuNi0wLjMsMC44LTAuOCwwLjgtMS41YzAtMC41LTAuMi0wLjktMC41LTEuMnMtMC45LTAuNS0xLjctMC43Yy0wLjMtMC4xLTAuNy0wLjItMS4yLTAuM2MtMC41LTAuMS0xLTAuMi0xLjQtMC4zYy0xLjItMC4zLTItMC44LTIuNS0xLjRjLTAuNS0wLjYtMC43LTEuMy0wLjctMi4yYzAtMC41LDAuMS0xLjEsMC4zLTEuNWMwLjItMC41LDAuNi0wLjksMS0xLjNjMC40LTAuNCwxLTAuNywxLjctMC45YzAuNy0wLjIsMS41LTAuMywyLjMtMC4zYzAuOCwwLDEuNiwwLjEsMi40LDAuM2MwLjgsMC4yLDEuNSwwLjQsMiwwLjd2Mi40aC0wLjFjLTAuNi0wLjQtMS4zLTAuOC0yLjEtMS4xYy0wLjgtMC4zLTEuNi0wLjQtMi40LTAuNGMtMC44LDAtMS41LDAuMi0yLjEsMC41Yy0wLjYsMC4zLTAuOCwwLjgtMC44LDEuNGMwLDAuNSwwLjIsMSwwLjUsMS4yYzAuMywwLjMsMC45LDAuNSwxLjYsMC43YzAuNCwwLjEsMC45LDAuMiwxLjQsMC4zczAuOSwwLjIsMS4zLDAuM2MxLDAuMiwxLjgsMC42LDIuNCwxLjJDMTczLjIsMzAsMTczLjUsMzAuOCwxNzMuNSwzMS43eiIvPjwvZz48L2c+PHBhdGggY2xhc3M9InN0MCIgZD0iTTI4LjcsMzcuNWgtNi4yYy0wLjUsMC0wLjktMC40LTAuOS0wLjlWMTYuOWMwLTAuNSwwLjQtMC45LDAuOS0wLjloNi4yYzAuNSwwLDAuOSwwLjQsMC45LDAuOXYxOS43QzI5LjYsMzcuMSwyOS4yLDM3LjUsMjguNywzNy41eiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MS41LDM3LjZoLTYuMmMtMC41LDAtMC45LTAuNC0wLjktMC45VjE2LjljMC0wLjUsMC40LTAuOSwwLjktMC45aDYuMmMwLjUsMCwwLjksMC40LDAuOSwwLjl2MTkuN0M0Mi40LDM3LjIsNDIsMzcuNiw0MS41LDM3LjZ6Ii8+PC9zdmc+"/> </a> <a href="#" class="SelfTest" target="_blank" style="text-decoration: none;"> <img style="height:20px;" alt="Sjlvtest" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTgwLjYgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTgwLjYgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6bm9uZTtzdHJva2U6dXJsKCNTVkdJRF8xXyk7c3Ryb2tlLXdpZHRoOjYuNzc0MjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9LnN0M3tmaWxsOiMxRTFFMUM7fTwvc3R5bGU+PGc+PHJlY3QgeD0iMC41IiB5PSIwLjUiIGNsYXNzPSJzdDAiIHdpZHRoPSIxNzkuNSIgaGVpZ2h0PSI1Mi40Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE3OS41LDF2NTEuNEgxVjFIMTc5LjUgTTE4MC42LDBIMHY1My40aDE4MC42VjBMMTgwLjYsMHoiLz48L2c+PGc+PHBhdGggY2xhc3M9InN0MCIgZD0iTTMxLjksNDcuOGMtNS41LTAuMS0xMC43LTIuMy0xNC42LTYuMmMtMy45LTQtNi05LjItNS45LTE0LjhjMC4xLTExLjMsOS40LTIwLjYsMjAuOC0yMC42bDAuMiwwYzUuNSwwLjEsMTAuNywyLjMsMTQuNiw2LjJjMy45LDQsNiw5LjIsNS45LDE0LjhjLTAuMSwxMS4zLTkuNCwyMC42LTIwLjgsMjAuNkwzMS45LDQ3Ljh6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTMyLjEsNS43djFsMC4yLDBjNS40LDAuMSwxMC41LDIuMiwxNC4zLDYuMWMzLjgsMy45LDUuOCw5LDUuOCwxNC40Yy0wLjEsMTEuMS05LjIsMjAuMS0yMC4zLDIwLjFsLTAuMiwwYy01LjQtMC4xLTEwLjUtMi4yLTE0LjMtNi4xYy0zLjgtMy45LTUuOC05LTUuOC0xNC40YzAuMS0xMS4xLDkuMi0yMC4xLDIwLjMtMjAuMUwzMi4xLDUuNyBNMzIuMSw1LjdjLTExLjYsMC0yMS4xLDkuNC0yMS4zLDIxYy0wLjEsMTEuNyw5LjMsMjEuNCwyMSwyMS41YzAuMSwwLDAuMSwwLDAuMiwwYzExLjYsMCwyMS4xLTkuNCwyMS4zLTIxYzAuMS0xMS43LTkuMy0yMS40LTIxLTIxLjVDMzIuMyw1LjcsMzIuMiw1LjcsMzIuMSw1LjdMMzIuMSw1Ljd6Ii8+PC9nPjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTMuMzkwNCIgeTE9Ii0zMDMuMjA3NyIgeDI9IjUwLjYwNDMiIHkyPSItMzAzLjIwNzciIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIC0xIDY0LjAwMDUgLTI4My41MzY1KSI+PHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0U0MTkxMyIvPjxzdG9wICBvZmZzZXQ9IjkuNzQ0MDIwZS0wMiIgc3R5bGU9InN0b3AtY29sb3I6I0VBNjUxNiIvPjxzdG9wICBvZmZzZXQ9IjAuMjE0OCIgc3R5bGU9InN0b3AtY29sb3I6I0YzQTUxOCIvPjxzdG9wICBvZmZzZXQ9IjAuMzEyMSIgc3R5bGU9InN0b3AtY29sb3I6I0Y5Q0QxQSIvPjxzdG9wICBvZmZzZXQ9IjAuMzg0IiBzdHlsZT0ic3RvcC1jb2xvcjojRkRFMzFBIi8+PHN0b3AgIG9mZnNldD0iMC40MjI4IiBzdHlsZT0ic3RvcC1jb2xvcjojRkVFQjFBIi8+PHN0b3AgIG9mZnNldD0iMC42MjMxIiBzdHlsZT0ic3RvcC1jb2xvcjojREZERTIwIi8+PHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6IzAwOTI0NSIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InN0MiIgZD0iTTQ3LjIsMjYuN2MtMi4yLTE4LjYtMjcuOC0xOS0zMC40LDAiLz48Zz48cGF0aCBjbGFzcz0ic3QzIiBkPSJNMjcuNywyNy4zbDguOC0xNS44bC0xLjgsMThjLTAuNiwxLjktMi43LDMtNC42LDIuNFMyNy4xLDI5LjIsMjcuNywyNy4zeiIvPjwvZz48Zz48Zz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNNzYuNSwzMC41YzAsMC43LTAuMiwxLjQtMC41LDJzLTAuOCwxLjItMS40LDEuN2MtMC42LDAuNS0xLjQsMC45LTIuMiwxLjJjLTAuOCwwLjMtMS45LDAuNC0zLjEsMC40Yy0xLjMsMC0yLjQtMC4xLTMuNC0wLjRjLTEtMC4yLTIuMS0wLjYtMy4xLTEuMXYtM0g2M2MwLjksMC43LDEuOSwxLjMsMy4xLDEuN2MxLjIsMC40LDIuMywwLjYsMy4zLDAuNmMxLjUsMCwyLjYtMC4zLDMuNC0wLjhjMC44LTAuNSwxLjItMS4zLDEuMi0yLjJjMC0wLjgtMC4yLTEuNC0wLjYtMS43cy0xLTAuNy0xLjgtMC45Yy0wLjYtMC4yLTEuMi0wLjMtMS45LTAuNGMtMC43LTAuMS0xLjQtMC4yLTIuMi0wLjRjLTEuNi0wLjMtMi43LTAuOS0zLjUtMS43Yy0wLjgtMC44LTEuMS0xLjktMS4xLTMuMWMwLTEuNSwwLjYtMi43LDEuOS0zLjZjMS4zLTAuOSwyLjgtMS40LDQuOC0xLjRjMS4yLDAsMi40LDAuMSwzLjQsMC40YzEsMC4yLDIsMC41LDIuOCwwLjl2Mi44aC0wLjJjLTAuNy0wLjYtMS42LTEtMi43LTEuNGMtMS4xLTAuNC0yLjItMC42LTMuNC0wLjZjLTEuMywwLTIuMywwLjMtMywwLjhjLTAuOCwwLjUtMS4xLDEuMi0xLjEsMmMwLDAuNywwLjIsMS4zLDAuNiwxLjdjMC40LDAuNCwxLjEsMC43LDIsMWMwLjUsMC4xLDEuMiwwLjIsMi4yLDAuNGMwLjksMC4yLDEuNywwLjMsMi40LDAuNWMxLjMsMC4zLDIuMywwLjksMywxLjZDNzYuMSwyOC4zLDc2LjUsMjkuMyw3Ni41LDMwLjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTg0LjMsMzUuOWMwLDEuNi0wLjQsMi43LTEuMiwzLjVzLTEuOSwxLjItMy4yLDEuMmMtMC4zLDAtMC43LDAtMS4zLTAuMWMtMC41LTAuMS0xLTAuMS0xLjMtMC4ydi0yLjFoMC4xYzAuMiwwLjEsMC41LDAuMiwwLjksMC4zYzAuNCwwLjEsMC43LDAuMiwxLjEsMC4yYzAuNiwwLDEtMC4xLDEuNC0wLjJjMC4zLTAuMiwwLjYtMC40LDAuOC0wLjdjMC4yLTAuMywwLjMtMC43LDAuMy0xLjFjMC4xLTAuNCwwLjEtMSwwLjEtMS42VjI0LjJoLTIuOHYtMS45aDVWMzUuOXogTTg0LjUsMjAuMWgtMi41di0yLjNoMi41VjIwLjF6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTk5LjMsMzUuNkg5N3YtMS40Yy0wLjIsMC4xLTAuNSwwLjMtMC44LDAuNnMtMC43LDAuNC0xLDAuNmMtMC40LDAuMi0wLjgsMC4zLTEuMywwLjVjLTAuNSwwLjEtMS4xLDAuMi0xLjcsMC4yYy0xLjIsMC0yLjItMC40LTMtMS4yQzg4LjQsMzQsODgsMzMsODgsMzEuN2MwLTEsMC4yLTEuOCwwLjYtMi40YzAuNC0wLjYsMS0xLjEsMS44LTEuNWMwLjgtMC40LDEuOC0wLjYsMi45LTAuN2MxLjEtMC4xLDIuNC0wLjIsMy43LTAuM3YtMC4zYzAtMC41LTAuMS0wLjktMC4zLTEuM3MtMC40LTAuNi0wLjgtMC44Yy0wLjMtMC4yLTAuNy0wLjMtMS4xLTAuNGMtMC40LTAuMS0wLjktMC4xLTEuNC0wLjFjLTAuNiwwLTEuMiwwLjEtMiwwLjJjLTAuNywwLjItMS41LDAuNC0yLjIsMC43aC0wLjF2LTIuM2MwLjQtMC4xLDEuMS0wLjMsMS45LTAuNGMwLjgtMC4xLDEuNi0wLjIsMi40LTAuMmMwLjksMCwxLjgsMC4xLDIuNCwwLjJjMC43LDAuMiwxLjMsMC40LDEuOCwwLjhjMC41LDAuNCwwLjksMC44LDEuMSwxLjRzMC40LDEuMywwLjQsMi4yVjM1LjZ6IE05NywzMi4zdi0zLjdjLTAuNywwLTEuNSwwLjEtMi40LDAuMlM5MywyOSw5Mi40LDI5LjFjLTAuNiwwLjItMS4yLDAuNS0xLjYsMC45Yy0wLjQsMC40LTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdjMC41LDAuNCwxLjIsMC42LDIuMSwwLjZjMC44LDAsMS41LTAuMiwyLjItMC41Qzk1LjksMzMuMSw5Ni41LDMyLjcsOTcsMzIuM3ogTTkyLjgsMjAuMWgtMi40di0yLjNoMi40VjIwLjF6IE05Ny44LDIwLjFoLTIuNHYtMi4zaDIuNFYyMC4xeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xMDYuMSwzNS42aC0yLjJWMTcuMWgyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTIyLjIsMjIuM2wtNS40LDEzLjNoLTIuMmwtNS4zLTEzLjNoMi40bDQuMSwxMC42bDQuMS0xMC42SDEyMi4yeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xMzIuMywzNS41Yy0wLjQsMC4xLTAuOSwwLjItMS40LDAuM2MtMC41LDAuMS0wLjksMC4xLTEuMywwLjFjLTEuNCwwLTIuNC0wLjQtMy4xLTEuMWMtMC43LTAuNy0xLjEtMS45LTEuMS0zLjV2LTcuMWgtMS41di0xLjloMS41di0zLjhoMi4ydjMuOGg0LjZ2MS45aC00LjZ2Ni4xYzAsMC43LDAsMS4yLDAsMS42YzAsMC40LDAuMSwwLjgsMC4zLDEuMWMwLjIsMC4zLDAuNCwwLjUsMC43LDAuN2MwLjMsMC4xLDAuOCwwLjIsMS40LDAuMmMwLjQsMCwwLjctMC4xLDEuMS0wLjJjMC40LTAuMSwwLjctMC4yLDAuOS0wLjNoMC4xVjM1LjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE0Ni40LDI5LjJoLTkuOGMwLDAuOCwwLjEsMS41LDAuNCwyLjFjMC4yLDAuNiwwLjYsMS4xLDEsMS41YzAuNCwwLjQsMC45LDAuNywxLjUsMC45YzAuNiwwLjIsMS4yLDAuMywxLjksMC4zYzAuOSwwLDEuOC0wLjIsMi43LTAuNWMwLjktMC40LDEuNi0wLjcsMi0xLjFoMC4xdjIuNGMtMC44LDAuMy0xLjUsMC42LTIuMywwLjhzLTEuNiwwLjMtMi41LDAuM2MtMi4yLDAtMy45LTAuNi01LjItMS44Yy0xLjItMS4yLTEuOS0yLjktMS45LTUuMWMwLTIuMiwwLjYtMy45LDEuOC01LjJjMS4yLTEuMywyLjctMS45LDQuNy0xLjljMS44LDAsMy4yLDAuNSw0LjEsMS42YzEsMSwxLjUsMi41LDEuNSw0LjVWMjkuMnogTTE0NC4yLDI3LjVjMC0xLjItMC4zLTIuMS0wLjktMi43cy0xLjUtMS0yLjctMWMtMS4yLDAtMi4yLDAuNC0yLjksMS4xYy0wLjcsMC43LTEuMSwxLjYtMS4yLDIuNkgxNDQuMnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTU5LjUsMzEuN2MwLDEuMi0wLjUsMi4yLTEuNSwzcy0yLjQsMS4yLTQuMSwxLjJjLTEsMC0xLjktMC4xLTIuNy0wLjRjLTAuOC0wLjItMS41LTAuNS0yLjEtMC44di0yLjVoMC4xYzAuNywwLjUsMS41LDEsMi40LDEuM3MxLjcsMC41LDIuNSwwLjVjMSwwLDEuOC0wLjIsMi4zLTAuNWMwLjYtMC4zLDAuOC0wLjgsMC44LTEuNWMwLTAuNS0wLjItMC45LTAuNS0xLjJzLTAuOS0wLjUtMS43LTAuN2MtMC4zLTAuMS0wLjctMC4yLTEuMi0wLjNjLTAuNS0wLjEtMS0wLjItMS40LTAuM2MtMS4yLTAuMy0yLTAuOC0yLjUtMS40Yy0wLjUtMC42LTAuNy0xLjMtMC43LTIuMmMwLTAuNSwwLjEtMS4xLDAuMy0xLjVjMC4yLTAuNSwwLjYtMC45LDEtMS4zYzAuNC0wLjQsMS0wLjcsMS43LTAuOWMwLjctMC4yLDEuNS0wLjMsMi4zLTAuM2MwLjgsMCwxLjYsMC4xLDIuNCwwLjNjMC44LDAuMiwxLjUsMC40LDIsMC43djIuNGgtMC4xYy0wLjYtMC40LTEuMy0wLjgtMi4xLTEuMWMtMC44LTAuMy0xLjYtMC40LTIuNC0wLjRjLTAuOCwwLTEuNSwwLjItMi4xLDAuNWMtMC42LDAuMy0wLjgsMC44LTAuOCwxLjRjMCwwLjUsMC4yLDEsMC41LDEuMmMwLjMsMC4zLDAuOSwwLjUsMS42LDAuN2MwLjQsMC4xLDAuOSwwLjIsMS40LDAuM2MwLjUsMC4xLDAuOSwwLjIsMS4zLDAuM2MxLDAuMiwxLjgsMC42LDIuNCwxLjJDMTU5LjIsMzAsMTU5LjUsMzAuOCwxNTkuNSwzMS43eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNjkuOSwzNS41Yy0wLjQsMC4xLTAuOSwwLjItMS40LDAuM2MtMC41LDAuMS0wLjksMC4xLTEuMywwLjFjLTEuNCwwLTIuNC0wLjQtMy4xLTEuMWMtMC43LTAuNy0xLjEtMS45LTEuMS0zLjV2LTcuMWgtMS41di0xLjloMS41di0zLjhoMi4ydjMuOGg0LjZ2MS45aC00LjZ2Ni4xYzAsMC43LDAsMS4yLDAsMS42YzAsMC40LDAuMSwwLjgsMC4zLDEuMWMwLjIsMC4zLDAuNCwwLjUsMC43LDAuN2MwLjMsMC4xLDAuOCwwLjIsMS40LDAuMmMwLjQsMCwwLjctMC4xLDEuMS0wLjJjMC40LTAuMSwwLjctMC4yLDAuOS0wLjNoMC4xVjM1LjV6Ii8+PC9nPjwvZz48L3N2Zz4="/> </a> <a href="#" class="PlayLimit" target="_blank" style="text-decoration: none;"> <img style="height:20px;" alt="Spelgrnser" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjE5LjYgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMjE5LjYgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6IzAwOTczOTt9LnN0M3tmaWxsOiNGRkZGRkY7c3Ryb2tlOiMwMDk3Mzk7c3Ryb2tlLXdpZHRoOjMuODcxO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO30uc3Q0e2ZpbGw6bm9uZTtzdHJva2U6IzAwOTczOTtzdHJva2Utd2lkdGg6MS45MzU1O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO308L3N0eWxlPjxnPjxyZWN0IHg9IjAuNSIgeT0iMC41IiBjbGFzcz0ic3QwIiB3aWR0aD0iMjE4LjUiIGhlaWdodD0iNTIuNCIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0yMTguNSwxdjUxLjRIMVYxSDIxOC41IE0yMTkuNiwwSDB2NTMuNGgyMTkuNlYwTDIxOS42LDB6Ii8+PC9nPjxnPjxnPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik03OC4yLDMwLjZjMCwwLjctMC4yLDEuNC0wLjUsMmMtMC4zLDAuNy0wLjgsMS4yLTEuNCwxLjdjLTAuNiwwLjUtMS40LDAuOS0yLjIsMS4yYy0wLjgsMC4zLTEuOSwwLjQtMy4xLDAuNGMtMS4zLDAtMi40LTAuMS0zLjQtMC40Yy0xLTAuMi0yLjEtMC42LTMuMS0xLjF2LTIuOWgwLjJjMC45LDAuNywxLjksMS4zLDMuMSwxLjdjMS4yLDAuNCwyLjMsMC42LDMuMywwLjZjMS41LDAsMi42LTAuMywzLjQtMC44YzAuOC0wLjUsMS4yLTEuMywxLjItMi4yYzAtMC44LTAuMi0xLjQtMC42LTEuN3MtMS0wLjctMS44LTAuOWMtMC42LTAuMi0xLjItMC4zLTEuOS0wLjRjLTAuNy0wLjEtMS40LTAuMi0yLjItMC40Yy0xLjYtMC4zLTIuNy0wLjktMy41LTEuN3MtMS4xLTEuOS0xLjEtMy4xYzAtMS41LDAuNi0yLjcsMS45LTMuNmMxLjMtMC45LDIuOC0xLjQsNC44LTEuNGMxLjIsMCwyLjQsMC4xLDMuNCwwLjRjMSwwLjIsMiwwLjUsMi44LDAuOXYyLjhoLTAuMmMtMC43LTAuNi0xLjYtMS0yLjctMS40Yy0xLjEtMC40LTIuMi0wLjYtMy40LTAuNmMtMS4zLDAtMi4zLDAuMy0zLDAuOHMtMS4xLDEuMi0xLjEsMmMwLDAuNywwLjIsMS4zLDAuNiwxLjdjMC40LDAuNCwxLjEsMC43LDIsMWMwLjUsMC4xLDEuMiwwLjIsMi4yLDAuNGMwLjksMC4yLDEuNywwLjMsMi40LDAuNWMxLjMsMC4zLDIuMywwLjksMywxLjZDNzcuOSwyOC4zLDc4LjIsMjkuMyw3OC4yLDMwLjZ6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTkzLjYsMjguOGMwLDEuMS0wLjIsMi4xLTAuNSwzYy0wLjMsMC45LTAuNywxLjYtMS4zLDIuM2MtMC41LDAuNi0xLjEsMS0xLjgsMS40Yy0wLjcsMC4zLTEuNSwwLjUtMi4zLDAuNWMtMC43LDAtMS4zLTAuMS0xLjktMC4yYy0wLjYtMC4yLTEuMS0wLjQtMS43LTAuN3Y1LjZoLTIuMlYyMi4zaDIuMnYxLjRjMC42LTAuNSwxLjMtMC45LDItMS4zYzAuNy0wLjMsMS41LTAuNSwyLjQtMC41YzEuNiwwLDIuOCwwLjYsMy43LDEuOEM5My4yLDI1LDkzLjYsMjYuNyw5My42LDI4Ljh6IE05MS4zLDI4LjljMC0xLjYtMC4zLTIuOC0wLjgtMy42Yy0wLjUtMC44LTEuNC0xLjItMi41LTEuMmMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0M5MSwzMS44LDkxLjMsMzAuNSw5MS4zLDI4Ljl6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTEwOC4zLDI5LjJoLTkuOGMwLDAuOCwwLjEsMS41LDAuNCwyLjFjMC4yLDAuNiwwLjYsMS4xLDEsMS41YzAuNCwwLjQsMC45LDAuNywxLjUsMC45czEuMiwwLjMsMS45LDAuM2MwLjksMCwxLjgtMC4yLDIuNy0wLjVjMC45LTAuNCwxLjYtMC43LDItMS4xaDAuMXYyLjRjLTAuOCwwLjMtMS41LDAuNi0yLjMsMC44cy0xLjYsMC4zLTIuNSwwLjNjLTIuMiwwLTMuOS0wLjYtNS4yLTEuOGMtMS4yLTEuMi0xLjktMi45LTEuOS01LjFjMC0yLjIsMC42LTMuOSwxLjgtNS4yYzEuMi0xLjMsMi43LTEuOSw0LjctMS45YzEuOCwwLDMuMiwwLjUsNC4xLDEuNmMxLDEsMS41LDIuNSwxLjUsNC41VjI5LjJ6IE0xMDYuMiwyNy41YzAtMS4yLTAuMy0yLjEtMC45LTIuN2MtMC42LTAuNi0xLjUtMS0yLjctMWMtMS4yLDAtMi4yLDAuNC0yLjksMS4xYy0wLjcsMC43LTEuMSwxLjYtMS4yLDIuNkgxMDYuMnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTE0LjEsMzUuNmgtMi4yVjE3LjFoMi4yVjM1LjZ6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTEyOS40LDM0LjFjMCwyLjMtMC41LDMuOS0xLjUsNWMtMSwxLjEtMi42LDEuNi00LjcsMS42Yy0wLjcsMC0xLjQsMC0yLjEtMC4xYy0wLjctMC4xLTEuMy0wLjItMi0wLjR2LTIuM2gwLjFjMC40LDAuMSwwLjksMC4zLDEuNywwLjVzMS42LDAuMywyLjQsMC4zYzAuOCwwLDEuNC0wLjEsMS45LTAuM2MwLjUtMC4yLDAuOS0wLjQsMS4yLTAuOGMwLjMtMC4zLDAuNS0wLjcsMC42LTEuMWMwLjEtMC40LDAuMi0wLjksMC4yLTEuNXYtMS4yYy0wLjcsMC41LTEuMywwLjktMS45LDEuMnMtMS40LDAuNC0yLjMsMC40Yy0xLjYsMC0yLjgtMC42LTMuOC0xLjdjLTAuOS0xLjEtMS40LTIuOC0xLjQtNC44YzAtMS4xLDAuMi0yLjEsMC41LTNjMC4zLTAuOCwwLjgtMS41LDEuMy0yLjFjMC41LTAuNiwxLjEtMSwxLjktMS4zYzAuNy0wLjMsMS41LTAuNSwyLjItMC41YzAuOCwwLDEuNCwwLjEsMS45LDAuMnMxLjEsMC40LDEuNiwwLjdsMC4xLTAuNmgyLjFWMzQuMXogTTEyNy4yLDMydi03LjJjLTAuNi0wLjMtMS4xLTAuNS0xLjctMC42Yy0wLjUtMC4xLTEtMC4yLTEuNS0wLjJjLTEuMiwwLTIuMiwwLjQtMi45LDEuMnMtMS4xLDItMS4xLDMuNmMwLDEuNSwwLjMsMi42LDAuOCwzLjRjMC41LDAuOCwxLjQsMS4yLDIuNiwxLjJjMC43LDAsMS4zLTAuMSwyLTAuNFMxMjYuNiwzMi40LDEyNy4yLDMyeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNDIuMiwyNC44aC0wLjFjLTAuMy0wLjEtMC43LTAuMS0xLTAuMmMtMC4zLDAtMC43LTAuMS0xLjEtMC4xYy0wLjcsMC0xLjQsMC4yLTIsMC41Yy0wLjYsMC4zLTEuMywwLjctMS45LDEuMnY5LjRIMTM0VjIyLjNoMi4ydjJjMC45LTAuNywxLjctMS4yLDIuMy0xLjVjMC43LTAuMywxLjQtMC40LDIuMS0wLjRjMC40LDAsMC43LDAsMC44LDBjMC4yLDAsMC40LDAuMSwwLjgsMC4xVjI0Ljh6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE1NC44LDM1LjZoLTIuMnYtMS40Yy0wLjIsMC4xLTAuNSwwLjMtMC44LDAuNnMtMC43LDAuNC0xLDAuNmMtMC40LDAuMi0wLjgsMC4zLTEuMywwLjVjLTAuNSwwLjEtMS4xLDAuMi0xLjcsMC4yYy0xLjIsMC0yLjItMC40LTMtMS4yYy0wLjgtMC44LTEuMi0xLjgtMS4yLTNjMC0xLDAuMi0xLjgsMC42LTIuNGMwLjQtMC42LDEtMS4xLDEuOC0xLjVjMC44LTAuNCwxLjgtMC42LDIuOS0wLjdzMi40LTAuMiwzLjctMC4zdi0wLjNjMC0wLjUtMC4xLTAuOS0wLjMtMS4zYy0wLjItMC4zLTAuNC0wLjYtMC44LTAuOGMtMC4zLTAuMi0wLjctMC4zLTEuMS0wLjRDMTUwLDI0LDE0OS41LDI0LDE0OSwyNGMtMC42LDAtMS4yLDAuMS0yLDAuMmMtMC43LDAuMi0xLjUsMC40LTIuMiwwLjdoLTAuMXYtMi4zYzAuNC0wLjEsMS4xLTAuMiwxLjktMC40YzAuOC0wLjEsMS42LTAuMiwyLjQtMC4yYzAuOSwwLDEuOCwwLjEsMi40LDAuMmMwLjcsMC4yLDEuMywwLjQsMS44LDAuOGMwLjUsMC40LDAuOSwwLjgsMS4xLDEuNGMwLjMsMC42LDAuNCwxLjMsMC40LDIuMlYzNS42eiBNMTUyLjYsMzIuM3YtMy43Yy0wLjcsMC0xLjUsMC4xLTIuNCwwLjJzLTEuNywwLjItMi4yLDAuM2MtMC42LDAuMi0xLjIsMC41LTEuNiwwLjlzLTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdzMS4yLDAuNiwyLjEsMC42YzAuOCwwLDEuNS0wLjIsMi4yLTAuNUMxNTEuNCwzMy4xLDE1MiwzMi44LDE1Mi42LDMyLjN6IE0xNDguNCwyMC4xSDE0NnYtMi4zaDIuNFYyMC4xeiBNMTUzLjMsMjAuMWgtMi40di0yLjNoMi40VjIwLjF6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE3MC4zLDM1LjZoLTIuMnYtNy42YzAtMC42LDAtMS4yLTAuMS0xLjdzLTAuMi0xLTAuNC0xLjNjLTAuMi0wLjMtMC41LTAuNi0wLjktMC43Yy0wLjQtMC4yLTAuOS0wLjItMS41LTAuMmMtMC42LDAtMS4yLDAuMi0xLjksMC41Yy0wLjcsMC4zLTEuMywwLjctMS45LDEuMnY5LjloLTIuMlYyMi4zaDIuMnYxLjVjMC43LTAuNiwxLjQtMSwyLjItMS40YzAuNy0wLjMsMS41LTAuNSwyLjMtMC41YzEuNCwwLDIuNSwwLjQsMy4zLDEuM2MwLjgsMC45LDEuMSwyLjEsMS4xLDMuN1YzNS42eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xODQuMywzMS44YzAsMS4yLTAuNSwyLjItMS41LDNjLTEsMC44LTIuNCwxLjItNC4xLDEuMmMtMSwwLTEuOS0wLjEtMi43LTAuNGMtMC44LTAuMi0xLjUtMC41LTIuMS0wLjh2LTIuNWgwLjFjMC43LDAuNSwxLjUsMSwyLjQsMS4zczEuNywwLjUsMi41LDAuNWMxLDAsMS44LTAuMiwyLjMtMC41YzAuNi0wLjMsMC44LTAuOCwwLjgtMS41YzAtMC41LTAuMi0wLjktMC41LTEuMnMtMC45LTAuNS0xLjctMC43Yy0wLjMtMC4xLTAuNy0wLjItMS4yLTAuM2MtMC41LTAuMS0xLTAuMi0xLjQtMC4zYy0xLjItMC4zLTItMC44LTIuNS0xLjRjLTAuNS0wLjYtMC43LTEuMy0wLjctMi4yYzAtMC41LDAuMS0xLjEsMC4zLTEuNWMwLjItMC41LDAuNi0wLjksMS0xLjNjMC40LTAuNCwxLTAuNywxLjctMC45YzAuNy0wLjIsMS41LTAuMywyLjMtMC4zYzAuOCwwLDEuNiwwLjEsMi40LDAuM2MwLjgsMC4yLDEuNSwwLjQsMiwwLjd2Mi40aC0wLjFjLTAuNi0wLjQtMS4zLTAuOC0yLjEtMS4xYy0wLjgtMC4zLTEuNi0wLjQtMi40LTAuNGMtMC44LDAtMS41LDAuMi0yLjEsMC41Yy0wLjYsMC4zLTAuOCwwLjgtMC44LDEuNGMwLDAuNSwwLjIsMSwwLjUsMS4yYzAuMywwLjMsMC45LDAuNSwxLjYsMC43YzAuNCwwLjEsMC45LDAuMiwxLjQsMC4zYzAuNSwwLjEsMC45LDAuMiwxLjMsMC4zYzEsMC4yLDEuOCwwLjYsMi40LDEuMkMxODQsMzAsMTg0LjMsMzAuOCwxODQuMywzMS44eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xOTguNywyOS4yaC05LjhjMCwwLjgsMC4xLDEuNSwwLjQsMi4xczAuNiwxLjEsMSwxLjVjMC40LDAuNCwwLjksMC43LDEuNSwwLjljMC42LDAuMiwxLjIsMC4zLDEuOSwwLjNjMC45LDAsMS44LTAuMiwyLjctMC41YzAuOS0wLjQsMS42LTAuNywyLTEuMWgwLjF2Mi40Yy0wLjgsMC4zLTEuNSwwLjYtMi4zLDAuOHMtMS42LDAuMy0yLjUsMC4zYy0yLjIsMC0zLjktMC42LTUuMi0xLjhjLTEuMi0xLjItMS45LTIuOS0xLjktNS4xYzAtMi4yLDAuNi0zLjksMS44LTUuMmMxLjItMS4zLDIuNy0xLjksNC43LTEuOWMxLjgsMCwzLjIsMC41LDQuMSwxLjZzMS41LDIuNSwxLjUsNC41VjI5LjJ6IE0xOTYuNSwyNy41YzAtMS4yLTAuMy0yLjEtMC45LTIuN3MtMS41LTEtMi43LTFjLTEuMiwwLTIuMiwwLjQtMi45LDEuMWMtMC43LDAuNy0xLjEsMS42LTEuMiwyLjZIMTk2LjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTIxMC41LDI0LjhoLTAuMWMtMC4zLTAuMS0wLjctMC4xLTEtMC4yYy0wLjMsMC0wLjctMC4xLTEuMS0wLjFjLTAuNywwLTEuNCwwLjItMiwwLjVjLTAuNiwwLjMtMS4zLDAuNy0xLjksMS4ydjkuNGgtMi4yVjIyLjNoMi4ydjJjMC45LTAuNywxLjctMS4yLDIuMy0xLjVjMC43LTAuMywxLjQtMC40LDIuMS0wLjRjMC40LDAsMC43LDAsMC44LDBjMC4yLDAsMC40LDAuMSwwLjgsMC4xVjI0Ljh6Ii8+PC9nPjwvZz48Zz48cGF0aCBjbGFzcz0ic3QwIiBkPSJNMzIuNSw0Ny4zYy0xMS4yLDAtMjAuMy05LjEtMjAuMy0yMC4zUzIxLjMsNi43LDMyLjUsNi43YzExLjIsMCwyMC4zLDkuMSwyMC4zLDIwLjNTNDMuNyw0Ny4zLDMyLjUsNDcuM3oiLz48cGF0aCBjbGFzcz0ic3QyIiBkPSJNMzIuNSw3LjdjMTAuNywwLDE5LjMsOC43LDE5LjMsMTkuM2MwLDEwLjctOC43LDE5LjMtMTkuMywxOS4zYy0xMC43LDAtMTkuMy04LjctMTkuMy0xOS4zQzEzLjIsMTYuMywyMS44LDcuNywzMi41LDcuNyBNMzIuNSw1LjdjLTExLjcsMC0yMS4zLDkuNS0yMS4zLDIxLjNjMCwxMS43LDkuNSwyMS4zLDIxLjMsMjEuM2MxMS43LDAsMjEuMy05LjUsMjEuMy0yMS4zQzUzLjcsMTUuMiw0NC4yLDUuNywzMi41LDUuN0wzMi41LDUuN3oiLz48L2c+PGxpbmUgY2xhc3M9InN0MyIgeDE9IjI2LjciIHkxPSIxNC4zIiB4Mj0iMzQuNCIgeTI9IjI2LjUiLz48bGluZSBjbGFzcz0ic3QzIiB4MT0iMjUuMyIgeTE9IjMzLjMiIHgyPSIzNC41IiB5Mj0iMjYuOSIvPjxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjQ4LjYiIGN5PSIzNi4yIiByPSIxMi45Ii8+PGc+PHBhdGggY2xhc3M9InN0MCIgZD0iTTQxLjMsMjkuOEg0NHY1LjRoMGw0LjItNS40aDMuNGwtNC44LDYuMWw1LDYuN2gtMy4zbC00LjUtNmgwdjZoLTIuN1YyOS44eiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik01NS4xLDM0LjJ2MS4yaDBjMC4yLTAuNCwwLjUtMC43LDAuOS0xYzAuMy0wLjIsMC42LTAuNCwwLjktMC40YzAuMiwwLDAuMywwLDAuNSwwdjIuN2MtMC4yLDAtMC40LTAuMS0wLjYtMC4xYy0wLjUsMC0wLjksMC4yLTEuMiwwLjVjLTAuMywwLjQtMC40LDAuOS0wLjQsMS41djMuN2gtMi41di04LjNINTUuMXoiLz48L2c+PGxpbmUgY2xhc3M9InN0NCIgeDE9IjE2IiB5MT0iMjciIHgyPSIxOC40IiB5Mj0iMjciLz48bGluZSBjbGFzcz0ic3Q0IiB4MT0iMzIuNyIgeTE9IjEyLjciIHgyPSIzMi43IiB5Mj0iMTAuMyIvPjxsaW5lIGNsYXNzPSJzdDQiIHgxPSIzMi41IiB5MT0iNDQuMiIgeDI9IjMyLjUiIHkyPSI0MS44Ii8+PC9zdmc+"/> </a><div id="InloggadLandscape" style="color:#fff; display:inline-block; float: right; font-size: 13px; padding-top: 4px;"></div></div></div>';
    else htmlString =
        '<div class="RGSContainerActive" style="display: block;" data-height="29"><div id="RGSDesktop" style="margin-left: auto; margin-right: auto; width: 100%; display:block; white-space: nowrap;"> <a href="#" class="PausePlay" target="_blank" style="text-decoration: none;"> <img style="height:25px;" alt="Spelpaus" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTg0LjkgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTg0LjkgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6I0UyMEQxODt9PC9zdHlsZT48Zz48cmVjdCB4PSIwLjUiIHk9IjAuNSIgY2xhc3M9InN0MCIgd2lkdGg9IjE4My45IiBoZWlnaHQ9IjUyLjQiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTgzLjksMXY1MS40SDFWMUgxODMuOSBNMTg0LjksMEgwdjUzLjRoMTg0LjlWMEwxODQuOSwweiIvPjwvZz48cGF0aCBjbGFzcz0ic3QyIiBkPSJNNTMuMywyNi44QzUzLjMsMzguNSw0My44LDQ4LDMyLDQ4Yy0xMS43LDAtMjEuMy05LjUtMjEuMy0yMS4zQzEwLjgsMTUsMjAuMyw1LjUsMzIsNS41QzQzLjgsNS41LDUzLjMsMTUsNTMuMywyNi44eiIvPjxnPjxnPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik03Ny4xLDMwLjVjMCwwLjctMC4yLDEuNC0wLjUsMmMtMC4zLDAuNy0wLjgsMS4yLTEuMywxLjdjLTAuNiwwLjUtMS40LDAuOS0yLjIsMS4yYy0wLjgsMC4zLTEuOSwwLjQtMy4xLDAuNGMtMS4zLDAtMi40LTAuMS0zLjQtMC40Yy0xLTAuMi0yLjEtMC42LTMuMS0xLjF2LTNoMC4yYzAuOSwwLjcsMS45LDEuMywzLjEsMS43czIuMywwLjYsMy4zLDAuNmMxLjUsMCwyLjYtMC4zLDMuNC0wLjhjMC44LTAuNSwxLjItMS4zLDEuMi0yLjJjMC0wLjgtMC4yLTEuNC0wLjYtMS43cy0xLTAuNy0xLjgtMC45Yy0wLjYtMC4yLTEuMi0wLjMtMS45LTAuNHMtMS40LTAuMi0yLjItMC40Yy0xLjYtMC4zLTIuNy0wLjktMy41LTEuN2MtMC44LTAuOC0xLjEtMS45LTEuMS0zLjFjMC0xLjUsMC42LTIuNywxLjktMy42YzEuMy0wLjksMi44LTEuNCw0LjgtMS40YzEuMiwwLDIuNCwwLjEsMy40LDAuNGMxLDAuMiwyLDAuNSwyLjgsMC45djIuOGgtMC4yYy0wLjctMC42LTEuNi0xLTIuNy0xLjRjLTEuMS0wLjQtMi4yLTAuNi0zLjQtMC42Yy0xLjMsMC0yLjMsMC4zLTMsMC44Yy0wLjgsMC41LTEuMSwxLjItMS4xLDJjMCwwLjcsMC4yLDEuMywwLjYsMS43YzAuNCwwLjQsMS4xLDAuNywyLDFjMC41LDAuMSwxLjIsMC4yLDIuMiwwLjRjMC45LDAuMiwxLjcsMC4zLDIuNCwwLjVjMS4zLDAuMywyLjMsMC45LDMsMS42Qzc2LjcsMjguMiw3Ny4xLDI5LjIsNzcuMSwzMC41eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik05Mi42LDI4LjhjMCwxLjEtMC4yLDIuMS0wLjUsM2MtMC4zLDAuOS0wLjcsMS42LTEuMywyLjNjLTAuNSwwLjYtMS4xLDEtMS45LDEuNHMtMS41LDAuNS0yLjMsMC41Yy0wLjcsMC0xLjMtMC4xLTEuOS0wLjJjLTAuNi0wLjItMS4xLTAuNC0xLjctMC43djUuNmgtMi4yVjIyLjNoMi4ydjEuNGMwLjYtMC41LDEuMy0wLjksMi0xLjNjMC43LTAuMywxLjUtMC41LDIuNC0wLjVjMS42LDAsMi44LDAuNiwzLjcsMS44QzkyLjIsMjQuOSw5Mi42LDI2LjYsOTIuNiwyOC44eiBNOTAuMywyOC44YzAtMS42LTAuMy0yLjgtMC44LTMuNkM4OC45LDI0LjQsODguMSwyNCw4NywyNGMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0M4OS45LDMxLjcsOTAuMywzMC41LDkwLjMsMjguOHoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTA3LjUsMjkuMWgtOS44YzAsMC44LDAuMSwxLjUsMC40LDIuMWMwLjIsMC42LDAuNiwxLjEsMSwxLjVjMC40LDAuNCwwLjksMC43LDEuNSwwLjljMC42LDAuMiwxLjIsMC4zLDEuOSwwLjNjMC45LDAsMS44LTAuMiwyLjctMC41YzAuOS0wLjQsMS42LTAuNywyLTEuMWgwLjF2Mi40Yy0wLjgsMC4zLTEuNSwwLjYtMi4zLDAuOGMtMC44LDAuMi0xLjYsMC4zLTIuNSwwLjNjLTIuMiwwLTMuOS0wLjYtNS4yLTEuOHMtMS45LTIuOS0xLjktNS4xYzAtMi4yLDAuNi0zLjksMS44LTUuMmMxLjItMS4zLDIuNy0xLjksNC43LTEuOWMxLjgsMCwzLjIsMC41LDQuMSwxLjZjMSwxLDEuNSwyLjUsMS41LDQuNVYyOS4xeiBNMTA1LjMsMjcuNGMwLTEuMi0wLjMtMi4xLTAuOS0yLjdjLTAuNi0wLjYtMS41LTEtMi43LTFjLTEuMiwwLTIuMiwwLjQtMi45LDEuMWMtMC43LDAuNy0xLjEsMS42LTEuMiwyLjZIMTA1LjN6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTExMy4zLDM1LjZoLTIuMlYxN2gyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTI5LjcsMjguOGMwLDEuMS0wLjIsMi4xLTAuNSwzYy0wLjMsMC45LTAuNywxLjYtMS4zLDIuM2MtMC41LDAuNi0xLjEsMS0xLjksMS40cy0xLjUsMC41LTIuMywwLjVjLTAuNywwLTEuMy0wLjEtMS45LTAuMmMtMC42LTAuMi0xLjEtMC40LTEuNy0wLjd2NS42SDExOFYyMi4zaDIuMnYxLjRjMC42LTAuNSwxLjMtMC45LDItMS4zYzAuNy0wLjMsMS41LTAuNSwyLjQtMC41YzEuNiwwLDIuOCwwLjYsMy43LDEuOEMxMjkuMywyNC45LDEyOS43LDI2LjYsMTI5LjcsMjguOHogTTEyNy40LDI4LjhjMC0xLjYtMC4zLTIuOC0wLjgtMy42Yy0wLjUtMC44LTEuNC0xLjItMi41LTEuMmMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0MxMjcuMSwzMS43LDEyNy40LDMwLjUsMTI3LjQsMjguOHoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTQzLjgsMzUuNmgtMi4ydi0xLjRjLTAuMiwwLjEtMC41LDAuMy0wLjgsMC42Yy0wLjMsMC4yLTAuNywwLjQtMSwwLjZjLTAuNCwwLjItMC44LDAuMy0xLjMsMC41Yy0wLjUsMC4xLTEuMSwwLjItMS43LDAuMmMtMS4yLDAtMi4yLTAuNC0zLTEuMnMtMS4yLTEuOC0xLjItM2MwLTEsMC4yLTEuOCwwLjYtMi40YzAuNC0wLjYsMS0xLjEsMS44LTEuNWMwLjgtMC40LDEuOC0wLjYsMi45LTAuN2MxLjEtMC4xLDIuNC0wLjIsMy43LTAuM3YtMC4zYzAtMC41LTAuMS0wLjktMC4zLTEuM2MtMC4yLTAuMy0wLjQtMC42LTAuOC0wLjhjLTAuMy0wLjItMC43LTAuMy0xLjEtMC40cy0wLjktMC4xLTEuNC0wLjFjLTAuNiwwLTEuMiwwLjEtMiwwLjJzLTEuNSwwLjQtMi4yLDAuN2gtMC4xdi0yLjNjMC40LTAuMSwxLjEtMC4zLDEuOS0wLjRjMC44LTAuMSwxLjYtMC4yLDIuNC0wLjJjMC45LDAsMS44LDAuMSwyLjQsMC4yYzAuNywwLjIsMS4zLDAuNCwxLjgsMC44YzAuNSwwLjQsMC45LDAuOCwxLjEsMS40czAuNCwxLjMsMC40LDIuMlYzNS42eiBNMTQxLjUsMzIuM3YtMy43Yy0wLjcsMC0xLjUsMC4xLTIuNCwwLjJzLTEuNywwLjItMi4yLDAuM2MtMC42LDAuMi0xLjIsMC41LTEuNiwwLjlzLTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdzMS4yLDAuNiwyLjEsMC42YzAuOCwwLDEuNS0wLjIsMi4yLTAuNUMxNDAuNCwzMy4xLDE0MSwzMi43LDE0MS41LDMyLjN6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE1OS4zLDM1LjZoLTIuMnYtMS41Yy0wLjgsMC42LTEuNSwxLjEtMi4yLDEuNHMtMS41LDAuNS0yLjMsMC41Yy0xLjQsMC0yLjUtMC40LTMuMy0xLjNzLTEuMi0yLjEtMS4yLTMuOHYtOC42aDIuMnY3LjZjMCwwLjcsMCwxLjMsMC4xLDEuN2MwLjEsMC41LDAuMiwwLjksMC40LDEuMmMwLjIsMC4zLDAuNSwwLjYsMC44LDAuOGMwLjMsMC4yLDAuOCwwLjIsMS41LDAuMmMwLjYsMCwxLjItMC4yLDEuOS0wLjVjMC43LTAuMywxLjMtMC43LDEuOS0xLjJ2LTkuOWgyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTczLjUsMzEuN2MwLDEuMi0wLjUsMi4yLTEuNSwzcy0yLjQsMS4yLTQuMSwxLjJjLTEsMC0xLjktMC4xLTIuNy0wLjRjLTAuOC0wLjItMS41LTAuNS0yLjEtMC44di0yLjVoMC4xYzAuNywwLjUsMS41LDEsMi40LDEuM2MwLjksMC4zLDEuNywwLjUsMi41LDAuNWMxLDAsMS44LTAuMiwyLjMtMC41YzAuNi0wLjMsMC44LTAuOCwwLjgtMS41YzAtMC41LTAuMi0wLjktMC41LTEuMnMtMC45LTAuNS0xLjctMC43Yy0wLjMtMC4xLTAuNy0wLjItMS4yLTAuM2MtMC41LTAuMS0xLTAuMi0xLjQtMC4zYy0xLjItMC4zLTItMC44LTIuNS0xLjRjLTAuNS0wLjYtMC43LTEuMy0wLjctMi4yYzAtMC41LDAuMS0xLjEsMC4zLTEuNWMwLjItMC41LDAuNi0wLjksMS0xLjNjMC40LTAuNCwxLTAuNywxLjctMC45YzAuNy0wLjIsMS41LTAuMywyLjMtMC4zYzAuOCwwLDEuNiwwLjEsMi40LDAuM2MwLjgsMC4yLDEuNSwwLjQsMiwwLjd2Mi40aC0wLjFjLTAuNi0wLjQtMS4zLTAuOC0yLjEtMS4xYy0wLjgtMC4zLTEuNi0wLjQtMi40LTAuNGMtMC44LDAtMS41LDAuMi0yLjEsMC41Yy0wLjYsMC4zLTAuOCwwLjgtMC44LDEuNGMwLDAuNSwwLjIsMSwwLjUsMS4yYzAuMywwLjMsMC45LDAuNSwxLjYsMC43YzAuNCwwLjEsMC45LDAuMiwxLjQsMC4zczAuOSwwLjIsMS4zLDAuM2MxLDAuMiwxLjgsMC42LDIuNCwxLjJDMTczLjIsMzAsMTczLjUsMzAuOCwxNzMuNSwzMS43eiIvPjwvZz48L2c+PHBhdGggY2xhc3M9InN0MCIgZD0iTTI4LjcsMzcuNWgtNi4yYy0wLjUsMC0wLjktMC40LTAuOS0wLjlWMTYuOWMwLTAuNSwwLjQtMC45LDAuOS0wLjloNi4yYzAuNSwwLDAuOSwwLjQsMC45LDAuOXYxOS43QzI5LjYsMzcuMSwyOS4yLDM3LjUsMjguNywzNy41eiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MS41LDM3LjZoLTYuMmMtMC41LDAtMC45LTAuNC0wLjktMC45VjE2LjljMC0wLjUsMC40LTAuOSwwLjktMC45aDYuMmMwLjUsMCwwLjksMC40LDAuOSwwLjl2MTkuN0M0Mi40LDM3LjIsNDIsMzcuNiw0MS41LDM3LjZ6Ii8+PC9zdmc+"/> </a> <a href="#" class="SelfTest" target="_blank" style="text-decoration: none;"> <img style="height:25px;" alt="Sjlvtest" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTgwLjYgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTgwLjYgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6bm9uZTtzdHJva2U6dXJsKCNTVkdJRF8xXyk7c3Ryb2tlLXdpZHRoOjYuNzc0MjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9LnN0M3tmaWxsOiMxRTFFMUM7fTwvc3R5bGU+PGc+PHJlY3QgeD0iMC41IiB5PSIwLjUiIGNsYXNzPSJzdDAiIHdpZHRoPSIxNzkuNSIgaGVpZ2h0PSI1Mi40Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE3OS41LDF2NTEuNEgxVjFIMTc5LjUgTTE4MC42LDBIMHY1My40aDE4MC42VjBMMTgwLjYsMHoiLz48L2c+PGc+PHBhdGggY2xhc3M9InN0MCIgZD0iTTMxLjksNDcuOGMtNS41LTAuMS0xMC43LTIuMy0xNC42LTYuMmMtMy45LTQtNi05LjItNS45LTE0LjhjMC4xLTExLjMsOS40LTIwLjYsMjAuOC0yMC42bDAuMiwwYzUuNSwwLjEsMTAuNywyLjMsMTQuNiw2LjJjMy45LDQsNiw5LjIsNS45LDE0LjhjLTAuMSwxMS4zLTkuNCwyMC42LTIwLjgsMjAuNkwzMS45LDQ3Ljh6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTMyLjEsNS43djFsMC4yLDBjNS40LDAuMSwxMC41LDIuMiwxNC4zLDYuMWMzLjgsMy45LDUuOCw5LDUuOCwxNC40Yy0wLjEsMTEuMS05LjIsMjAuMS0yMC4zLDIwLjFsLTAuMiwwYy01LjQtMC4xLTEwLjUtMi4yLTE0LjMtNi4xYy0zLjgtMy45LTUuOC05LTUuOC0xNC40YzAuMS0xMS4xLDkuMi0yMC4xLDIwLjMtMjAuMUwzMi4xLDUuNyBNMzIuMSw1LjdjLTExLjYsMC0yMS4xLDkuNC0yMS4zLDIxYy0wLjEsMTEuNyw5LjMsMjEuNCwyMSwyMS41YzAuMSwwLDAuMSwwLDAuMiwwYzExLjYsMCwyMS4xLTkuNCwyMS4zLTIxYzAuMS0xMS43LTkuMy0yMS40LTIxLTIxLjVDMzIuMyw1LjcsMzIuMiw1LjcsMzIuMSw1LjdMMzIuMSw1Ljd6Ii8+PC9nPjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTMuMzkwNCIgeTE9Ii0zMDMuMjA3NyIgeDI9IjUwLjYwNDMiIHkyPSItMzAzLjIwNzciIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIC0xIDY0LjAwMDUgLTI4My41MzY1KSI+PHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0U0MTkxMyIvPjxzdG9wICBvZmZzZXQ9IjkuNzQ0MDIwZS0wMiIgc3R5bGU9InN0b3AtY29sb3I6I0VBNjUxNiIvPjxzdG9wICBvZmZzZXQ9IjAuMjE0OCIgc3R5bGU9InN0b3AtY29sb3I6I0YzQTUxOCIvPjxzdG9wICBvZmZzZXQ9IjAuMzEyMSIgc3R5bGU9InN0b3AtY29sb3I6I0Y5Q0QxQSIvPjxzdG9wICBvZmZzZXQ9IjAuMzg0IiBzdHlsZT0ic3RvcC1jb2xvcjojRkRFMzFBIi8+PHN0b3AgIG9mZnNldD0iMC40MjI4IiBzdHlsZT0ic3RvcC1jb2xvcjojRkVFQjFBIi8+PHN0b3AgIG9mZnNldD0iMC42MjMxIiBzdHlsZT0ic3RvcC1jb2xvcjojREZERTIwIi8+PHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6IzAwOTI0NSIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InN0MiIgZD0iTTQ3LjIsMjYuN2MtMi4yLTE4LjYtMjcuOC0xOS0zMC40LDAiLz48Zz48cGF0aCBjbGFzcz0ic3QzIiBkPSJNMjcuNywyNy4zbDguOC0xNS44bC0xLjgsMThjLTAuNiwxLjktMi43LDMtNC42LDIuNFMyNy4xLDI5LjIsMjcuNywyNy4zeiIvPjwvZz48Zz48Zz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNNzYuNSwzMC41YzAsMC43LTAuMiwxLjQtMC41LDJzLTAuOCwxLjItMS40LDEuN2MtMC42LDAuNS0xLjQsMC45LTIuMiwxLjJjLTAuOCwwLjMtMS45LDAuNC0zLjEsMC40Yy0xLjMsMC0yLjQtMC4xLTMuNC0wLjRjLTEtMC4yLTIuMS0wLjYtMy4xLTEuMXYtM0g2M2MwLjksMC43LDEuOSwxLjMsMy4xLDEuN2MxLjIsMC40LDIuMywwLjYsMy4zLDAuNmMxLjUsMCwyLjYtMC4zLDMuNC0wLjhjMC44LTAuNSwxLjItMS4zLDEuMi0yLjJjMC0wLjgtMC4yLTEuNC0wLjYtMS43cy0xLTAuNy0xLjgtMC45Yy0wLjYtMC4yLTEuMi0wLjMtMS45LTAuNGMtMC43LTAuMS0xLjQtMC4yLTIuMi0wLjRjLTEuNi0wLjMtMi43LTAuOS0zLjUtMS43Yy0wLjgtMC44LTEuMS0xLjktMS4xLTMuMWMwLTEuNSwwLjYtMi43LDEuOS0zLjZjMS4zLTAuOSwyLjgtMS40LDQuOC0xLjRjMS4yLDAsMi40LDAuMSwzLjQsMC40YzEsMC4yLDIsMC41LDIuOCwwLjl2Mi44aC0wLjJjLTAuNy0wLjYtMS42LTEtMi43LTEuNGMtMS4xLTAuNC0yLjItMC42LTMuNC0wLjZjLTEuMywwLTIuMywwLjMtMywwLjhjLTAuOCwwLjUtMS4xLDEuMi0xLjEsMmMwLDAuNywwLjIsMS4zLDAuNiwxLjdjMC40LDAuNCwxLjEsMC43LDIsMWMwLjUsMC4xLDEuMiwwLjIsMi4yLDAuNGMwLjksMC4yLDEuNywwLjMsMi40LDAuNWMxLjMsMC4zLDIuMywwLjksMywxLjZDNzYuMSwyOC4zLDc2LjUsMjkuMyw3Ni41LDMwLjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTg0LjMsMzUuOWMwLDEuNi0wLjQsMi43LTEuMiwzLjVzLTEuOSwxLjItMy4yLDEuMmMtMC4zLDAtMC43LDAtMS4zLTAuMWMtMC41LTAuMS0xLTAuMS0xLjMtMC4ydi0yLjFoMC4xYzAuMiwwLjEsMC41LDAuMiwwLjksMC4zYzAuNCwwLjEsMC43LDAuMiwxLjEsMC4yYzAuNiwwLDEtMC4xLDEuNC0wLjJjMC4zLTAuMiwwLjYtMC40LDAuOC0wLjdjMC4yLTAuMywwLjMtMC43LDAuMy0xLjFjMC4xLTAuNCwwLjEtMSwwLjEtMS42VjI0LjJoLTIuOHYtMS45aDVWMzUuOXogTTg0LjUsMjAuMWgtMi41di0yLjNoMi41VjIwLjF6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTk5LjMsMzUuNkg5N3YtMS40Yy0wLjIsMC4xLTAuNSwwLjMtMC44LDAuNnMtMC43LDAuNC0xLDAuNmMtMC40LDAuMi0wLjgsMC4zLTEuMywwLjVjLTAuNSwwLjEtMS4xLDAuMi0xLjcsMC4yYy0xLjIsMC0yLjItMC40LTMtMS4yQzg4LjQsMzQsODgsMzMsODgsMzEuN2MwLTEsMC4yLTEuOCwwLjYtMi40YzAuNC0wLjYsMS0xLjEsMS44LTEuNWMwLjgtMC40LDEuOC0wLjYsMi45LTAuN2MxLjEtMC4xLDIuNC0wLjIsMy43LTAuM3YtMC4zYzAtMC41LTAuMS0wLjktMC4zLTEuM3MtMC40LTAuNi0wLjgtMC44Yy0wLjMtMC4yLTAuNy0wLjMtMS4xLTAuNGMtMC40LTAuMS0wLjktMC4xLTEuNC0wLjFjLTAuNiwwLTEuMiwwLjEtMiwwLjJjLTAuNywwLjItMS41LDAuNC0yLjIsMC43aC0wLjF2LTIuM2MwLjQtMC4xLDEuMS0wLjMsMS45LTAuNGMwLjgtMC4xLDEuNi0wLjIsMi40LTAuMmMwLjksMCwxLjgsMC4xLDIuNCwwLjJjMC43LDAuMiwxLjMsMC40LDEuOCwwLjhjMC41LDAuNCwwLjksMC44LDEuMSwxLjRzMC40LDEuMywwLjQsMi4yVjM1LjZ6IE05NywzMi4zdi0zLjdjLTAuNywwLTEuNSwwLjEtMi40LDAuMlM5MywyOSw5Mi40LDI5LjFjLTAuNiwwLjItMS4yLDAuNS0xLjYsMC45Yy0wLjQsMC40LTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdjMC41LDAuNCwxLjIsMC42LDIuMSwwLjZjMC44LDAsMS41LTAuMiwyLjItMC41Qzk1LjksMzMuMSw5Ni41LDMyLjcsOTcsMzIuM3ogTTkyLjgsMjAuMWgtMi40di0yLjNoMi40VjIwLjF6IE05Ny44LDIwLjFoLTIuNHYtMi4zaDIuNFYyMC4xeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xMDYuMSwzNS42aC0yLjJWMTcuMWgyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTIyLjIsMjIuM2wtNS40LDEzLjNoLTIuMmwtNS4zLTEzLjNoMi40bDQuMSwxMC42bDQuMS0xMC42SDEyMi4yeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xMzIuMywzNS41Yy0wLjQsMC4xLTAuOSwwLjItMS40LDAuM2MtMC41LDAuMS0wLjksMC4xLTEuMywwLjFjLTEuNCwwLTIuNC0wLjQtMy4xLTEuMWMtMC43LTAuNy0xLjEtMS45LTEuMS0zLjV2LTcuMWgtMS41di0xLjloMS41di0zLjhoMi4ydjMuOGg0LjZ2MS45aC00LjZ2Ni4xYzAsMC43LDAsMS4yLDAsMS42YzAsMC40LDAuMSwwLjgsMC4zLDEuMWMwLjIsMC4zLDAuNCwwLjUsMC43LDAuN2MwLjMsMC4xLDAuOCwwLjIsMS40LDAuMmMwLjQsMCwwLjctMC4xLDEuMS0wLjJjMC40LTAuMSwwLjctMC4yLDAuOS0wLjNoMC4xVjM1LjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE0Ni40LDI5LjJoLTkuOGMwLDAuOCwwLjEsMS41LDAuNCwyLjFjMC4yLDAuNiwwLjYsMS4xLDEsMS41YzAuNCwwLjQsMC45LDAuNywxLjUsMC45YzAuNiwwLjIsMS4yLDAuMywxLjksMC4zYzAuOSwwLDEuOC0wLjIsMi43LTAuNWMwLjktMC40LDEuNi0wLjcsMi0xLjFoMC4xdjIuNGMtMC44LDAuMy0xLjUsMC42LTIuMywwLjhzLTEuNiwwLjMtMi41LDAuM2MtMi4yLDAtMy45LTAuNi01LjItMS44Yy0xLjItMS4yLTEuOS0yLjktMS45LTUuMWMwLTIuMiwwLjYtMy45LDEuOC01LjJjMS4yLTEuMywyLjctMS45LDQuNy0xLjljMS44LDAsMy4yLDAuNSw0LjEsMS42YzEsMSwxLjUsMi41LDEuNSw0LjVWMjkuMnogTTE0NC4yLDI3LjVjMC0xLjItMC4zLTIuMS0wLjktMi43cy0xLjUtMS0yLjctMWMtMS4yLDAtMi4yLDAuNC0yLjksMS4xYy0wLjcsMC43LTEuMSwxLjYtMS4yLDIuNkgxNDQuMnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTU5LjUsMzEuN2MwLDEuMi0wLjUsMi4yLTEuNSwzcy0yLjQsMS4yLTQuMSwxLjJjLTEsMC0xLjktMC4xLTIuNy0wLjRjLTAuOC0wLjItMS41LTAuNS0yLjEtMC44di0yLjVoMC4xYzAuNywwLjUsMS41LDEsMi40LDEuM3MxLjcsMC41LDIuNSwwLjVjMSwwLDEuOC0wLjIsMi4zLTAuNWMwLjYtMC4zLDAuOC0wLjgsMC44LTEuNWMwLTAuNS0wLjItMC45LTAuNS0xLjJzLTAuOS0wLjUtMS43LTAuN2MtMC4zLTAuMS0wLjctMC4yLTEuMi0wLjNjLTAuNS0wLjEtMS0wLjItMS40LTAuM2MtMS4yLTAuMy0yLTAuOC0yLjUtMS40Yy0wLjUtMC42LTAuNy0xLjMtMC43LTIuMmMwLTAuNSwwLjEtMS4xLDAuMy0xLjVjMC4yLTAuNSwwLjYtMC45LDEtMS4zYzAuNC0wLjQsMS0wLjcsMS43LTAuOWMwLjctMC4yLDEuNS0wLjMsMi4zLTAuM2MwLjgsMCwxLjYsMC4xLDIuNCwwLjNjMC44LDAuMiwxLjUsMC40LDIsMC43djIuNGgtMC4xYy0wLjYtMC40LTEuMy0wLjgtMi4xLTEuMWMtMC44LTAuMy0xLjYtMC40LTIuNC0wLjRjLTAuOCwwLTEuNSwwLjItMi4xLDAuNWMtMC42LDAuMy0wLjgsMC44LTAuOCwxLjRjMCwwLjUsMC4yLDEsMC41LDEuMmMwLjMsMC4zLDAuOSwwLjUsMS42LDAuN2MwLjQsMC4xLDAuOSwwLjIsMS40LDAuM2MwLjUsMC4xLDAuOSwwLjIsMS4zLDAuM2MxLDAuMiwxLjgsMC42LDIuNCwxLjJDMTU5LjIsMzAsMTU5LjUsMzAuOCwxNTkuNSwzMS43eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNjkuOSwzNS41Yy0wLjQsMC4xLTAuOSwwLjItMS40LDAuM2MtMC41LDAuMS0wLjksMC4xLTEuMywwLjFjLTEuNCwwLTIuNC0wLjQtMy4xLTEuMWMtMC43LTAuNy0xLjEtMS45LTEuMS0zLjV2LTcuMWgtMS41di0xLjloMS41di0zLjhoMi4ydjMuOGg0LjZ2MS45aC00LjZ2Ni4xYzAsMC43LDAsMS4yLDAsMS42YzAsMC40LDAuMSwwLjgsMC4zLDEuMWMwLjIsMC4zLDAuNCwwLjUsMC43LDAuN2MwLjMsMC4xLDAuOCwwLjIsMS40LDAuMmMwLjQsMCwwLjctMC4xLDEuMS0wLjJjMC40LTAuMSwwLjctMC4yLDAuOS0wLjNoMC4xVjM1LjV6Ii8+PC9nPjwvZz48L3N2Zz4="/> </a> <a href="#" class="PlayLimit" target="_blank" style="text-decoration: none;"> <img style="height:25px;" alt="Spelgrnser" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjE5LjYgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMjE5LjYgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6IzAwOTczOTt9LnN0M3tmaWxsOiNGRkZGRkY7c3Ryb2tlOiMwMDk3Mzk7c3Ryb2tlLXdpZHRoOjMuODcxO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO30uc3Q0e2ZpbGw6bm9uZTtzdHJva2U6IzAwOTczOTtzdHJva2Utd2lkdGg6MS45MzU1O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO308L3N0eWxlPjxnPjxyZWN0IHg9IjAuNSIgeT0iMC41IiBjbGFzcz0ic3QwIiB3aWR0aD0iMjE4LjUiIGhlaWdodD0iNTIuNCIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0yMTguNSwxdjUxLjRIMVYxSDIxOC41IE0yMTkuNiwwSDB2NTMuNGgyMTkuNlYwTDIxOS42LDB6Ii8+PC9nPjxnPjxnPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik03OC4yLDMwLjZjMCwwLjctMC4yLDEuNC0wLjUsMmMtMC4zLDAuNy0wLjgsMS4yLTEuNCwxLjdjLTAuNiwwLjUtMS40LDAuOS0yLjIsMS4yYy0wLjgsMC4zLTEuOSwwLjQtMy4xLDAuNGMtMS4zLDAtMi40LTAuMS0zLjQtMC40Yy0xLTAuMi0yLjEtMC42LTMuMS0xLjF2LTIuOWgwLjJjMC45LDAuNywxLjksMS4zLDMuMSwxLjdjMS4yLDAuNCwyLjMsMC42LDMuMywwLjZjMS41LDAsMi42LTAuMywzLjQtMC44YzAuOC0wLjUsMS4yLTEuMywxLjItMi4yYzAtMC44LTAuMi0xLjQtMC42LTEuN3MtMS0wLjctMS44LTAuOWMtMC42LTAuMi0xLjItMC4zLTEuOS0wLjRjLTAuNy0wLjEtMS40LTAuMi0yLjItMC40Yy0xLjYtMC4zLTIuNy0wLjktMy41LTEuN3MtMS4xLTEuOS0xLjEtMy4xYzAtMS41LDAuNi0yLjcsMS45LTMuNmMxLjMtMC45LDIuOC0xLjQsNC44LTEuNGMxLjIsMCwyLjQsMC4xLDMuNCwwLjRjMSwwLjIsMiwwLjUsMi44LDAuOXYyLjhoLTAuMmMtMC43LTAuNi0xLjYtMS0yLjctMS40Yy0xLjEtMC40LTIuMi0wLjYtMy40LTAuNmMtMS4zLDAtMi4zLDAuMy0zLDAuOHMtMS4xLDEuMi0xLjEsMmMwLDAuNywwLjIsMS4zLDAuNiwxLjdjMC40LDAuNCwxLjEsMC43LDIsMWMwLjUsMC4xLDEuMiwwLjIsMi4yLDAuNGMwLjksMC4yLDEuNywwLjMsMi40LDAuNWMxLjMsMC4zLDIuMywwLjksMywxLjZDNzcuOSwyOC4zLDc4LjIsMjkuMyw3OC4yLDMwLjZ6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTkzLjYsMjguOGMwLDEuMS0wLjIsMi4xLTAuNSwzYy0wLjMsMC45LTAuNywxLjYtMS4zLDIuM2MtMC41LDAuNi0xLjEsMS0xLjgsMS40Yy0wLjcsMC4zLTEuNSwwLjUtMi4zLDAuNWMtMC43LDAtMS4zLTAuMS0xLjktMC4yYy0wLjYtMC4yLTEuMS0wLjQtMS43LTAuN3Y1LjZoLTIuMlYyMi4zaDIuMnYxLjRjMC42LTAuNSwxLjMtMC45LDItMS4zYzAuNy0wLjMsMS41LTAuNSwyLjQtMC41YzEuNiwwLDIuOCwwLjYsMy43LDEuOEM5My4yLDI1LDkzLjYsMjYuNyw5My42LDI4Ljh6IE05MS4zLDI4LjljMC0xLjYtMC4zLTIuOC0wLjgtMy42Yy0wLjUtMC44LTEuNC0xLjItMi41LTEuMmMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0M5MSwzMS44LDkxLjMsMzAuNSw5MS4zLDI4Ljl6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTEwOC4zLDI5LjJoLTkuOGMwLDAuOCwwLjEsMS41LDAuNCwyLjFjMC4yLDAuNiwwLjYsMS4xLDEsMS41YzAuNCwwLjQsMC45LDAuNywxLjUsMC45czEuMiwwLjMsMS45LDAuM2MwLjksMCwxLjgtMC4yLDIuNy0wLjVjMC45LTAuNCwxLjYtMC43LDItMS4xaDAuMXYyLjRjLTAuOCwwLjMtMS41LDAuNi0yLjMsMC44cy0xLjYsMC4zLTIuNSwwLjNjLTIuMiwwLTMuOS0wLjYtNS4yLTEuOGMtMS4yLTEuMi0xLjktMi45LTEuOS01LjFjMC0yLjIsMC42LTMuOSwxLjgtNS4yYzEuMi0xLjMsMi43LTEuOSw0LjctMS45YzEuOCwwLDMuMiwwLjUsNC4xLDEuNmMxLDEsMS41LDIuNSwxLjUsNC41VjI5LjJ6IE0xMDYuMiwyNy41YzAtMS4yLTAuMy0yLjEtMC45LTIuN2MtMC42LTAuNi0xLjUtMS0yLjctMWMtMS4yLDAtMi4yLDAuNC0yLjksMS4xYy0wLjcsMC43LTEuMSwxLjYtMS4yLDIuNkgxMDYuMnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTE0LjEsMzUuNmgtMi4yVjE3LjFoMi4yVjM1LjZ6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTEyOS40LDM0LjFjMCwyLjMtMC41LDMuOS0xLjUsNWMtMSwxLjEtMi42LDEuNi00LjcsMS42Yy0wLjcsMC0xLjQsMC0yLjEtMC4xYy0wLjctMC4xLTEuMy0wLjItMi0wLjR2LTIuM2gwLjFjMC40LDAuMSwwLjksMC4zLDEuNywwLjVzMS42LDAuMywyLjQsMC4zYzAuOCwwLDEuNC0wLjEsMS45LTAuM2MwLjUtMC4yLDAuOS0wLjQsMS4yLTAuOGMwLjMtMC4zLDAuNS0wLjcsMC42LTEuMWMwLjEtMC40LDAuMi0wLjksMC4yLTEuNXYtMS4yYy0wLjcsMC41LTEuMywwLjktMS45LDEuMnMtMS40LDAuNC0yLjMsMC40Yy0xLjYsMC0yLjgtMC42LTMuOC0xLjdjLTAuOS0xLjEtMS40LTIuOC0xLjQtNC44YzAtMS4xLDAuMi0yLjEsMC41LTNjMC4zLTAuOCwwLjgtMS41LDEuMy0yLjFjMC41LTAuNiwxLjEtMSwxLjktMS4zYzAuNy0wLjMsMS41LTAuNSwyLjItMC41YzAuOCwwLDEuNCwwLjEsMS45LDAuMnMxLjEsMC40LDEuNiwwLjdsMC4xLTAuNmgyLjFWMzQuMXogTTEyNy4yLDMydi03LjJjLTAuNi0wLjMtMS4xLTAuNS0xLjctMC42Yy0wLjUtMC4xLTEtMC4yLTEuNS0wLjJjLTEuMiwwLTIuMiwwLjQtMi45LDEuMnMtMS4xLDItMS4xLDMuNmMwLDEuNSwwLjMsMi42LDAuOCwzLjRjMC41LDAuOCwxLjQsMS4yLDIuNiwxLjJjMC43LDAsMS4zLTAuMSwyLTAuNFMxMjYuNiwzMi40LDEyNy4yLDMyeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNDIuMiwyNC44aC0wLjFjLTAuMy0wLjEtMC43LTAuMS0xLTAuMmMtMC4zLDAtMC43LTAuMS0xLjEtMC4xYy0wLjcsMC0xLjQsMC4yLTIsMC41Yy0wLjYsMC4zLTEuMywwLjctMS45LDEuMnY5LjRIMTM0VjIyLjNoMi4ydjJjMC45LTAuNywxLjctMS4yLDIuMy0xLjVjMC43LTAuMywxLjQtMC40LDIuMS0wLjRjMC40LDAsMC43LDAsMC44LDBjMC4yLDAsMC40LDAuMSwwLjgsMC4xVjI0Ljh6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE1NC44LDM1LjZoLTIuMnYtMS40Yy0wLjIsMC4xLTAuNSwwLjMtMC44LDAuNnMtMC43LDAuNC0xLDAuNmMtMC40LDAuMi0wLjgsMC4zLTEuMywwLjVjLTAuNSwwLjEtMS4xLDAuMi0xLjcsMC4yYy0xLjIsMC0yLjItMC40LTMtMS4yYy0wLjgtMC44LTEuMi0xLjgtMS4yLTNjMC0xLDAuMi0xLjgsMC42LTIuNGMwLjQtMC42LDEtMS4xLDEuOC0xLjVjMC44LTAuNCwxLjgtMC42LDIuOS0wLjdzMi40LTAuMiwzLjctMC4zdi0wLjNjMC0wLjUtMC4xLTAuOS0wLjMtMS4zYy0wLjItMC4zLTAuNC0wLjYtMC44LTAuOGMtMC4zLTAuMi0wLjctMC4zLTEuMS0wLjRDMTUwLDI0LDE0OS41LDI0LDE0OSwyNGMtMC42LDAtMS4yLDAuMS0yLDAuMmMtMC43LDAuMi0xLjUsMC40LTIuMiwwLjdoLTAuMXYtMi4zYzAuNC0wLjEsMS4xLTAuMiwxLjktMC40YzAuOC0wLjEsMS42LTAuMiwyLjQtMC4yYzAuOSwwLDEuOCwwLjEsMi40LDAuMmMwLjcsMC4yLDEuMywwLjQsMS44LDAuOGMwLjUsMC40LDAuOSwwLjgsMS4xLDEuNGMwLjMsMC42LDAuNCwxLjMsMC40LDIuMlYzNS42eiBNMTUyLjYsMzIuM3YtMy43Yy0wLjcsMC0xLjUsMC4xLTIuNCwwLjJzLTEuNywwLjItMi4yLDAuM2MtMC42LDAuMi0xLjIsMC41LTEuNiwwLjlzLTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdzMS4yLDAuNiwyLjEsMC42YzAuOCwwLDEuNS0wLjIsMi4yLTAuNUMxNTEuNCwzMy4xLDE1MiwzMi44LDE1Mi42LDMyLjN6IE0xNDguNCwyMC4xSDE0NnYtMi4zaDIuNFYyMC4xeiBNMTUzLjMsMjAuMWgtMi40di0yLjNoMi40VjIwLjF6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE3MC4zLDM1LjZoLTIuMnYtNy42YzAtMC42LDAtMS4yLTAuMS0xLjdzLTAuMi0xLTAuNC0xLjNjLTAuMi0wLjMtMC41LTAuNi0wLjktMC43Yy0wLjQtMC4yLTAuOS0wLjItMS41LTAuMmMtMC42LDAtMS4yLDAuMi0xLjksMC41Yy0wLjcsMC4zLTEuMywwLjctMS45LDEuMnY5LjloLTIuMlYyMi4zaDIuMnYxLjVjMC43LTAuNiwxLjQtMSwyLjItMS40YzAuNy0wLjMsMS41LTAuNSwyLjMtMC41YzEuNCwwLDIuNSwwLjQsMy4zLDEuM2MwLjgsMC45LDEuMSwyLjEsMS4xLDMuN1YzNS42eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xODQuMywzMS44YzAsMS4yLTAuNSwyLjItMS41LDNjLTEsMC44LTIuNCwxLjItNC4xLDEuMmMtMSwwLTEuOS0wLjEtMi43LTAuNGMtMC44LTAuMi0xLjUtMC41LTIuMS0wLjh2LTIuNWgwLjFjMC43LDAuNSwxLjUsMSwyLjQsMS4zczEuNywwLjUsMi41LDAuNWMxLDAsMS44LTAuMiwyLjMtMC41YzAuNi0wLjMsMC44LTAuOCwwLjgtMS41YzAtMC41LTAuMi0wLjktMC41LTEuMnMtMC45LTAuNS0xLjctMC43Yy0wLjMtMC4xLTAuNy0wLjItMS4yLTAuM2MtMC41LTAuMS0xLTAuMi0xLjQtMC4zYy0xLjItMC4zLTItMC44LTIuNS0xLjRjLTAuNS0wLjYtMC43LTEuMy0wLjctMi4yYzAtMC41LDAuMS0xLjEsMC4zLTEuNWMwLjItMC41LDAuNi0wLjksMS0xLjNjMC40LTAuNCwxLTAuNywxLjctMC45YzAuNy0wLjIsMS41LTAuMywyLjMtMC4zYzAuOCwwLDEuNiwwLjEsMi40LDAuM2MwLjgsMC4yLDEuNSwwLjQsMiwwLjd2Mi40aC0wLjFjLTAuNi0wLjQtMS4zLTAuOC0yLjEtMS4xYy0wLjgtMC4zLTEuNi0wLjQtMi40LTAuNGMtMC44LDAtMS41LDAuMi0yLjEsMC41Yy0wLjYsMC4zLTAuOCwwLjgtMC44LDEuNGMwLDAuNSwwLjIsMSwwLjUsMS4yYzAuMywwLjMsMC45LDAuNSwxLjYsMC43YzAuNCwwLjEsMC45LDAuMiwxLjQsMC4zYzAuNSwwLjEsMC45LDAuMiwxLjMsMC4zYzEsMC4yLDEuOCwwLjYsMi40LDEuMkMxODQsMzAsMTg0LjMsMzAuOCwxODQuMywzMS44eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xOTguNywyOS4yaC05LjhjMCwwLjgsMC4xLDEuNSwwLjQsMi4xczAuNiwxLjEsMSwxLjVjMC40LDAuNCwwLjksMC43LDEuNSwwLjljMC42LDAuMiwxLjIsMC4zLDEuOSwwLjNjMC45LDAsMS44LTAuMiwyLjctMC41YzAuOS0wLjQsMS42LTAuNywyLTEuMWgwLjF2Mi40Yy0wLjgsMC4zLTEuNSwwLjYtMi4zLDAuOHMtMS42LDAuMy0yLjUsMC4zYy0yLjIsMC0zLjktMC42LTUuMi0xLjhjLTEuMi0xLjItMS45LTIuOS0xLjktNS4xYzAtMi4yLDAuNi0zLjksMS44LTUuMmMxLjItMS4zLDIuNy0xLjksNC43LTEuOWMxLjgsMCwzLjIsMC41LDQuMSwxLjZzMS41LDIuNSwxLjUsNC41VjI5LjJ6IE0xOTYuNSwyNy41YzAtMS4yLTAuMy0yLjEtMC45LTIuN3MtMS41LTEtMi43LTFjLTEuMiwwLTIuMiwwLjQtMi45LDEuMWMtMC43LDAuNy0xLjEsMS42LTEuMiwyLjZIMTk2LjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTIxMC41LDI0LjhoLTAuMWMtMC4zLTAuMS0wLjctMC4xLTEtMC4yYy0wLjMsMC0wLjctMC4xLTEuMS0wLjFjLTAuNywwLTEuNCwwLjItMiwwLjVjLTAuNiwwLjMtMS4zLDAuNy0xLjksMS4ydjkuNGgtMi4yVjIyLjNoMi4ydjJjMC45LTAuNywxLjctMS4yLDIuMy0xLjVjMC43LTAuMywxLjQtMC40LDIuMS0wLjRjMC40LDAsMC43LDAsMC44LDBjMC4yLDAsMC40LDAuMSwwLjgsMC4xVjI0Ljh6Ii8+PC9nPjwvZz48Zz48cGF0aCBjbGFzcz0ic3QwIiBkPSJNMzIuNSw0Ny4zYy0xMS4yLDAtMjAuMy05LjEtMjAuMy0yMC4zUzIxLjMsNi43LDMyLjUsNi43YzExLjIsMCwyMC4zLDkuMSwyMC4zLDIwLjNTNDMuNyw0Ny4zLDMyLjUsNDcuM3oiLz48cGF0aCBjbGFzcz0ic3QyIiBkPSJNMzIuNSw3LjdjMTAuNywwLDE5LjMsOC43LDE5LjMsMTkuM2MwLDEwLjctOC43LDE5LjMtMTkuMywxOS4zYy0xMC43LDAtMTkuMy04LjctMTkuMy0xOS4zQzEzLjIsMTYuMywyMS44LDcuNywzMi41LDcuNyBNMzIuNSw1LjdjLTExLjcsMC0yMS4zLDkuNS0yMS4zLDIxLjNjMCwxMS43LDkuNSwyMS4zLDIxLjMsMjEuM2MxMS43LDAsMjEuMy05LjUsMjEuMy0yMS4zQzUzLjcsMTUuMiw0NC4yLDUuNywzMi41LDUuN0wzMi41LDUuN3oiLz48L2c+PGxpbmUgY2xhc3M9InN0MyIgeDE9IjI2LjciIHkxPSIxNC4zIiB4Mj0iMzQuNCIgeTI9IjI2LjUiLz48bGluZSBjbGFzcz0ic3QzIiB4MT0iMjUuMyIgeTE9IjMzLjMiIHgyPSIzNC41IiB5Mj0iMjYuOSIvPjxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjQ4LjYiIGN5PSIzNi4yIiByPSIxMi45Ii8+PGc+PHBhdGggY2xhc3M9InN0MCIgZD0iTTQxLjMsMjkuOEg0NHY1LjRoMGw0LjItNS40aDMuNGwtNC44LDYuMWw1LDYuN2gtMy4zbC00LjUtNmgwdjZoLTIuN1YyOS44eiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik01NS4xLDM0LjJ2MS4yaDBjMC4yLTAuNCwwLjUtMC43LDAuOS0xYzAuMy0wLjIsMC42LTAuNCwwLjktMC40YzAuMiwwLDAuMywwLDAuNSwwdjIuN2MtMC4yLDAtMC40LTAuMS0wLjYtMC4xYy0wLjUsMC0wLjksMC4yLTEuMiwwLjVjLTAuMywwLjQtMC40LDAuOS0wLjQsMS41djMuN2gtMi41di04LjNINTUuMXoiLz48L2c+PGxpbmUgY2xhc3M9InN0NCIgeDE9IjE2IiB5MT0iMjciIHgyPSIxOC40IiB5Mj0iMjciLz48bGluZSBjbGFzcz0ic3Q0IiB4MT0iMzIuNyIgeTE9IjEyLjciIHgyPSIzMi43IiB5Mj0iMTAuMyIvPjxsaW5lIGNsYXNzPSJzdDQiIHgxPSIzMi41IiB5MT0iNDQuMiIgeDI9IjMyLjUiIHkyPSI0MS44Ii8+PC9zdmc+"/> </a><div id="InloggadLandscape" style="color:#fff; display:inline-block; float: right; font-size: 18px; padding-top: 3px;"></div></div></div>';
    if (!hasLogos) htmlString = htmlString.replace(/<a\b[^>]*>(.*?)<\/a>/g, "");
    var htmlContent = (new DOMParser).parseFromString(htmlString, "text/html");
    document.body.insertBefore(htmlContent.firstChild, document.getElementsByTagName("canvas")[0]);
    if (hasLogos) {
        var pausePlayContainers = document.getElementsByClassName("PausePlay");
        var selfTestContainers = document.getElementsByClassName("SelfTest");
        var playLimitContainers = document.getElementsByClassName("PlayLimit");
        for (var i = 0; i < pausePlayContainers.length; i++) {
            pausePlayContainers[i].href =
                UHT_GAME_CONFIG["pauseplayUrl"];
            selfTestContainers[i].href = UHT_GAME_CONFIG["selftestUrl"];
            playLimitContainers[i].href = UHT_GAME_CONFIG["playlimitUrl"]
        }
    }
    this.elapsedTimeContainerLandscape = document.getElementById("InloggadLandscape");
    this.elapsedTimeContainerPortrait = document.getElementById("InloggadPortrait");
    document.getElementsByTagName("canvas")[0].classList.add("SwedishCanvas")
};
SwedishRegulationManager.prototype.UpdateTimer = function() {
    var currentTime = (new Date).getTime();
    this.elapsedTime = Math.floor((currentTime - this.initialTime) / 1E3) + this.initialElapsedTime;
    var seconds = (parseInt(this.elapsedTime, 10) % 60).toString();
    var minutes = parseInt(parseInt(this.elapsedTime, 10) / 60 % 60, 10).toString();
    var hours = parseInt(parseInt(this.elapsedTime, 10) / 3600, 10).toString();
    if (seconds.length < 2) seconds = "0" + seconds;
    if (minutes.length < 2) minutes = "0" + minutes;
    if (hours.length < 2) hours = "0" + hours;
    this.elapsedTimeContainerLandscape.innerHTML =
        "Inloggad: " + hours + ":" + minutes + ":" + seconds;
    if (this.elapsedTimeContainerPortrait != null) this.elapsedTimeContainerPortrait.innerHTML = "Inloggad: " + hours + ":" + minutes + ":" + seconds
};
SwedishRegulationManager.prototype.OnUHTResize = function(unused) {
    var canv = document.getElementsByTagName("canvas")[0];
    var rgsParent = document.getElementsByClassName("RGSContainerActive")[0].dataset;
    var pixelRatio = UHTScreen.height / window.innerHeight;
    var scale = 1 - rgsParent.height * pixelRatio / UHTScreen.height;
    var sign = document.documentElement.className.indexOf("iPhone") >= 0 && document.documentElement.id == "Mobile" && window.orientation == 90 ? 1 : -1;
    var transY = sign * (rgsParent.height * pixelRatio / (UHTScreen.height - rgsParent.height *
        pixelRatio) / 2) * 100;
    canv.style.transform = "scale(" + scale + ") translateY(" + transY + "%)"
};
goog.provide("UHT.TournamentConnection");

function TournamentConnection() {
    this.xtLayer = null;
    this.reloadEndedLeaderboardsInterval = 120;
    this.reloadLeaderboardsInterval = 30;
    this.leaderboardsTimer = 30;
    this.isReloadindLeaderboards = false;
    this.leaderboardsDiscardedTime = 0;
    this.leaderboardsReloadedTime = 0;
    this.reloadTournamentsInterval = 300;
    this.tournamentsTimer = 300;
    this.isReloadindTournaments = false;
    this.reloadRacePrizesInterval = 30;
    this.racePrizesTimer = 30;
    this.isReloadindRacePrizes = false;
    this.reloadRaceWinnersInterval = 30;
    this.raceWinnersTimer = 30;
    this.isReloadindRaceWinners =
        false;
    this.raceWinnersReloadedTime = 0;
    this.reloadTournamentScoresInterval = 30;
    this.tournamentScoresTimer = 30;
    this.isReloadingTournamentScores = false;
    this.tournamentScoresDiscardedTime = 0;
    this.tournamentScoresReloadedTime = 0;
    this.tournamentIds = [];
    this.raceIds = [];
    this.tournamentsURL;
    this.detailsURL;
    this.leaderboardsURL;
    this.raceDetailsURL;
    this.racePrizesURL;
    this.raceWinnersURL;
    this.raceOptInURL;
    this.raceOptOutURL;
    this.tournamentOptInURL;
    this.tournamentOptOutURL;
    this.tournamentScoresURL;
    this.optRequests = {};
    this.promoHolders = [];
    this.activeTournaments = false;
    this.activeRaces = false;
    this.isReloaded = false;
    this.isRaceDetailsReloaded = true;
    this.isRacePrizesReloaded = true;
    this.isTournamentDetailsReloaded = true;
    this.retryInterval = 2;
    this.reloadRaceDetails = false;
    this.reloadRaceDetailsDelay = 0;
    this.reloadTournamentDetails = false;
    this.reloadTournamentDetailsDelay = 0;
    this.hasUpdates = false;
    this.canUpdate = false;
    this.timesNumberOfPrizesAKAMaxLeaderboardPosition = 2;
    var args = new Array(2);
    args[0] = GameProtocolDictionary.symbol +
        "=" + ServerOptions.gameSymbol;
    args[1] = GameProtocolDictionary.mgckey + "=" + ServerOptions.mgckey;
    var query = args.join("&");
    this.tournamentsURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.tournaments;
    this.tournamentsURL += this.QueryPrefix(this.tournamentsURL) + query;
    this.detailsURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.details;
    this.detailsURL += this.QueryPrefix(this.detailsURL) + query;
    this.leaderboardsURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.leaderboards;
    this.leaderboardsURL +=
        this.QueryPrefix(this.leaderboardsURL) + query;
    this.raceDetailsURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.raceDetails;
    this.raceDetailsURL += this.QueryPrefix(this.raceDetailsURL) + query;
    this.racePrizesURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.racePrizes;
    this.racePrizesURL += this.QueryPrefix(this.racePrizesURL) + query;
    this.raceWinnersURL = ServerOptions.serverUrl + "/gs2c/promo/race/v2/winners/";
    this.raceWinnersURL += this.QueryPrefix(this.raceWinnersURL) + query;
    this.raceOptInURL = ServerOptions.serverUrl +
        ServerOptions.TournamentURLs.raceOptIn;
    this.raceOptInURL += this.QueryPrefix(this.raceOptInURL) + query;
    this.raceOptOutURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.raceOptOut;
    this.raceOptOutURL += this.QueryPrefix(this.raceOptOutURL) + query;
    this.tournamentOptInURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.tournamentOptIn;
    this.tournamentOptInURL += this.QueryPrefix(this.tournamentOptInURL) + query;
    this.tournamentOptOutURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.tournamentOptOut;
    this.tournamentOptOutURL += this.QueryPrefix(this.tournamentOptOutURL) + query;
    this.tournamentScoresURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.tournamentScores;
    this.tournamentScoresURL += this.QueryPrefix(this.tournamentScoresURL) + query;
    this.tournamentsReloadedHandler = new EventHandler(this, this.OnTournamentsReloaded);
    this.leaderboardReloadedHandler = new EventHandler(this, this.OnLeaderboardReloaded);
    this.tournamentScoresReloadedHandler = new EventHandler(this, this.OnTournamentScoresReloaded);
    this.racePrizesReloadedHandler = new EventHandler(this, this.OnRacePrizesReloaded);
    this.detailsReloadedHandler = new EventHandler(this, this.OnDetailsReloaded);
    this.raceDetailsReloadedHandler = new EventHandler(this, this.OnRaceDetailsReloaded);
    this.raceWinnersReloadedHandler = new EventHandler(this, this.OnRaceWinnersReloaded);
    this.ldbItemTitle_0 = null;
    this.ldbItemTitle_1 = null;
    this.updateWinnerPrizesWhenDetailsReloaded = false;
    this.convertLeaderboardWhenDetailsReloaded = false;
    this.promotionsOpen = false;
    this.leaderboardOpen =
        false;
    this.selectedPromoHolder = null;
    TournamentConnection.instance = this
}
TournamentConnection.instance = null;
TournamentConnection.PromoHolder = function(_id, _type) {
    this.id = _id;
    this.type = _type;
    this.uid = TournamentConnection.PromoHolder.GetUID(_id, _type);
    this.promotion = null;
    this.details = null;
    this.leaderboard = null;
    this.score = null;
    this.isNew = true;
    this.prizesType = TournamentProtocol.PrizePoolType.Invalid;
    this.generatedLeaderboard = null;
    this.expandedLeaderboard = null;
    this.cumulatedLeaderboard = null;
    this.maxLeaderboardPosition = -1;
    this.isMerged = false
};
TournamentConnection.PromoHolder.GetUID = function(id, type) {
    return type + "#" + id
};
TournamentConnection.PromoHolder.Compare = function(x, y) {
    var ret = 0;
    var xVal = 0;
    var yVal = 0;
    xVal = x.promotion != null ? -1 : 1;
    yVal = y.promotion != null ? -1 : 1;
    ret = xVal - yVal;
    if (ret == 0)
        if (x.promotion == null) return ret;
    if (ret == 0) ret = x.promotion.status - y.promotion.status;
    if (ret == 0) ret = x.type - y.type;
    if (ret == 0) {
        if (x.type == TournamentProtocol.PromoType.Race) {
            xVal = x.details != null ? -1 : 1;
            yVal = y.details != null ? -1 : 1;
            ret = xVal - yVal;
            if (ret == 0)
                if (x.details != null) {
                    xVal = x.details.prizePool != null ? -1 : 1;
                    yVal = y.details.prizePool != null ? -1 :
                        1;
                    ret = xVal - yVal;
                    if (ret == 0)
                        if (x.details.prizePool != null) ret = y.details.prizePool.totalCount - x.details.prizePool.totalCount
                }
        }
        if (x.type == TournamentProtocol.PromoType.Tournament)
            if (TournamentConnection.instance.CanUseLeaderboards()) {
                xVal = x.leaderboard != null ? -1 : 1;
                yVal = y.leaderboard != null ? -1 : 1;
                ret = xVal - yVal;
                if (ret == 0)
                    if (x.leaderboard != null) ret = x.leaderboard.playerPosition - y.leaderboard.playerPosition
            } else {
                xVal = x.score != null ? -1 : 1;
                yVal = y.score != null ? -1 : 1;
                ret = xVal - yVal;
                if (ret == 0)
                    if (x.score != null) ret = x.score.position -
                        y.score.position
            }
    }
    if (ret == 0) {
        if (x.promotion.status == TournamentProtocol.StatusCode.Open) ret = x.promotion.endDate - y.promotion.endDate;
        if (x.promotion.status == TournamentProtocol.StatusCode.StartsSoon) ret = x.promotion.startDate - y.promotion.startDate;
        if (x.promotion.status == TournamentProtocol.StatusCode.Closed) ret = y.promotion.endDate - x.promotion.endDate
    }
    return ret
};
TournamentConnection.prototype.Update = function() {
    this.isRacePrizesReloaded = true;
    if (!this.isReloadindTournaments && this.tournamentsTimer >= this.reloadTournamentsInterval) {
        this.isReloadindTournaments = true;
        this.Reload(this.tournamentsURL, this.tournamentsReloadedHandler)
    }
    if (!this.isReloadindLeaderboards && this.leaderboardsTimer >= this.reloadLeaderboardsInterval && this.activeTournaments && this.promotionsOpen) {
        var canReload = !this.CanUseLeaderboards() || this.leaderboardOpen && this.selectedPromoHolder != null && this.selectedPromoHolder.type ==
            TournamentProtocol.PromoType.Tournament;
        if (canReload) this.isReloadindLeaderboards = this.ReloadLeaderboards(this.leaderboardsURL, this.leaderboardReloadedHandler, false);
        if (!this.isReloadindLeaderboards) this.leaderboardsTimer = 0
    }
    if (!this.isReloadingTournamentScores && this.tournamentScoresTimer >= this.reloadTournamentScoresInterval && this.activeTournaments && !this.promotionsOpen) {
        this.isReloadingTournamentScores = this.ReloadLeaderboards(this.tournamentScoresURL, this.tournamentScoresReloadedHandler, true);
        if (!this.isReloadingTournamentScores) this.tournamentScoresTimer =
            0
    }
    if (!this.isReloadindRacePrizes && this.racePrizesTimer >= this.reloadRacePrizesInterval && this.activeRaces) {
        this.isReloadindRacePrizes = true;
        this.Reload(this.racePrizesURL, this.racePrizesReloadedHandler)
    }
    if (!this.isReloadindRaceWinners && this.raceWinnersTimer >= this.reloadRaceWinnersInterval && this.activeRaces && this.promotionsOpen) {
        var canReload = !this.CanUseRaceWinners() || this.leaderboardOpen && this.selectedPromoHolder != null && this.selectedPromoHolder.type == TournamentProtocol.PromoType.Race;
        if (canReload) {
            this.isReloadindRaceWinners =
                true;
            this.ReloadRaceWinners()
        } else this.raceWinnersTimer = 0
    }
    this.tournamentsTimer += Time.deltaTime;
    this.leaderboardsTimer += Time.deltaTime;
    this.tournamentScoresTimer += Time.deltaTime;
    this.racePrizesTimer += Time.deltaTime;
    this.raceWinnersTimer += Time.deltaTime;
    if (this.reloadRaceDetails) {
        this.reloadRaceDetailsDelay -= Time.deltaTime;
        if (this.reloadRaceDetailsDelay <= 0) {
            this.reloadRaceDetails = false;
            this.Reload(this.raceDetailsURL, this.raceDetailsReloadedHandler)
        }
    }
    if (this.reloadTournamentDetails) {
        this.reloadTournamentDetailsDelay -=
            Time.deltaTime;
        if (this.reloadTournamentDetailsDelay <= 0) {
            this.reloadTournamentDetails = false;
            this.Reload(this.detailsURL, this.detailsReloadedHandler)
        }
    }
    if (this.isReloaded && (!this.hasUpdates || this.canUpdate && (this.isRaceDetailsReloaded && this.isRacePrizesReloaded) && this.isTournamentDetailsReloaded)) {
        this.ProcessPromotions();
        this.xtLayer.SetDetails(this.GetDetails());
        this.xtLayer.SetLeaderboards(this.GetLeaderboards());
        this.xtLayer.SetTournaments(this.GetPromotions(true));
        if (this.hasUpdates) this.xtLayer.AnnouncePromotions();
        this.canUpdate = false;
        this.hasUpdates = false;
        this.isReloaded = false
    }
    this.CheckOptResponses()
};
TournamentConnection.prototype.Reload = function(url, callback) {
    var req = new ServerRequest;
    req.Url = url;
    req.Handler = callback;
    req.Method = "GET";
    RequestManager.AddRequest(req)
};
TournamentConnection.prototype.OnTournamentsReloaded = function(param, statusCode) {
    this.tournamentsTimer = 0;
    this.isReloadindTournaments = false;
    TournamentProtocol.TournamentParser.errorMessage = "PromoAPI Parsing Error (promo/active)";
    var response = TournamentProtocol.TournamentParser.ParseTournamentsResponse(param);
    if (response == null) {
        this.xtLayer.SetTournaments(null);
        return
    }
    var items = [];
    this.ReloadIfNeeded(response.tournaments, this.tournamentIds, this.detailsURL, this.detailsReloadedHandler, items);
    this.ReloadIfNeeded(response.races,
        this.raceIds, this.raceDetailsURL, this.raceDetailsReloadedHandler, items);
    this.promoHolders = items;
    this.activeTournaments = false;
    this.activeRaces = false;
    for (var i = 0; i < this.promoHolders.length; i++) {
        if (this.promoHolders[i].type == TournamentProtocol.PromoType.Tournament) this.activeTournaments = true;
        if (this.promoHolders[i].type == TournamentProtocol.PromoType.Race) this.activeRaces = true
    }
    this.xtLayer.SetServerTime(response.serverTime);
    this.isReloaded = true
};
TournamentConnection.prototype.OnDetailsReloaded = function(param, statusCode) {
    TournamentProtocol.TournamentParser.errorMessage = "PromoAPI Parsing Error (promo/tournament/details)";
    var response = TournamentProtocol.TournamentParser.ParseDetailsResponse(param);
    if (response == null || response.details == null) {
        this.reloadTournamentDetails = true;
        this.reloadTournamentDetailsDelay = this.retryInterval;
        return
    }
    for (var i = 0; i < response.details.length; ++i) {
        var promo = this.FindPromoHolderInternal(response.details[i].id, TournamentProtocol.PromoType.Tournament);
        promo.details = response.details[i];
        this.ConvertDetailsToPlayerCurrency(promo);
        PromotionsHelper.ConvertDynamicFields(promo.details);
        if (this.convertLeaderboardWhenDetailsReloaded) this.ConvertLeaderboardToPlayerCurrency(promo)
    }
    this.isReloaded = true;
    this.isTournamentDetailsReloaded = true;
    this.convertLeaderboardWhenDetailsReloaded = false
};
TournamentConnection.prototype.OnLeaderboardReloaded = function(param, statusCode) {
    this.leaderboardsTimer = 0;
    this.isReloadindLeaderboards = false;
    TournamentProtocol.TournamentParser.errorMessage = "PromoAPI Parsing Error (promo/tournament/leaderboard)";
    var response = TournamentProtocol.TournamentParser.ParseLeaderboardResponse(param);
    if (response == null) return;
    if (response.leaderboards != null)
        for (var i = 0; i < response.leaderboards.length; ++i) {
            var promo = this.FindPromoHolderInternal(response.leaderboards[i].tournamentID,
                TournamentProtocol.PromoType.Tournament);
            promo.leaderboard = response.leaderboards[i];
            this.ConvertLeaderboardToPlayerCurrency(promo)
        }
    this.isReloaded = true;
    this.leaderboardsReloadedTime = this.tournamentScoresDiscardedTime = Time.time;
    XT.TriggerEvent(TournamentVars.Evt_Internal_LeaderboardsReloaded)
};
TournamentConnection.prototype.OnRaceDetailsReloaded = function(param, statusCode) {
    TournamentProtocol.TournamentParser.errorMessage = "PromoAPI Parsing Error (promo/race/details)";
    var response = TournamentProtocol.TournamentParser.ParseDetailsResponse(param);
    if (response == null || response.details == null) {
        this.reloadRaceDetails = true;
        this.reloadRaceDetailsDelay = this.retryInterval;
        return
    }
    for (var i = 0; i < response.details.length; ++i) {
        var item = this.FindPromoHolderInternal(response.details[i].id, TournamentProtocol.PromoType.Race);
        if (item.details == null) {
            item.details = response.details[i];
            this.isRacePrizesReloaded = false
        } else {
            var _prizeList = item.details.prizePool.prizesList;
            item.details.prizePool = response.details[i].prizePool;
            item.details.prizePool.prizesList = _prizeList
        }
        item.details.htmlRules = response.details[i].htmlRules;
        item.details.shortHtmlRules = response.details[i].shortHtmlRules;
        item.details.prizePoolTotal = new TournamentProtocol.PrizePool(response.details[i].prizePool);
        item.details.currencyRateMap = response.details[i].currencyRateMap;
        this.ConvertDetailsToPlayerCurrency(item);
        PromotionsHelper.ConvertDynamicFields(item.details);
        if (this.updateWinnerPrizesWhenDetailsReloaded) this.UpdateWinnerPrizes(item)
    }
    this.isReloaded = true;
    this.isRaceDetailsReloaded = true;
    this.updateWinnerPrizesWhenDetailsReloaded = false
};
TournamentConnection.prototype.OnRacePrizesReloaded = function(param, statusCode) {
    this.racePrizesTimer = 0;
    this.isReloadindRacePrizes = false;
    TournamentProtocol.TournamentParser.errorMessage = "PromoAPI Parsing Error (promo/race/prizes)";
    var response = TournamentProtocol.TournamentParser.ParseDetailsResponse(param);
    if (response == null || response.details == null) return;
    for (var i = 0; i < response.details.length; ++i) {
        var item = this.FindPromoHolderInternal(response.details[i].id, TournamentProtocol.PromoType.Race);
        if (item.details ==
            null) item.details = response.details[i];
        item.details.prizePool.prizesList = response.details[i].prizePool.prizesList;
        item.details.prizePool.totalCount = response.details[i].prizePool.totalCount;
        this.ConvertDetailsToPlayerCurrency(item);
        PromotionsHelper.ConvertDynamicFields(item.details)
    }
    this.isReloaded = true;
    this.isRacePrizesReloaded = true
};
TournamentConnection.prototype.ReloadRaceWinners = function() {
    var identities = [];
    for (var i = 0; i < this.promoHolders.length; ++i) {
        if (this.promoHolders[i].type != TournamentProtocol.PromoType.Race) continue;
        var identity = '"' + this.promoHolders[i].id + '":';
        if (this.promoHolders[i].leaderboard == null || _string.IsNullOrEmpty(this.promoHolders[i].leaderboard.lastIdentity)) identity += "null";
        else identity += '"' + this.promoHolders[i].leaderboard.lastIdentity + '"';
        identities.push(identity)
    }
    if (identities.length == 0) {
        this.raceWinnersTimer =
            0;
        this.isReloadindRaceWinners = false;
        return
    }
    var req = new ServerRequest;
    req.Url = this.raceWinnersURL;
    req.Handler = this.raceWinnersReloadedHandler;
    req.PostData = '{"latestIdentity":{' + identities.join(",") + "}}";
    req.ContentType = "application/json";
    RequestManager.AddRequest(req)
};
TournamentConnection.prototype.OnRaceWinnersReloaded = function(param, statusCode) {
    this.raceWinnersTimer = 0;
    this.isReloadindRaceWinners = false;
    TournamentProtocol.TournamentParser.errorMessage = "PromoAPI Parsing Error (promo/race/winners)";
    var response = TournamentProtocol.TournamentParser.ParseLeaderboardResponse(String(param));
    if (response == null) return;
    if (response.leaderboards != null)
        for (var i = 0; i < response.leaderboards.length; ++i) {
            var promo = this.FindPromoHolderInternal(response.leaderboards[i].tournamentID,
                TournamentProtocol.PromoType.Race);
            var ldb0 = promo.cumulatedLeaderboard;
            var ldb1 = response.leaderboards[i];
            if (ldb1 != null && ldb1.items != null) {
                if (ldb0 != null && ldb0.items != null && ldb1.winnersAction == TournamentProtocol.WinnersActionType.Add) {
                    ldb1.items = ldb1.items.concat(ldb0.items);
                    ldb1.playerWinsCount += ldb0.playerWinsCount;
                    ldb1.scoreHasDecimals = ldb0.scoreHasDecimals || ldb1.scoreHasDecimals
                }
                ldb0 = promo.leaderboard;
                if (ldb0 == null) {
                    ldb0 = new TournamentProtocol.Leaderboard;
                    ldb0.uid = promo.uid;
                    ldb0.tournamentID = promo.id;
                    ldb0.items = []
                }
                if (!_string.IsNullOrEmpty(ldb1.lastIdentity)) ldb0.lastIdentity = ldb1.lastIdentity;
                ldb0.scoreHasDecimals = ldb1.scoreHasDecimals;
                ldb0.items.splice(0);
                var prizes = this.GetPrizes(promo);
                var defaultCountryID = ldb1.hasCountryID ? TournamentLeaderboardItem.defaultCountryID : "";
                var currencyRateMap = null;
                if (promo.details != null) currencyRateMap = promo.details.currencyRateMap;
                for (var j = 0; j < ldb1.items.length; ++j) {
                    var item = ldb1.items[j];
                    if (_string.IsNullOrEmpty(item.countryID)) item.countryID = defaultCountryID;
                    this.UpdateWinnerPrize(item, prizes, currencyRateMap)
                }
                this.SortPrizeDropWinners(ldb1.items);
                if (ldb1.playerWinsCount > 0) {
                    if (this.ldbItemTitle_0 == null) {
                        this.ldbItemTitle_0 = new TournamentProtocol.LeaderboardItem;
                        this.ldbItemTitle_0.winnerContent = TournamentProtocol.WinnerContentType.Title_0;
                        this.ldbItemTitle_0.isPlayer = true
                    }
                    ldb0.items.push(this.ldbItemTitle_0);
                    for (var j = 0; j < ldb1.items.length; ++j) {
                        if (!ldb1.items[j].isPlayer) continue;
                        ldb1.items[j].valueIndexExtra = 1;
                        ldb0.items.push(ldb1.items[j])
                    }
                }
                if (ldb1.playerWinsCount <
                    ldb1.items.length) {
                    if (this.ldbItemTitle_1 == null) {
                        this.ldbItemTitle_1 = new TournamentProtocol.LeaderboardItem;
                        this.ldbItemTitle_1.winnerContent = TournamentProtocol.WinnerContentType.Title_1
                    }
                    ldb0.items.push(this.ldbItemTitle_1);
                    var valueIndexExtra = ldb0.items.length % 2;
                    for (var j = 0; j < ldb1.items.length; ++j) {
                        if (ldb1.items[j].isPlayer) continue;
                        ldb1.items[j].valueIndexExtra = valueIndexExtra;
                        ldb0.items.push(ldb1.items[j])
                    }
                }
                promo.leaderboard = ldb0;
                promo.cumulatedLeaderboard = ldb1
            }
        }
    this.isReloaded = true;
    this.raceWinnersReloadedTime =
        Time.time
};
TournamentConnection.prototype.UpdateWinnerPrizes = function(promo) {
    var ldb = promo.cumulatedLeaderboard;
    if (ldb == null) return;
    var prizes = this.GetPrizes(promo);
    var currencyRateMap = null;
    if (promo.details != null) currencyRateMap = promo.details.currencyRateMap;
    for (var j = 0; j < ldb.items.length; ++j) this.UpdateWinnerPrize(ldb.items[j], prizes, currencyRateMap)
};
TournamentConnection.prototype.UpdateWinnerPrize = function(item, prizes, currencyRateMap) {
    var prize = this.FindPrizeByID(prizes, item.prizeID);
    if (prize == null) {
        this.updateWinnerPrizesWhenDetailsReloaded = true;
        return
    }
    item.type = prize.type;
    item.currency = prize.currency;
    item.amount = prize.amount;
    item.gift = prize.gift;
    item.betMultiplier = prize.betMultiplier;
    item.freeRoundAmount = prize.freeRoundAmount;
    item.freeRoundLimitType = prize.freeRoundLimitType;
    if (currencyRateMap != null && prize.currency != item.memberCurrency) {
        item.scoreBet =
            PromotionsHelper.ConvertToPlayerCurrency(currencyRateMap, item.scoreBet, item.memberCurrency);
        item.effectiveBetForBetMultiplier = PromotionsHelper.ConvertToPlayerCurrency(currencyRateMap, item.effectiveBetForBetMultiplier, item.memberCurrency);
        item.memberCurrency = ServerOptions.currency
    }
    item.prize = item.effectiveBetForBetMultiplier * item.betMultiplier
};
TournamentConnection.prototype.GetPrizes = function(holder) {
    if (holder == null || holder.details == null || holder.details.prizePoolTotal == null) return null;
    return holder.details.prizePoolTotal.prizesList
};
TournamentConnection.prototype.FindPrizeByID = function(list, prizeID) {
    if (list == null) return null;
    for (var i = 0; i < list.length; ++i)
        if (prizeID == list[i].prizeID) return list[i];
    return null
};
TournamentConnection.prototype.ConvertDetailsToPlayerCurrency = function(promo) {
    var details = promo.details;
    if (details != null && details.currencyRateMap != null) {
        var prizeList = details.prizePool.prizesList;
        if (prizeList != null)
            for (var j = 0; j < prizeList.length; j++) {
                var amount = PromotionsHelper.ConvertToPlayerCurrency(details.currencyRateMap, prizeList[j].amount, details.prizePool.realCurrency);
                if (amount > -.5) {
                    prizeList[j].amount = amount;
                    prizeList[j].currency = ServerOptions.currency;
                    details.prizePool.currency = ServerOptions.currency
                }
            }
    }
};
TournamentConnection.prototype.ConvertLeaderboardToPlayerCurrency = function(promo) {
    var details = promo.details;
    if (details == null) {
        this.convertLeaderboardWhenDetailsReloaded = true;
        return
    }
    if (details != null && details.currencyRateMap != null && promo.leaderboard != null) {
        var itemList = promo.leaderboard.items;
        for (var j = 0; j < itemList.length; j++) {
            var amount = PromotionsHelper.ConvertToPlayerCurrency(details.currencyRateMap, itemList[j].amount, itemList[j].memberCurrency);
            if (amount > -.5) {
                itemList[j].amount = amount;
                itemList[j].scoreBet =
                    PromotionsHelper.ConvertToPlayerCurrency(details.currencyRateMap, itemList[j].scoreBet, itemList[j].memberCurrency);
                itemList[j].effectiveBetForBetMultiplier = PromotionsHelper.ConvertToPlayerCurrency(details.currencyRateMap, itemList[j].effectiveBetForBetMultiplier, itemList[j].memberCurrency);
                itemList[j].memberCurrency = ServerOptions.currency
            }
        }
    }
};
TournamentConnection.prototype.QueryPrefix = function(url) {
    return /\?/.test(url) ? "&" : "?"
};
TournamentConnection.prototype.ReloadIfNeeded = function(events, eventIds, url, handler, items) {
    if (events == null) return;
    var reload = false;
    var ids = [];
    for (var i = 0; i < events.length; ++i) {
        ids.push(events[i].id);
        var item = this.FindPromoHolderInternal(events[i].id, events[i].type);
        if (!item.isNew && item.promotion != null && item.promotion.isOpted && !events[i].isOpted) {
            item.isNew = true;
            this.hasUpdates = true
        }
        item.promotion = events[i];
        items.push(item);
        if (eventIds.indexOf(events[i].id) < 0) {
            reload = true;
            if (item.type == TournamentProtocol.PromoType.Race) this.isRaceDetailsReloaded =
                false;
            else if (item.type == TournamentProtocol.PromoType.Tournament) this.isTournamentDetailsReloaded = false
        }
    }
    eventIds.splice(0);
    for (var i = 0; i < ids.length; ++i) eventIds.push(ids[i]);
    if (reload) {
        this.hasUpdates = true;
        this.Reload(url, handler)
    }
};
TournamentConnection.prototype.FindPromoHolderInternal = function(id, type) {
    var item = this.FindPromoHolder(TournamentConnection.PromoHolder.GetUID(id, type));
    if (item == null) {
        item = new TournamentConnection.PromoHolder(id, type);
        this.promoHolders.push(item);
        if (item.type == TournamentProtocol.PromoType.Tournament) this.activeTournaments = true;
        if (item.type == TournamentProtocol.PromoType.Race) this.activeRaces = true
    }
    return item
};
TournamentConnection.prototype.FindPromoHolder = function(uid) {
    for (var i = 0; i < this.promoHolders.length; ++i)
        if (this.promoHolders[i].uid == uid) return this.promoHolders[i];
    return null
};
TournamentConnection.prototype.FindNewPromoHolders = function() {
    var list = [];
    var mergedDDW = false;
    var groupedPromotions = [];
    var groupedPromotionsIds = [];
    for (var i = 0; i < this.promoHolders.length; ++i)
        if (this.promoHolders[i].promotion != null && this.promoHolders[i].promotion.displayStyle == TournamentProtocol.DisplayStyle.DropsAndWins)
            if (this.promoHolders[i].isNew && this.promoHolders[i].details != null && this.promoHolders[i].promotion != null)
                if (!this.promoHolders[i].promotion.isOpted && this.promoHolders[i].promotion.promotionId !=
                    "") {
                    var index = groupedPromotionsIds.indexOf(this.promoHolders[i].promotion.promotionId);
                    if (index == -1) {
                        groupedPromotionsIds.push(this.promoHolders[i].promotion.promotionId);
                        groupedPromotions.push([]);
                        index = groupedPromotionsIds.length - 1
                    }
                    groupedPromotions[index].push(this.promoHolders[i])
                }
    for (var i = 0; i < groupedPromotions.length; i++)
        if (groupedPromotions[i].length == 2) {
            groupedPromotions[i].sort(function(x, y) {
                return y.promotion.type - x.promotion.type
            });
            groupedPromotions[i][0].isMerged = true;
            groupedPromotions[i][0].details.htmlRulesForOptIn =
                groupedPromotions[i][0].promotion.name + "\n\n" + groupedPromotions[i][0].details.htmlRules + "\n\n" + groupedPromotions[i][1].promotion.name + "\n\n" + groupedPromotions[i][1].details.htmlRules;
            list.push(groupedPromotions[i][0]);
            list.push(groupedPromotions[i][1]);
            mergedDDW = true
        }
    for (var i = 0; i < this.promoHolders.length; ++i) {
        if (this.promoHolders[i].promotion != null && this.promoHolders[i].promotion.displayStyle == TournamentProtocol.DisplayStyle.DropsAndWins)
            if (this.promoHolders[i].isNew && this.promoHolders[i].details !=
                null && this.promoHolders[i].promotion != null)
                if (!this.promoHolders[i].promotion.isOpted && this.promoHolders[i].promotion.promotionId != "")
                    if (mergedDDW) continue;
        if (this.promoHolders[i].isNew && this.promoHolders[i].details != null && this.promoHolders[i].promotion != null) {
            this.promoHolders[i].isNew = false;
            if (!this.promoHolders[i].promotion.isOpted) {
                this.promoHolders[i].details.htmlRulesForOptIn = this.promoHolders[i].details.htmlRules;
                list.push(this.promoHolders[i])
            }
        }
    }
    return list
};
TournamentConnection.prototype.GetPromotions = function(sort) {
    var ret = [];
    if (sort) this.promoHolders.sort(TournamentConnection.PromoHolder.Compare);
    for (var i = 0; i < this.promoHolders.length; ++i)
        if (this.promoHolders[i].promotion != null && this.promoHolders[i].promotion.clientMode == TournamentProtocol.ClientMode.Visible) {
            if (_string.IsNullOrEmpty(this.promoHolders[i].promotion.uid)) this.promoHolders[i].promotion.uid = this.promoHolders[i].uid;
            ret.push(this.promoHolders[i].promotion)
        }
    return ret.length > 0 ? ret : null
};
TournamentConnection.prototype.GetPromotionForRankInfo = function() {
    var ret = [];
    var addedAnyTournament = false;
    var addedAnyRace = false;
    for (var i = 0; i < this.promoHolders.length; ++i) {
        var promo = this.promoHolders[i];
        if (promo.promotion != null && promo.promotion.clientMode == TournamentProtocol.ClientMode.Visible && promo.type != TournamentProtocol.PromoType.Invalid) {
            if (_string.IsNullOrEmpty(promo.promotion.uid)) promo.promotion.uid = promo.uid;
            if (promo.type == TournamentProtocol.PromoType.Tournament) {
                if (promo.promotion.status ==
                    TournamentProtocol.StatusCode.Open || !addedAnyTournament) ret.push(promo.promotion);
                addedAnyTournament = true
            }
            if (promo.type == TournamentProtocol.PromoType.Race) {
                if (promo.promotion.status == TournamentProtocol.StatusCode.Open || !addedAnyRace) ret.push(promo.promotion);
                addedAnyRace = true
            }
        }
    }
    return ret.length > 0 ? ret : null
};
TournamentConnection.prototype.GetDetails = function() {
    var ret = [];
    for (var i = 0; i < this.promoHolders.length; ++i)
        if (this.promoHolders[i].details != null) {
            if (_string.IsNullOrEmpty(this.promoHolders[i].details.uid)) this.promoHolders[i].details.uid = this.promoHolders[i].uid;
            if (this.promoHolders[i].type == TournamentProtocol.PromoType.Race && this.promoHolders[i].promotion != null && this.promoHolders[i].promotion.status == TournamentProtocol.StatusCode.Closed && this.promoHolders[i].details.prizePool != null && this.promoHolders[i].details.prizePool.prizesList !=
                null) this.promoHolders[i].details.prizePool.prizesList = null;
            ret.push(this.promoHolders[i].details)
        }
    return ret.length > 0 ? ret : null
};
TournamentConnection.prototype.GetLeaderboards = function() {
    var ret = [];
    for (var i = 0; i < this.promoHolders.length; ++i)
        if (this.promoHolders[i].leaderboard != null) {
            if (_string.IsNullOrEmpty(this.promoHolders[i].leaderboard.uid)) this.promoHolders[i].leaderboard.uid = this.promoHolders[i].uid;
            ret.push(this.promoHolders[i].leaderboard)
        }
    return ret.length > 0 ? ret : null
};
TournamentConnection.prototype.SendOptRequest = function(uid, isIn) {
    var holder = this.FindPromoHolder(uid);
    if (holder == null) return;
    if (holder.promotion.type == TournamentProtocol.PromoType.Tournament) this.InternalSendOptRequest(isIn ? this.tournamentOptInURL : this.tournamentOptOutURL, uid, holder.id);
    else if (holder.promotion.type == TournamentProtocol.PromoType.Race) this.InternalSendOptRequest(isIn ? this.raceOptInURL : this.raceOptOutURL, uid, holder.id)
};
TournamentConnection.prototype.InternalSendOptRequest = function(url, uid, id) {
    var req = new ServerRequest;
    req.Url = url;
    req.PostData = '{"promoID":' + String(id) + "}";
    req.ContentType = "application/json";
    RequestManager.AddRequest(req);
    this.optRequests[uid] = req
};
TournamentConnection.prototype.CheckOptResponses = function() {
    if (Object.keys(Object(this.optRequests)).length == 0) return;
    var outUids = [];
    var reqs = this.optRequests;
    this.optRequests = {};
    for (var uid in reqs) {
        var req = reqs[uid];
        if (!req.IsDone()) this.optRequests[uid] = req;
        else {
            TournamentProtocol.TournamentParser.errorMessage = "PromoAPI Parsing Error (player/choice)";
            var response = TournamentProtocol.TournamentParser.ParseBaseResponse(req.request.Data);
            var holder = this.FindPromoHolder(uid);
            if (response == null || response.error !=
                TournamentProtocol.ErrorCode.None) this.InternalSendOptRequest(req.Url, uid, holder.id);
            else {
                holder.promotion.isOpted = true;
                if (req.Url.indexOf("OPTOUT") > -1) outUids.push(uid)
            }
        }
    }
    if (outUids.length == 0) return;
    var holders = this.promoHolders;
    this.promoHolders = [];
    this.activeTournaments = false;
    this.activeRaces = false;
    for (var i = 0; i < holders.length; ++i)
        if (outUids.indexOf(holders[i].uid) < 0) {
            this.promoHolders.push(holders[i]);
            if (holders[i].type == TournamentProtocol.PromoType.Tournament) this.activeTournaments = true;
            if (holders[i].type ==
                TournamentProtocol.PromoType.Race) this.activeRaces = true
        }
    if (outUids.indexOf(XT.GetString(TournamentVars.SelectedTournamentID)) > -1) XT.SetString(TournamentVars.SelectedTournamentID, "");
    this.xtLayer.SetTournaments(this.GetPromotions(false))
};
TournamentConnection.prototype.ProcessPromotions = function() {
    for (var i = 0; i < this.promoHolders.length; ++i) {
        var holder = this.promoHolders[i];
        if (holder.promotion == null) continue;
        var prizesType = this.GetPrizePoolType(holder);
        holder.prizesType = holder.promotion.prizesType = prizesType;
        if (holder.details != null && holder.details.prizePool != null && holder.promotion.type == TournamentProtocol.PromoType.Tournament) {
            var maxLbdPos = holder.details.prizePool.totalCount * this.timesNumberOfPrizesAKAMaxLeaderboardPosition;
            holder.maxLeaderboardPosition =
                maxLbdPos > 0 ? maxLbdPos : -1
        }
        if (prizesType != TournamentProtocol.PrizePoolType.Invalid) this.OmitLeaderboardItemsAfterMaxPosition(holder);
        if (prizesType == TournamentProtocol.PrizePoolType.Invalid || prizesType == TournamentProtocol.PrizePoolType.AG) continue;
        if (holder.promotion.type == TournamentProtocol.PromoType.Tournament) {
            if (holder.generatedLeaderboard == null) this.GenerateExpandedLeaderboard(holder);
            this.PopulateExpandedLeaderboard(holder)
        } else if (holder.promotion.type == TournamentProtocol.PromoType.Race) this.PopulatePrizesTotalCount(holder)
    }
};
TournamentConnection.prototype.GetPrizePoolType = function(holder) {
    if (holder.details == null || holder.details.prizePool == null || holder.details.prizePool.prizesList == null) return holder.prizesType;
    var prizes = holder.details.prizePool.prizesList;
    var bmCount = 0;
    for (var i = 0; i < prizes.length; ++i)
        if (prizes[i].type == TournamentProtocol.PrizeType.BetMultiplier) bmCount++;
    if (bmCount > 0) return bmCount == prizes.length ? TournamentProtocol.PrizePoolType.BM : TournamentProtocol.PrizePoolType.AGBM;
    return TournamentProtocol.PrizePoolType.AG
};
TournamentConnection.prototype.GenerateExpandedLeaderboard = function(holder) {
    var items = [];
    var prizes = holder.details.prizePool.prizesList;
    for (var i = 0; i < prizes.length; ++i) {
        var prize = prizes[i];
        var itemsCount = prize.placeTo - prize.placeFrom + 1;
        for (var j = 0; j < itemsCount; ++j) {
            var item = new TournamentProtocol.LeaderboardItem;
            item.position = prize.placeFrom + j;
            item.type = prize.type;
            item.currency = prize.currency;
            item.amount = prize.amount;
            item.gift = prize.gift;
            item.betMultiplier = prize.betMultiplier;
            item.freeRoundAmount =
                prize.freeRoundAmount;
            item.freeRoundLimitType = prize.freeRoundLimitType;
            items.push(item)
        }
    }
    holder.generatedLeaderboard = new TournamentProtocol.Leaderboard;
    holder.generatedLeaderboard.items = items
};
TournamentConnection.prototype.PopulateExpandedLeaderboard = function(holder) {
    var leaderboard = holder.leaderboard;
    if (leaderboard == null) leaderboard = new TournamentProtocol.Leaderboard;
    var items = leaderboard.items;
    if (items == null) items = [];
    var itemsExpanded = holder.generatedLeaderboard.items.slice();
    for (var i = 0; i < itemsExpanded.length; ++i) {
        var lbi = this.FindLeaderboardItem(items, itemsExpanded[i].position);
        if (lbi != null) {
            var lbiExp = itemsExpanded[i];
            lbi.type = lbiExp.type;
            lbi.currency = lbiExp.currency;
            lbi.amount = lbiExp.amount;
            lbi.gift = lbiExp.gift;
            lbi.betMultiplier = lbiExp.betMultiplier;
            lbi.prize = lbi.effectiveBetForBetMultiplier * lbi.betMultiplier;
            lbi.freeRoundAmount = lbiExp.freeRoundAmount;
            lbi.freeRoundLimitType = lbiExp.freeRoundLimitType;
            itemsExpanded[i] = lbi
        }
    }
    for (var i = 0; i < items.length; ++i) {
        var lbi = this.FindLeaderboardItem(itemsExpanded, items[i].position);
        if (lbi == null) itemsExpanded.push(items[i])
    }
    if (holder.expandedLeaderboard == null) {
        var lb = new TournamentProtocol.Leaderboard;
        lb.uid = holder.promotion.uid;
        lb.tournamentID = holder.promotion.id;
        holder.expandedLeaderboard = lb
    }
    holder.expandedLeaderboard.items = itemsExpanded
};
TournamentConnection.prototype.FindLeaderboardItem = function(items, position) {
    for (var i = 0; i < items.length; ++i)
        if (items[i].position == position) return items[i];
    return null
};
TournamentConnection.prototype.PopulatePrizesTotalCount = function(holder) {
    if (holder.details == null || holder.details.prizePool == null || holder.details.prizePool.prizesList == null || holder.details.prizePoolTotal == null || holder.details.prizePoolTotal.prizesList == null) return;
    var prizes = holder.details.prizePool.prizesList;
    var prizesTotal = holder.details.prizePoolTotal.prizesList;
    for (var i = 0; i < prizes.length; ++i) {
        var prize = prizes[i];
        var prizeTotal = this.FindPrizeByID(prizesTotal, prize.prizeID);
        if (prizeTotal != null) prize.totalCount =
            prizeTotal.count
    }
};
TournamentConnection.prototype.OmitLeaderboardItemsAfterMaxPosition = function(holder) {
    if (holder.leaderboard == null || holder.leaderboard.items == null || holder.leaderboard.items.length < 2) return;
    var items = holder.leaderboard.items;
    var omitIdx = -1;
    for (var i = 1; i < items.length; ++i)
        if (holder.maxLeaderboardPosition > -1 && items[i].position > holder.maxLeaderboardPosition) {
            omitIdx = i;
            break
        }
    if (omitIdx < 0) return;
    var itemsOmitted = [];
    for (var i = omitIdx; i < items.length; ++i) {
        itemsOmitted.push(items[i]);
        if (items[i].isPlayer) {
            holder.leaderboard.playerIndex = -1;
            holder.leaderboard.playerIndexOmitted = itemsOmitted.length - 1
        }
    }
    holder.leaderboard.itemsOmitted = itemsOmitted;
    items.splice(omitIdx, items.length - omitIdx)
};
TournamentConnection.prototype.ReloadLeaderboards = function(url, callback, score) {
    var tourneyIds = [];
    for (var i = 0; i < this.promoHolders.length; ++i) {
        var holder = this.promoHolders[i];
        var promo = holder.promotion;
        if (promo == null || promo.type != TournamentProtocol.PromoType.Tournament || promo.status == TournamentProtocol.StatusCode.StartsSoon) continue;
        var checkEndedInterval = score ? holder.score != null : holder.leaderboard != null;
        if (checkEndedInterval) {
            var interval = XT.GetInt(TournamentVars.ServerTime) - promo.endDate;
            if (interval >
                this.reloadEndedLeaderboardsInterval) continue
        }
        tourneyIds.push(promo.id)
    }
    if (tourneyIds.length > 0) {
        var query = "tournamentIDs=" + tourneyIds.join(",");
        this.Reload(url + this.QueryPrefix(url) + query, callback);
        return true
    }
    return false
};
TournamentConnection.prototype.OnTournamentScoresReloaded = function(param, statusCode) {
    this.tournamentScoresTimer = 0;
    this.isReloadingTournamentScores = false;
    TournamentProtocol.TournamentParser.errorMessage = "PromoAPI Parsing Error (promo/tournament/scores)";
    var response = TournamentProtocol.TournamentParser.ParseTournamentScoresResponse(param);
    if (response == null) return;
    if (response.scores != null)
        for (var i = 0; i < response.scores.length; ++i) {
            var promo = this.FindPromoHolderInternal(response.scores[i].tournamentID,
                TournamentProtocol.PromoType.Tournament);
            promo.score = response.scores[i]
        }
    this.isReloaded = true;
    this.tournamentScoresReloadedTime = this.leaderboardsDiscardedTime = Time.time
};
TournamentConnection.prototype.PromotionsOpen = function() {
    this.promotionsOpen = true;
    var time = Time.time;
    if (!this.CanUseLeaderboards() && !this.isReloadindLeaderboards) this.leaderboardsTimer = this.reloadLeaderboardsInterval;
    if (!this.CanUseRaceWinners() && !this.isReloadindRaceWinners) this.raceWinnersTimer = this.reloadRaceWinnersInterval
};
TournamentConnection.prototype.PromotionsClosed = function() {
    this.promotionsOpen = false
};
TournamentConnection.prototype.LeaderboardOpen = function() {
    this.leaderboardOpen = true
};
TournamentConnection.prototype.LeaderboardClosed = function() {
    this.leaderboardOpen = false
};
TournamentConnection.prototype.CanUseLeaderboards = function() {
    if (this.promotionsOpen) return this.leaderboardsReloadedTime > this.leaderboardsDiscardedTime;
    return this.tournamentScoresReloadedTime < this.tournamentScoresDiscardedTime
};
TournamentConnection.prototype.CanUseRaceWinners = function() {
    return this.raceWinnersReloadedTime > 1E-4
};
TournamentConnection.prototype.SelectedTournamentIDChanged = function(uid) {
    this.selectedPromoHolder = this.FindPromoHolder(uid)
};
TournamentConnection.prototype.SortPrizeDropWinners = function(winners) {
    if (winners == null) return;
    for (var i = 0; i < winners.length; ++i)
        if (winners[i].type != TournamentProtocol.PrizeType.Amount && winners[i].type != TournamentProtocol.PrizeType.BetMultiplier) return;
    winners.sort(TournamentConnection.SortPrizeDropWinnersByAmount)
};
TournamentConnection.SortPrizeDropWinnersByAmount = function(x, y) {
    var xVal = x.type == TournamentProtocol.PrizeType.BetMultiplier ? x.prize : x.amount;
    var yVal = y.type == TournamentProtocol.PrizeType.BetMultiplier ? y.prize : y.amount;
    return yVal - xVal
};
var PromotionsHelper = {};
PromotionsHelper.lastPromotionShownIndex = 0;
PromotionsHelper.currentPromotionsUUID = "";
PromotionsHelper.Formats = {
    beyondMaxRank: "{0}+",
    scoreOptions: null
};
PromotionsHelper.RankInfo = function() {
    this.uid = "";
    this.realUID = "";
    this.value = -1;
    this.type = TournamentProtocol.PromoType.Invalid;
    this.style = TournamentProtocol.ClientStyle.Invalid
};
PromotionsHelper.AnnouncementInfo = function() {
    this.uid = "";
    this.type = TournamentProtocol.PromoType.Invalid;
    this.currency = "";
    this.prizesCount = 0;
    this.prizesAmount = 0;
    this.description = ""
};
PromotionsHelper.FindPromotion = function(uid) {
    if (_string.IsNullOrEmpty(uid)) return null;
    var item = TournamentConnection.instance.FindPromoHolder(uid);
    return item == null ? null : item.promotion
};
PromotionsHelper.FindDetails = function(uid) {
    if (_string.IsNullOrEmpty(uid)) return null;
    var item = TournamentConnection.instance.FindPromoHolder(uid);
    return item == null ? null : item.details
};
PromotionsHelper.FindLeaderboard = function(uid, expanded) {
    expanded = expanded == undefined ? false : expanded;
    if (_string.IsNullOrEmpty(uid)) return null;
    var item = TournamentConnection.instance.FindPromoHolder(uid);
    return item == null ? null : expanded ? item.expandedLeaderboard : item.leaderboard
};
PromotionsHelper.GetRankInfo = function() {
    var ri = new PromotionsHelper.RankInfo;
    var connection = TournamentConnection.instance;
    if (connection == null) return ri;
    var list = connection.GetPromotionForRankInfo();
    if (list == null) return ri;
    PromotionsHelper.lastPromotionShownIndex %= list.length;
    var i = PromotionsHelper.lastPromotionShownIndex;
    var item = connection.FindPromoHolder(list[i].uid);
    if (item == null) return ri;
    ri.type = item.type;
    ri.style = list[i].clientStyle;
    ri.realUID = item.uid;
    if (list[i].status != TournamentProtocol.StatusCode.Open) return ri;
    ri.uid = item.uid;
    if (item.type == TournamentProtocol.PromoType.Tournament)
        if (connection.CanUseLeaderboards()) {
            if (item.leaderboard != null) ri.value = item.leaderboard.playerIndex > -1 || item.leaderboard.playerIndexOmitted > -1 ? item.leaderboard.playerPosition : -1
        } else {
            if (item.score != null) ri.value = item.score.position
        }
    else if (item.type == TournamentProtocol.PromoType.Race)
        if (item.details != null && item.details.prizePool != null) ri.value = item.details.prizePool.totalCount > 0 ? item.details.prizePool.totalCount : -1;
    PromotionsHelper.currentPromotionsUUID =
        ri.uid;
    XT.TriggerEvent(TournamentVars.Evt_Internal_UpdatePromotionWarning);
    return ri
};
PromotionsHelper.GetPromotionType = function(uid) {
    if (_string.IsNullOrEmpty(uid)) return TournamentProtocol.PromoType.Invalid;
    var item = TournamentConnection.instance.FindPromoHolder(uid);
    return item == null ? TournamentProtocol.PromoType.Invalid : item.type
};
PromotionsHelper.GetAnnouncements = function() {
    var ret = [];
    var list = TournamentConnection.instance.FindNewPromoHolders();
    for (var i = 0; i < list.length; ++i) {
        var item = new PromotionsHelper.AnnouncementInfo;
        item.uid = list[i].uid;
        item.type = list[i].type;
        item.prizesCount = list[i].details.prizePool.totalCount;
        item.prizesAmount = list[i].details.prizePool.totalAmount;
        item.description = list[i].details.shortHtmlRules;
        ret.push(item)
    }
    return ret
};
PromotionsHelper.GetUID = function(id, type) {
    return TournamentConnection.PromoHolder.GetUID(id, type)
};
PromotionsHelper.GetCurrency = function(uid) {
    if (_string.IsNullOrEmpty(uid)) return ServerOptions.realCurrency;
    var item = TournamentConnection.instance.FindPromoHolder(uid);
    if (item == null || item.details == null || item.details.prizePool == null) return ServerOptions.realCurrency;
    return item.details.prizePool.currency
};
PromotionsHelper.OptIn = function(uid) {
    TournamentConnection.instance.SendOptRequest(uid, true)
};
PromotionsHelper.OptOut = function(uid) {
    TournamentConnection.instance.SendOptRequest(uid, false)
};
PromotionsHelper.PromotionAvailable = function(uid) {
    var promo = PromotionsHelper.FindPromotion(uid);
    if (promo == null) return false;
    if (promo.status == TournamentProtocol.StatusCode.Open)
        if (promo.endDate - XT.GetInt(TournamentVars.ServerTime) <= 0) return false;
    return true
};
PromotionsHelper.FindPlayerInLeaderboard = function(uid) {
    var leaderboard = PromotionsHelper.FindLeaderboard(uid);
    if (leaderboard != null)
        if (leaderboard.playerIndex > -1) return leaderboard.items[leaderboard.playerIndex];
        else if (leaderboard.playerIndexOmitted > -1) return leaderboard.itemsOmitted[leaderboard.playerIndexOmitted];
    return null
};
PromotionsHelper.FindPlayerLeaderboardPosition = function(uid) {
    var player = PromotionsHelper.FindPlayerInLeaderboard(uid);
    if (player != null) return player.position;
    return -1
};
PromotionsHelper.FormatRank = function(uid, rank) {
    var holder = TournamentConnection.instance.FindPromoHolder(uid);
    if (holder != null && holder.maxLeaderboardPosition > -1 && rank > holder.maxLeaderboardPosition) return PromotionsHelper.Formats.beyondMaxRank.replace("{0}", String(holder.maxLeaderboardPosition));
    return String(rank)
};
PromotionsHelper.FormatScore = function(value, ldb) {
    var Formats = PromotionsHelper.Formats;
    var opts = Formats.scoreOptions;
    if (opts == null) {
        opts = Formats.scoreOptions = new FormatOptions;
        opts.hasCurrency = false
    }
    opts.hasDecimals = ldb == null ? false : ldb.scoreHasDecimals;
    return LocaleManager.FormatValue(value, opts)
};
PromotionsHelper.ConvertToPlayerCurrency = function(crm, amount, currency) {
    if (crm != null && crm[ServerOptions.realCurrency] && crm[currency]) return crm[currency] * amount / crm[ServerOptions.realCurrency];
    return -1
};
PromotionsHelper.ConvertDynamicFields = function(details) {
    if (details == null) return;
    var highestPrize = "";
    if (details.prizePool.prizesList != null && details.prizePool.prizesList.length > 0 && details.prizePool.prizesList[0].type == TournamentProtocol.PrizeType.Amount) highestPrize = LocaleManager.FormatValueWithCustomCurrency(details.prizePool.prizesList[0].amount, details.prizePool.currency);
    details.htmlRules = details.htmlRules.replace(/~highestPrize/g, highestPrize);
    details.shortHtmlRules = details.shortHtmlRules.replace(/~highestPrize/g,
        highestPrize);
    var minBet = "";
    if (details.prizePool.minBetLimit > 0) minBet = LocaleManager.FormatValueWithCustomCurrency(details.prizePool.minBetLimit, ServerOptions.currency);
    details.htmlRules = details.htmlRules.replace(/~minBet/g, minBet);
    details.shortHtmlRules = details.shortHtmlRules.replace(/~minBet/g, minBet);
    var maxBet = "";
    if (details.prizePool.maxBetLimitByMultiplier > 0) maxBet = LocaleManager.FormatValueWithCustomCurrency(details.prizePool.maxBetLimitByMultiplier, ServerOptions.currency);
    details.htmlRules = details.htmlRules.replace(/~maxBet/g,
        maxBet);
    details.shortHtmlRules = details.shortHtmlRules.replace(/~maxBet/g, maxBet);
    var totalPrizeAmount = "";
    if (details.prizePool.totalPrizeAmount > 0) totalPrizeAmount = LocaleManager.FormatValueWithCustomCurrency(details.prizePool.totalPrizeAmount, ServerOptions.currency);
    details.htmlRules = details.htmlRules.replace(/~totalPrizeAmount/g, totalPrizeAmount);
    details.shortHtmlRules = details.shortHtmlRules.replace(/~totalPrizeAmount/g, totalPrizeAmount);
    for (var dfName in details.dynamicFieldMap) {
        var dfi = details.dynamicFieldMap[dfName];
        var dfValue = dfi.defaultValue;
        if (dfi.valueMap[ServerOptions.realCurrency] != undefined) {
            var val = _number.otod(dfi.valueMap[ServerOptions.realCurrency]);
            dfValue = LocaleManager.FormatValueWithCustomCurrency(val, ServerOptions.currency)
        }
        details.htmlRules = details.htmlRules.replace(new RegExp("~" + dfName, "g"), dfValue);
        details.shortHtmlRules = details.shortHtmlRules.replace(new RegExp("~" + dfName, "g"), dfValue)
    }
    for (var i = details.prizePool.prizesList.length - 1; i >= 0; i--) {
        var amount = details.prizePool.prizesList[i].amount;
        var convertedAmount = LocaleManager.FormatValueWithCustomCurrency(amount, ServerOptions.currency);
        details.htmlRules = details.htmlRules.replace(new RegExp("~prize." + (i + 1), "g"), convertedAmount);
        details.shortHtmlRules = details.shortHtmlRules.replace(new RegExp("~prize." + (i + 1), "g"), convertedAmount)
    }
};
PromotionsHelper.PromotionCheckTournamentOptOut = function(uid) {
    var promo = PromotionsHelper.FindPromotion(uid);
    if (promo == null) return;
    if (promo.optJurisdiction.indexOf(ServerOptions.jurisdiction) > -1) XT.SetBool(TournamentVars.TournamentEnforced_Jurisdiction_TournamentOptOut, true);
    else XT.SetBool(TournamentVars.TournamentEnforced_Jurisdiction_TournamentOptOut, false)
};
PromotionsHelper.CanUseLeaderboard = function(uid) {
    var type = PromotionsHelper.GetPromotionType(uid);
    if (type == TournamentProtocol.PromoType.Race) return TournamentConnection.instance.CanUseRaceWinners();
    if (type == TournamentProtocol.PromoType.Tournament) return TournamentConnection.instance.CanUseLeaderboards();
    return true
};
goog.provide("UHT.TournamentProtocol");
var TournamentProtocol = {};
TournamentProtocol.Dictionary = {
    StatusCode: {
        StartsSoon: "S",
        Open: "O",
        Closed: "C"
    },
    ClientMode: {
        Visible: "V",
        Hidden: "H"
    },
    ClientStyle: {
        Europe: "EU",
        Asia: "AS"
    },
    Tournament: {
        id: "id",
        status: "status",
        name: "name",
        startDate: "startDate",
        endDate: "endDate",
        clientMode: "clientMode",
        clientStyle: "clientStyle",
        optIn: "optin",
        type: "type"
    },
    Details: {
        id: "id",
        htmlRules: "htmlRules",
        prizePool: "prizePool",
        prizes: "prizes",
        shortHtmlRules: "shortHtmlRules",
        currencyRateMap: "currencyRateMap",
        dynamicFieldMap: "dynamicFieldMap",
        freeRoundSettings: "freeRoundSettings"
    },
    PrizePool: {
        currency: "currency",
        realCurrency: "currencyOriginal",
        prizesList: "prizesList",
        prizeRemains: "prizeRemains"
    },
    Prize: {
        placeFrom: "placeFrom",
        placeTo: "placeTo",
        amount: "amount",
        gift: "gift",
        count: "count"
    },
    Leaderboard: {
        tournamentID: "tournamentID",
        playerIndex: "index",
        items: "items"
    },
    LeaderboardItem: {
        position: "position",
        playerID: "playerID",
        score: "score"
    },
    Response: {
        error: "error",
        description: "description"
    },
    TournamentsResponse: {
        tournaments: "tournaments",
        serverTime: "serverTime",
        races: "races"
    },
    DetailsResponse: {
        details: "details"
    },
    LeaderboardResponse: {
        leaderboards: "leaderboards"
    }
};
goog.require("UHT.TournamentProtocol");
TournamentProtocol.TournamentParser = {};
TournamentProtocol.TournamentParser.errorMessage = "";
TournamentProtocol.TournamentParser.ParseTournamentsResponse = function(json) {
    if (_string.IsNullOrEmpty(json)) return null;
    var dict = _JSON.TryParse(json);
    var response = TournamentProtocol.TournamentParser.ParseResponse(dict);
    if (response == null || dict[TournamentProtocol.Dictionary.TournamentsResponse.serverTime] == undefined) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    return TournamentProtocol.TournamentParser.ParseOnlyTournamentsResponse(response, dict)
};
TournamentProtocol.TournamentParser.ParseOnlyTournamentsResponse = function(response, dict) {
    var TPD = TournamentProtocol.Dictionary;
    var TPP = TournamentProtocol.TournamentParser;
    var PromoType = TournamentProtocol.PromoType;
    var res = new TournamentProtocol.TournamentsResponse(response);
    if (dict[TPD.TournamentsResponse.serverTime] != undefined) res.serverTime = _number.otoi(dict[TPD.TournamentsResponse.serverTime]);
    if (dict[TPD.TournamentsResponse.tournaments] != undefined) res.tournaments = TPP.ParseTournaments(dict[TPD.TournamentsResponse.tournaments],
        PromoType.Tournament);
    if (dict[TPD.TournamentsResponse.races] != undefined) res.races = TPP.ParseTournaments(dict[TPD.TournamentsResponse.races], PromoType.Race);
    return res
};
TournamentProtocol.TournamentParser.ParseDetailsResponse = function(json) {
    if (_string.IsNullOrEmpty(json)) return null;
    var dict = _JSON.TryParse(json);
    var response = TournamentProtocol.TournamentParser.ParseResponse(dict);
    if (response == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = new TournamentProtocol.DetailsResponse(response);
    if (dict[TournamentProtocol.Dictionary.DetailsResponse.details] != undefined) res.details = TournamentProtocol.TournamentParser.ParseTournamentDetails(dict[TournamentProtocol.Dictionary.DetailsResponse.details]);
    if (dict[TournamentProtocol.Dictionary.Details.prizes] != undefined) res.details = TournamentProtocol.TournamentParser.ParseTournamentDetails(dict[TournamentProtocol.Dictionary.Details.prizes]);
    return res
};
TournamentProtocol.TournamentParser.ParseLeaderboardResponse = function(json) {
    if (_string.IsNullOrEmpty(json)) return null;
    var dict = _JSON.TryParse(json);
    var response = TournamentProtocol.TournamentParser.ParseResponse(dict);
    if (response == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = new TournamentProtocol.LeaderboardResponse(response);
    if (dict[TournamentProtocol.Dictionary.LeaderboardResponse.leaderboards] != undefined) res.leaderboards = TournamentProtocol.TournamentParser.ParseLeaderboards(dict[TournamentProtocol.Dictionary.LeaderboardResponse.leaderboards],
        true);
    var key = "winners";
    if (dict[key] != undefined) res.leaderboards = TournamentProtocol.TournamentParser.ParseLeaderboards(dict[key], false);
    return res
};
TournamentProtocol.TournamentParser.ParseResponse = function(dict) {
    if (dict == null || dict[TournamentProtocol.Dictionary.Response.error] == undefined || dict[TournamentProtocol.Dictionary.Response.description] == undefined) return null;
    var res = new TournamentProtocol.Response;
    res.description = String(dict[TournamentProtocol.Dictionary.Response.description]);
    var error = _number.otoi(dict[TournamentProtocol.Dictionary.Response.error]);
    switch (error) {
        case TournamentProtocol.ErrorCode.None:
            res.error = TournamentProtocol.ErrorCode.None;
            break;
        case TournamentProtocol.ErrorCode.InvalidParameter:
            res.error = TournamentProtocol.ErrorCode.InvalidParameter;
            break;
        case TournamentProtocol.ErrorCode.TournamentNotFound:
            res.error = TournamentProtocol.ErrorCode.TournamentNotFound;
            break;
        case TournamentProtocol.ErrorCode.ServiceError:
            res.error = TournamentProtocol.ErrorCode.ServiceError;
            break
    }
    return res
};
TournamentProtocol.TournamentParser.ParseTournaments = function(param, promoType) {
    var list = param;
    if (list == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null || dict[TournamentProtocol.Dictionary.Tournament.id] == undefined || dict[TournamentProtocol.Dictionary.Tournament.name] == undefined) {
            console.error(TournamentProtocol.TournamentParser.errorMessage);
            continue
        }
        var tournament = new TournamentProtocol.Tournament;
        tournament.id = _number.otoi(dict[TournamentProtocol.Dictionary.Tournament.id]);
        tournament.name = String(dict[TournamentProtocol.Dictionary.Tournament.name]);
        tournament.type = promoType;
        if (dict[TournamentProtocol.Dictionary.Tournament.startDate] != undefined) tournament.startDate = _number.otoi(dict[TournamentProtocol.Dictionary.Tournament.startDate]);
        if (dict[TournamentProtocol.Dictionary.Tournament.endDate] != undefined) tournament.endDate = _number.otoi(dict[TournamentProtocol.Dictionary.Tournament.endDate]);
        var tag =
            "#DDW#";
        if (tournament.name.indexOf(tag) > -1) {
            tournament.name = tournament.name.replace(new RegExp(tag, "g"), "");
            tournament.displayStyle = TournamentProtocol.DisplayStyle.DropsAndWins
        }
        tag = "#IDNSM#";
        if (tournament.name.indexOf(tag) > -1) {
            tournament.name = tournament.name.replace(new RegExp(tag, "g"), "");
            tournament.displayStyle = TournamentProtocol.DisplayStyle.IDNSM
        }
        tag = "#IDNCSM#";
        if (tournament.name.indexOf(tag) > -1) {
            tournament.name = tournament.name.replace(new RegExp(tag, "g"), "");
            tournament.displayStyle = TournamentProtocol.DisplayStyle.IDNCSM
        }
        tag =
            "#IDNEX#";
        if (tournament.name.indexOf(tag) > -1) {
            tournament.name = tournament.name.replace(new RegExp(tag, "g"), "");
            tournament.displayStyle = TournamentProtocol.DisplayStyle.IDNEX
        }
        tag = "#IDNVIP#";
        if (tournament.name.indexOf(tag) > -1) {
            tournament.name = tournament.name.replace(new RegExp(tag, "g"), "");
            tournament.displayStyle = TournamentProtocol.DisplayStyle.IDNVIP
        }
        var promotionId = tournament.name.match(/#.+#/);
        if (promotionId != null && promotionId.length > 0) {
            tournament.name = tournament.name.replace(promotionId[0], "");
            tournament.promotionId =
                promotionId[0].replace(/#/g, "")
        }
        if (dict[TournamentProtocol.Dictionary.Tournament.status] != undefined) {
            var status = String(dict[TournamentProtocol.Dictionary.Tournament.status]);
            switch (status) {
                case TournamentProtocol.Dictionary.StatusCode.StartsSoon:
                    tournament.status = TournamentProtocol.StatusCode.StartsSoon;
                    break;
                case TournamentProtocol.Dictionary.StatusCode.Open:
                    tournament.status = TournamentProtocol.StatusCode.Open;
                    break;
                case TournamentProtocol.Dictionary.StatusCode.Closed:
                    tournament.status = TournamentProtocol.StatusCode.Closed;
                    break
            }
        }
        if (dict[TournamentProtocol.Dictionary.Tournament.clientMode] != undefined) {
            var clientMode = String(dict[TournamentProtocol.Dictionary.Tournament.clientMode]);
            switch (clientMode) {
                case TournamentProtocol.Dictionary.ClientMode.Visible:
                    tournament.clientMode = TournamentProtocol.ClientMode.Visible;
                    break;
                case TournamentProtocol.Dictionary.ClientMode.Hidden:
                    tournament.clientMode = TournamentProtocol.ClientMode.Hidden;
                    break
            }
        } else if (promoType == TournamentProtocol.PromoType.Race) tournament.clientMode = TournamentProtocol.ClientMode.Visible;
        if (dict[TournamentProtocol.Dictionary.Tournament.optIn] != undefined) tournament.isOpted = _bool.Parse(dict[TournamentProtocol.Dictionary.Tournament.optIn]);
        if (dict[TournamentProtocol.Dictionary.Tournament.clientStyle] != undefined) {
            var clientStyle = String(dict[TournamentProtocol.Dictionary.Tournament.clientStyle]);
            switch (clientStyle) {
                case TournamentProtocol.Dictionary.ClientStyle.Asia:
                    tournament.clientStyle = TournamentProtocol.ClientStyle.Asia;
                    break;
                case TournamentProtocol.Dictionary.ClientStyle.Europe:
                    tournament.clientStyle =
                        TournamentProtocol.ClientStyle.Europe;
                    break
            }
        }
        var key = "showWinnersList";
        if (dict[key] != undefined) tournament.showWinnersList = _bool.Parse(dict[key]);
        key = "optJurisdiction";
        if (dict[key] != undefined) tournament.optJurisdiction = dict[key];
        key = "games";
        if (dict[key] != undefined) tournament.games = dict[key];
        res.push(tournament)
    }
    return res
};
TournamentProtocol.TournamentParser.ParseTournamentDetails = function(param) {
    var list = param;
    if (list == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null || dict[TournamentProtocol.Dictionary.Details.id] == undefined) {
            console.error(TournamentProtocol.TournamentParser.errorMessage);
            continue
        }
        var details = new TournamentProtocol.TournamentDetails;
        details.id = _number.otoi(dict[TournamentProtocol.Dictionary.Details.id]);
        if (dict[TournamentProtocol.Dictionary.Details.prizePool] != undefined) details.prizePool = TournamentProtocol.TournamentParser.ParsePrizePool(dict[TournamentProtocol.Dictionary.Details.prizePool]);
        if (dict[TournamentProtocol.Dictionary.PrizePool.prizeRemains] != undefined) details.prizePool = TournamentProtocol.TournamentParser.ParsePrizePool(dict);
        if (dict[TournamentProtocol.Dictionary.Details.htmlRules] != undefined) details.htmlRules = _string.Trim(String(dict[TournamentProtocol.Dictionary.Details.htmlRules]).replace("\r",
            ""), "\n");
        details.htmlRules += "\n \n \n";
        if (dict[TournamentProtocol.Dictionary.Details.shortHtmlRules] != undefined) details.shortHtmlRules = _string.Trim(String(dict[TournamentProtocol.Dictionary.Details.shortHtmlRules]).replace("\r", ""), "\n");
        if (dict[TournamentProtocol.Dictionary.Details.currencyRateMap] != undefined) details.currencyRateMap = dict[TournamentProtocol.Dictionary.Details.currencyRateMap];
        if (dict[TournamentProtocol.Dictionary.Details.dynamicFieldMap] != undefined) details.dynamicFieldMap = dict[TournamentProtocol.Dictionary.Details.dynamicFieldMap];
        if (dict[TournamentProtocol.Dictionary.Details.freeRoundSettings] != undefined) {
            details.freeRoundSettings = dict[TournamentProtocol.Dictionary.Details.freeRoundSettings];
            if (details.freeRoundSettings["availableGameNames"] != null && details.freeRoundSettings["availableGameNames"].length > 0)
                for (var frIdx = 0; frIdx < details.freeRoundSettings["availableGameNames"].length; frIdx++) details.freeRoundSettings["availableGameNames"][frIdx] = details.freeRoundSettings["availableGameNames"][frIdx].replace(/ /g, "")
        }
        res.push(details)
    }
    return res
};
TournamentProtocol.TournamentParser.ParsePrizePool = function(param) {
    var dict = param;
    if (dict == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = new TournamentProtocol.PrizePool;
    if (dict[TournamentProtocol.Dictionary.PrizePool.currency] != undefined) res.currency = String(dict[TournamentProtocol.Dictionary.PrizePool.currency]);
    else res.currency = ServerOptions.realCurrency;
    if (dict[TournamentProtocol.Dictionary.PrizePool.realCurrency] != undefined) res.realCurrency = String(dict[TournamentProtocol.Dictionary.PrizePool.realCurrency]);
    else res.realCurrency = res.currency;
    if (dict[TournamentProtocol.Dictionary.PrizePool.prizesList] != undefined) res.prizesList = TournamentProtocol.TournamentParser.ParsePrizes(dict[TournamentProtocol.Dictionary.PrizePool.prizesList], res);
    if (dict[TournamentProtocol.Dictionary.PrizePool.prizeRemains] != undefined) res.prizesList = TournamentProtocol.TournamentParser.ParsePrizes(dict[TournamentProtocol.Dictionary.PrizePool.prizeRemains], res);
    var key = "maxBetLimitByMultiplier";
    if (dict[key] != undefined) res.maxBetLimitByMultiplier =
        _number.otod(dict[key]) / 100;
    key = "minBetLimit";
    if (dict[key] != undefined) res.minBetLimit = _number.otoi(dict[key]) / 100;
    key = "totalPrizeAmount";
    if (dict[key] != undefined) res.totalPrizeAmount = _number.otoi(dict[key]);
    return res
};
TournamentProtocol.TournamentParser.ParsePrizes = function(param, pool) {
    var list = param;
    if (list == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var totalCount = 0;
    var totalAmount = 0;
    var res = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null) {
            console.error(TournamentProtocol.TournamentParser.errorMessage);
            continue
        }
        var prize = new TournamentProtocol.Prize;
        if (dict[TournamentProtocol.Dictionary.Prize.placeFrom] != undefined) prize.placeFrom = _number.otoi(dict[TournamentProtocol.Dictionary.Prize.placeFrom]);
        if (dict[TournamentProtocol.Dictionary.Prize.placeTo] != undefined) prize.placeTo = _number.otoi(dict[TournamentProtocol.Dictionary.Prize.placeTo]);
        if (dict[TournamentProtocol.Dictionary.Prize.amount] != undefined) prize.amount = _number.otod(dict[TournamentProtocol.Dictionary.Prize.amount]);
        if (dict[TournamentProtocol.Dictionary.Prize.gift] != undefined) prize.gift = String(dict[TournamentProtocol.Dictionary.Prize.gift]);
        if (dict[TournamentProtocol.Dictionary.Prize.count] != undefined) {
            prize.count = _number.otod(dict[TournamentProtocol.Dictionary.Prize.count]);
            totalCount += prize.count;
            totalAmount += prize.amount * prize.count
        } else if (prize.placeFrom > 0 && prize.placeTo > 0) totalCount += prize.placeTo - prize.placeFrom + 1;
        prize.currency = pool.currency;
        var key = "type";
        if (dict[key] != undefined) prize.type = TournamentProtocol.PrizeTypeConverter.Convert(dict[key]);
        key = "betMultiplier";
        if (dict[key] != undefined) prize.betMultiplier = _number.otoi(dict[key]);
        key = "prizeID";
        if (dict[key] != undefined) prize.prizeID = _number.otoi(dict[key]);
        if (prize.type == TournamentProtocol.PrizeType.FreeRounds) {
            key =
                "freeRounds";
            if (dict[key] != undefined) {
                var freeRoundsDict = dict[key];
                if (freeRoundsDict["freeRoundLimitType"] != undefined) prize.freeRoundLimitType = freeRoundsDict["freeRoundLimitType"];
                if (freeRoundsDict["amount"] != undefined) prize.freeRoundAmount = _number.otoi(freeRoundsDict["amount"])
            }
        }
        res.push(prize)
    }
    pool.totalCount = totalCount;
    pool.totalAmount = totalAmount;
    return res
};
TournamentProtocol.TournamentParser.ParseLeaderboards = function(param, isLDB) {
    var list = param;
    if (list == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null || dict[TournamentProtocol.Dictionary.Leaderboard.items] == undefined) {
            console.error(TournamentProtocol.TournamentParser.errorMessage);
            continue
        }
        var leaderboard = new TournamentProtocol.Leaderboard;
        if (isLDB) leaderboard.items = TournamentProtocol.TournamentParser.ParseLeaderboardItems(dict[TournamentProtocol.Dictionary.Leaderboard.items],
            leaderboard);
        else leaderboard.items = TournamentProtocol.TournamentParser.ParseLeaderboardWinners(dict[TournamentProtocol.Dictionary.Leaderboard.items], leaderboard);
        if (dict[TournamentProtocol.Dictionary.Leaderboard.tournamentID] != undefined) leaderboard.tournamentID = _number.otoi(dict[TournamentProtocol.Dictionary.Leaderboard.tournamentID]);
        if (dict[TournamentProtocol.Dictionary.Leaderboard.playerIndex] != undefined) leaderboard.playerIndex = _number.otoi(dict[TournamentProtocol.Dictionary.Leaderboard.playerIndex]);
        else leaderboard.playerIndex = -1;
        if (leaderboard.items != null && leaderboard.playerIndex > -1) {
            leaderboard.items[leaderboard.playerIndex].isPlayer = true;
            leaderboard.playerPosition = leaderboard.items[leaderboard.playerIndex].position
        }
        var key = "raceID";
        if (dict[key] != undefined) leaderboard.tournamentID = _number.otoi(dict[key]);
        key = "lastIdentity";
        if (dict[key] != undefined) leaderboard.lastIdentity = String(dict[key]);
        key = "action";
        if (dict[key] != undefined) leaderboard.winnersAction = TournamentProtocol.WinnersActionConverter.Convert(String(dict[key]));
        res.push(leaderboard)
    }
    return res
};
TournamentProtocol.TournamentParser.ParseLeaderboardWinners = function(param, leaderboard) {
    var list = param;
    if (list == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = [];
    for (var i = 0; i < list.length; ++i) {
        var item = new TournamentProtocol.LeaderboardItem;
        item.isRanked = true;
        item.leaderboard = leaderboard;
        var split = list[i].split("|");
        for (var j = 0; j < split.length; ++j) {
            var value = split[j];
            if (_string.IsNullOrEmpty(value)) continue;
            if (j == 0) item.prizeID = _number.otoi(value);
            else if (j ==
                1) {
                var playerID = String(value).replace(/\*/g, "");
                playerID = _string.PadLeft(playerID, "*", playerID.length + 4);
                item.playerID = playerID
            } else if (j == 2) item.scoreBet = _number.otod(value);
            else if (j == 3) item.effectiveBetForBetMultiplier = _number.otoi(_number.otod(value) * 100) / 100;
            else if (j == 5) item.memberCurrency = value;
            else if (j == 6) {
                item.countryID = String(value).toLowerCase();
                leaderboard.hasCountryID = true
            } else if (j == 7) {
                item.isPlayer = value == "1";
                if (item.isPlayer) leaderboard.playerWinsCount++
            }
        }
        res.push(item)
    }
    return res
};
TournamentProtocol.TournamentParser.ParseLeaderboardItems = function(param, leaderboard) {
    var list = param;
    if (list == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = [];
    for (var i = 0; i < list.length; ++i) {
        var item = new TournamentProtocol.LeaderboardItem;
        item.isRanked = true;
        item.leaderboard = leaderboard;
        var split = list[i].split("|");
        for (var j = 0; j < split.length; ++j) {
            var value = split[j];
            if (_string.IsNullOrEmpty(value)) continue;
            if (j == 0) item.position = _number.otoi(value);
            else if (j ==
                1) {
                var playerID = String(value).replace(/\*/g, "");
                playerID = _string.PadLeft(playerID, "*", playerID.length + 4);
                item.playerID = playerID
            } else if (j == 2) {
                item.score = _number.otod(value);
                if (!_number.isInt(item.score)) leaderboard.scoreHasDecimals = true
            } else if (j == 3) item.scoreBet = _number.otod(value);
            else if (j == 4) item.effectiveBetForBetMultiplier = _number.otoi(_number.otod(value) * 100) / 100;
            else if (j == 6) item.memberCurrency = value;
            else if (j == 7) {
                item.countryID = String(value).toLowerCase();
                leaderboard.hasCountryID = true
            }
        }
        res.push(item)
    }
    return res
};
TournamentProtocol.TournamentParser.ParseBaseResponse = function(json) {
    if (_string.IsNullOrEmpty(json)) return null;
    var dict = _JSON.TryParse(json);
    var response = TournamentProtocol.TournamentParser.ParseResponse(dict);
    if (response == null) console.error(TournamentProtocol.TournamentParser.errorMessage);
    return response
};
TournamentProtocol.TournamentParser.ParsePromoKeys = function(list) {
    var TPP = TournamentProtocol.TournamentParser;
    if (list == null) {
        console.error(TPP.errorMessage);
        return null
    }
    var TPD = TournamentProtocol.Dictionary;
    var ret = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null || dict[TPD.Tournament.id] == undefined || dict[TPD.Tournament.type] == undefined) {
            console.error(TPP.errorMessage);
            continue
        }
        var key = new TournamentProtocol.PromoKey;
        key.id = _number.otoi(dict[TPD.Tournament.id]);
        key.type = TPP.ParsePromoType(dict[TPD.Tournament.type]);
        ret.push(key)
    }
    return ret
};
TournamentProtocol.TournamentParser.ParsePromoType = function(type) {
    var PromoType = TournamentProtocol.PromoType;
    if (type == "MR") return PromoType.Race;
    else if (type == "TM") return PromoType.Tournament;
    return PromoType.Invalid
};
TournamentProtocol.TournamentParser.ParseTournamentScoresResponse = function(json) {
    var TP = TournamentProtocol;
    var I = TP.TournamentParser;
    if (_string.IsNullOrEmpty(json)) return null;
    var dict = _JSON.TryParse(json);
    var response = I.ParseResponse(dict);
    if (response == null) {
        console.error(I.errorMessage);
        return null
    }
    var res = new TP.TournamentScoresResponse(response);
    var key = "scores";
    if (dict[key] != undefined) res.scores = I.ParseTournamentScores(dict[key]);
    return res
};
TournamentProtocol.TournamentParser.ParseTournamentScores = function(list) {
    var TP = TournamentProtocol;
    var I = TP.TournamentParser;
    if (list == null) {
        console.error(I.errorMessage);
        return null
    }
    var res = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null) {
            console.error(I.errorMessage);
            continue
        }
        var item = new TP.TournamentScore;
        if (dict[TP.Dictionary.Leaderboard.tournamentID] != undefined) item.tournamentID = _number.otoi(dict[TP.Dictionary.Leaderboard.tournamentID]);
        if (dict[TP.Dictionary.LeaderboardItem.position] !=
            undefined) item.position = _number.otoi(dict[TP.Dictionary.LeaderboardItem.position]);
        if (dict[TP.Dictionary.LeaderboardItem.score] != undefined) item.score = _number.otod(dict[TP.Dictionary.LeaderboardItem.score]);
        res.push(item)
    }
    return res
};
goog.require("UHT.TournamentProtocol");
TournamentProtocol.ErrorCode = {
    Invalid: 500,
    None: 0,
    InvalidParameter: 1,
    TournamentNotFound: 2,
    ServiceError: 100
};
TournamentProtocol.StatusCode = {
    Open: 0,
    StartsSoon: 1,
    Closed: 2,
    Invalid: 3
};
TournamentProtocol.ClientMode = {
    Visible: 0,
    Hidden: 1,
    Invalid: 2
};
TournamentProtocol.ClientStyle = {
    Europe: 0,
    Asia: 1,
    Invalid: 2
};
TournamentProtocol.PromoType = {
    Race: 0,
    Tournament: 1,
    Invalid: 2
};
TournamentProtocol.PrizePoolType = {
    AG: 0,
    BM: 1,
    AGBM: 2,
    Invalid: 3
};
TournamentProtocol.DisplayStyle = {
    Default: 0,
    DropsAndWins: 1,
    IDNSM: 2,
    IDNCSM: 3,
    IDNEX: 4,
    IDNVIP: 5
};
TournamentProtocol.Tournament = function() {
    this.id = 0;
    this.status = TournamentProtocol.StatusCode.Invalid;
    this.name = "";
    this.startDate = 0;
    this.endDate = 0;
    this.clientMode = TournamentProtocol.ClientMode.Invalid;
    this.clientStyle = TournamentProtocol.ClientStyle.Invalid;
    this.type = TournamentProtocol.PromoType.Invalid;
    this.uid = "";
    this.isOpted = true;
    this.prizesType = TournamentProtocol.PrizePoolType.Invalid;
    this.displayStyle = TournamentProtocol.DisplayStyle.Default;
    this.showWinnersList = false;
    this.optJurisdiction = [];
    this.games =
        null;
    this.promotionId = ""
};
TournamentProtocol.DynamicFieldInfo = function() {
    this.defaultValue = "";
    this.valueMap = {}
};
TournamentProtocol.TournamentDetails = function() {
    this.id = 0;
    this.htmlRules = "";
    this.htmlRulesForOptIn = "";
    this.prizePool = null;
    this.prizePoolTotal = null;
    this.uid = "";
    this.shortHtmlRules = "";
    this.currencyRateMap = null;
    this.dynamicFieldMap = {};
    this.freeRoundSettings = {}
};
TournamentProtocol.PrizePool = function(pool) {
    this.currency = "";
    this.realCurrency = "";
    this.prizesList = null;
    this.totalCount = 0;
    this.totalAmount = 0;
    this.maxBetLimitByMultiplier = 0;
    this.minBetLimit = 0;
    this.totalPrizeAmount = 0;
    if (pool == null) return;
    this.currency = pool.currency;
    this.realCurrency = pool.realCurrency;
    this.totalCount = pool.totalCount;
    this.totalAmount = pool.totalAmount;
    this.maxBetLimitByMultiplier = pool.maxBetLimitByMultiplier;
    this.minBetLimit = pool.minBetLimit;
    this.totalPrizeAmount = pool.totalPrizeAmount;
    if (pool.prizesList != null) this.prizesList = pool.prizesList.slice()
};
TournamentProtocol.PrizeType = {
    Invalid: 0,
    Amount: 1,
    Gift: 2,
    BetMultiplier: 3,
    FreeRounds: 4
};
TournamentProtocol.PrizeTypeConverter = {
    prizeTypes: ["Invalid", "A", "G", "BM", "FR"],
    Convert: function(type) {
        var idx = TournamentProtocol.PrizeTypeConverter.prizeTypes.indexOf(type);
        return idx > -1 ? idx : TournamentProtocol.PrizeType.Invalid
    }
};
TournamentProtocol.Prize = function() {
    this.placeFrom = 0;
    this.placeTo = 0;
    this.amount = 0;
    this.gift = "";
    this.count = 0;
    this.totalCount = 0;
    this.betMultiplier = 0;
    this.type = TournamentProtocol.PrizeType.Invalid;
    this.currency = "";
    this.prizeID = 0;
    this.freeRoundLimitType = "";
    this.freeRoundAmount = 0
};
TournamentProtocol.WinnersActionType = {
    Invalid: 0,
    Add: 1,
    Replace: 2
};
TournamentProtocol.WinnersActionConverter = {
    actionTypes: ["Invalid", "A", "R"],
    Convert: function(type) {
        var idx = TournamentProtocol.WinnersActionConverter.actionTypes.indexOf(type);
        return idx > -1 ? idx : TournamentProtocol.WinnersActionType.Invalid
    }
};
TournamentProtocol.Leaderboard = function() {
    this.tournamentID = 0;
    this.playerIndex = -1;
    this.playerIndexOmitted = -1;
    this.playerPosition = 0;
    this.items = null;
    this.itemsOmitted = null;
    this.uid = "";
    this.lastIdentity = "";
    this.hasCountryID = false;
    this.playerWinsCount = 0;
    this.winnersAction = TournamentProtocol.WinnersActionType.Invalid;
    this.scoreHasDecimals = false
};
TournamentProtocol.WinnerContentType = {
    Default: 0,
    Title_0: 1,
    Title_1: 2
};
TournamentProtocol.LeaderboardItem = function() {
    this.position = 0;
    this.playerID = "";
    this.score = 0;
    this.scoreBet = 0;
    this.betMultiplier = 0;
    this.effectiveBetForBetMultiplier = 0;
    this.prize = 0;
    this.memberCurrency = "";
    this.isPlayer = false;
    this.isRanked = false;
    this.type = TournamentProtocol.PrizeType.Invalid;
    this.currency = "";
    this.amount = 0;
    this.gift = "";
    this.countryID = "";
    this.prizeID = 0;
    this.winDate = 0;
    this.winnerContent = TournamentProtocol.WinnerContentType.Default;
    this.valueIndexExtra = 0;
    this.leaderboard = null;
    this.freeRoundLimitType =
        "";
    this.freeRoundAmount = 0
};
TournamentProtocol.Request = function() {
    this.symbol = "";
    this.mgckey = ""
};
TournamentProtocol.Response = function(response) {
    this.error = TournamentProtocol.ErrorCode.Invalid;
    this.description;
    if (response != undefined) {
        this.error = response.error;
        this.description = response.description
    }
};
TournamentProtocol.TournamentsResponse = function(response) {
    TournamentProtocol.Response.call(this, response);
    this.tournaments = null;
    this.races = null;
    this.serverTime = 0
};
TournamentProtocol.TournamentsResponse.prototype = Object.create(TournamentProtocol.Response.prototype);
TournamentProtocol.TournamentsResponse.prototype.constructor = TournamentProtocol.TournamentsResponse;
TournamentProtocol.DetailsResponse = function(response) {
    TournamentProtocol.Response.call(this, response);
    this.details = null
};
TournamentProtocol.DetailsResponse.prototype = Object.create(TournamentProtocol.Response.prototype);
TournamentProtocol.DetailsResponse.prototype.constructor = TournamentProtocol.DetailsResponse;
TournamentProtocol.LeaderboardResponse = function(response) {
    TournamentProtocol.Response.call(this, response);
    this.leaderboards = null
};
TournamentProtocol.LeaderboardResponse.prototype = Object.create(TournamentProtocol.Response.prototype);
TournamentProtocol.LeaderboardResponse.prototype.constructor = TournamentProtocol.LeaderboardResponse;
TournamentProtocol.PromoKey = function() {
    this.id = 0;
    this.type = TournamentProtocol.PromoType.Invalid
};
TournamentProtocol.TournamentScore = function() {
    this.tournamentID = 0;
    this.uid = "";
    this.score = 0;
    this.position = -1
};
TournamentProtocol.TournamentScoresResponse = function(response) {
    TournamentProtocol.Response.call(this, response);
    this.scores = null
};
TournamentProtocol.TournamentScoresResponse.prototype = Object.create(TournamentProtocol.Response.prototype);
TournamentProtocol.TournamentScoresResponse.prototype.constructor = TournamentProtocol.TournamentScoresResponse;
var TournamentVars = {
    Tournaments: "Tournaments",
    Evt_Internal_TournamentsUpdated: "Evt_Internal_TournamentsUpdated",
    TournamentDetails: "TournamentDetails",
    TournamentLeaderboards: "TournamentLeaderboards",
    ServerTime: "ServerTime",
    SelectedTournamentID: "SelectedTournamentID",
    Evt_Internal_PromotionsAnnouncer_Prepare: "Evt_Internal_PromotionsAnnouncer_Prepare",
    Evt_Internal_PromotionsAnnouncer_Announce: "Evt_Internal_PromotionsAnnouncer_Announce",
    Evt_Internal_PromotionsAnnouncer_PrepareForWin: "Evt_Internal_PromotionsAnnouncer_PrepareForWin",
    Evt_Internal_PromotionsAnnouncer_ShowWin: "Evt_Internal_PromotionsAnnouncer_ShowWin",
    Evt_Internal_PromotionsAnnouncer_WinShown: "Evt_Internal_PromotionsAnnouncer_WinShown",
    Promotion_WinID: "Promotion_WinID",
    Promotion_WinReceived: "Promotion_WinReceived",
    Promotion_WinDisplayed: "Promotion_WinDisplayed",
    Promotion_GiftReceived: "Promotion_GiftReceived",
    PrizeDropWin_PrizeType: "PrizeDropWin_PrizeType",
    PrizeDropWin_Bet: "PrizeDropWin_Bet",
    PrizeDropWin_BetMultiplier: "PrizeDropWin_BetMultiplier",
    PrizeDropWin_FreeRoundsType: "PrizeDropWin_FreeRoundsType",
    PrizeDropWin_FreeRoundsAmount: "PrizeDropWin_FreeRoundsAmount",
    PrizeDropManuallyCredited: "PrizeDropManuallyCredited",
    PrizeDropWin_FreeRoundGames: "PrizeDropWin_FreeRoundGames",
    PromotionRuleUnitsPooler: "PromotionRuleUnitsPooler",
    PromotionRuleLinkID: "PromotionRuleLinkID",
    Evt_Internal_PromotionRuleLink_Visited: "Evt_Internal_PromotionRuleLink_Visited",
    Evt_Internal_PromotionRuleLink_HoveredOn: "Evt_Internal_PromotionRuleLink_HoveredOn",
    Evt_Internal_PromotionRuleLink_HoveredOff: "Evt_Internal_PromotionRuleLink_HoveredOff",
    Evt_Internal_PromotionRuleLink_Pressed: "Evt_Internal_PromotionRuleLink_Pressed",
    Evt_Internal_PromotionRuleLink_Released: "Evt_Internal_PromotionRuleLink_Released",
    ClosedByTimePromotionUID: "ClosedByTimePromotionUID",
    Evt_Internal_PromotionClosedByTime: "Evt_Internal_PromotionClosedByTime",
    RankPromotionID: "RankPromotionID",
    MenuPromotionType: "MenuPromotionType",
    CurrentPromotionDisplayStyle: "CurrentPromotionDisplayStyle",
    TournamentEnforced_Jurisdiction_TournamentOptOut: "TournamentEnforced_Jurisdiction_TournamentOptOut",
    Evt_Internal_UpdatePromotionWarning: "Evt_Internal_UpdatePromotionWarning",
    Evt_Internal_PromotionsOpen: "Evt_Internal_PromotionsOpen",
    Evt_Internal_PromotionsClosed: "Evt_Internal_PromotionsClosed",
    Evt_DataToCode_LeaderboardOpen: "Evt_DataToCode_LeaderboardOpen",
    Evt_DataToCode_LeaderboardClosed: "Evt_DataToCode_LeaderboardClosed",
    Evt_Internal_LeaderboardsReloaded: "Evt_Internal_LeaderboardsReloaded",
    Evt_CodeToData_ShowWheelOfPatience: "Evt_CodeToData_ShowWheelOfPatience",
    Evt_CodeToData_HideWheelOfPatience: "Evt_CodeToData_HideWheelOfPatience"
};
goog.provide("UHT.TournamentRule");

function TournamentRule() {
    this.rules = "";
    this.sampleLabel = null;
    this.maxLabelWidth = 0;
    this.maxNumberOfLines = 0;
    this.isSplit = false;
    this.splitRules = [];
    this.paragraphs = [];
    this.isStopped = false
}
TournamentRule.prototype.UpdateRules = function(value) {
    if (this.rules == value) {
        if (_string.IsNullOrEmpty(value)) this.isSplit = true;
        return
    }
    this.rules = value;
    this.splitRules.splice(0);
    this.isSplit = _string.IsNullOrEmpty(this.rules);
    if (!this.isSplit) this.SplitParagraphs()
};
TournamentRule.prototype.Split = function() {
    if (this.isSplit) return;
    this.splitRules = this.splitRules.concat(this.SplitToLines())
};
TournamentRule.prototype.GetSplitRules = function() {
    if (!this.isSplit) this.Split();
    return this.splitRules
};
TournamentRule.prototype.SplitParagraphs = function() {
    this.paragraphs.splice(0);
    this.paragraphs = this.paragraphs.concat(this.rules.split("\n"))
};
TournamentRule.prototype.SplitToLines = function() {
    this.isStopped = false;
    var res = [];
    for (var i = 0; i < this.paragraphs.length; ++i) {
        var words = this.paragraphs[i].split(" ");
        this.sampleLabel.text = "";
        if (words.length > 1) {
            this.SplitWords(res, words, i + 1);
            if (this.isStopped) return res
        } else {
            this.SplitChars(res, "", this.paragraphs[i], i + 1, null, 0);
            if (this.isStopped) return res
        }
    }
    this.isSplit = true;
    return res
};
TournamentRule.prototype.SplitWords = function(res, words, paragraphIdx) {
    var text = "";
    var labelTxt = "";
    for (var i = 0; i < words.length; ++i) {
        labelTxt = this.sampleLabel.text;
        this.sampleLabel.text = words[i];
        if (this.sampleLabel.GetWidth() <= this.maxLabelWidth) {
            this.sampleLabel.text = labelTxt + words[i];
            if (this.sampleLabel.GetWidth() <= this.maxLabelWidth) {
                text = this.sampleLabel.text;
                this.sampleLabel.text += " "
            } else {
                res.push(text);
                if (res.length >= this.maxNumberOfLines) {
                    this.StopAt(null, 0, words, i, paragraphIdx);
                    return
                }
                this.sampleLabel.text =
                    "";
                text = "";
                i--
            }
        } else {
            this.sampleLabel.text = labelTxt;
            text = "";
            this.SplitChars(res, text, words[i], paragraphIdx, words, i);
            if (this.isStopped) return
        }
    }
    if (text != "") {
        res.push(text);
        if (res.length >= this.maxNumberOfLines) this.StopAt(null, 0, null, 0, paragraphIdx)
    }
};
TournamentRule.prototype.SplitChars = function(res, text, chars, paragraphIdx, words, wordIdx) {
    if (chars.length == 0) {
        res.push("");
        if (res.length >= this.maxNumberOfLines) this.StopAt(null, 0, null, 0, paragraphIdx);
        return
    }
    for (var i = 0; i < chars.length; ++i) {
        this.sampleLabel.text += chars[i];
        if (this.sampleLabel.GetWidth() <= this.maxLabelWidth) text = this.sampleLabel.text;
        else {
            res.push(text);
            if (res.length >= this.maxNumberOfLines) {
                this.StopAt(chars, i, words, wordIdx + 1, paragraphIdx);
                return
            }
            this.sampleLabel.text = "";
            text = "";
            i--
        }
    }
    if (text !=
        "" && (words == null || words != null && words.length - 1 == wordIdx)) {
        res.push(text);
        if (res.length >= this.maxNumberOfLines) this.StopAt(null, 0, null, 0, paragraphIdx)
    }
};
TournamentRule.prototype.StopAt = function(chars, charIdx, words, wordIdx, paragraphIdx) {
    var curParagraph = [];
    if (chars != null) {
        var c = "";
        for (var i = charIdx; i < chars.length; ++i) c += chars[i];
        if (!_string.IsNullOrEmpty(c)) curParagraph.push(c)
    }
    if (words != null)
        for (var i = wordIdx; i < words.length; ++i) curParagraph.push(words[i]);
    var notProcessedParagraphs = [];
    if (curParagraph.length > 0) notProcessedParagraphs.push(curParagraph.join(" "));
    for (var i = paragraphIdx; i < this.paragraphs.length; ++i) notProcessedParagraphs.push(this.paragraphs[i]);
    this.paragraphs = notProcessedParagraphs;
    this.isStopped = true;
    this.isSplit = this.paragraphs.length == 0
};
goog.provide("UHT.PromotionRule");
goog.require("UHT.TournamentRule");
PromotionRule.prototype = Object.create(TournamentRule.prototype);
PromotionRule.prototype.constructor = PromotionRule;

function PromotionRule() {
    TournamentRule.call(this);
    this.uid = "";
    this.rulesText = "";
    this.links = [];
    this.lines = []
}
PromotionRule.Unit = function(arg0, arg1, arg2, arg3, arg4) {
    this.uid = "";
    this.text = "";
    this.url = "";
    this.startIdx = 0;
    this.endIdxExcl = 0;
    this.isLink = false;
    this.isVisited = false;
    if (arguments.length == 2 || arguments.length == 5) {
        this.text = arguments[0];
        this.SetURL(arguments[1])
    }
    if (arguments.length == 3) {
        this.text = arguments[0];
        this.startIdx = arguments[1];
        this.endIdxExcl = arguments[2]
    }
    if (arguments.length == 5) {
        this.uid = arguments[2];
        this.startIdx = arguments[3];
        this.endIdxExcl = arguments[4]
    }
};
PromotionRule.Unit.visitedURLs = [];
PromotionRule.Unit.prototype.SetURL = function(url) {
    this.url = url;
    this.isLink = !_string.IsNullOrEmpty(url);
    this.isVisited = PromotionRule.Unit.visitedURLs.indexOf(url) > -1
};
PromotionRule.Unit.prototype.SetVisited = function() {
    this.isVisited = true;
    PromotionRule.Unit.visitedURLs.push(this.url)
};
PromotionRule.Unit.prototype.CheckVisited = function() {
    if (!this.isVisited) this.isVisited = PromotionRule.Unit.visitedURLs.indexOf(this.url) > -1
};
PromotionRule.Line = function() {
    this.endIdxExcl = 0;
    this.units = []
};
PromotionRule.prototype.Split = function() {
    if (this.isSplit) return;
    var prevCount = this.splitRules.length;
    this.splitRules = this.splitRules.concat(this.SplitToLines());
    if (prevCount == 0) this.lines.push(this.ProcessLine(0, this.splitRules[0]));
    for (var i = this.lines.length; i < this.splitRules.length; ++i) this.lines.push(this.ProcessLine(this.lines[i - 1].endIdxExcl, this.splitRules[i]));
    if (this.isSplit) {
        this.splitRules.splice(0);
        this.rulesText = ""
    }
};
PromotionRule.prototype.GetSplitLines = function() {
    if (!this.isSplit) this.Split();
    return this.lines
};
PromotionRule.prototype.SplitParagraphs = function() {
    this.ProcessLinks();
    this.paragraphs.splice(0);
    this.paragraphs = this.paragraphs.concat(this.rulesText.split("\n"))
};
PromotionRule.prototype.ProcessLinks = function() {
    this.links.splice(0);
    this.lines.splice(0);
    var htmls = [];
    var htmlMatch = this.rules.match(/<a\s.*?>.*?<\/a\s*?>/gi);
    if (htmlMatch != null)
        for (var i = 0; i < htmlMatch.length; ++i) {
            var html = htmlMatch[i];
            var text = "";
            var url = "";
            var textMatch = html.match(/>.*?</i);
            if (textMatch != null) text = textMatch[0].replace(">", "").replace("<", "");
            var urlMatch = html.match(/\bhref=".*?"/i);
            if (urlMatch == null) urlMatch = html.match(/\bhref='.*?'/i);
            if (urlMatch != null) url = urlMatch[0].replace("href=",
                "").replace(/['"]/g, "");
            htmls.push(html);
            this.links.push(new PromotionRule.Unit(text, url))
        }
    this.rulesText = this.rules;
    for (var i = 0; i < this.links.length; ++i) {
        this.links[i].uid = this.uid + "Link#" + i;
        this.links[i].startIdx = this.rulesText.indexOf(htmls[i]);
        this.links[i].endIdxExcl = this.links[i].startIdx + this.links[i].text.length;
        this.rulesText = this.rulesText.substr(0, this.links[i].startIdx) + this.links[i].text + this.rulesText.substr(this.links[i].startIdx + htmls[i].length)
    }
};
PromotionRule.prototype.ProcessLine = function(startIdx, text) {
    var ret = new PromotionRule.Line;
    var units = [];
    startIdx += this.rulesText.substr(startIdx).indexOf(text);
    ret.endIdxExcl = startIdx + text.length;
    ret.units = units;
    var prevUnit = new PromotionRule.Unit(text, startIdx, ret.endIdxExcl);
    units.push(prevUnit);
    for (var i = 0; i < this.links.length; ++i) {
        if (this.links[i].endIdxExcl <= startIdx) continue;
        else if (this.links[i].startIdx >= ret.endIdxExcl) break;
        if (this.links[i].startIdx <= startIdx) {
            var endIdxEx = this.links[i].endIdxExcl >
                ret.endIdxExcl ? ret.endIdxExcl : this.links[i].endIdxExcl;
            prevUnit.uid = this.links[i].uid;
            prevUnit.text = this.rulesText.substr(startIdx, endIdxEx - startIdx);
            prevUnit.SetURL(this.links[i].url);
            prevUnit.endIdxExcl = endIdxEx
        } else if (this.links[i].startIdx > startIdx) {
            if (prevUnit.endIdxExcl < this.links[i].startIdx) {
                prevUnit = new PromotionRule.Unit(this.rulesText.substr(prevUnit.endIdxExcl, this.links[i].startIdx - prevUnit.endIdxExcl), prevUnit.endIdxExcl, this.links[i].startIdx);
                units.push(prevUnit)
            } else if (_string.IsNullOrEmpty(prevUnit.url)) {
                prevUnit.text =
                    this.rulesText.substr(prevUnit.startIdx, this.links[i].startIdx - prevUnit.startIdx);
                prevUnit.endIdxExcl = this.links[i].startIdx
            }
            var unit = null;
            if (this.links[i].endIdxExcl > ret.endIdxExcl) unit = new PromotionRule.Unit(this.rulesText.substr(this.links[i].startIdx, ret.endIdxExcl - this.links[i].startIdx), this.links[i].url, this.links[i].uid, this.links[i].startIdx, ret.endIdxExcl);
            else unit = this.links[i];
            units.push(unit);
            prevUnit = unit
        }
    }
    if (prevUnit.endIdxExcl < ret.endIdxExcl) units.push(new PromotionRule.Unit(this.rulesText.substr(prevUnit.endIdxExcl,
        ret.endIdxExcl - prevUnit.endIdxExcl), prevUnit.endIdxExcl, ret.endIdxExcl));
    return ret
};
goog.require("UHT.Component");
ButtonAutoClicker.prototype = Object.create(Component.prototype);
ButtonAutoClicker.prototype.constructor = ButtonAutoClicker;

function ButtonAutoClicker() {
    Component.call(this);
    this.delay = 0;
    this.delayInAutoplay = 0;
    this.timeLeft = 0;
    this.started = false;
    this.isUsingShortDelay = false
}
ButtonAutoClicker.prototype.OnEnable = function() {
    this.isUsingShortDelay = XT.GetBool(Vars.Autoplay_SkipScreens) && XT.GetInt(Vars.AutoplaySpinsLeft) >= 0 || XT.GetBool(Vars.ContinuousSpin);
    this.timeLeft = this.isUsingShortDelay ? this.delayInAutoplay : this.delay;
    if (!this.isUsingShortDelay && this.delay > 29) this.started = false;
    else this.started = true
};
ButtonAutoClicker.prototype.Update = function() {
    if (this.started)
        if (!XT.GetBool(Vars.LastWinIsCounting) && !XT.GetBool(Vars.WaitInResultForBigWin)) {
            this.timeLeft -= Time.deltaTime;
            if (this.timeLeft < 0) {
                this.gameObject.SendMessage("OnClick");
                this.started = false
            }
        }
};
goog.require("UHT.Component");
goog.provide("UHT.MessageSender");
MessageSender.prototype = Object.create(Component.prototype);
MessageSender.prototype.constructor = MessageSender;

function MessageSender() {
    Component.call(this);
    this.animationEvents = [];
    this.onClickEvents = [];
    this.onEnabledEvents = []
}
MessageSender.MessageDataParamType = {
    None: 0,
    Bool: 1,
    Int: 2,
    Float: 3,
    Double: 4,
    String: 5
};
MessageSender.prototype.SendMessageFromAnimation = function(id) {
    if (id >= this.animationEvents.length || id < 0) return;
    this.InternalSendMessage(this.animationEvents, id)
};
MessageSender.SendMessage = function(msg) {
    if (msg.eventReceiver != null && !_string.IsNullOrEmpty(msg.methodToCall))
        if (msg.useParam) switch (msg.paramType) {
            case MessageSender.MessageDataParamType.Bool:
                msg.eventReceiver.SendMessage(msg.methodToCall, msg.paramString.toLowerCase() == "true");
                break;
            case MessageSender.MessageDataParamType.Int:
                msg.eventReceiver.SendMessage(msg.methodToCall, _number.otoi(msg.paramString));
                break;
            case MessageSender.MessageDataParamType.Float:
                msg.eventReceiver.SendMessage(msg.methodToCall,
                    _number.otod(msg.paramString));
                break;
            case MessageSender.MessageDataParamType.Double:
                msg.eventReceiver.SendMessage(msg.methodToCall, _number.otod(msg.paramString));
                break;
            case MessageSender.MessageDataParamType.String:
                msg.eventReceiver.SendMessage(msg.methodToCall, msg.paramString);
                break;
            default:
                msg.eventReceiver.SendMessage(msg.methodToCall);
                break
        } else msg.eventReceiver.SendMessage(msg.methodToCall)
};
MessageSender.prototype.OnClick = function() {
    if (this.gameObject.collider == null || !this.gameObject.collider.enabled) return;
    if (this.onClickEvents.length <= 0) return;
    this.InternalSendMessageToAll(this.onClickEvents)
};
MessageSender.prototype.OnEnable = function() {
    if (this.onEnabledEvents == null || this.onEnabledEvents.length <= 0) return;
    this.InternalSendMessageToAll(this.onEnabledEvents)
};
MessageSender.prototype.InternalSendMessageToAll = function(data) {
    for (var i in data) this.InternalSendMessage(data, i)
};
MessageSender.prototype.InternalSendMessage = function(data, idx) {
    if (idx >= data.length || idx < 0) return;
    MessageSender.SendMessage(data[idx])
};

function MessageData(_receiver, _methodToCall, _useParam, _paramString, _paramType) {
    if (_paramType == undefined) _paramType = MessageSender.MessageDataParamType.String;
    this.eventReceiver = _receiver;
    this.useParam = _useParam;
    this.paramType = _paramType;
    this.paramString = _paramString;
    this.methodToCall = _methodToCall
}
goog.require("UHT.CAT_Action");
goog.require("UHT.MessageSender");
CAT_Action_SendMessage.prototype = Object.create(CAT_Action.prototype);
CAT_Action_SendMessage.prototype.constructor = CAT_Action_SendMessage;

function CAT_Action_SendMessage() {
    CAT_Action.call(this);
    this.data = null
}
CAT_Action_SendMessage.prototype.OnStateChanged_Running = function() {
    MessageSender.SendMessage(this.data);
    this.ChangeState(CATState.Finished)
};
goog.require("UHT.CAT_Action");
goog.require("UHT.MessageSender");
CAT_Action_SendMessageMultipleReceivers.prototype = Object.create(CAT_Action.prototype);
CAT_Action_SendMessageMultipleReceivers.prototype.constructor = CAT_Action_SendMessageMultipleReceivers;

function CAT_Action_SendMessageMultipleReceivers() {
    CAT_Action.call(this);
    this.eventReceivers = [];
    this.methodToCall = "";
    this.useParam = false;
    this.paramString = ""
}
CAT_Action_SendMessageMultipleReceivers.prototype.OnStateChanged_Running = function() {
    for (var i in this.eventReceivers) MessageSender.SendMessage(new MessageData(this.eventReceivers[i], this.methodToCall, this.useParam, this.paramString));
    this.ChangeState(CATState.Finished)
};
goog.require("UHT.Component");
goog.require("UHT.MessageSender");
SendMessageToChildren.prototype = Object.create(Component.prototype);
SendMessageToChildren.prototype.constructor = SendMessageToChildren;

function SendMessageToChildren() {
    Component.call(this);
    this.broadcastToFirstChildOnly = true
}
SendMessageToChildren.prototype.SendToChildren = function(message) {
    var ind1 = message.indexOf("(");
    var ind2 = message.indexOf(")");
    var methodToCall = message.substring(0, ind1);
    var param = message.substring(ind1 + 1, ind2);
    for (var i = 0; i < (this.broadcastToFirstChildOnly ? 1 : this.gameObject.transform.childCount); i++) {
        var msg = new MessageData(this.gameObject.transform.children[i].gameObject, methodToCall, !_string.IsNullOrEmpty(param), param);
        MessageSender.SendMessage(msg)
    }
};
goog.provide("UHT.TwoFloatsAnimatedMonoBehaviour");
goog.require("UHT.Component");
CurveTwoValuesAnimator.prototype = Object.create(Component.prototype);
CurveTwoValuesAnimator.prototype.constructor = CurveTwoValuesAnimator;
TwoFloatsAnimatedMonoBehaviour.prototype = Object.create(Component.prototype);
TwoFloatsAnimatedMonoBehaviour.prototype.constructor = TwoFloatsAnimatedMonoBehaviour;

function CurveTwoValuesAnimator() {
    Component.call(this);
    this.animatedMemberTarget = null;
    this.curve_1 = null;
    this.curve_2 = null;
    this.Loop_1 = true;
    this.Loop_2 = true;
    this.isStarted_1 = false;
    this.startTime_1 = 0;
    this.lastKeyTime_1 = 0;
    this.isStarted_2 = false;
    this.startTime_2 = 0;
    this.lastKeyTime_2 = 0
}

function TwoFloatsAnimatedMonoBehaviour() {
    Component.call(this)
}
TwoFloatsAnimatedMonoBehaviour.prototype.SetAnimatedF_1 = function(val) {};
TwoFloatsAnimatedMonoBehaviour.prototype.SetAnimatedF_2 = function(val) {};
TwoFloatsAnimatedMonoBehaviour.prototype.ResetF_1 = function() {};
TwoFloatsAnimatedMonoBehaviour.prototype.ResetF_2 = function() {};
CurveTwoValuesAnimator.prototype.Awake = function() {
    this.lastKeyTime_1 = this.curve_1.keys[this.curve_1.keys.length - 1].time;
    this.lastKeyTime_2 = this.curve_2.keys[this.curve_2.keys.length - 1].time
};
CurveTwoValuesAnimator.prototype.StartCurveAnimation_1 = function() {
    this.isStarted_1 = true;
    this.startTime_1 = Time.time
};
CurveTwoValuesAnimator.prototype.StopCurveAnimation_1 = function() {
    this.isStarted_1 = false;
    this.animatedMemberTarget.ResetF_1()
};
CurveTwoValuesAnimator.prototype.StartCurveAnimation_2 = function() {
    this.isStarted_2 = true;
    this.startTime_2 = Time.time
};
CurveTwoValuesAnimator.prototype.StopCurveAnimation_2 = function() {
    this.isStarted_2 = false;
    this.animatedMemberTarget.ResetF_2()
};
CurveTwoValuesAnimator.prototype.Update = function() {
    var current_time = Time.time;
    if (this.isStarted_1) {
        if (this.isStarted_1) {
            var animF1 = this.curve_1.Evaluate(this.Loop_1 ? (current_time - this.startTime_1) % this.lastKeyTime_1 : UHTMath.clamp(current_time - this.startTime_1, 0, this.lastKeyTime_2));
            this.animatedMemberTarget.SetAnimatedF_1(animF1)
        }
        if (!this.Loop_1)
            if (current_time - this.startTime_1 > this.lastKeyTime_1) this.isStarted_1 = false
    }
    if (this.isStarted_2) {
        if (this.isStarted_2) {
            var animF2 = this.curve_2.Evaluate(this.Loop_2 ?
                (current_time - this.startTime_2) % this.lastKeyTime_2 : UHTMath.clamp(current_time - this.startTime_2, 0, this.lastKeyTime_2));
            this.animatedMemberTarget.SetAnimatedF_2(animF2)
        }
        if (!this.Loop_2)
            if (current_time - this.startTime_2 > this.lastKeyTime_2) this.isStarted_2 = false
    }
};
goog.provide("UHT.Globals");

function Globals() {}
Globals.InputBlocked = true;
Globals.timeChannels = [];
Globals.isMobile = false;
Globals.isMini = false;
Globals.GamePaused = false;
Globals.WatchingReplay = false;
Globals.SetLayerRecursively = function(obj, layer) {
    if (obj.layer != layer) obj.transform.SetAllDirtyUserFlags();
    obj.layer = layer;
    for (var i = 0; i < obj.transform.children.length; i++) Globals.SetLayerRecursively(obj.transform.children[i].gameObject, layer)
};
Globals.GetCameraForObject = function(go) {
    var allCameras = Camera.allCameras;
    var layerMask = 1 << go.layer;
    for (var i = 0; i < allCameras.length; i++)
        if (allCameras[i].cullingMask == layerMask) return allCameras[i];
    return null
};
Globals.RegisterToTimeChannel = function(mb, id) {
    for (var i = 0; i < Globals.timeChannels.length; i++)
        if (Globals.timeChannels[i].id == id) {
            for (var jm = 0; jm < Globals.timeChannels[i].members.length; jm++)
                if (Globals.timeChannels[i].members[jm] == mb) return Globals.timeChannels[i];
            Globals.timeChannels[i].members.push(mb);
            return Globals.timeChannels[i]
        }
    var tc = new TimeChannel(id);
    tc.members.push(mb);
    Globals.timeChannels.push(tc);
    return tc
};
Globals.UnregisterFromTimeChannel = function(mb, id) {
    for (var i = 0; i < Globals.timeChannels.length; i++)
        if (Globals.timeChannels[i].id == id) {
            var idx = Globals.timeChannels[i].members.indexOf(mb);
            Globals.timeChannels[i].members.splice(idx, 1);
            if (Globals.timeChannels[i].members.length == 0) Globals.timeChannels.splice(i, 1);
            return
        }
};

function TimeChannel(id) {
    this.id = id;
    this.members = [];
    this.currentTime = 0
}
TimeChannel.prototype.IsChannelMaster = function(mb) {
    return this.members[0] == mb
};
var TimeScaler = {};
TimeScaler.timeScales = {};
TimeScaler.GetDeltaTime = function(id) {
    var scale = 1;
    if (TimeScaler.timeScales[id] != undefined) scale = TimeScaler.timeScales[id];
    return Time.deltaTime * scale
};
TimeScaler.SetTimeScale = function(id, scale) {
    TimeScaler.timeScales[id] = scale
};
TimeScaler.ClearTimeScale = function(id) {
    if (TimeScaler.timeScales[id] != undefined) delete TimeScaler.timeScales[id]
};
goog.provide("UHT.UICamera");
goog.require("UHT.Component");
goog.require("UHT.Collider");
goog.require("UHT.Globals");
UICamera.prototype = Object.create(Component.prototype);
UICamera.prototype.constructor = UICamera;

function UICamera() {
    Component.call(this);
    this.eventReceiverMask = null;
    this.target = null;
    this.mousePosOnPress = null;
    this.mouseWasPressed = false;
    this.mouseWasDragged = false;
    this.mouseIsOverTarget = false;
    this.cachedCamera = null;
    this.mustGoFullscreen = false
}
UICamera.messageHover = "OnHover";
UICamera.messagePress = "OnPress";
UICamera.messageClick = "OnClick";
UICamera.allUICameras = [];
UICamera.lastProcessedFrameCount = -1;
UICamera.prototype.OnEnable = function() {
    this.cachedCamera = this.GetComponent(Camera);
    var pos = 0;
    for (var i = 0; i < UICamera.allUICameras.length; i++)
        if (UICamera.allUICameras[i].cachedCamera.depth < this.cachedCamera.depth) pos++;
        else break;
    UICamera.allUICameras.splice(pos, 0, this)
};
UICamera.prototype.OnDisable = function() {
    for (var i = 0; i < UICamera.allUICameras.length; i++)
        if (UICamera.allUICameras[i] == this) {
            UICamera.allUICameras.splice(i, 1);
            break
        }
};
UICamera.prototype.Update = function() {
    if (ServerOptions.isReplay)
        if (Input.GetMouseButtonDown(0)) XT.TriggerEvent(ReplaySessionVars.Replay_UserClicked);
    if (Time.frameCount != UICamera.lastProcessedFrameCount) {
        UICamera.lastProcessedFrameCount = Time.frameCount;
        for (var i = UICamera.allUICameras.length - 1; i >= 0; i--) {
            if (Globals.InputBlocked && !UICamera.allUICameras[i].cachedCamera.ignoreInputBlocked && !ServerOptions.isReplay) continue;
            var stop = UICamera.allUICameras[i].UpdateCamera();
            if (stop) break
        }
    }
};
UICamera.prototype.UpdateCamera = function() {
    var hoveredCollider = null;
    var skipGettingCollider = false;
    if (this.cachedCamera.IsClippingInput()) {
        var TL = new UHTMath.Vector3(-this.cachedCamera.extraCameraSettings.clipLeft, this.cachedCamera.extraCameraSettings.clipUp, 0);
        var BR = new UHTMath.Vector3(this.cachedCamera.extraCameraSettings.clipRight, -this.cachedCamera.extraCameraSettings.clipDown, 0);
        var TLW = this.gameObject.transform.transformPoint(TL);
        var BRW = this.gameObject.transform.transformPoint(BR);
        var TLS =
            this.cachedCamera.WorldToScreenPoint(TLW);
        var BRS = this.cachedCamera.WorldToScreenPoint(BRW);
        if (Input.mousePosition.x < TLS.x || Input.mousePosition.y < TLS.y || Input.mousePosition.x > BRS.x || Input.mousePosition.y > BRS.y) skipGettingCollider = true
    }
    if (!skipGettingCollider) hoveredCollider = globalColliderInputManager.getHoveredCollider(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition), this.eventReceiverMask);
    if (ServerOptions.isReplay && Globals.InputBlocked && hoveredCollider != null)
        if (hoveredCollider["usedForReplay"] !=
            true) hoveredCollider = null;
    if (Input.GetMouseButton(0)) {
        this.mouseWasPressed = true;
        if (Input.GetMouseButtonDown(0)) {
            this.target = hoveredCollider;
            if (this.target != null) this.target.gameObject.SendMessage(UICamera.messagePress, true);
            this.mousePosOnPress = new UHTMath.Vector3(Input.mousePosition);
            this.mouseWasDragged = false;
            this.mouseIsOverTarget = true
        }
    } else if (this.mouseWasPressed == true) {
        this.mouseWasPressed = false;
        if (this.target != null) {
            this.target.gameObject.SendMessage(UICamera.messagePress, false);
            if (hoveredCollider ==
                this.target) {
                if (Input.lastUsedInputDeviceIsTouch == false) this.target.gameObject.SendMessage(UICamera.messageHover, true);
                if (this.mouseWasDragged == false) this.target.gameObject.SendMessage(UICamera.messageClick)
            }
        }
    } else if (Input.lastUsedInputDeviceIsTouch == false && hoveredCollider != this.target) {
        if (this.target != null) this.target.gameObject.SendMessage(UICamera.messageHover, false);
        this.target = hoveredCollider;
        if (this.target != null) this.target.gameObject.SendMessage(UICamera.messageHover, true)
    }
    return hoveredCollider !=
        null
};
goog.provide("UHT.Engine");
goog.require("UHT.Tracking");
goog.require("UHT.Globals");
goog.require("UHT.System.Misc.Utils");
goog.require("UHT.Component");
goog.require("UHT.GameObject");
goog.require("UHT.AnimationUtils");
goog.require("UHT.TextAsset");
goog.require("UHT.Input");
goog.require("UHT.UHTScreen");
goog.require("UHT.Animation");
goog.require("UHT.UIUtils");
goog.require("UHT.UIAtlas");
goog.require("UHT.UILabel");
goog.require("UHT.UICamera");
goog.require("UHT.UIPanel");
goog.require("UHT.UISprite");
goog.require("UHT.UIZoomSprite");
goog.require("UHT.UIButton");
goog.require("UHT.UIRoot");
goog.require("UHT.UIFont");
goog.require("UHT.UIButtonScale");
goog.require("UHT.UIInput");
goog.require("UHT.Gradient");
goog.require("UHT.UHTEngine");
goog.require("UHT.Engine");
BoneFollower.prototype = Object.create(Component.prototype);
BoneFollower.prototype.constructor = BoneFollower;

function BoneFollower() {
    Component.call(this);
    this.spineController = null;
    this.boneName = "";
    this.followZPosition = false;
    this.followBoneRotation = false;
    this.followSkeletonFlip = false;
    this.followLocalScale = false;
    this.initializeOnAwake = false;
    this.valid = false;
    this.bone = null;
    this.skeletonTransform = null;
    this.skeletonTransformIsParent = false
}
BoneFollower.prototype.scriptUpdatePriority = 4;
BoneFollower.prototype.Awake = function() {
    if (this.initializeOnAwake) this.Initialize()
};
BoneFollower.prototype.Initialize = function() {
    this.bone = null;
    this.valid = this.spineController != null && this.spineController.spine != null;
    if (!this.valid) return;
    this.skeletonTransform = this.spineController.transform;
    this.skeletonTransformIsParent = this.skeletonTransform == this.transform.parent;
    if (!_string.IsNullOrEmpty(this.boneName)) this.bone = this.spineController.spine.skeleton.findBone(this.boneName)
};
BoneFollower.prototype.LateUpdate = function() {
    if (!this.valid) {
        this.Initialize();
        return
    }
    if (this.bone == null) {
        if (_string.IsNullOrEmpty(this.boneName)) return;
        this.bone = this.spineController.spine.skeleton.findBone(this.boneName);
        if (this.bone == null) {
            console.error("Bone not found: " + this.boneName, this);
            return
        }
    }
    var thisTransform = this.transform;
    var ls = this.skeletonTransform.localScale();
    var wx = this.bone.worldX / ls.x;
    var wy = -this.bone.worldY / ls.y;
    var wrx = -this.bone.getWorldRotationX();
    if (this.skeletonTransformIsParent) {
        thisTransform.localPosition(new UHTMath.Vector3(this.bone.worldX,
            this.bone.worldY, this.followZPosition ? 0 : thisTransform.localPosition().z));
        if (this.followBoneRotation) thisTransform.localRotation(UHTMath.Quaternion.euler(new UHTMath.Vector3(0, 0, this.bone.rotation)))
    } else {
        var targetWorldPosition = this.skeletonTransform.transformPoint(new UHTMath.Vector3(wx, wy, 0));
        if (!this.followZPosition) targetWorldPosition.z = thisTransform.position().z;
        thisTransform.position(targetWorldPosition);
        if (this.followBoneRotation) {
            var worldRotation = this.skeletonTransform.eulerAngles();
            thisTransform.rotation(UHTMath.Quaternion.euler(worldRotation.x,
                worldRotation.y, worldRotation.z + wrx))
        }
    }
    var localScale = this.followLocalScale ? new UHTMath.Vector3(this.bone.scaleX, this.bone.scaleY, 1) : new UHTMath.Vector3(1, 1, 1);
    if (this.followSkeletonFlip) localScale.y *= this.bone.skeleton.flipX ^ this.bone.skeleton.flipY ? -1 : 1;
    thisTransform.localScale(localScale)
};
goog.provide("UHT.CAT_Action_SpineAnimation");
goog.require("UHT.Engine");
goog.require("UHT.CAT_Action");
CAT_Action_SpineAnimation.prototype = Object.create(CAT_Action.prototype);
CAT_Action_SpineAnimation.prototype.constructor = CAT_Action_SpineAnimation;

function CAT_Action_SpineAnimation() {
    CAT_Action.call(this);
    this.controller = null;
    this.action = SpineControllerCATAction.Play;
    this.animationName = "";
    this.animationTime = -1;
    this.normalizedTime = 0;
    this.animationMode = SpineControllerMode.Default;
    this.onEnable = SpineControllerAction.Reset;
    this.onComplete = null;
    this.overrideOnEnable = false;
    this.overrideOnComplete = false
}
CAT_Action_SpineAnimation.prototype.OnStateChanged_Running = function() {
    if (this.controller == null || this.controller.spineData == null) {
        this.ChangeState(CATState.Finished);
        return
    }
    if (this.overrideOnEnable) this.controller.onEnable = this.onEnable;
    if (this.overrideOnComplete) this.controller.onComplete = this.onComplete;
    if (this.action == SpineControllerCATAction.Reset || this.action == SpineControllerCATAction.Play || this.action == SpineControllerCATAction.Sample) {
        if (_string.IsNullOrEmpty(this.animationName)) {
            this.ChangeState(CATState.Finished);
            return
        }
        this.controller.animationName = this.animationName
    }
    if (this.action == SpineControllerCATAction.Play) {
        this.controller.animationTime = this.animationTime;
        this.controller.animationMode = this.animationMode;
        if (!this.controller.gameObject.activeInHierarchy) console.error("Trying to play spine animation on an inactive controller (" + this.controller.gameObject.name + ")");
        this.controller.Play()
    } else if (this.action == SpineControllerCATAction.Resume) {
        if (!this.controller.gameObject.activeInHierarchy) console.error("Trying to resume spine animation on an inactive controller (" +
            this.controller.gameObject.name + ")");
        this.controller.Resume()
    } else if (this.action == SpineControllerCATAction.Sample) this.controller.Sample(this.normalizedTime);
    else if (this.action == SpineControllerCATAction.Pause) this.controller.Pause();
    else if (this.action == SpineControllerCATAction.Reset) this.controller.Reset();
    else if (this.action == SpineControllerCATAction.Stop) this.controller.Stop();
    if (this.action == SpineControllerCATAction.Reset || this.action == SpineControllerCATAction.Stop || this.action == SpineControllerCATAction.Pause ||
        this.action == SpineControllerCATAction.Sample) this.ChangeState(CATState.Finished)
};
CAT_Action_SpineAnimation.prototype.OnStateChanged_Stopping = function() {
    if (this.controller != null) this.controller.Stop();
    this.ChangeState(CATState.Finished)
};
CAT_Action_SpineAnimation.prototype.CATUpdate = function() {
    if (this.GetState() == CATState.Running && !this.controller.IsPlaying()) this.ChangeState(CATState.Finished)
};
goog.require("UHT.CAT_Action_SpineAnimation");
CAT_Action_SpineAnimation_NoWait.prototype = Object.create(CAT_Action_SpineAnimation.prototype);
CAT_Action_SpineAnimation_NoWait.prototype.constructor = CAT_Action_SpineAnimation_NoWait;

function CAT_Action_SpineAnimation_NoWait() {
    CAT_Action_SpineAnimation.call(this)
}
CAT_Action_SpineAnimation_NoWait.prototype.OnStateChanged_Running = function() {
    CAT_Action_SpineAnimation.prototype.OnStateChanged_Running.call(this);
    if (this.internalState != CATState.Finished) this.ChangeState(CATState.Finished)
};
goog.require("UHT.Engine");
goog.require("UHT.CAT_Action");
goog.require("UHT.AnimationUtils");
CAT_Action_StartAnim.prototype = Object.create(CAT_Action.prototype);
CAT_Action_StartAnim.prototype.constructor = CAT_Action_StartAnim;

function CAT_Action_StartAnim() {
    CAT_Action.call(this);
    this.target = null;
    this.animClipName = "";
    this.mode = WrapMode.Default;
    this.speed = 1
}
CAT_Action_StartAnim.prototype.OnStateChanged_Running = function() {
    if (this.target == null || this.animClipName == "" || this.target.animation == null) {
        this.ChangeState(CATState.Finished);
        return
    }
    if (!this.target.activeInHierarchy) console.error("Trying to start an animation on an inactive object (" + this.target.name + "). This is undefined behaviour!");
    var anim = this.target.animation;
    anim.Stop();
    anim.GetAnimationState(this.animClipName).wrapMode = this.mode;
    anim.GetAnimationState(this.animClipName).speed = this.speed;
    if (this.speed <
        0) anim.GetAnimationState(this.animClipName).time = anim.GetAnimationState(this.animClipName).length;
    anim.Play(this.animClipName)
};
CAT_Action_StartAnim.prototype.OnStateChanged_Stopping = function() {
    if (this.target != null && this.target.animation != null && this.target.animation.isPlaying) this.target.animation.Stop();
    this.ChangeState(CATState.Finished)
};
CAT_Action_StartAnim.prototype.CATUpdate = function() {
    if (this.GetState() == CATState.Running)
        if (this.target.animation.isPlaying == false) this.ChangeState(CATState.Finished)
};
goog.require("UHT.Engine");
goog.require("UHT.CAT_Action");
CAT_Action_SwitchLayer.prototype = Object.create(CAT_Action.prototype);
CAT_Action_SwitchLayer.prototype.constructor = CAT_Action_SwitchLayer;

function CAT_Action_SwitchLayer() {
    CAT_Action.call(this);
    this.newLayer = null;
    this.root = null
}
CAT_Action_SwitchLayer.prototype.OnStateChanged_Running = function() {
    Globals.SetLayerRecursively(this.root, this.newLayer.value());
    this.ChangeState(CATState.Finished)
};
goog.require("UHT.Engine");
var BehaviourMessage2CATMessage = {
    None: 0,
    Awake: 1,
    Start: 2,
    Update: 3,
    LateUpdate: 4,
    Disable: 5,
    Enable: 6
};
var BehaviourMessage2CATActionType = {
    None: 0,
    StartOnMessage: 1,
    StopOnMessage: 2
};

function BehaviourMessage2CATLink() {
    this.cat = null;
    this.message = BehaviourMessage2CATMessage.None;
    this.actionType = BehaviourMessage2CATActionType.None
}
BehaviourMessage2CAT.prototype = Object.create(Component.prototype);
BehaviourMessage2CAT.prototype.constructor = BehaviourMessage2CAT;

function BehaviourMessage2CAT() {
    Component.call(this);
    this.cats = null
}
BehaviourMessage2CAT.prototype.Awake = function() {
    this.DoIt(BehaviourMessage2CATMessage.Awake)
};
BehaviourMessage2CAT.prototype.Start = function() {
    this.DoIt(BehaviourMessage2CATMessage.Start)
};
BehaviourMessage2CAT.prototype.Update = function() {
    this.DoIt(BehaviourMessage2CATMessage.Update)
};
BehaviourMessage2CAT.prototype.LateUpdate = function() {
    this.DoIt(BehaviourMessage2CATMessage.LateUpdate)
};
BehaviourMessage2CAT.prototype.OnDisable = function() {
    this.DoIt(BehaviourMessage2CATMessage.Disable)
};
BehaviourMessage2CAT.prototype.OnEnable = function() {
    this.DoIt(BehaviourMessage2CATMessage.Enable)
};
BehaviourMessage2CAT.prototype.DoIt = function(msg) {
    for (var i = 0; i < this.cats.length; ++i) {
        if (this.cats[i].message != msg || this.cats[i].cat == null) continue;
        if (this.cats[i].actionType == BehaviourMessage2CATActionType.StartOnMessage) this.cats[i].cat.Start();
        if (this.cats[i].actionType == BehaviourMessage2CATActionType.StopOnMessage) this.cats[i].cat.Stop()
    }
};
goog.require("UHT.Engine");
CatTestHelper.prototype = Object.create(Component.prototype);
CatTestHelper.prototype.constructor = CatTestHelper;

function CatTestHelper() {
    Component.call(this);
    this.eventIdToTest = 0
}
CatTestHelper.prototype.Awake = function() {
    var cat = this.gameObject.GetComponent(CAT_Container);
    if (cat != null) {
        this.eventIdToTest = new CATLink;
        this.eventIdToTest.cat = cat
    }
};
CatTestHelper.prototype.Start = function() {};
goog.provide("UHT.CAT_ContainerInterface");
goog.require("UHT.Engine");
CAT_ContainerInterface.prototype = Object.create(Component.prototype);
CAT_ContainerInterface.prototype.constructor = CAT_ContainerInterface;

function CAT_ContainerInterface() {
    Component.call(this)
}
CAT_ContainerInterface.prototype.IsEventRunning = function(id) {};
CAT_ContainerInterface.prototype.StartEvent = function(id) {};
CAT_ContainerInterface.prototype.StopEvent = function(id) {};
CAT_ContainerInterface.prototype.StopAllRunningEvents = function() {};
CAT_ContainerInterface.prototype.RegisterCallback = function(eventId, newCallback, object) {};
CAT_ContainerInterface.prototype.UnregisterCallback = function(eventId, toRemoveCallback, object) {};
CAT_ContainerInterface.prototype.StartEventByMessage = function(id) {
    this.StartEvent(_number.otoi(id))
};
goog.require("UHT.CAT_ContainerInterface");
CAT_Container.prototype = Object.create(CAT_ContainerInterface.prototype);
CAT_Container.prototype.constructor = CAT_Container;

function CAT_Container() {
    CAT_ContainerInterface.call(this);
    this.events = [];
    this.runningEvents = []
}
CAT_Container.prototype.scriptUpdatePriority = 9;
CAT_Container.prototype.IsEventRunning = function(id) {
    return this.GetEventByID(id).isRunning
};
CAT_Container.prototype.StartEvent = function(id) {
    this.GetEventByID(id).Start()
};
CAT_Container.prototype.StopEvent = function(id) {
    this.GetEventByID(id).Stop()
};
CAT_Container.prototype.StopAllRunningEvents = function() {
    for (var i = 0; i < this.runningEvents.length; i++) this.runningEvents[i].Stop()
};
CAT_Container.prototype.Awake = function() {
    for (var evIndex = 0; evIndex < this.events.length; evIndex++)
        for (var evtIndex = evIndex + 1; evtIndex < this.events.length; evtIndex++)
            if (this.events[evIndex].id == this.events[evtIndex].id) console.error("Cat_Container " + this.gameObject.name + " has duplicate Event IDs!")
};
CAT_Container.prototype.OnEnable = function() {
    for (var i = 0; i < this.events.length; i++)
        if (this.events[i].playAutomatically) this.events[i].Start()
};
CAT_Container.prototype.OnDisable = function() {
    this.StopAllRunningEvents()
};
CAT_Container.prototype.Update = function() {
    var i = this.runningEvents.length;
    while (i--) this.runningEvents[i].Update()
};
CAT_Container.prototype.RegisterCallback = function(eventId, newCallback, object) {
    this.GetEventByID(eventId).RegisterCallback(newCallback, object)
};
CAT_Container.prototype.UnregisterCallback = function(eventId, toRemoveCallback, object) {
    this.GetEventByID(eventId).UnregisterCallback(toRemoveCallback, object)
};
CAT_Container.prototype.GetEventByID = function(id) {
    for (var i = 0; i < this.events.length; i++)
        if (this.events[i].id == id) return this.events[i];
    return null
};
CAT_Container.prototype.AddRunningEvent = function(event) {
    this.runningEvents.push(event)
};
CAT_Container.prototype.RemoveRunningEvent = function(event) {
    if (this.runningEvents.indexOf(event) != -1) this.runningEvents.splice(this.runningEvents.indexOf(event), 1)
};
CAT_Container.prototype.AfterDeserialize = function() {
    for (var i = 0; i < this.events.length; i++) this.events[i].SetParent(this)
};
CAT_Container.prototype.DisableEvent = function(id) {
    this.GetEventByID(Number(id)).isEnabled = false
};
CAT_Container.prototype.EnableEvent = function(id) {
    this.GetEventByID(Number(id)).isEnabled = true
};
goog.require("UHT.CAT_ContainerInterface");
CAT_Container_Proxy.prototype = Object.create(CAT_ContainerInterface.prototype);
CAT_Container_Proxy.prototype.constructor = CAT_Container_Proxy;

function CAT_Container_Proxy() {
    CAT_ContainerInterface.call(this);
    this.con = null
}
CAT_Container_Proxy.prototype.IsEventRunning = function(id) {
    this.con = this.GetComponentInChildren(CAT_Container);
    if (this.con != null) return this.con.IsEventRunning(id);
    console.log("CAT_Container_Proxy: No container found in children!" + this.gameObject);
    return false
};
CAT_Container_Proxy.prototype.StartEvent = function(id) {
    this.con = this.GetComponentInChildren(CAT_Container);
    if (this.con != null) {
        this.con.StartEvent(id);
        return
    }
    console.log("CAT_Container_Proxy: No container found in children!" + this.gameObject)
};
CAT_Container_Proxy.prototype.StopEvent = function(id) {
    this.con = this.GetComponentInChildren(CAT_Container);
    if (this.con != null) {
        this.con.StopEvent(id);
        return
    }
    console.log("CAT_Container_Proxy: No container found in children!" + this.gameObject)
};
CAT_Container_Proxy.prototype.StopAllRunningEvents = function() {
    this.con = this.GetComponentInChildren(CAT_Container);
    if (this.con != null) {
        this.con.StopAllRunningEvents();
        return
    }
    console.log("CAT_Container_Proxy: No container found in children!" + this.gameObject)
};
CAT_Container_Proxy.prototype.RegisterCallback = function(eventId, newCallback, object) {
    this.con = this.GetComponentInChildren(CAT_Container);
    if (this.con != null) {
        this.con.RegisterCallback(eventId, newCallback, object);
        return
    }
    console.log("CAT_Container_Proxy: No container found in children!" + this.gameObject)
};
CAT_Container_Proxy.prototype.UnregisterCallback = function(eventId, toRemoveCallback, object) {
    this.con = this.GetComponentInChildren(CAT_Container);
    if (this.con != null) {
        this.con.UnregisterCallback(eventId, toRemoveCallback, object);
        return
    }
    console.log("CAT_Container_Proxy: No container found in children!" + this.gameObject)
};
goog.require("UHT.Engine");
FeatureID2CAT.prototype = Object.create(Component.prototype);
FeatureID2CAT.prototype.constructor = FeatureID2CAT;

function FeatureID2CAT() {
    Component.call(this);
    this.provider = null;
    this.cats = null
}
FeatureID2CAT.prototype.StartCATLink = function() {
    if (this.provider.featureID > -1) this.cats[this.provider.featureID].Start()
};
goog.require("UHT.Engine");
XTButton.prototype = Object.create(Component.prototype);
XTButton.prototype.constructor = XTButton;
var XTButtonAction = {
    OnClick: 0,
    OnPress: 1
};

function XTButton() {
    Component.call(this);
    this.action = XTButtonAction.OnClick;
    this.eventToCode = null;
    this.useParam = false;
    this.param = null;
    this.paramValue = 0
}
XTButton.prototype.OnClick = function() {
    if (this.action == XTButtonAction.OnClick) {
        var cd = this.gameObject.GetComponent(ClickDelay);
        if (cd == null || cd.CanClick()) this.DoIt()
    }
};
XTButton.prototype.OnPress = function(isPressed) {
    if (isPressed && this.action == XTButtonAction.OnPress) this.DoIt()
};
XTButton.prototype.DoIt = function() {
    if (this.useParam) XT.SetInt(this.param.name, this.paramValue);
    XT.TriggerEvent(this.eventToCode.name)
};
goog.provide("UHT.XTLink");
goog.require("UHT.Engine");
XTLink.prototype = Object.create(Component.prototype);
XTLink.prototype.constructor = XTLink;

function XTLink() {
    Component.call(this);
    this.isRegisteredAndInited = false;
    this.xtEnabled = true
}
XTLink.prototype.XTRegisterCallbacksBase = function() {
    this.isRegisteredAndInited = true;
    this.XTRegisterCallbacks()
};
XTLink.prototype.XTRegisterCallbacks = function() {};
XTLink.prototype.XTInitVariablesAndEvents = function() {};
XTLink.prototype.OnDestroy = function() {};
XTLink.prototype.Awake = function() {
    if (XT.RegisterAndInitDone && !this.isRegisteredAndInited) {
        this.XTRegisterCallbacksBase();
        this.XTInitVariablesAndEvents()
    }
};
goog.require("UHT.XTLink");
goog.provide("UHT.AnnouncementDisplayer");
AnnouncementDisplayer.prototype = Object.create(XTLink.prototype);
AnnouncementDisplayer.prototype.constructor = AnnouncementDisplayer;

function AnnouncementDisplayer() {
    XTLink.call(this);
    this.type = AnnouncementAPI.AnnouncementType.Undefined;
    this.show = null;
    this.message = null
}
AnnouncementDisplayer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(AnnouncementVars.Evt_Internal_ShowAnnouncement, this.OnShowAnnouncement, this)
};
AnnouncementDisplayer.prototype.OnShowAnnouncement = function() {
    var announcement = XT.GetObject(AnnouncementVars.Announcement);
    if (this.type != announcement.type) return;
    XT.SetDouble(Vars.ExtraSessionWin, announcement.extraWin);
    XT.SetDouble(Vars.ExtraSessionWin, 0);
    XT.TriggerEvent(AnnouncementVars.Evt_Internal_AnnouncementHandled);
    for (var i = 0; i < this.message.length; ++i) this.message[i].text = announcement.message;
    this.show.Start()
};
goog.require("UHT.XTLink");

function StageTransition2CATDesc() {
    this.cat = null;
    this.fromStage = UHTStageName.No_Stage;
    this.toStage = UHTStageName.No_Stage
}
StageTransition2CAT.prototype = Object.create(XTLink.prototype);
StageTransition2CAT.prototype.constructor = StageTransition2CAT;

function StageTransition2CAT() {
    XTLink.call(this);
    this.transitions = null
}
StageTransition2CAT.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.ToStageName, this.OnToStageChanged, this)
};
StageTransition2CAT.prototype.OnToStageChanged = function(toStageName) {
    var fromStageName = XT.GetObject(Vars.FromStageName);
    for (var i = 0; i < this.transitions.length; ++i)
        if (this.transitions[i].fromStage == fromStageName && this.transitions[i].toStage == toStageName && this.transitions[i].cat != null) this.transitions[i].cat.Start()
};
StageTransition2CAT.prototype.StartCATLink = function() {
    this.OnToStageChanged(XT.GetObject(Vars.ToStageName))
};
goog.require("UHT.XTLink");
XT2CAT.prototype = Object.create(XTLink.prototype);
XT2CAT.prototype.constructor = XT2CAT;

function XT2CAT() {
    XTLink.call(this);
    this.actionType = XT2CAT.ActionType.StartOnEvent;
    this.xtEventName = null;
    this.catLink = null
}
XT2CAT.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(this.xtEventName.name, this.OnEventTriggered, this)
};
XT2CAT.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnEventTriggered, this)
};
XT2CAT.prototype.OnEventTriggered = function() {
    if (!this.gameObject.activeInHierarchy) return;
    if (this.actionType == XT2CAT.ActionType.StartOnEvent) this.catLink.Start();
    else if (this.actionType == XT2CAT.ActionType.StopOnEvent) this.catLink.Stop()
};
XT2CAT.ActionType = {
    None: 0,
    StartOnEvent: 1,
    StopOnEvent: 2
};
goog.require("UHT.XTLink");
var XTVariable2CATType = {
    XT_Double: 0,
    XT_Float: 1,
    XT_Int: 2,
    XT_Bool: 3,
    XT_Object: 4,
    XT_String: 5,
    None: 6
};
var XTVariable2CATActionType = {
    None: 0,
    StartOnCondition: 1,
    StopOnCondition: 2
};
XTVariable2CAT.prototype = Object.create(XTLink.prototype);
XTVariable2CAT.prototype.constructor = XTVariable2CAT;

function XTVariable2CAT() {
    XTLink.call(this);
    this.actionType = XTVariable2CATActionType.StartOnCondition;
    this.variableType = XTVariable2CATType.None;
    this.variableName = "";
    this.value = "";
    this.less = null;
    this.lessOrEquals = null;
    this.equals = null;
    this.notEquals = null;
    this.greaterOrEquals = null;
    this.greater = null;
    this.isNull = null;
    this.isNotNull = null;
    this.valueDouble = 0;
    this.valueFloat = 0;
    this.valueInt = 0;
    this.valueBool = false
}
XTVariable2CAT.prototype.XTRegisterCallbacks = function() {
    switch (this.variableType) {
        case XTVariable2CATType.XT_Bool:
            this.valueBool = _bool.Parse(this.value);
            XT.RegisterCallbackBool(this.variableName, this.CallbackBool, this);
            break;
        case XTVariable2CATType.XT_Double:
            this.valueDouble = _number.otod(this.value);
            XT.RegisterCallbackDouble(this.variableName, this.CallbackDouble, this);
            break;
        case XTVariable2CATType.XT_Float:
            this.valueFloat = _number.otod(this.value);
            XT.RegisterCallbackFloat(this.variableName, this.CallbackFloat,
                this);
            break;
        case XTVariable2CATType.XT_Int:
            this.valueInt = _number.otoi(this.value);
            XT.RegisterCallbackInt(this.variableName, this.CallbackInt, this);
            break;
        case XTVariable2CATType.XT_Object:
            XT.RegisterCallbackObject(this.variableName, this.CallbackObject, this);
            break;
        case XTVariable2CATType.XT_String:
            XT.RegisterCallbackString(this.variableName, this.CallbackString, this);
            break
    }
};
XTVariable2CAT.prototype.CallbackBool = function(param) {
    this.DoIt(this.equals, param == this.valueBool);
    this.DoIt(this.notEquals, param != this.valueBool)
};
XTVariable2CAT.prototype.CallbackObject = function(param) {
    this.DoIt(this.isNull, param == null);
    this.DoIt(this.isNotNull, param != null)
};
XTVariable2CAT.prototype.CallbackString = function(param) {
    this.DoIt(this.equals, param == this.value);
    this.DoIt(this.notEquals, param != this.value);
    this.DoIt(this.isNull, param == null);
    this.DoIt(this.isNotNull, param != null)
};
XTVariable2CAT.prototype.CallbackInt = function(param) {
    this.DoIt(this.less, param < this.valueInt);
    this.DoIt(this.lessOrEquals, param <= this.valueInt);
    this.DoIt(this.equals, param == this.valueInt);
    this.DoIt(this.notEquals, param != this.valueInt);
    this.DoIt(this.greaterOrEquals, param >= this.valueInt);
    this.DoIt(this.greater, param > this.valueInt)
};
XTVariable2CAT.prototype.CallbackFloat = function(param) {
    this.DoIt(this.less, param < this.valueFloat);
    this.DoIt(this.lessOrEquals, param <= this.valueFloat);
    this.DoIt(this.equals, param == this.valueFloat);
    this.DoIt(this.notEquals, param != this.valueFloat);
    this.DoIt(this.greaterOrEquals, param >= this.valueFloat);
    this.DoIt(this.greater, param > this.valueFloat)
};
XTVariable2CAT.prototype.CallbackDouble = function(param) {
    this.DoIt(this.less, param < this.valueDouble);
    this.DoIt(this.lessOrEquals, param <= this.valueDouble);
    this.DoIt(this.equals, param == this.valueDouble);
    this.DoIt(this.notEquals, param != this.valueDouble);
    this.DoIt(this.greaterOrEquals, param >= this.valueDouble);
    this.DoIt(this.greater, param > this.valueDouble)
};
XTVariable2CAT.prototype.DoIt = function(cat, conditionMet) {
    if (cat == null || !conditionMet) return;
    switch (this.actionType) {
        case XTVariable2CATActionType.StartOnCondition:
            cat.Start();
            break;
        case XTVariable2CATActionType.StopOnCondition:
            cat.Stop();
            break
    }
};
XTVariable2CAT.prototype.JustDoIt = function() {
    if (this.variableType == XTVariable2CATType.XT_Bool) this.CallbackBool(XT.GetBool(this.variableName));
    else if (this.variableType == XTVariable2CATType.XT_Double) this.CallbackDouble(XT.GetDouble(this.variableName));
    else if (this.variableType == XTVariable2CATType.XT_Float) this.CallbackFloat(XT.GetFloat(this.variableName));
    else if (this.variableType == XTVariable2CATType.XT_Int) this.CallbackInt(XT.GetInt(this.variableName));
    else if (this.variableType == XTVariable2CATType.XT_Object) this.CallbackObject(XT.GetObject(this.variableName));
    else if (this.variableType == XTVariable2CATType.XT_String) this.CallbackString(XT.GetString(this.variableName))
};
goog.require("UHT.XTLink");

function CustomizationWidgetColorSettings() {
    this.name = "";
    this.color = null;
    this.widgets = null
}
CustomizationWidgetColorSettings.prototype.Apply = function() {
    for (var i = 0; i < this.widgets.length; ++i) this.widgets[i].color = this.color
};

function CustomizationButtonColorsSettings() {
    this.name = "";
    this.normal = null;
    this.hover = null;
    this.pressed = null;
    this.disabled = null;
    this.buttons = null
}
CustomizationButtonColorsSettings.prototype.Apply = function() {
    for (var i = 0; i < this.buttons.length; ++i) {
        this.buttons[i].color_normal = this.normal;
        this.buttons[i].color_hover = this.hover;
        this.buttons[i].color_pressed = this.pressed;
        this.buttons[i].color_disabled = this.disabled
    }
};

function CustomizationSettings() {
    this.name = "";
    this.styleNames = null;
    this.widgetsColors = null;
    this.buttonsColors = null;
    this.cat = null
}
CustomizationSettings.prototype.Apply = function() {
    for (var i = 0; i < this.widgetsColors.length; ++i) this.widgetsColors[i].Apply();
    for (var i = 0; i < this.buttonsColors.length; ++i) this.buttonsColors[i].Apply();
    if (this.cat != null) this.cat.Start()
};
CustomizationsManager.prototype = Object.create(XTLink.prototype);
CustomizationsManager.prototype.constructor = CustomizationsManager;

function CustomizationsManager() {
    XTLink.call(this);
    this.customizations = null
}
CustomizationsManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this, 1)
};
CustomizationsManager.prototype.OnGameInit = function() {
    var customization = this.FindCustomization();
    if (customization != null) customization.Apply()
};
CustomizationsManager.prototype.FindCustomization = function() {
    for (var i = 0; i < this.customizations.length; ++i)
        if (this.customizations[i].styleNames.indexOf(ServerOptions.styleName) > -1) return this.customizations[i];
    return null
};
goog.require("UHT.XTLink");
VarDisplayer.prototype = Object.create(XTLink.prototype);
VarDisplayer.prototype.constructor = VarDisplayer;
var VarType = {
    XT_Int: 0,
    XT_Float: 1,
    XT_Double: 2,
    XT_String: 3,
    XT_GameInfo: 4
};

function VarDisplayer() {
    XTLink.call(this);
    this.type = VarType.XT_Int;
    this.variable = null;
    this.label = null;
    this.replaceWhenZero = false;
    this.replaceWhenZeroChar = ""
}
VarDisplayer.prototype.XTRegisterCallbacks = function() {
    switch (this.type) {
        case VarType.XT_Int:
            XT.RegisterCallbackInt(this.variable.name, this.OnTargetValueChangedInt, this);
            break;
        case VarType.XT_Float:
            XT.RegisterCallbackFloat(this.variable.name, this.OnTargetValueChangedFloat, this);
            break;
        case VarType.XT_Double:
            XT.RegisterCallbackDouble(this.variable.name, this.OnTargetValueChangedFloat, this);
            break;
        case VarType.XT_String:
            XT.RegisterCallbackString(this.variable.name, this.OnTargetValueChangedString, this);
            break;
        default:
            console.warn("The " + this.type + " case was not implemented.");
            break
    }
};
VarDisplayer.prototype.OnDestroy = function() {
    switch (this.type) {
        case VarType.XT_Int:
            XT.UnregisterCallbackInt(this.OnTargetValueChangedInt, this);
            break;
        case VarType.XT_Float:
            XT.UnregisterCallbackFloat(this.OnTargetValueChangedFloat, this);
            break;
        case VarType.XT_Double:
            XT.UnregisterCallbackDouble(this.OnTargetValueChangedFloat, this);
            break;
        case VarType.XT_String:
            XT.UnregisterCallbackString(this.OnTargetValueChangedString, this);
            break;
        default:
            console.warn("The " + this.type + " case was not implemented.");
            break
    }
};
VarDisplayer.prototype.OnTargetValueChangedInt = function(newVal) {
    this.label.text = this.replaceWhenZero && newVal == 0 ? this.replaceWhenZeroChar : newVal.toString()
};
VarDisplayer.prototype.OnTargetValueChangedFloat = function(newVal) {
    this.label.text = this.replaceWhenZero && newVal == 0 ? this.replaceWhenZeroChar : newVal.toString()
};
VarDisplayer.prototype.OnTargetValueChangedString = function(newVal) {
    this.label.text = newVal
};
goog.require("UHT.Engine");
var XTLinkActivatorAction = {
    None: 0,
    ActivateAll: 1,
    DeactivateAll: 2
};
XTLinkActivator.prototype = Object.create(Component.prototype);
XTLinkActivator.prototype.constructor = XTLinkActivator;

function XTLinkActivator() {
    Component.call(this);
    this.list = null;
    this.includeChildren = true;
    this.excludeArrangeables = true;
    this.awakeAction = XTLinkActivatorAction.None
}
XTLinkActivator.prototype.Activate = function(index, enabled) {
    index = _number.otoi(index);
    enabled = enabled == undefined ? true : enabled;
    var links;
    if (this.includeChildren) links = this.list[index].GetComponentsInChildren(XTLink, true);
    else links = this.list[index].GetComponents(XTLink);
    for (var i = 0; i < links.length; ++i) {
        if (this.excludeArrangeables && links[i] instanceof ArrangeableBase) continue;
        links[i].xtEnabled = enabled
    }
};
XTLinkActivator.prototype.Deactivate = function(index) {
    this.Activate(index, false)
};
XTLinkActivator.prototype.ActivateAll = function() {
    for (var i = 0; i < this.list.length; ++i) this.Activate(i, true)
};
XTLinkActivator.prototype.DeactivateAll = function() {
    for (var i = 0; i < this.list.length; ++i) this.Activate(i, false)
};
XTLinkActivator.prototype.Awake = function() {
    switch (this.awakeAction) {
        case XTLinkActivatorAction.ActivateAll:
            this.ActivateAll();
            break;
        case XTLinkActivatorAction.DeactivateAll:
            this.DeactivateAll();
            break
    }
};
goog.provide("UHT.ArrangeableBase");
goog.require("UHT.XTLink");
ArrangeableBase.prototype = Object.create(XTLink.prototype);
ArrangeableBase.prototype.constructor = ArrangeableBase;

function ArrangeableBase() {
    XTLink.call(this);
    this.useOnMobile = true;
    this.useOnDesktop = false
}
ArrangeableBase.prototype.XTRegisterCallbacks = function() {
    if (this.useOnMobile && Globals.isMobile || this.useOnDesktop && !Globals.isMobile) {
        XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayout, this.OnSwitchToLandscape, this);
        XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWide, this.OnSwitchToLandscapeWide, this);
        XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWideFull, this.OnSwitchToLandscapeWideFull, this);
        if (this.useOnMobile && Globals.isMobile) {
            XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayout,
                this.OnSwitchToPortrait, this);
            XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPhone, this.OnSwitchToPortraitIPhone, this);
            XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPad, this.OnSwitchToPortraitIPad, this)
        }
    }
};
ArrangeableBase.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnSwitchToLandscape, this);
    XT.UnregisterCallbackEvent(this.OnSwitchToLandscapeWide, this);
    XT.UnregisterCallbackEvent(this.OnSwitchToPortrait, this);
    XT.UnregisterCallbackEvent(this.OnSwitchToPortraitIPhone, this);
    XT.UnregisterCallbackEvent(this.OnSwitchToPortraitIPad, this)
};
ArrangeableBase.prototype.OnSwitchToPortrait = function() {};
ArrangeableBase.prototype.OnSwitchToLandscape = function() {};
ArrangeableBase.prototype.OnSwitchToLandscapeWide = function() {
    this.OnSwitchToLandscape()
};
ArrangeableBase.prototype.OnSwitchToLandscapeWideFull = function() {
    this.OnSwitchToLandscapeWide()
};
ArrangeableBase.prototype.OnSwitchToPortraitIPhone = function() {
    this.OnSwitchToPortrait()
};
ArrangeableBase.prototype.OnSwitchToPortraitIPad = function() {
    this.OnSwitchToPortraitIPhone()
};
goog.require("UHT.ArrangeableBase");
ArrangeableActive.prototype = Object.create(ArrangeableBase.prototype);
ArrangeableActive.prototype.constructor = ArrangeableActive;

function ArrangeableActive() {
    ArrangeableBase.call(this);
    this.activeInLandscape = false;
    this.activeInPortrait = false
}
ArrangeableActive.prototype.OnSwitchToPortrait = function() {
    this.gameObject.SetActive(this.activeInPortrait)
};
ArrangeableActive.prototype.OnSwitchToLandscape = function() {
    this.gameObject.SetActive(this.activeInLandscape)
};
goog.require("UHT.ArrangeableBase");
ArrangeableActiveComplex.prototype = Object.create(ArrangeableBase.prototype);
ArrangeableActiveComplex.prototype.constructor = ArrangeableActiveComplex;

function ArrangeableActiveComplex() {
    ArrangeableBase.call(this);
    this.activeInLandscape = false;
    this.activeInLandscapeWide = false;
    this.activeInLandscapeWideFull = false;
    this.activeInPortrait = false;
    this.activeInPortraitIPhone = false;
    this.activeInPortraitIPad = false
}
ArrangeableActiveComplex.prototype.OnSwitchToLandscape = function() {
    this.gameObject.SetActive(this.activeInLandscape)
};
ArrangeableActiveComplex.prototype.OnSwitchToLandscapeWide = function() {
    this.gameObject.SetActive(this.activeInLandscapeWide)
};
ArrangeableActiveComplex.prototype.OnSwitchToLandscapeWideFull = function() {
    this.gameObject.SetActive(this.activeInLandscapeWideFull)
};
ArrangeableActiveComplex.prototype.OnSwitchToPortrait = function() {
    this.gameObject.SetActive(this.activeInPortrait)
};
ArrangeableActiveComplex.prototype.OnSwitchToPortraitIPhone = function() {
    this.gameObject.SetActive(this.activeInPortraitIPhone)
};
ArrangeableActiveComplex.prototype.OnSwitchToPortraitIPad = function() {
    this.gameObject.SetActive(this.activeInPortraitIPad)
};
goog.require("UHT.ArrangeableBase");
ArrangeableLayer.prototype = Object.create(ArrangeableBase.prototype);
ArrangeableLayer.prototype.constructor = ArrangeableLayer;

function ArrangeableLayer() {
    ArrangeableBase.call(this);
    this.layerLandscape = null;
    this.layerPortrait = null;
    this.objects = null
}
ArrangeableLayer.prototype.OnSwitchToPortrait = function() {
    for (var i = 0; i < this.objects.length; ++i) Globals.SetLayerRecursively(this.objects[i], this.layerPortrait.value())
};
ArrangeableLayer.prototype.OnSwitchToLandscape = function() {
    for (var i = 0; i < this.objects.length; ++i) Globals.SetLayerRecursively(this.objects[i], this.layerLandscape.value())
};
goog.require("UHT.ArrangeableBase");
ArrangeableMLAnchor.prototype = Object.create(ArrangeableBase.prototype);
ArrangeableMLAnchor.prototype.constructor = ArrangeableMLAnchor;

function ArrangeableMLAnchor() {
    ArrangeableBase.call(this);
    this.anchors = null;
    this.maxWidthLandscape = 0;
    this.separateForLandscapeWide = false;
    this.maxWidthLandscapeWide = 0;
    this.separateForLandscapeWideFull = false;
    this.maxWidthLandscapeWideFull = 0;
    this.maxWidthPortrait = 0;
    this.separateForIPhone = false;
    this.maxWidthIPhonePortrait = 0;
    this.separateForIPad = false;
    this.maxWidthIPadPortrait = 0
}
ArrangeableMLAnchor.prototype.OnSwitchToPortrait = function() {
    this.OnLayoutChanged(this.maxWidthPortrait)
};
ArrangeableMLAnchor.prototype.OnSwitchToPortraitIPhone = function() {
    if (this.separateForIPhone) this.OnLayoutChanged(this.maxWidthIPhonePortrait);
    else this.OnSwitchToPortrait()
};
ArrangeableMLAnchor.prototype.OnSwitchToPortraitIPad = function() {
    if (this.separateForIPad) this.OnLayoutChanged(this.maxWidthIPadPortrait);
    else this.OnSwitchToPortraitIPhone()
};
ArrangeableMLAnchor.prototype.OnSwitchToLandscape = function() {
    this.OnLayoutChanged(this.maxWidthLandscape)
};
ArrangeableMLAnchor.prototype.OnSwitchToLandscapeWide = function() {
    if (this.separateForLandscapeWide) this.OnLayoutChanged(this.maxWidthLandscapeWide);
    else this.OnSwitchToLandscape()
};
ArrangeableMLAnchor.prototype.OnSwitchToLandscapeWideFull = function() {
    if (this.separateForLandscapeWideFull) this.OnLayoutChanged(this.maxWidthLandscapeWideFull);
    else this.OnSwitchToLandscapeWide()
};
ArrangeableMLAnchor.prototype.OnLayoutChanged = function(maxWidth) {
    for (var i = 0; i < this.anchors.length; ++i) {
        this.anchors[i].maxWidth = maxWidth;
        this.anchors[i].ForceNextUpdate()
    }
};
goog.require("UHT.ArrangeableBase");
ArrangeableTransform.prototype = Object.create(ArrangeableBase.prototype);
ArrangeableTransform.prototype.constructor = ArrangeableTransform;

function ArrangeableTransform() {
    ArrangeableBase.call(this);
    this.localPositionLandscape = null;
    this.localScaleLandscape = null;
    this.separateForLandscapeWide = false;
    this.localPositionLandscapeWide = null;
    this.localScaleLandscapeWide = null;
    this.separateForLandscapeWideFull = false;
    this.localPositionLandscapeWideFull = null;
    this.localScaleLandscapeWideFull = null;
    this.localPositionPortrait = null;
    this.localScalePortrait = null;
    this.separateForIPhone = false;
    this.localPositionIPhonePortrait = null;
    this.localScaleIPhonePortrait =
        null;
    this.separateForIPad = false;
    this.localPositionIPadPortrait = null;
    this.localScaleIPadPortrait = null
}
ArrangeableTransform.prototype.OnSwitchToPortrait = function() {
    this.gameObject.transform.localPosition(this.localPositionPortrait);
    this.gameObject.transform.localScale(this.localScalePortrait)
};
ArrangeableTransform.prototype.OnSwitchToPortraitIPhone = function() {
    if (this.separateForIPhone) {
        this.gameObject.transform.localPosition(this.localPositionIPhonePortrait);
        this.gameObject.transform.localScale(this.localScaleIPhonePortrait)
    } else this.OnSwitchToPortrait()
};
ArrangeableTransform.prototype.OnSwitchToPortraitIPad = function() {
    if (this.separateForIPad) {
        this.gameObject.transform.localPosition(this.localPositionIPadPortrait);
        this.gameObject.transform.localScale(this.localScaleIPadPortrait)
    } else this.OnSwitchToPortraitIPhone()
};
ArrangeableTransform.prototype.OnSwitchToLandscape = function() {
    this.gameObject.transform.localPosition(this.localPositionLandscape);
    this.gameObject.transform.localScale(this.localScaleLandscape)
};
ArrangeableTransform.prototype.OnSwitchToLandscapeWide = function() {
    if (this.separateForLandscapeWide) {
        this.gameObject.transform.localPosition(this.localPositionLandscapeWide);
        this.gameObject.transform.localScale(this.localScaleLandscapeWide)
    } else this.OnSwitchToLandscape()
};
ArrangeableTransform.prototype.OnSwitchToLandscapeWideFull = function() {
    if (this.separateForLandscapeWideFull) {
        this.gameObject.transform.localPosition(this.localPositionLandscapeWideFull);
        this.gameObject.transform.localScale(this.localScaleLandscapeWideFull)
    } else this.OnSwitchToLandscapeWide()
};
goog.require("UHT.ArrangeableBase");
ArrangeableTransformV2.prototype = Object.create(ArrangeableBase.prototype);
ArrangeableTransformV2.prototype.constructor = ArrangeableTransformV2;

function ArrangeableTransformV2() {
    ArrangeableBase.call(this);
    this.localPositionLandscape = null;
    this.localRotationLandscape = null;
    this.localScaleLandscape = null;
    this.separateForLandscapeWide = false;
    this.localPositionLandscapeWide = null;
    this.localRotationLandscapeWide = null;
    this.localScaleLandscapeWide = null;
    this.separateForLandscapeWideFull = false;
    this.localPositionLandscapeWideFull = null;
    this.localRotationLandscapeWideFull = null;
    this.localScaleLandscapeWideFull = null;
    this.localPositionPortrait = null;
    this.localRotationPortrait =
        null;
    this.localScalePortrait = null;
    this.separateForIPhone = false;
    this.localPositionIPhonePortrait = null;
    this.localRotationIPhonePortrait = null;
    this.localScaleIPhonePortrait = null;
    this.separateForIPad = false;
    this.localPositionIPadPortrait = null;
    this.localRotationIPadPortrait = null;
    this.localScaleIPadPortrait = null;
    this.applyPosition = false;
    this.applyRotation = false;
    this.applyScale = false
}
ArrangeableTransformV2.prototype.OnSwitchToPortrait = function() {
    this.OnLayoutChanged(this.localPositionPortrait, this.localScalePortrait, this.localRotationPortrait)
};
ArrangeableTransformV2.prototype.OnSwitchToPortraitIPhone = function() {
    if (this.separateForIPhone) this.OnLayoutChanged(this.localPositionIPhonePortrait, this.localScaleIPhonePortrait, this.localRotationIPhonePortrait);
    else this.OnSwitchToPortrait()
};
ArrangeableTransformV2.prototype.OnSwitchToPortraitIPad = function() {
    if (this.separateForIPad) this.OnLayoutChanged(this.localPositionIPadPortrait, this.localScaleIPadPortrait, this.localRotationIPadPortrait);
    else this.OnSwitchToPortraitIPhone()
};
ArrangeableTransformV2.prototype.OnSwitchToLandscape = function() {
    this.OnLayoutChanged(this.localPositionLandscape, this.localScaleLandscape, this.localRotationLandscape)
};
ArrangeableTransformV2.prototype.OnSwitchToLandscapeWide = function() {
    if (this.separateForLandscapeWide) this.OnLayoutChanged(this.localPositionLandscapeWide, this.localScaleLandscapeWide, this.localRotationLandscapeWide);
    else this.OnSwitchToLandscape()
};
ArrangeableTransformV2.prototype.OnSwitchToLandscapeWideFull = function() {
    if (this.separateForLandscapeWideFull) this.OnLayoutChanged(this.localPositionLandscapeWideFull, this.localScaleLandscapeWideFull, this.localRotationLandscapeWideFull);
    else this.OnSwitchToLandscapeWide()
};
ArrangeableTransformV2.prototype.OnLayoutChanged = function(position, scale, rotation) {
    if (this.applyPosition) this.gameObject.transform.localPosition(position);
    if (this.applyRotation) this.gameObject.transform.localRotation(UHTMath.Quaternion.euler(rotation));
    if (this.applyScale) this.gameObject.transform.localScale(scale)
};
goog.require("UHT.ArrangeableBase");
ArrangeableUIRoot.prototype = Object.create(ArrangeableBase.prototype);
ArrangeableUIRoot.prototype.constructor = ArrangeableUIRoot;

function ArrangeableUIRoot() {
    ArrangeableBase.call(this);
    this.manualWidthLandscape = 1444;
    this.manualHeightLandscape = 999;
    this.manualWidthPortrait = 1444;
    this.manualHeightPortrait = 2567
}
ArrangeableUIRoot.prototype.OnSwitchToPortrait = function() {
    var uiRoot = this.GetComponent(UIRoot);
    uiRoot.manualWidth = this.manualWidthPortrait;
    uiRoot.manualHeight = this.manualHeightPortrait
};
ArrangeableUIRoot.prototype.OnSwitchToLandscape = function() {
    var uiRoot = this.GetComponent(UIRoot);
    uiRoot.manualWidth = this.manualWidthLandscape;
    uiRoot.manualHeight = this.manualHeightLandscape
};
goog.require("UHT.XTLink");
goog.provide("UHT.LayoutManager");
LayoutManager.prototype = Object.create(XTLink.prototype);
LayoutManager.prototype.constructor = LayoutManager;

function LayoutManager() {
    XTLink.call(this);
    this.curWidth = -1;
    this.curHeight = -1;
    this.curMode = LayoutManager.Mode.Invalid;
    this.isInit = false;
    this.LandscapeWideRatio = 1.57;
    this.LandscapeWideFullRatio = 1.77;
    this.PortraitIPhoneRatio = .59;
    this.PortraitIPadRatio = .74;
    this.isMobile = true;
    this.isMini = false
}
LayoutManager.Mode = {
    Invalid: 0,
    Landscape: 1,
    Portrait: 2,
    LandscapeWide: 3,
    PortraitIPhone: 4,
    PortraitIPad: 5,
    LandscapeWideFull: 6
};
LayoutManager.layoutMode = LayoutManager.Mode.Invalid;
LayoutManager.I = null;
LayoutManager.prototype.XTRegisterCallbacks = function() {
    LayoutManager.I = this;
    this.isInit = true
};
var BT_ORIENTATION_InitialSent = false;
var BT_ORIENTATION_lastTime = 0;
var BT_ORIENTATION_timers = [0, 0];
var BT_ORIENTATION_currentMode;
var BT_OrientationUpdateTimers = function() {
    var cTime = (new Date).getTime();
    BT_ORIENTATION_timers[BT_ORIENTATION_currentMode] += cTime - BT_ORIENTATION_lastTime;
    BT_ORIENTATION_lastTime = cTime
};
var BT_OrientationSendTimers = function() {
    BT_OrientationUpdateTimers();
    if (BT_ORIENTATION_timers[0] != 0) {
        globalTracking.SendEvent("uht_behaviour", "ORIENTATION_MOBILE_time_landscape", BT_ORIENTATION_timers[0], "BehaviourTracker");
        BT_ORIENTATION_timers[0] = 0
    }
    if (BT_ORIENTATION_timers[1] != 0) {
        globalTracking.SendEvent("uht_behaviour", "ORIENTATION_MOBILE_time_portrait", BT_ORIENTATION_timers[1], "BehaviourTracker");
        BT_ORIENTATION_timers[1] = 0
    }
};
var BT_OrientationSwitched = function(mode) {
    BT_OrientationUpdateTimers();
    BT_ORIENTATION_currentMode = mode
};
LayoutManager.prototype.Awake = function() {
    XTLink.prototype.Awake.call(this);
    Globals.isMobile = this.isMobile;
    Globals.isMini = this.isMini
};
LayoutManager.prototype.Update = function() {
    if (this.isInit && (UHTScreen.width != this.curWidth || UHTScreen.height != this.curHeight)) {
        this.curWidth = UHTScreen.width;
        this.curHeight = UHTScreen.height;
        var c = null;
        var s = null;
        var i = 0;
        var ratio = UHTScreen.width / UHTScreen.height;
        if (this.isMini) {
            if (this.curMode != LayoutManager.Mode.Landscape) {
                console.log("-- LayoutManager - switched to Landscape!");
                this.curMode = LayoutManager.Mode.Landscape;
                XT.TriggerEvent(LMVars.Evt_Internal_SwitchToLandscapeLayout)
            }
        } else if (this.isMobile)
            if (this.curWidth >=
                this.curHeight && ratio < this.LandscapeWideRatio && this.curMode != LayoutManager.Mode.Landscape) {
                console.log("-- LayoutManager - switched to Landscape!");
                this.curMode = LayoutManager.Mode.Landscape;
                XT.TriggerEvent(LMVars.Evt_Internal_SwitchToLandscapeLayout)
            } else if (this.curWidth >= this.curHeight && ratio >= this.LandscapeWideRatio && ratio < this.LandscapeWideFullRatio && this.curMode != LayoutManager.Mode.LandscapeWide) {
            console.log("-- LayoutManager - switched to Landscape Wide!");
            this.curMode = LayoutManager.Mode.LandscapeWide;
            XT.TriggerEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWide)
        } else if (this.curWidth >= this.curHeight && ratio >= this.LandscapeWideFullRatio && this.curMode != LayoutManager.Mode.LandscapeWideFull) {
            console.log("-- LayoutManager - switched to Landscape Wide Full!");
            this.curMode = LayoutManager.Mode.LandscapeWideFull;
            XT.TriggerEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWideFull)
        } else if (this.curWidth < this.curHeight && ratio < this.PortraitIPhoneRatio && this.curMode != LayoutManager.Mode.Portrait) {
            console.log("-- LayoutManager - switched to Portrait!");
            this.curMode = LayoutManager.Mode.Portrait;
            XT.TriggerEvent(LMVars.Evt_Internal_SwitchToPortraitLayout)
        } else if (this.curWidth < this.curHeight && ratio >= this.PortraitIPhoneRatio && ratio < this.PortraitIPadRatio && this.curMode != LayoutManager.Mode.PortraitIPhone) {
            console.log("-- LayoutManager - switched to Portrait IPhone!");
            this.curMode = LayoutManager.Mode.PortraitIPhone;
            XT.TriggerEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPhone)
        } else {
            if (this.curWidth < this.curHeight && ratio >= this.PortraitIPadRatio && this.curMode !=
                LayoutManager.Mode.PortraitIPad) {
                console.log("-- LayoutManager - switched to Portrait IPad!");
                this.curMode = LayoutManager.Mode.PortraitIPad;
                XT.TriggerEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPad)
            }
        } else if (ratio < this.LandscapeWideRatio && this.curMode != LayoutManager.Mode.Landscape) {
            console.log("-- LayoutManager - switched to Landscape!");
            this.curMode = LayoutManager.Mode.Landscape;
            XT.TriggerEvent(LMVars.Evt_Internal_SwitchToLandscapeLayout)
        } else if (ratio >= this.LandscapeWideRatio && ratio < this.LandscapeWideFullRatio &&
            this.curMode != LayoutManager.Mode.LandscapeWide) {
            console.log("-- LayoutManager - switched to Landscape Wide!");
            this.curMode = LayoutManager.Mode.LandscapeWide;
            XT.TriggerEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWide)
        } else if (ratio >= this.LandscapeWideFullRatio && this.curMode != LayoutManager.Mode.LandscapeWideFull) {
            console.log("-- LayoutManager - switched to Landscape Wide Full!");
            this.curMode = LayoutManager.Mode.LandscapeWideFull;
            XT.TriggerEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWideFull)
        }
        LayoutManager.layoutMode =
            this.curMode;
        if (UHT_DEVICE_TYPE.DESKTOP == false)
            if (!BT_ORIENTATION_InitialSent) {
                if (this.curMode == LayoutManager.Mode.Landscape || this.curMode == LayoutManager.Mode.LandscapeWide) globalTracking.SendEvent("uht_behaviour", "ORIENTATION_MOBILE_initial_landscape", 1, "BehaviourTracker");
                else globalTracking.SendEvent("uht_behaviour", "ORIENTATION_MOBILE_initial_portrait", 1, "BehaviourTracker");
                BT_ORIENTATION_InitialSent = true;
                BT_ORIENTATION_lastTime = (new Date).getTime();
                BT_ORIENTATION_currentMode = this.curMode - 1;
                setInterval(BT_OrientationSendTimers,
                    3E5)
            } else BT_OrientationSwitched(this.curMode - 1)
    }
};
LayoutManager.GetLayoutMode = function() {
    return LayoutManager.I.curMode
};
LayoutManager.GetLayoutType = function() {
    var Mode = LayoutManager.Mode;
    switch (LayoutManager.I.curMode) {
        case Mode.Portrait:
        case Mode.PortraitIPad:
        case Mode.PortraitIPhone:
            return Mode.Portrait
    }
    return Mode.Landscape
};
goog.require("UHT.LayoutManager");
goog.require("UHT.ArrangeableBase");
ArrangeableCameraSettings.prototype = Object.create(ArrangeableBase.prototype);
ArrangeableCameraSettings.prototype.constructor = ArrangeableCameraSettings;

function ArrangeableCameraSettings() {
    ArrangeableBase.call(this);
    this._extraCameraSettings = null;
    this._landscapeClipUp = -1;
    this._landscapeClipDown = -1;
    this._landscapeClipLeft = -1;
    this._landscapeClipRight = -1;
    this._portraitClipUp = -1;
    this._portraitClipDown = -1;
    this._portraitClipLeft = -1;
    this._portraitClipRight = -1;
    this.separateForIPhone = false;
    this._portraitIPhoneClipUp = -1;
    this._portraitIPhoneClipDown = -1;
    this._portraitIPhoneClipLeft = -1;
    this._portraitIPhoneClipRight = -1;
    this.separateForIPad = false;
    this._portraitIPadClipUp = -1;
    this._portraitIPadClipDown = -1;
    this._portraitIPadClipLeft = -1;
    this._portraitIPadClipRight = -1;
    this.separateForLandscapeWide = false;
    this._landscapeWideClipUp = -1;
    this._landscapeWideClipDown = -1;
    this._landscapeWideClipLeft = -1;
    this._landscapeWideClipRight = -1;
    this.separateForLandscapeWideFull = false;
    this._landscapeWideFullClipUp = -1;
    this._landscapeWideFullClipDown = -1;
    this._landscapeWideFullClipLeft = -1;
    this._landscapeWideFullClipRight = -1;
    this.curMode = LayoutManager.Mode.Invalid
}
ArrangeableCameraSettings.prototype.extraCameraSettings = null;
ArrangeableCameraSettings.prototype.landscapeClipUp = -1;
ArrangeableCameraSettings.prototype.landscapeClipDown = -1;
ArrangeableCameraSettings.prototype.landscapeClipLeft = -1;
ArrangeableCameraSettings.prototype.landscapeClipRight = -1;
ArrangeableCameraSettings.prototype.portraitClipUp = -1;
ArrangeableCameraSettings.prototype.portraitClipDown = -1;
ArrangeableCameraSettings.prototype.portraitClipLeft = -1;
ArrangeableCameraSettings.prototype.portraitClipRight = -1;
ArrangeableCameraSettings.prototype.portraitIPhoneClipUp = -1;
ArrangeableCameraSettings.prototype.portraitIPhoneClipDown = -1;
ArrangeableCameraSettings.prototype.portraitIPhoneClipLeft = -1;
ArrangeableCameraSettings.prototype.portraitIPhoneClipRight = -1;
ArrangeableCameraSettings.prototype.portraitIPadClipUp = -1;
ArrangeableCameraSettings.prototype.portraitIPadClipDown = -1;
ArrangeableCameraSettings.prototype.portraitIPadClipLeft = -1;
ArrangeableCameraSettings.prototype.portraitIPadClipRight = -1;
ArrangeableCameraSettings.prototype.landscapeWideClipUp = -1;
ArrangeableCameraSettings.prototype.landscapeWideClipDown = -1;
ArrangeableCameraSettings.prototype.landscapeWideClipLeft = -1;
ArrangeableCameraSettings.prototype.landscapeWideClipRight = -1;
ArrangeableCameraSettings.prototype.landscapeWideFullClipUp = -1;
ArrangeableCameraSettings.prototype.landscapeWideFullClipDown = -1;
ArrangeableCameraSettings.prototype.landscapeWideFullClipLeft = -1;
ArrangeableCameraSettings.prototype.landscapeWideFullClipRight = -1;
Object.defineProperties(ArrangeableCameraSettings.prototype, {
    extraCameraSettings: {
        get: function() {
            if (this._extraCameraSettings == null) this._extraCameraSettings = this.GetComponent(ExtraCameraSettings);
            return this._extraCameraSettings
        },
        set: function(value) {
            this._extraCameraSettings = value
        }
    },
    landscapeClipUp: {
        get: function() {
            return this._landscapeClipUp
        },
        set: function(value) {
            this._landscapeClipUp = value;
            if (this.curMode == LayoutManager.Mode.Landscape) this.extraCameraSettings.clipUp = this._landscapeClipUp
        }
    },
    landscapeClipDown: {
        get: function() {
            return this._landscapeClipDown
        },
        set: function(value) {
            this._landscapeClipDown = value;
            if (this.curMode == LayoutManager.Mode.Landscape) this.extraCameraSettings.clipDown = this._landscapeClipDown
        }
    },
    landscapeClipLeft: {
        get: function() {
            return this._landscapeClipLeft
        },
        set: function(value) {
            this._landscapeClipLeft = value;
            if (this.curMode == LayoutManager.Mode.Landscape) this.extraCameraSettings.clipLeft = this._landscapeClipLeft
        }
    },
    landscapeClipRight: {
        get: function() {
            return this._landscapeClipRight
        },
        set: function(value) {
            this._landscapeClipRight = value;
            if (this.curMode ==
                LayoutManager.Mode.Landscape) this.extraCameraSettings.clipRight = this._landscapeClipRight
        }
    },
    portraitClipUp: {
        get: function() {
            return this._portraitClipUp
        },
        set: function(value) {
            this._portraitClipUp = value;
            if (this.curMode == LayoutManager.Mode.Portrait) this.extraCameraSettings.clipUp = this._portraitClipUp
        }
    },
    portraitClipDown: {
        get: function() {
            return this._portraitClipDown
        },
        set: function(value) {
            this._portraitClipDown = value;
            if (this.curMode == LayoutManager.Mode.Portrait) this.extraCameraSettings.clipDown = this._portraitClipDown
        }
    },
    portraitClipLeft: {
        get: function() {
            return this._portraitClipLeft
        },
        set: function(value) {
            this._portraitClipLeft = value;
            if (this.curMode == LayoutManager.Mode.Portrait) this.extraCameraSettings.clipLeft = this._portraitClipLeft
        }
    },
    portraitClipRight: {
        get: function() {
            return this._portraitClipRight
        },
        set: function(value) {
            this._portraitClipRight = value;
            if (this.curMode == LayoutManager.Mode.Portrait) this.extraCameraSettings.clipRight = this._portraitClipRight
        }
    },
    portraitIPhoneClipUp: {
        get: function() {
            return this._portraitIPhoneClipUp
        },
        set: function(value) {
            this._portraitIPhoneClipUp = value;
            if (this.curMode == LayoutManager.Mode.PortraitIPhone) this.extraCameraSettings.clipUp = this._portraitIPhoneClipUp
        }
    },
    portraitIPhoneClipDown: {
        get: function() {
            return this._portraitIPhoneClipDown
        },
        set: function(value) {
            this._portraitIPhoneClipDown = value;
            if (this.curMode == LayoutManager.Mode.PortraitIPhone) this.extraCameraSettings.clipDown = this._portraitIPhoneClipDown
        }
    },
    portraitIPhoneClipLeft: {
        get: function() {
            return this._portraitIPhoneClipLeft
        },
        set: function(value) {
            this._portraitIPhoneClipLeft =
                value;
            if (this.curMode == LayoutManager.Mode.PortraitIPhone) this.extraCameraSettings.clipLeft = this._portraitIPhoneClipLeft
        }
    },
    portraitIPhoneClipRight: {
        get: function() {
            return this._portraitIPhoneClipRight
        },
        set: function(value) {
            this._portraitIPhoneClipRight = value;
            if (this.curMode == LayoutManager.Mode.PortraitIPhone) this.extraCameraSettings.clipRight = this._portraitIPhoneClipRight
        }
    },
    portraitIPadClipUp: {
        get: function() {
            return this._portraitIPadClipUp
        },
        set: function(value) {
            this._portraitIPadClipUp = value;
            if (this.curMode ==
                LayoutManager.Mode.PortraitIPad) this.extraCameraSettings.clipUp = this._portraitIPadClipUp
        }
    },
    portraitIPadClipDown: {
        get: function() {
            return this._portraitIPadClipDown
        },
        set: function(value) {
            this._portraitIPadClipDown = value;
            if (this.curMode == LayoutManager.Mode.PortraitIPad) this.extraCameraSettings.clipDown = this._portraitIPadClipDown
        }
    },
    portraitIPadClipLeft: {
        get: function() {
            return this._portraitIPadClipLeft
        },
        set: function(value) {
            this._portraitIPadClipLeft = value;
            if (this.curMode == LayoutManager.Mode.PortraitIPad) this.extraCameraSettings.clipLeft =
                this._portraitIPadClipLeft
        }
    },
    portraitIPadClipRight: {
        get: function() {
            return this._portraitIPadClipRight
        },
        set: function(value) {
            this._portraitIPadClipRight = value;
            if (this.curMode == LayoutManager.Mode.PortraitIPad) this.extraCameraSettings.clipRight = this._portraitIPadClipRight
        }
    },
    landscapeWideClipUp: {
        get: function() {
            return this._landscapeWideClipUp
        },
        set: function(value) {
            this._landscapeWideClipUp = value;
            if (this.curMode == LayoutManager.Mode.LandscapeWide) this.extraCameraSettings.clipUp = this._landscapeWideClipUp
        }
    },
    landscapeWideClipDown: {
        get: function() {
            return this._landscapeWideClipDown
        },
        set: function(value) {
            this._landscapeWideClipDown = value;
            if (this.curMode == LayoutManager.Mode.LandscapeWide) this.extraCameraSettings.clipDown = this._landscapeWideClipDown
        }
    },
    landscapeWideClipLeft: {
        get: function() {
            return this._landscapeWideClipLeft
        },
        set: function(value) {
            this._landscapeWideClipLeft = value;
            if (this.curMode == LayoutManager.Mode.LandscapeWide) this.extraCameraSettings.clipLeft = this._landscapeWideClipLeft
        }
    },
    landscapeWideClipRight: {
        get: function() {
            return this._landscapeWideClipRight
        },
        set: function(value) {
            this._landscapeWideClipRight = value;
            if (this.curMode == LayoutManager.Mode.LandscapeWide) this.extraCameraSettings.clipRight = this._landscapeWideClipRight
        }
    },
    landscapeWideFullClipUp: {
        get: function() {
            return this._landscapeWideFullClipUp
        },
        set: function(value) {
            this._landscapeWideFullClipUp = value;
            if (this.curMode == LayoutManager.Mode.LandscapeWideFull) this.extraCameraSettings.clipUp = this._landscapeWideFullClipUp
        }
    },
    landscapeWideFullClipDown: {
        get: function() {
            return this._landscapeWideFullClipDown
        },
        set: function(value) {
            this._landscapeWideFullClipDown = value;
            if (this.curMode == LayoutManager.Mode.LandscapeWideFull) this.extraCameraSettings.clipDown = this._landscapeWideFullClipDown
        }
    },
    landscapeWideFullClipLeft: {
        get: function() {
            return this._landscapeWideFullClipLeft
        },
        set: function(value) {
            this._landscapeWideFullClipLeft = value;
            if (this.curMode == LayoutManager.Mode.LandscapeWideFull) this.extraCameraSettings.clipLeft = this._landscapeWideFullClipLeft
        }
    },
    landscapeWideFullClipRight: {
        get: function() {
            return this._landscapeWideFullClipRight
        },
        set: function(value) {
            this._landscapeWideFullClipRight = value;
            if (this.curMode == LayoutManager.Mode.LandscapeWideFull) this.extraCameraSettings.clipRight = this._landscapeWideFullClipRight
        }
    }
});
ArrangeableCameraSettings.prototype.OnSwitchToPortrait = function() {
    this.OnLayoutChanged(LayoutManager.Mode.Portrait, this.portraitClipUp, this.portraitClipDown, this.portraitClipLeft, this.portraitClipRight)
};
ArrangeableCameraSettings.prototype.OnSwitchToPortraitIPhone = function() {
    if (this.separateForIPhone) this.OnLayoutChanged(LayoutManager.Mode.PortraitIPhone, this.portraitIPhoneClipUp, this.portraitIPhoneClipDown, this.portraitIPhoneClipLeft, this.portraitIPhoneClipRight);
    else this.OnSwitchToPortrait()
};
ArrangeableCameraSettings.prototype.OnSwitchToPortraitIPad = function() {
    if (this.separateForIPad) this.OnLayoutChanged(LayoutManager.Mode.PortraitIPad, this.portraitIPadClipUp, this.portraitIPadClipDown, this.portraitIPadClipLeft, this.portraitIPadClipRight);
    else this.OnSwitchToPortraitIPhone()
};
ArrangeableCameraSettings.prototype.OnSwitchToLandscape = function() {
    this.OnLayoutChanged(LayoutManager.Mode.Landscape, this.landscapeClipUp, this.landscapeClipDown, this.landscapeClipLeft, this.landscapeClipRight)
};
ArrangeableCameraSettings.prototype.OnSwitchToLandscapeWide = function() {
    if (this.separateForLandscapeWide) this.OnLayoutChanged(LayoutManager.Mode.LandscapeWide, this.landscapeWideClipUp, this.landscapeWideClipDown, this.landscapeWideClipLeft, this.landscapeWideClipRight);
    else this.OnSwitchToLandscape()
};
ArrangeableCameraSettings.prototype.OnSwitchToLandscapeWideFull = function() {
    if (this.separateForLandscapeWideFull) this.OnLayoutChanged(LayoutManager.Mode.LandscapeWideFull, this.landscapeWideFullClipUp, this.landscapeWideFullClipDown, this.landscapeWideFullClipLeft, this.landscapeWideFullClipRight);
    else this.OnSwitchToLandscapeWide()
};
ArrangeableCameraSettings.prototype.OnLayoutChanged = function(mode, clipUp, clipDown, clipLeft, clipRight) {
    this.curMode = mode;
    this.extraCameraSettings.clipUp = clipUp;
    this.extraCameraSettings.clipDown = clipDown;
    this.extraCameraSettings.clipLeft = clipLeft;
    this.extraCameraSettings.clipRight = clipRight
};
goog.provide("UHT.LobbyCategories");
goog.require("UHT.XTLink");
LobbyCategories.prototype = Object.create(XTLink.prototype);
LobbyCategories.prototype.constructor = LobbyCategories;

function LobbyCategories() {
    XTLink.call(this);
    this.featuredCategories = null;
    this.featuredGames = null;
    this.categories = null;
    this.localizedSymbols = null;
    this.maxWidth = 0;
    this.padding = 0;
    this.arrangeFeaturedGamesIfLessThan = null;
    this.featuredGamesArrangers = null;
    this.searchInput = null;
    this.noResultsFoundLabel = null;
    this.featuredContent = null;
    this.searchContent = null;
    this.categorySymbols = null;
    this.categoriesData = null;
    this.cachedfeaturedCategory = null;
    this.lastUpdatedCategorySymbol = ""
}
LobbyCategories.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(LobbyVars.FeaturedLobbyCategory, this.OnFeaturedCategory, this);
    XT.RegisterCallbackObject(LobbyVars.LobbyCategorySymbols, this.OnCategorySymbols, this);
    XT.RegisterCallbackInt(LobbyVars.LobbyCategoryIndex, this.OnLobbyCategoryIndex, this)
};
LobbyCategories.prototype.OnFeaturedCategory = function(param) {
    var category = param;
    if (category == null) return;
    if (this.cachedfeaturedCategory == null) this.cachedfeaturedCategory = category;
    if (this.lastUpdatedCategorySymbol != category.symbol)
        for (var i = 0; i < this.featuredCategories.length; ++i) this.featuredCategories[i].UpdateCategory(this.FindLocalizedSymbol(category.symbol));
    this.lastUpdatedCategorySymbol = category.symbol;
    for (var i = 0; i < this.featuredGames.length; ++i) this.featuredGames[i].SetValues([].concat(category.games));
    for (var i = 0; i < this.arrangeFeaturedGamesIfLessThan.length; ++i) this.featuredGamesArrangers[i].Sample(category.games.length / this.arrangeFeaturedGamesIfLessThan[i]);
    if (category.symbol == "searchresults") {
        if (this.featuredContent != null) this.featuredContent.SetActive(false);
        if (this.searchContent != null) this.searchContent.SetActive(true)
    } else {
        if (this.featuredContent != null) this.featuredContent.SetActive(true);
        if (this.searchContent != null) this.searchContent.SetActive(false)
    }
};
LobbyCategories.prototype.OnCategorySymbols = function(param) {
    this.categorySymbols = param;
    this.categoriesData = XT.GetObject(LobbyVars.LobbyCategories);
    if (this.categorySymbols == null) return;
    this.UpdateCategories()
};
LobbyCategories.prototype.UpdateCategories = function() {};
LobbyCategories.prototype.OnLobbyCategoryIndex = function(index) {
    for (var i = 0; i < this.categories.length; ++i) this.categories[i].SetSelected(i == index)
};
LobbyCategories.prototype.FindLocalizedSymbol = function(name) {
    for (var i = 0; i < this.localizedSymbols.length; ++i)
        if (this.localizedSymbols[i].gameObject.name == name) return this.localizedSymbols[i];
    return null
};
LobbyCategories.prototype.SearchGames = function(gameName) {
    var categories = XT.GetObject(LobbyVars.LobbyCategories);
    if (categories == null) return;
    var searchList = null;
    for (var i = 0; i < categories.length; i++)
        if (categories[i] != null && categories[i].symbol == "allgames") {
            searchList = new LobbyCategory(categories[i]);
            searchList.symbol = "searchresults";
            searchList.games = categories[i].games;
            break
        }
    if (searchList == null)
        for (var i = 0; i < categories.length; i++)
            if (categories[i] != null) {
                searchList = new LobbyCategory(categories[i]);
                searchList.symbol =
                    "searchresults";
                searchList.games = categories[i].games;
                break
            }
    if (searchList == null) return;
    var results = [];
    if (gameName != "") {
        results = searchList.games.filter(function(e) {
            return this.SmartSearch(e, gameName)
        }.bind(this));
        if (results.length == 0) this.noResultsFoundLabel.SetActive(true);
        else this.noResultsFoundLabel.SetActive(false)
    }
    searchList.games = results;
    XT.SetObject(LobbyVars.FeaturedLobbyCategory, searchList)
};
LobbyCategories.prototype.ChangeBackToFeatured = function() {
    this.searchInput.Reset();
    this.noResultsFoundLabel.SetActive(false);
    XT.SetObject(LobbyVars.FeaturedLobbyCategory, this.cachedfeaturedCategory)
};
LobbyCategories.prototype.UpdateSearchResults = function() {
    this.SearchGames(this.searchInput.value)
};
LobbyCategories.prototype.SmartSearch = function(lobbyGame, gameName) {
    var found = true;
    var words = gameName.split(" ");
    for (var i = 0; i < words.length; i++)
        if (lobbyGame.name.toLowerCase().indexOf(words[i].toLowerCase()) == -1) {
            found = false;
            break
        }
    return found
};
goog.require("UHT.LobbyCategories");
LobbyCategoriesDesktop.prototype = Object.create(LobbyCategories.prototype);
LobbyCategoriesDesktop.prototype.constructor = LobbyCategoriesDesktop;

function LobbyCategoriesDesktop() {
    LobbyCategories.call(this);
    this.allGamesMinWidth = 0
}
LobbyCategoriesDesktop.prototype.UpdateCategories = function() {
    var allGamesIdx = this.categorySymbols.indexOf(LobbyCategorySymbol.AllGames);
    var allGamesWidth = 0;
    var allGamesMLAnchor = this.FindLocalizedSymbol(LobbyCategorySymbol.AllGames);
    if (allGamesIdx > -1) allGamesWidth = Math.max(allGamesMLAnchor.width, this.allGamesMinWidth);
    var categoryWidth = this.maxWidth - allGamesWidth;
    if (this.categorySymbols.length > 1) categoryWidth /= this.categorySymbols.length - 1;
    var textWidth = Math.round(categoryWidth - this.padding);
    var lastSymbol =
        this.categorySymbols[this.categorySymbols.length - 1];
    var categoryX = 0;
    for (var i = 0; i < this.categoriesData.length; ++i)
        if (this.categoriesData[i] == null) this.categories[i].UpdateButton(null, 0, 0, false);
        else {
            var width = Math.round(this.categoriesData[i].symbol == LobbyCategorySymbol.AllGames ? allGamesWidth : categoryWidth);
            var isLast = this.categoriesData[i].symbol == lastSymbol;
            this.categories[i].UpdateButton(this.FindLocalizedSymbol(this.categoriesData[i].symbol), width, textWidth, isLast);
            categoryX += width * .5;
            this.categories[i].transform.localPosition(new UHTMath.Vector3(categoryX,
                0, 0));
            categoryX += width * .5
        }
    for (var i = this.categoriesData.length; i < this.categories.length; ++i) this.categories[i].UpdateButton(null, 0, 0, false)
};
goog.require("UHT.XTLink");
LobbyCategoriesManager.prototype = Object.create(XTLink.prototype);
LobbyCategoriesManager.prototype.constructor = LobbyCategoriesManager;

function LobbyCategoriesManager() {
    XTLink.call(this);
    this.catEnable = null;
    this.catShow = null;
    this.catHide = null;
    this.scrollableListLandscape = null;
    this.scrollableListPortrait = null;
    this.categoriesData = null;
    this.categoryIndex = 0;
    this.indicesLandscape = null;
    this.indicesPortrait = null;
    this.scrollLandscape = null;
    this.scrollPortrait = null;
    this.isEnabled = false;
    this.isVisible = false
}
LobbyCategoriesManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(LobbyVars.LobbyCategories, this.OnCategoriesChanged, this);
    XT.RegisterCallbackInt(LobbyVars.LobbyCategoryIndex, this.OnCategoryIndexChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ChangeVSGameState, this.OnVSGameStateChanged, this);
    XT.RegisterCallbackEvent(LobbyVars.Evt_DataToCode_ShowLobbyCategories, this.OnShowCategories, this);
    XT.RegisterCallbackEvent(LobbyVars.Evt_DataToCode_HideLobbyCategories, this.OnHideCategories,
        this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_CodeToData_InterfaceWindowOpen, this.OnHideCategories, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_DataToCode_CloseAllInterfaceWindows, this.OnHideCategories, this)
};
LobbyCategoriesManager.prototype.OnVSGameStateChanged = function() {
    if (!this.isEnabled) return;
    var state = VSGameStateManager.GetState();
    if (state == VSGameState.Spin || state == VSGameState.SpinBonusRounds) this.catHide.Start()
};
LobbyCategoriesManager.prototype.OnCategoriesChanged = function(param) {
    this.categoriesData = param;
    this.OnCategoryIndexChanged(XT.GetInt(LobbyVars.LobbyCategoryIndex))
};
LobbyCategoriesManager.prototype.OnCategoryIndexChanged = function(index) {
    if (this.categoriesData == null) return;
    if (!this.isEnabled) {
        this.catEnable.Start();
        this.isEnabled = true;
        this.indicesLandscape = [];
        this.indicesPortrait = [];
        this.scrollLandscape = [];
        this.scrollPortrait = [];
        for (var i = 0; i < this.categoriesData.length; ++i) {
            this.indicesLandscape.push(0);
            this.indicesPortrait.push(0);
            this.scrollLandscape.push(0);
            this.scrollPortrait.push(0)
        }
    } else {
        this.indicesLandscape[this.categoryIndex] = this.scrollableListLandscape.items[0].valueIdx;
        this.scrollLandscape[this.categoryIndex] = this.scrollableListLandscape.scrollRemain;
        if (this.scrollableListPortrait != null) {
            this.indicesPortrait[this.categoryIndex] = this.scrollableListPortrait.items[0].valueIdx;
            this.scrollPortrait[this.categoryIndex] = this.scrollableListPortrait.scrollRemain
        }
    }
    this.scrollableListLandscape.SetValues(this.categoriesData[index].listLandscape.slice());
    this.scrollableListLandscape.scrollRemain = this.scrollLandscape[index];
    this.scrollableListLandscape.UpdateValuesAndIndex(null,
        this.indicesLandscape[index], true);
    if (this.scrollableListPortrait != null) {
        this.scrollableListPortrait.SetValues(this.categoriesData[index].listPortrait.slice());
        this.scrollableListPortrait.scrollRemain = this.scrollPortrait[index];
        this.scrollableListPortrait.UpdateValuesAndIndex(null, this.indicesPortrait[index], true)
    }
    this.categoryIndex = index
};
LobbyCategoriesManager.prototype.OnShowCategories = function() {
    if (!this.isVisible) {
        XT.TriggerEvent(InterfaceVars.Evt_CodeToData_InterfaceWindowOpen);
        this.catShow.Start();
        this.isVisible = true;
        XT.TriggerEvent(LobbyVars.Evt_Internal_LobbyCategoriesOpen)
    }
};
LobbyCategoriesManager.prototype.OnHideCategories = function() {
    if (this.isVisible) {
        this.catHide.Start();
        this.isVisible = false;
        XT.TriggerEvent(LobbyVars.Evt_Internal_LobbyCategoriesClosed)
    }
};
goog.require("UHT.LobbyCategories");
LobbyCategoriesMobile.prototype = Object.create(LobbyCategories.prototype);
LobbyCategoriesMobile.prototype.constructor = LobbyCategoriesMobile;

function LobbyCategoriesMobile() {
    LobbyCategories.call(this);
    this.selectedCategory = null;
    this.selectButton = null;
    this.selectMinWidth = 0;
    this.animator = null;
    this.categorySize = null;
    this.categoryMargin = null;
    this.categoriesPerLine = 1;
    this.categoriesArranger = null;
    this.selectedCategoryWidth = 0;
    this.selectedCategoryTextWidth = 0
}
LobbyCategoriesMobile.prototype.XTRegisterCallbacks = function() {
    LobbyCategories.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackInt(LobbyVars.LobbyCategoryIndexUnconfirmed, this.OnLobbyCategoryIndexUnconfirmed, this);
    XT.RegisterCallbackEvent(LobbyVars.Evt_DataToCode_ConfirmLobbyCategoryIndex, this.ConfirmLobbyCategory, this);
    XT.RegisterCallbackEvent(LobbyVars.Evt_DataToCode_UnconfirmLobbyCategoryIndex, this.UnconfirmLobbyCategory, this)
};
LobbyCategoriesMobile.prototype.ConfirmLobbyCategory = function() {
    var idx = XT.GetInt(LobbyVars.LobbyCategoryIndex);
    var idxUnc = XT.GetInt(LobbyVars.LobbyCategoryIndexUnconfirmed);
    if (idx != idxUnc) XT.SetInt(LobbyVars.LobbyCategoryIndex, idxUnc)
};
LobbyCategoriesMobile.prototype.UnconfirmLobbyCategory = function() {
    var idx = XT.GetInt(LobbyVars.LobbyCategoryIndex);
    var idxUnc = XT.GetInt(LobbyVars.LobbyCategoryIndexUnconfirmed);
    if (idx != idxUnc) XT.SetInt(LobbyVars.LobbyCategoryIndexUnconfirmed, idx)
};
LobbyCategoriesMobile.prototype.UpdateCategories = function() {
    this.ArrangeCategories();
    this.ArrangeSelectedCategory()
};
LobbyCategoriesMobile.prototype.ArrangeSelectedCategory = function() {
    var selectWidth = 0;
    if (this.categorySymbols.length > 1) {
        var selectSymbol = this.FindLocalizedSymbol(this.selectButton.gameObject.name);
        selectWidth = Math.max(selectSymbol.width, this.selectMinWidth);
        this.selectButton.UpdateButton(selectSymbol, selectWidth, Math.round(selectWidth - this.padding), false)
    } else this.selectButton.UpdateButton(null, 0, 0, false);
    this.selectedCategoryWidth = Math.round(this.maxWidth - selectWidth);
    this.selectedCategoryTextWidth =
        Math.round(this.selectedCategoryWidth - this.padding);
    this.UpdateSelectedCategory(XT.GetInt(LobbyVars.LobbyCategoryIndex));
    var categoryX = this.selectedCategoryWidth * .5;
    this.selectedCategory.transform.localPosition(new UHTMath.Vector3(categoryX, 0, 0));
    categoryX += (this.selectedCategoryWidth + selectWidth) * .5;
    this.selectButton.transform.localPosition(new UHTMath.Vector3(categoryX, 0, 0))
};
LobbyCategoriesMobile.prototype.ArrangeCategories = function() {
    var textWidth = Math.round(this.categorySize.x - this.padding);
    var catIdx = 0;
    var groupIdx = 0;
    var groups = [];
    for (var i = 0; i < this.categoriesData.length; ++i)
        if (this.categoriesData[i] == null) this.categories[i].UpdateButton(null, 0, 0, false);
        else {
            if (catIdx % this.categoriesPerLine == 0) groups.push([]);
            this.categories[i].UpdateButton(this.FindLocalizedSymbol(this.categoriesData[i].symbol), Math.round(this.categorySize.x), textWidth, false);
            groups[groupIdx].push(this.categories[i]);
            if (++catIdx % this.categoriesPerLine == 0) groupIdx++
        }
    var groupY = 0;
    var catWidth = this.categorySize.x + this.categoryMargin.x;
    var catWidthHalf = catWidth * .5;
    for (var i = 0; i < groups.length; ++i) {
        var catX = 0;
        var groupX = (this.categoriesPerLine - groups[i].length) * catWidthHalf;
        for (var j = 0; j < groups[i].length; ++j) {
            groups[i][j].transform.localPosition(new UHTMath.Vector3(catX + groupX, groupY, 0));
            catX += catWidth
        }
        groupY -= this.categorySize.y + this.categoryMargin.y
    }
    this.categoriesArranger.Sample(groups.length / Math.ceil(this.categories.length /
        this.categoriesPerLine))
};
LobbyCategoriesMobile.prototype.OnLobbyCategoryIndex = function(index) {
    LobbyCategories.prototype.OnLobbyCategoryIndex.call(this, index);
    this.UpdateSelectedCategory(index)
};
LobbyCategoriesMobile.prototype.OnLobbyCategoryIndexUnconfirmed = function(index) {
    LobbyCategories.prototype.OnLobbyCategoryIndex.call(this, index)
};
LobbyCategoriesMobile.prototype.UpdateSelectedCategory = function(index) {
    if (this.categoriesData == null) return;
    this.selectedCategory.UpdateButton(this.FindLocalizedSymbol(this.categoriesData[index].symbol), this.selectedCategoryWidth, this.selectedCategoryTextWidth, false)
};
goog.provide("UHT.LobbyConnection");
goog.require("UHT.XTLink");
var LobbyVendorType = {
    Undefined: -1,
    Slots: 0,
    LiveCasino: 1
};
var LobbyVendors = {
    Slots: "SLOTS",
    LiveCasino: "LC"
};
var LobbyVendorTypeConverter = {};
LobbyVendorTypeConverter.types = [LobbyVendors.Slots, LobbyVendors.LiveCasino];
LobbyVendorTypeConverter.Convert = function(type) {
    var idx = LobbyVendorTypeConverter.types.indexOf(type);
    return idx > -1 ? idx : LobbyVendorType.Undefined
};

function LobbyGame(game) {
    this.name = "";
    this.nameLower = "";
    this.symbol = "";
    this.vendorType = LobbyVendorType.Undefined;
    this.casinoId = "";
    this.id = "";
    this.launchURL = "";
    this.atlas = null;
    this.uid = "";
    this.promoKeys = null;
    this.displayStyle = TournamentProtocol.DisplayStyle.Default;
    this.displayStyles = null;
    if (game != undefined) {
        this.name = game.name;
        this.symbol = game.symbol;
        this.vendorType = game.vendorType;
        this.casinoId = game.casinoId;
        this.id = game.id;
        this.uid = game.uid;
        this.launchURL = game.launchURL;
        this.promoKeys = game.promoKeys;
        this.displayStyle = game.displayStyle;
        if (game.displayStyles != null) this.displayStyles = game.displayStyles.slice()
    }
}
var LobbyCategorySymbol = {
    Hot: "hot",
    New: "new",
    Popular: "popular",
    Exclusive: "exclusive",
    All: "all",
    AllGames: "allgames"
};

function LobbyCategory(category) {
    this.name = "";
    this.symbol = "";
    this.games = null;
    this.receivedGames = null;
    this.searchGames = null;
    this.searchGameSymbols = null;
    this.listLandscape = null;
    this.listPortrait = null;
    this.featured = null;
    this.receivedCategories = null;
    this.categories = null;
    this.categoryIndex = -1;
    this.subcategoryIndex = 0;
    this.subcategoriesIndex = -1;
    this.isSubcategory = false;
    this.hasGames = false;
    if (category != undefined) {
        this.name = category.name;
        this.symbol = category.symbol;
        this.categoryIndex = category.categoryIndex;
        this.subcategoryIndex = category.subcategoryIndex;
        this.subcategoriesIndex = category.subcategoriesIndex;
        this.isSubcategory = category.isSubcategory;
        this.hasGames = category.hasGames;
        if (category.games != null) {
            this.games = [];
            for (var i = 0; i < category.games.length; ++i) this.games.push(new LobbyGame(category.games[i]))
        }
        if (category.categories != null) {
            this.categories = [];
            for (var i = 0; i < category.categories.length; ++i) this.categories.push(new LobbyCategory(category.categories[i]))
        }
    }
}
var LobbyVars = {
    LobbyCategories: "LobbyCategories",
    LobbyCategoryIndex: "LobbyCategoryIndex",
    LobbySubcategoryIndex: "LobbySubcategoryIndex",
    LobbyCategorySymbols: "LobbyCategorySymbols",
    FeaturedLobbyCategory: "FeaturedLobbyCategory",
    LobbyCategoryIndexUnconfirmed: "LobbyCategoryIndexUnconfirmed",
    Evt_DataToCode_ConfirmLobbyCategoryIndex: "Evt_DataToCode_ConfirmLobbyCategoryIndex",
    Evt_DataToCode_UnconfirmLobbyCategoryIndex: "Evt_DataToCode_UnconfirmLobbyCategoryIndex",
    Evt_Internal_LobbyGameButton_ConfirmationButtonChanged: "Evt_Internal_LobbyGameButton_ConfirmationButtonChanged",
    Evt_DataToCode_ShowLobbyCategories: "Evt_DataToCode_ShowLobbyCategories",
    Evt_DataToCode_HideLobbyCategories: "Evt_DataToCode_HideLobbyCategories",
    Evt_Internal_LobbyCategoriesOpen: "Evt_Internal_LobbyCategoriesOpen",
    Evt_Internal_LobbyCategoriesClosed: "Evt_Internal_LobbyCategoriesClosed"
};
var LobbyAPIVersion = {
    Undefined: 0,
    V1: 0,
    V2: 1
};
LobbyConnection.prototype = Object.create(XTLink.prototype);
LobbyConnection.prototype.constructor = LobbyConnection;

function LobbyConnection() {
    XTLink.call(this);
    this.gamesPerLineLandscape = 0;
    this.gamesPerLinePortrait = 0;
    this.textureSuffix = "";
    this.featuredTextureSuffix = "";
    this.deactivateXTLinks = null;
    this.urlQuery = "";
    this.categoriesURL;
    this.gameLaunchURL = "";
    this.gameIconsURL = "";
    this.categories = null;
    this.categoriesOrder = ["New", "Hot", "Popular"];
    this.featuredCategory = null;
    this.featuredCategoriesOrder = [LobbyCategorySymbol.Hot, LobbyCategorySymbol.New, LobbyCategorySymbol.Popular, LobbyCategorySymbol.Exclusive, LobbyCategorySymbol.All];
    this.texturesBySuffix = null;
    this.texturesToLoadCount = 0;
    this.texturesLoaded = false;
    this.errorMessage = "";
    this.retryCount = 0;
    this.isMultiLobby = false;
    this.promoResponse = null;
    this.langPrefix = "";
    this.updateLangPrefix = true
}
LobbyConnection.APIVersion = LobbyAPIVersion.Undefined;
LobbyConnection.TextureData = function() {
    this.url = "";
    this.texture = null
};
LobbyConnection.Keys = {
    categoriesURL: "ingameLobbyApiURL",
    gameLaunchURL: "gameLaunchURL",
    gameIconsURL: "gameIconsURL",
    lobbyCategories: "lobbyCategories",
    categorySymbol: "categorySymbol",
    categoryName: "categoryName",
    lobbyGames: "lobbyGames",
    name: "name",
    symbol: "symbol",
    activePromos: "activePromos",
    promoKeys: "promoKeys",
    multiProductMiniLobby: "multiProductMiniLobby"
};
LobbyConnection.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_InitReceived, this.OnInitReceived, this)
};
LobbyConnection.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(LobbyVars.LobbyCategories, null);
    XT.SetObject(LobbyVars.LobbyCategorySymbols, null);
    XT.SetInt(LobbyVars.LobbyCategoryIndex, 0);
    XT.SetInt(LobbyVars.LobbySubcategoryIndex, 0);
    XT.SetInt(LobbyVars.LobbyCategoryIndexUnconfirmed, 0);
    XT.SetObject(LobbyVars.FeaturedLobbyCategory, null)
};
LobbyConnection.SentGAvailable = false;
LobbyConnection.prototype.OnInitReceived = function() {
    if (UHT_GAME_CONFIG_SRC == null) return;
    var Keys = LobbyConnection.Keys;
    var categoriesURL = UHT_GAME_CONFIG_SRC[Keys.categoriesURL];
    if (categoriesURL == undefined) return;
    if (UHT_GAME_CONFIG_SRC[Keys.multiProductMiniLobby] != undefined) this.isMultiLobby = _bool.Parse(UHT_GAME_CONFIG_SRC[Keys.multiProductMiniLobby]);
    this.texturesBySuffix = {};
    this.urlQuery = GameProtocolDictionary.mgckey + "=" + ServerOptions.mgckey;
    this.categoriesURL = categoriesURL + "?" + this.urlQuery;
    if (!LobbyConnection.SentGAvailable)
        if (this.isMultiLobby) globalTracking.SendEvent("uht_behaviour",
            "MultiLobby_available", Time.time | 0, "BehaviourTracker");
        else globalTracking.SendEvent("uht_behaviour", "Lobby_available", Time.time | 0, "BehaviourTracker");
    LobbyConnection.SentGAvailable = true;
    if (this.isMultiLobby) {
        this.deactivateXTLinks.Start();
        return
    }
    LobbyConnection.APIVersion = categoriesURL.indexOf("minilobby") > -1 ? LobbyAPIVersion.V2 : LobbyAPIVersion.V1;
    this.errorMessage = "LobbyAPI Parsing Error " + (LobbyConnection.APIVersion == LobbyAPIVersion.V2 ? "(minilobby/games)" : "(lobby/game/list)");
    this.LoadCategories()
};
LobbyConnection.prototype.LoadCategories = function() {
    if (this.categoriesURL.indexOf("lobby/game/list") > -1) LobbyConnection.APIVersion = LobbyAPIVersion.V1;
    else if (this.categoriesURL.indexOf("/minilobby/games") > -1) LobbyConnection.APIVersion = LobbyAPIVersion.V2;
    var req = new ServerRequest;
    req.Url = this.categoriesURL;
    req.Handler = new EventHandler(this, this.OnCategoriesLoaded);
    req.Method = "GET";
    RequestManager.AddRequest(req)
};
LobbyConnection.prototype.OnCategoriesLoaded = function(param, statusCode) {
    if (statusCode != 200 && this.retryCount++ < 5) {
        this.LoadCategories();
        return
    }
    var dict;
    try {
        dict = JSON.parse(param)
    } catch (e) {
        console.error(e.message);
        return
    }
    var response = TournamentProtocol.TournamentParser.ParseResponse(dict);
    if (response == null || response.error != TournamentProtocol.ErrorCode.None) {
        console.error(this.errorMessage);
        return
    }
    var Keys = LobbyConnection.Keys;
    if (dict[Keys.gameLaunchURL] == undefined || dict[Keys.gameIconsURL] == undefined ||
        dict[Keys.lobbyCategories] == undefined) {
        console.error(this.errorMessage);
        return
    }
    this.gameLaunchURL = String(dict[Keys.gameLaunchURL]);
    this.gameLaunchURL += (this.gameLaunchURL.indexOf("?") > -1 ? "&" : "?") + this.urlQuery + "&gameSymbol=";
    this.gameIconsURL = String(dict[Keys.gameIconsURL]);
    if (this.gameIconsURL[this.gameIconsURL.length - 1] != "/") this.gameIconsURL += "/";
    if (dict[Keys.activePromos] != undefined) this.promoResponse = TournamentProtocol.TournamentParser.ParseOnlyTournamentsResponse(response, dict[Keys.activePromos]);
    var categories = this.categories = this.ParseCategories(dict[Keys.lobbyCategories]);
    if (categories == null) return;
    if (categories.length > 1) {
        var allGames = [];
        var allGameSymbols = [];
        var categoryAll = this.FindCategory(LobbyCategorySymbol.All);
        if (categoryAll != null) {
            this.FindUniqueGames(categoryAll, allGames, allGameSymbols);
            categories.splice(categories.indexOf(categoryAll), 1)
        }
        for (var i = 0; i < categories.length; ++i) this.FindUniqueGames(categories[i], allGames, allGameSymbols);
        while (categories.length < this.featuredCategoriesOrder.length) categories.push(null);
        categoryAll = new LobbyCategory;
        categoryAll.symbol = LobbyCategorySymbol.AllGames;
        categoryAll.games = allGames;
        categories.push(categoryAll)
    }
    for (var i = 0; i < this.featuredCategoriesOrder.length; ++i) {
        var category = this.FindCategory(this.featuredCategoriesOrder[i]);
        if (category == null) continue;
        this.featuredCategory = new LobbyCategory(category);
        this.AddTextures(this.featuredTextureSuffix, this.featuredCategory);
        break
    }
    this.LoadTextures()
};
LobbyConnection.prototype.ParseCategories = function(list) {
    if (list == null) {
        console.error(this.errorMessage);
        return null
    }
    var Keys = LobbyConnection.Keys;
    var APIVersion = LobbyConnection.APIVersion;
    var count = APIVersion == LobbyAPIVersion.V2 ? list.length : this.categoriesOrder.length;
    var ret = new Array(count);
    for (var i = 0; i < count; ++i) {
        var dict = list[i];
        if (dict == null || dict[Keys.categorySymbol] == undefined || dict[Keys.lobbyGames] == undefined) {
            console.error(this.errorMessage);
            continue
        }
        var category = new LobbyCategory;
        category.symbol =
            String(dict[Keys.categorySymbol]);
        category.games = this.ParseGames(dict[Keys.lobbyGames]);
        category.name = APIVersion == LobbyAPIVersion.V2 ? String(dict[Keys.categoryName]) : category.symbol;
        this.AddTextures(this.textureSuffix, category);
        var idx = APIVersion == LobbyAPIVersion.V2 ? i : this.categoriesOrder.indexOf(category.name);
        if (idx > -1) ret[idx] = category
    }
    return ret
};
LobbyConnection.prototype.ParseGames = function(list) {
    if (list == null) {
        console.error(this.errorMessage);
        return null
    }
    var Keys = LobbyConnection.Keys;
    var ret = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null || dict[Keys.name] == undefined || dict[Keys.symbol] == undefined) {
            console.error(this.errorMessage);
            continue
        }
        var game = new LobbyGame;
        game.name = String(dict[Keys.name]);
        game.symbol = game.uid = String(dict[Keys.symbol]);
        game.launchURL = this.gameLaunchURL + game.symbol;
        if (dict[Keys.promoKeys] != undefined) {
            game.promoKeys =
                TournamentProtocol.TournamentParser.ParsePromoKeys(dict[Keys.promoKeys]);
            game.displayStyle = this.GetDisplayStyle(game, true)
        }
        ret.push(game)
    }
    return ret
};
LobbyConnection.prototype.LoadTexture = function(symbol, data) {
    var image = new Image;
    image.crossOrigin = "anonymous";
    var atlas = null;
    var self = this;
    image.onload = function() {
        try {
            var spriteName = "s_" + symbol;
            var sprite = {
                borderBottom: 0,
                borderLeft: 0,
                borderRight: 0,
                borderTop: 0,
                paddingBottom: 0,
                paddingLeft: 0,
                paddingRight: 0,
                paddingTop: 0,
                width: image.width,
                height: image.height,
                x: 0,
                y: 0
            };
            atlas = new UIAtlas;
            atlas.isInit = true;
            atlas.pixiTexture = new PIXI.Texture(new PIXI.BaseTexture(image));
            atlas.spriteList[spriteName] = sprite;
            atlas.cachedSprites[symbol] = sprite;
            atlas.cachedSpriteNames[symbol] = spriteName
        } catch (e) {
            atlas = null;
            console.error("Failed to load texture for " + symbol + ". Error: " + e.message)
        }
        data.texture = atlas;
        self.OnTextureLoaded()
    };
    image.onerror = function() {
        console.error("Failed to load texture for " + symbol);
        data.texture = atlas;
        self.OnTextureLoaded()
    };
    image.src = data.url
};
LobbyConnection.prototype.OnTextureLoaded = function() {
    this.texturesToLoadCount--;
    this.texturesLoaded = this.texturesToLoadCount == 0
};
LobbyConnection.prototype.Update = function() {
    if (!this.texturesLoaded) return;
    this.texturesLoaded = false;
    var symbols = [];
    var textures = this.GetTextures(this.textureSuffix);
    for (var i = 0; i < this.categories.length; ++i) {
        var category = this.categories[i];
        if (category == null) continue;
        symbols.push(category.symbol);
        category.listLandscape = [];
        category.listPortrait = [];
        var listL = null;
        var listP = null;
        for (var j = 0; j < category.games.length; ++j) {
            var game = category.games[j];
            this.UpdateTexture(textures, game);
            var idxL = j % this.gamesPerLineLandscape;
            var idxP = j % this.gamesPerLinePortrait;
            if (idxL == 0) {
                if (listL != null) category.listLandscape.push(listL);
                listL = []
            }
            if (idxP == 0) {
                if (listP != null) category.listPortrait.push(listP);
                listP = []
            }
            listL.push(game);
            listP.push(game)
        }
        if (listL != null) category.listLandscape.push(listL);
        if (listP != null) category.listPortrait.push(listP)
    }
    this.UpdateTextures(this.featuredTextureSuffix, this.featuredCategory);
    XT.SetObject(LobbyVars.LobbyCategories, this.categories);
    XT.SetObject(LobbyVars.LobbyCategorySymbols, symbols);
    XT.SetObject(LobbyVars.FeaturedLobbyCategory,
        this.featuredCategory)
};
LobbyConnection.prototype.FindCategory = function(symbol, categories) {
    if (categories == undefined) categories = this.categories;
    for (var i = 0; i < categories.length; ++i)
        if (categories[i] != null && categories[i].symbol.toLowerCase() == symbol.toLowerCase()) return categories[i];
    return null
};
LobbyConnection.prototype.FindUniqueGames = function(category, list, found) {
    if (category == null || category.games == null) return;
    for (var i = 0; i < category.games.length; ++i) {
        if (found.indexOf(category.games[i].uid) > -1) continue;
        list.push(category.games[i]);
        found.push(category.games[i].uid)
    }
};
LobbyConnection.prototype.GetDisplayStyle = function(game, checkClientMode) {
    var displayStyles = game.displayStyles;
    if (displayStyles == null) displayStyles = game.displayStyles = [];
    var promoKeys = game.promoKeys;
    for (var i = 0; i < promoKeys.length; ++i) {
        var promo = this.FindPromotion(promoKeys[i].id, promoKeys[i].type);
        if (promo != null && (!checkClientMode || promo.clientMode == TournamentProtocol.ClientMode.Visible) && promo.status != TournamentProtocol.StatusCode.Closed)
            if (displayStyles.indexOf(promo.displayStyle) < 0) displayStyles.push(promo.displayStyle)
    }
    displayStyles.sort(LobbyConnection.SortDisplayStyles);
    return displayStyles.length > 0 ? displayStyles[0] : TournamentProtocol.DisplayStyle.Default
};
LobbyConnection.SortDisplayStyles = function(x, y) {
    return y - x
};
LobbyConnection.prototype.FindPromotion = function(id, type) {
    if (this.promoResponse == null) return null;
    var list = null;
    if (type == TournamentProtocol.PromoType.Race) list = this.promoResponse.races;
    else if (type == TournamentProtocol.PromoType.Tournament) list = this.promoResponse.tournaments;
    if (list != null)
        for (var i = 0; i < list.length; ++i)
            if (id == list[i].id && type == list[i].type) return list[i];
    return null
};
LobbyConnection.prototype.LoadTextures = function() {
    for (var i in this.texturesBySuffix)
        if (this.texturesBySuffix.hasOwnProperty(i))
            for (var j in this.texturesBySuffix[i])
                if (this.texturesBySuffix[i].hasOwnProperty(j)) this.LoadTexture(j, this.texturesBySuffix[i][j])
};
LobbyConnection.prototype.GetTextures = function(suffix) {
    if (!this.texturesBySuffix.hasOwnProperty(suffix)) this.texturesBySuffix[suffix] = {};
    return this.texturesBySuffix[suffix]
};
LobbyConnection.prototype.GetTexture = function(textures, symbol) {
    if (textures[symbol] != undefined) return textures[symbol];
    return null
};
LobbyConnection.prototype.AddTextures = function(suffix, category) {
    if (category == null) return;
    var games = category.games;
    if (games == null) return;
    for (var i = 0; i < games.length; ++i) this.AddTexture(suffix, games[i].uid)
};
LobbyConnection.prototype.AddTexture = function(suffix, symbol, force, forceUrl) {
    if (_string.IsNullOrEmpty(symbol)) return;
    if (this.updateLangPrefix) {
        this.updateLangPrefix = false;
        if (window["UHTLobbySeparateIcons"] != undefined)
            if (window["UHTLobbySeparateIcons"][UHT_GAME_CONFIG["LANGUAGE"]] != undefined) this.langPrefix = window["UHTLobbySeparateIcons"][UHT_GAME_CONFIG["LANGUAGE"]]
    }
    force = force == undefined ? false : force;
    forceUrl = forceUrl == undefined ? "" : forceUrl;
    var textures = this.GetTextures(suffix);
    var texture = this.GetTexture(textures,
        symbol);
    if (texture != null && !force) return;
    if (texture == null) {
        texture = new LobbyConnection.TextureData;
        textures[symbol] = texture
    }
    texture.url = force ? forceUrl : this.gameIconsURL + this.langPrefix + symbol + "/" + symbol + suffix + ".jpg";
    this.texturesToLoadCount++
};
LobbyConnection.prototype.UpdateTextures = function(suffix, category) {
    if (category == null) return;
    var games = category.games;
    if (games == null) return;
    var textures = this.GetTextures(suffix);
    for (var i = 0; i < games.length; ++i) this.UpdateTexture(textures, games[i])
};
LobbyConnection.prototype.UpdateTexture = function(textures, game) {
    var key = game.uid;
    if (textures[key] != undefined && textures[key].texture != null) game.atlas = textures[key].texture
};
goog.provide("UHT.CurrencyPatch");
goog.require("UHT.Engine");

function CurrencyProperties() {
    this.CurrencyDecimalSeparator = ".";
    this.CurrencyGroupSeparator = ",";
    this.CurrencyGroupSizes = [3];
    this.CurrencyDecimalDigits = 2;
    this.CurrencySymbol = "$";
    this.CurrencyPositivePattern = 3;
    this.CurrencyNegativePattern = 3
}

function CurrencyFontDescriptor() {
    this.id = 0;
    this.trueTypeFont = "";
    this.bitmapFont = ""
}
CurrencyPatch.prototype = Object.create(Component.prototype);
CurrencyPatch.prototype.constructor = CurrencyPatch;

function CurrencyPatch() {
    Component.call(this);
    this.currencyFile = null;
    this.languageFormatFile = null;
    this.currencyName = "USD";
    this.languageName = "en";
    this.localeName = "en";
    this.fonts = null;
    this.revisionNumber = 0;
    this.currencies = null;
    this.languageFormats = null
}
var testCurrencyPatch = false;
CurrencyPatch.prototype.Update = function() {
    if (testCurrencyPatch) {
        testCurrencyPatch = false;
        LocaleManager.Init(this)
    }
};
CurrencyPatch.prototype.InitCurrencies = function(args) {
    console.info("Initializating currency prefab with revision " + this.revisionNumber);
    this.ReadFiles();
    args.currencyInfo = this.InitCurrencyInfo(this.languageName, this.currencyName, this.localeName);
    args.jackpotCurrencyInfo = this.InitCurrencyInfo(this.languageName, "USD", this.localeName)
};
CurrencyPatch.prototype.InitCurrency = function(currencyName) {
    return this.InitCurrencyInfo(this.languageName, currencyName, this.localeName)
};
CurrencyPatch.prototype.InitCurrencyInfo = function(_languageName, _currencyName, _localeName) {
    var currencyInfo = new CurrencyProperties;
    currencyInfo.CurrencySymbol = _currencyName;
    if (this.currencies[_currencyName + "sym"] != undefined) currencyInfo.CurrencySymbol = this.currencies[_currencyName + "sym"];
    if (this.languageFormats[_localeName + "_dsep"] != undefined) this.InitLanguageFormat(currencyInfo, _localeName);
    else if (this.languageFormats[_languageName + "_dsep"] != undefined) this.InitLanguageFormat(currencyInfo, _languageName);
    return currencyInfo
};
CurrencyPatch.prototype.InitLanguageFormat = function(currencyInfo, _languageName) {
    currencyInfo.CurrencyDecimalSeparator = this.languageFormats[_languageName + "_dsep"];
    currencyInfo.CurrencyGroupSeparator = this.languageFormats[_languageName + "_gsep"];
    var groupSize = this.languageFormats[_languageName + "_gnum"];
    var groupSizes = groupSize.split(" ");
    var groupSizesList = [];
    for (var str in groupSizes) groupSizesList.push(_number.otoi(groupSizes[str]));
    currencyInfo.CurrencyGroupSizes = groupSizesList;
    currencyInfo.CurrencyDecimalDigits =
        _number.otoi(this.languageFormats[_languageName + "_dnum"]);
    currencyInfo.CurrencyPositivePattern = _number.otoi(this.languageFormats[_languageName + "_symp"]);
    currencyInfo.CurrencyNegativePattern = currencyInfo.CurrencyPositivePattern
};
CurrencyPatch.prototype.ReadFiles = function() {
    this.currencies = this.ReadFileInDictionary(this.currencyFile);
    this.languageFormats = this.ReadFileInDictionary(this.languageFormatFile)
};
CurrencyPatch.prototype.ReadFileInDictionary = function(textAsset) {
    return Object(textAsset.text)
};
goog.provide("UHT.LocaleManager");
goog.require("UHT.CurrencyPatch");

function FormatOptions() {
    this.hasCurrency = true;
    this.hasJackpotCurrency = false;
    this.hasCustomCurrency = false;
    this.hasDecimals = true;
    this.customCurrency = "";
    this.fontId = -1
}
var LocaleManager = {};
LocaleManager.currencyInfo = new CurrencyProperties;
LocaleManager.jackpotCurrencyInfo = new CurrencyProperties;
LocaleManager.patchData = null;
LocaleManager.customCurrencyInfo = {};
LocaleManager.isInit = false;
LocaleManager.decimalsAllowed = true;
LocaleManager.FormatValue = function(val, formatInfo) {
    if (formatInfo.hasCustomCurrency) return LocaleManager.FormatValueWithCustomCurrency(val, formatInfo.customCurrency);
    var ci = formatInfo.hasJackpotCurrency ? LocaleManager.jackpotCurrencyInfo : LocaleManager.currencyInfo;
    var ret = LocaleManager.InternalFormatValue(val, formatInfo.hasDecimals ? ci.CurrencyDecimalDigits : 0, formatInfo.hasDecimals ? ci.CurrencyDecimalSeparator : "", ci.CurrencyGroupSeparator);
    if (formatInfo.hasCurrency) ret = LocaleManager.FormatCurrency(ret,
        ci.CurrencySymbol, ci.CurrencyPositivePattern);
    return ret
};
LocaleManager.FormatValueWithCustomCurrency = function(val, currencyName) {
    var ci = LocaleManager.currencyInfo;
    if (LocaleManager.patchData != null) {
        if (LocaleManager.customCurrencyInfo[currencyName] == undefined) LocaleManager.customCurrencyInfo[currencyName] = LocaleManager.patchData.InitCurrency(currencyName);
        ci = LocaleManager.customCurrencyInfo[currencyName]
    }
    var ret = LocaleManager.InternalFormatValue(val, ci.CurrencyDecimalDigits, ci.CurrencyDecimalSeparator, ci.CurrencyGroupSeparator);
    ret = LocaleManager.FormatCurrency(ret,
        ci.CurrencySymbol, ci.CurrencyPositivePattern);
    return ret.replace(new RegExp(" ", "g"), "")
};
LocaleManager.FormatCurrency = function(value, symbol, pattern) {
    var ret = _number.otod(value) >= 0 ? "" : "-";
    value = value.replace("-", "");
    switch (pattern) {
        case 0:
            ret += symbol + value;
            break;
        case 1:
            ret += value + symbol;
            break;
        case 2:
            ret += symbol + " " + value;
            break;
        case 3:
            ret += value + " " + symbol;
            break;
        case 4:
            ret += value;
            break
    }
    return ret
};
LocaleManager.InternalFormatValue = function(n, c, d, t) {
    var s = n < 0 ? "-" : "";
    n = Math.abs(+n || 0);
    var aftercomma = "";
    if (!IS_UCBROWSER) n = n.toFixed(c);
    else {
        var toFixedN = n.toFixed(c);
        var rounderMul = Math.pow(10, c);
        n *= rounderMul;
        n += .5;
        n /= rounderMul;
        var tfs = n.toString().split(".");
        if (tfs.length == 1) tfs.push("");
        while (tfs[1].length < c) tfs[1] += "0";
        tfs[1] = tfs[1].slice(0, 2);
        aftercomma = c ? tfs[1] : "";
        n = tfs[0] + (c ? "." + tfs[1] : "");
        if (n != toFixedN) console.error("      WRONG COMPUTATION, should be " + n + " but it's " + toFixedN)
    }
    var i =
        parseInt(n, 10) + "";
    var j = i.length;
    j = j > 3 ? j % 3 : 0;
    if (!IS_UCBROWSER) aftercomma = Math.abs(n - i).toFixed(c).slice(2);
    return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (LocaleManager.decimalsAllowed ? d + aftercomma : "")
};
LocaleManager.ApplyFontToLabel = function(fontID, l) {};
LocaleManager.Init = function(newData) {
    LocaleManager.patchData = newData;
    if (LocaleManager.patchData != null) {
        var args = {
            currencyInfo: LocaleManager.currencyInfo,
            jackpotCurrencyInfo: LocaleManager.jackpotCurrencyInfo
        };
        LocaleManager.patchData.InitCurrencies(args);
        LocaleManager.currencyInfo = args.currencyInfo;
        LocaleManager.jackpotCurrencyInfo = args.jackpotCurrencyInfo
    }
    if (UHT_GAME_CONFIG_SRC["allowDecimals"] != undefined) LocaleManager.decimalsAllowed = UHT_GAME_CONFIG_SRC["allowDecimals"];
    LocaleManager.isInit = true;
    XT.TriggerEvent(Vars.Evt_Internal_LocaleChanged)
};
LocaleManager.GetCurrencySymbol = function() {
    return LocaleManager.currencyInfo.CurrencySymbol
};
goog.require("UHT.Engine");
LocalizationRoot.prototype = Object.create(Component.prototype);
LocalizationRoot.prototype.constructor = LocalizationRoot;

function LocalizationRoot() {
    Component.call(this)
}
goog.require("UHT.XTLink");
LocalizedLabels.prototype = Object.create(XTLink.prototype);
LocalizedLabels.prototype.constructor = LocalizedLabels;

function LocalizedLabels() {
    XTLink.call(this);
    this.localizedLabel = null;
    this.labels = null;
    this.useIncludedLanguages = false;
    this.includedLanguages = null;
    this.useExcludedLanguages = false;
    this.excludedLanguages = null;
    this.applyFontSize = false;
    this.applyText = false;
    this.capitalizeText = false;
    this.cat = null;
    this.gameInitPriority = 0
}
LocalizedLabels.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this, this.gameInitPriority)
};
LocalizedLabels.prototype.OnGameInit = function() {
    var canUpdate = true;
    if (this.useIncludedLanguages) canUpdate = this.includedLanguages.indexOf(ServerOptions.language) != -1;
    if (this.useExcludedLanguages) canUpdate = this.excludedLanguages.indexOf(ServerOptions.language) == -1;
    if (!canUpdate) return;
    for (var i = 0; i < this.labels.length; ++i) {
        if (this.applyFontSize) this.labels[i].fontSize = this.localizedLabel.fontSize;
        if (this.applyText) this.labels[i].text = this.capitalizeText ? this.localizedLabel.text.toUpperCase() : this.localizedLabel.text;
        this.labels[i].fontName = this.localizedLabel.fontName;
        this.labels[i].Prepare()
    }
    if (this.cat != null) this.cat.Start()
};
goog.require("UHT.Engine");
goog.require("UHT.ModificationsManager_XChange");
goog.require("UHTMath.Vector3");
ModificationsManager.prototype = Object.create(Component.prototype);
ModificationsManager.prototype.constructor = ModificationsManager;

function ModificationsManager() {
    Component.call(this);
    this.root = null;
    this.EditMode = false;
    this.Atlases = null;
    this.Transforms = null;
    this.Labels = null;
    this.Spines = [];
    this.revisionNumber = 0
}
ModificationsManager.Applied = false;
ModificationsManager.prototype.Start = function() {
    if (this.EditMode) this.Init()
};
ModificationsManager.prototype.Update = function() {
    if (this.EditMode) this.UpdateAllValuesFromScene()
};
ModificationsManager.prototype.OnDrawGizmos = function() {};
ModificationsManager.prototype.Init = function() {
    console.info("Initializating localization prefab with revision " + this.revisionNumber);
    this.root = Component.FindObjectOfType(LocalizationRoot).gameObject.transform;
    this.UpdatePrefabReferences();
    if (this.Atlases != null && this.Atlases.length != 0) this.ApplyAtlases();
    if (this.Labels != null && this.Labels.length != 0) this.ApplyLabels();
    if (this.Transforms != null && this.Transforms.length != 0) this.ApplyTransforms();
    if (this.Spines != null && this.Spines.length != 0) this.ApplySpines();
    if (!this.EditMode) console.warn("We're NOT in edit mode, we destroy this prefab...");
    ModificationsManager.Applied = true
};
ModificationsManager.prototype.UpdatePrefabReferences = function() {
    var i;
    for (i = 0; i < this.Transforms.length; ++i) {
        var _transform = this.Transforms[i];
        if (_transform.Target == null) _transform.Target = this.root.Find(_transform.path)
    }
    for (i = 0; i < this.Atlases.length; ++i) {
        var _atlas = this.Atlases[i];
        if (_atlas.Target == null) _atlas.Target = this.root.Find(_atlas.oldPath)
    }
    for (i = 0; i < this.Labels.length; ++i) {
        var _label = this.Labels[i];
        _label.Target = this.root.Find(_label.path)
    }
    for (i = 0; i < this.Spines.length; ++i) {
        var _spine = this.Spines[i];
        if (_spine.Target == null) _spine.Target = this.root.Find(_spine.oldPath)
    }
};
ModificationsManager.prototype.UpdateAllValuesFromScene = function() {
    var i;
    for (i = 0; i < this.Atlases.length; ++i) {
        var atlas = this.Atlases[i];
        this.UpdateAtlasValues(atlas)
    }
    for (i = 0; i < this.Transforms.length; ++i) {
        var transform = this.Transforms[i];
        this.UpdateTransformValues(transform)
    }
    for (i = 0; i < this.Labels.length; ++i) {
        var label = this.Labels[i];
        this.UpdateLabelValues(label)
    }
    for (i = 0; i < this.Spines.length; ++i) {
        var spine = this.Spines[i];
        this.UpdateSpineValues(spine)
    }
};
ModificationsManager.prototype.GetNamePath = function(target) {
    var path = target.gameObject.name;
    while (target.parent != this.root) {
        if (target.parent == null) return "";
        path = target.parent.gameObject.name + "/" + path;
        target = target.parent
    }
    return path
};
ModificationsManager.prototype.UpdateLabelValues = function(_label) {};
ModificationsManager.CopyFromLabelToLabel = function(copyFrom, copyTo, alsoCopyText, copyEffects) {
    if (alsoCopyText) copyTo.text = copyFrom.text;
    copyTo.fontName = copyFrom.fontName;
    var val = copyFrom.fontSize * copyTo.resize;
    copyTo.fontSize = Math.round(Math.max(2, val));
    copyTo.currentFontSize = copyFrom.fontSize;
    copyTo.anchorX = copyFrom.anchorX;
    copyTo.anchorY = copyFrom.anchorY;
    copyTo.overflow = copyFrom.overflow;
    copyTo.alignment = copyFrom.alignment;
    copyTo.maxLines = copyFrom.maxLines;
    copyTo.spacingY = copyFrom.spacingY * copyTo.resize;
    copyTo.mArcRadius = copyFrom.mArcRadius * copyTo.resize;
    if (copyEffects) ModificationsManager.CopyEffectsAndColors(copyFrom, copyTo);
    if (copyFrom.overflow == UILabel.Overflow.ShrinkContent || copyFrom.overflow == UILabel.Overflow.ClampContent) {
        val = copyFrom.width * copyTo.resize;
        copyTo.width = Math.round(Math.max(2, val));
        val = copyFrom.height * copyTo.resize;
        copyTo.height = Math.round(Math.max(2, val))
    } else if (copyFrom.overflow == UILabel.Overflow.ResizeHeight) {
        val = copyFrom.width * copyTo.resize;
        copyTo.width = Math.round(Math.max(2,
            val))
    }
    copyTo.wasInitCalled = false;
    copyTo.Prepare()
};
ModificationsManager.CopyEffectsAndColors = function(copyFrom, copyTo) {
    copyTo.effectStyle = copyFrom.effectStyle;
    copyTo.effectColor = copyFrom.effectColor;
    copyTo.effectWidth = copyFrom.effectWidth * copyTo.resize;
    copyTo.mBlurShadow = copyFrom.mBlurShadow;
    copyTo.mBlurShadowSize = copyFrom.mBlurShadowSize * copyTo.resize;
    copyTo.mBlurShadowOffsetX = copyFrom.mBlurShadowOffsetX * copyTo.resize;
    copyTo.mBlurShadowOffsetY = copyFrom.mBlurShadowOffsetY * copyTo.resize;
    copyTo.mBlurShadowColor = copyFrom.mBlurShadowColor;
    copyTo.mOutline =
        copyFrom.mOutline;
    copyTo.mOutlineColor = copyFrom.mOutlineColor;
    copyTo.mFillCenter = copyFrom.mFillCenter
};
ModificationsManager.prototype.UpdateTransformValues = function(_transform) {
    if (_transform.Target == null) return;
    var targetPath = this.GetNamePath(_transform.Target);
    if (targetPath != _transform.path) {
        _transform.path = targetPath;
        _transform.TransformData = [];
        _transform.TransformData.push(new TransformInfo);
        _transform.TransformData[0].SetPosition(_transform.Target.localPosition());
        _transform.TransformData[0].SetScale(_transform.Target.localScale());
        _transform.TransformData[0].SetRotation(_transform.Target.localEulerAngles().z);
        _transform.isSet = true;
        this.ApplyTransforms()
    } else {
        _transform.TransformData[0].SetPosition(_transform.Target.localPosition());
        _transform.TransformData[0].SetScale(_transform.Target.localScale());
        _transform.TransformData[0].SetRotation(_transform.Target.localEulerAngles().z)
    }
};
ModificationsManager.prototype.UpdateAtlasValues = function(_atlas) {
    if (_atlas.Target == null) return;
    var targetSprite = _atlas.Target.GetComponentsInChildren(UISprite, true);
    if (targetSprite.length == 0) {
        console.error("This transform does not contain an UISprite, you need to select another!");
        _atlas.Target = null;
        _atlas.isSet = false
    } else {
        _atlas.oldPath = this.GetNamePath(targetSprite[0].transform);
        _atlas.isSet = true;
        this.ApplyAtlases()
    }
};
ModificationsManager.prototype.UpdateSpineValues = function(_spine) {
    if (_spine.Target == null) return;
    var targetSpineController = _spine.Target.GetComponentsInChildren(SpineController, true);
    if (targetSpineController.length == 0) {
        _spine.Target = null;
        _spine.isSet = false
    } else {
        _spine.oldPath = this.GetNamePath(targetSpineController[0].transform);
        _spine.isSet = true;
        this.ApplySpines()
    }
};
ModificationsManager.prototype.ApplyLabels = function() {
    for (var i = 0; i < this.Labels.length; ++i) {
        var _label = this.Labels[i];
        _label.currentPayload = this.ChooseExtraPayload();
        if (!_label.isSet) continue;
        if (_label.Target == null) {
            console.error("Could not find target at path\n" + _label.path);
            continue
        }
        if (this.EditMode) _label.oldContent = _label.Target.GetComponent(UILabel).text;
        _label.SetValuesToLabel()
    }
};
ModificationsManager.prototype.ApplyTransforms = function() {
    for (var i = 0; i < this.Transforms.length; ++i) {
        var _transform = this.Transforms[i];
        _transform.currentPayload = this.ChooseExtraPayload();
        if (_transform.Target == null) _transform.Target = this.root.Find(_transform.path);
        if (_transform.Target != null) _transform.SetValuesToElement(this.EditMode);
        else console.error("Transform not found at path: " + _transform.path)
    }
};
ModificationsManager.prototype.ApplyAtlases = function() {
    for (var i = 0; i < this.Atlases.length; ++i) {
        var _atlas = this.Atlases[i];
        _atlas.currentPayload = this.ChooseExtraPayload();
        if (_atlas.currentPayload != -1 && _atlas.extraPayloads)
            if (_atlas.extraPayloads.length > _atlas.currentPayload && !_atlas.extraPayloads[_atlas.currentPayload] != null) _atlas.NewAtlas = _atlas.extraPayloads[_atlas.currentPayload];
        if (_atlas.NewAtlas == null) continue;
        if (!_atlas.isSet) continue;
        var targetTransform = this.root.Find(_atlas.oldPath);
        if (targetTransform ==
            null) continue;
        var targetSprite = targetTransform.GetComponent(UISprite);
        if (targetSprite == null) continue;
        var targetAtlas = targetSprite.atlas;
        var sprites = this.root.GetComponentsInChildren(UISprite, true);
        var j;
        for (j = 0; j < sprites.length; ++j) {
            var sprite = sprites[j];
            if (sprite.atlas == targetAtlas) {
                sprite.atlas = _atlas.NewAtlas;
                sprite.SetSpriteName(sprite.spriteName)
            }
        }
    }
};
ModificationsManager.prototype.ApplySpines = function() {
    for (var i = 0; i < this.Spines.length; ++i) {
        var _spine = this.Spines[i];
        if (!_spine.isSet) continue;
        var targetTransform = this.root.Find(_spine.oldPath);
        if (targetTransform == null) continue;
        var controller = targetTransform.GetComponent(SpineController);
        if (controller == null) continue;
        _spine.currentPayload = this.ChooseExtraPayload();
        if (_spine.currentPayload != -1 && _spine.extraPayloads)
            if (_spine.extraPayloads.length > _spine.currentPayload && _spine.extraPayloads[_spine.currentPayload] !=
                null) {
                _spine.NewSkeletonData = _spine.extraPayloads[_spine.currentPayload].NewSkeletonData;
                _spine.Atlases = _spine.extraPayloads[_spine.currentPayload].Atlases
            }
        if (_spine.NewSkeletonData == null) continue;
        var targetSpineData = controller.spineData;
        controller.spineData = _spine.NewSkeletonData;
        controller.spineAtlases = _spine.Atlases;
        var spineControllers = this.root.GetComponentsInChildren(SpineController, true);
        for (var j = 0; j < spineControllers.length; ++j)
            if (spineControllers[j].spineData == targetSpineData) {
                spineControllers[j].spineData =
                    _spine.NewSkeletonData;
                spineControllers[j].spineAtlases = _spine.Atlases
            }
    }
};
ModificationsManager.prototype.ChooseExtraPayload = function() {
    if (XT.GetBool(Vars.Jurisdiction_Text_DE)) return 0;
    return -1
};
goog.require("UHT.Engine");
var Modules = {};
Modules.exportPrefix = "MDL_";
Modules.exportNameByType = ["MultiLobby"];
Modules.OnDownloadMainGame = function() {
    var dict = UHT_GAME_CONFIG_SRC;
    if (dict == null) return;
    var key = LobbyConnection.Keys.multiProductMiniLobby;
    if (dict[key] == undefined || !_bool.Parse(dict[key])) Modules.UnloadModule(ModuleType.MultiLobby)
};
Modules.UnloadModule = function(type) {
    var name = Modules.exportNameByType[type];
    var filename = Modules.exportPrefix + name + ".json";
    var idx = -1;
    for (var i = 0; i < UHT_GAME_FILES.length; i++) {
        idx = UHT_GAME_FILES[i].split("?key=")[0].indexOf(filename);
        if (idx != -1) {
            idx = i;
            break
        }
    }
    if (idx < 0) {
        console.log("ModulesManager: Attempt to unload module of type " + name + ". Module type not found");
        return
    }
    UHT_GAME_SIZE -= UHT_GAME_FILES_SIZES[idx];
    UHT_GAME_FILES.splice(idx, 1);
    UHT_GAME_FILES_SIZES.splice(idx, 1)
};
Modules.LoadSounds = function(soundSizes) {
    var dict = UHT_GAME_CONFIG_SRC;
    if (dict == null) return;
    var key = LobbyConnection.Keys.multiProductMiniLobby;
    if (dict[key] != undefined && _bool.Parse(dict[key])) Modules.LoadSound(ModuleType.MultiLobby, soundSizes)
};
Modules.LoadSound = function(type, soundSizes) {
    var name = Modules.exportNameByType[type];
    var filename = Modules.exportPrefix + name + "_sounds." + SoundHelper.audioFormat;
    if (soundSizes[filename] != undefined) SoundLoader.packageList.push(filename)
};
var ModuleType = {
    Undefined: -1,
    MultiLobby: 0
};
ModulesManager.prototype = Object.create(Component.prototype);
ModulesManager.prototype.constructor = ModulesManager;

function ModulesManager() {
    Component.call(this)
}
goog.require("UHT.XTLink");
MultiLobbyCategories.prototype = Object.create(XTLink.prototype);
MultiLobbyCategories.prototype.constructor = MultiLobbyCategories;

function MultiLobbyCategories() {
    XTLink.call(this);
    this.categories = null;
    this.featuredCategories = null;
    this.featuredGames = null;
    this.arrangeFeaturedGamesIfLessOrEqual = null;
    this.featuredGamesArrangers = null;
    this.categoriesData = null;
    this.selectedCategory = null;
    this.featuredArranged = null;
    this.featuredArrangedDefPos = null
}
MultiLobbyCategories.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(LobbyVars.LobbyCategories, this.OnLobbyCategories, this);
    XT.RegisterCallbackInt(LobbyVars.LobbyCategoryIndex, this.OnLobbyCategoryIndex, this)
};
MultiLobbyCategories.prototype.OnLobbyCategories = function(param) {
    this.categoriesData = param;
    if (this.categoriesData == null) return;
    this.UpdateCategories();
    this.OnLobbyCategoryIndex(XT.GetInt(LobbyVars.LobbyCategoryIndex))
};
MultiLobbyCategories.prototype.UpdateCategories = function() {
    for (var i = 0; i < this.categories.length; ++i) this.categories[i].SetEnabled(this.categoriesData[i].hasGames)
};
MultiLobbyCategories.prototype.OnLobbyCategoryIndex = function(index) {
    for (var i = 0; i < this.categories.length; ++i) {
        var selected = i == index;
        this.categories[i].SetSelected(selected);
        if (!selected) continue;
        this.selectedCategory = this.GetCategory(i);
        if (this.selectedCategory != null) this.UpdateFeaturedCategory(this.selectedCategory.featured)
    }
};
MultiLobbyCategories.prototype.GetCategory = function(index) {
    if (this.categoriesData != null && index < this.categoriesData.length) return this.categoriesData[index];
    return null
};
MultiLobbyCategories.prototype.UpdateFeaturedCategory = function(featured) {
    if (featured == null) return;
    if (this.featuredArranged == null) {
        this.featuredArranged = [];
        this.featuredArrangedDefPos = [];
        for (var i = 0; i < this.featuredGamesArrangers.length; ++i) {
            this.featuredArranged.push(this.featuredGamesArrangers[i].target.transform);
            this.featuredArrangedDefPos.push(this.featuredArranged[i].localPosition())
        }
    }
    for (var i = 0; i < this.featuredGames.length; ++i) {
        var scroll = this.featuredGames[i];
        scroll.SetValues(featured.games.slice(),
            false);
        scroll.scrollRemain = scroll.isEnabled ? scroll.scrollRemain : 0;
        var itemsCount = scroll.items.length;
        var valuesCount = scroll.itemValues == null ? 0 : scroll.itemValues.length;
        var firstIdx = Math.max(0, scroll.items[0].valueIdx);
        if (firstIdx + itemsCount > valuesCount) firstIdx = valuesCount - itemsCount;
        scroll.UpdateValuesAndIndex(null, scroll.isEnabled ? firstIdx : 0, true)
    }
    for (var i = 0; i < this.arrangeFeaturedGamesIfLessOrEqual.length; ++i) {
        var gamesCount = featured.games.length;
        var arrangeCount = this.arrangeFeaturedGamesIfLessOrEqual[i];
        if (gamesCount <= arrangeCount) this.featuredGamesArrangers[i].Sample(gamesCount / arrangeCount);
        else this.featuredArranged[i].localPosition(this.featuredArrangedDefPos[i])
    }
};
goog.require("UHT.XTLink");
var MultiLobbyMinPageScrollLimitType = {
    Default: 0,
    Featured: 1,
    CategoryAndGames: 2,
    Games: 3,
    Search: 4
};
var MultiLobbyMaxPageScrollLimitType = {
    Default: 0,
    FeaturedNoGames: 1,
    CategoryAndGamesNoScroll: 2,
    SearchNoScroll: 3
};
var MultiLobbyGamesListType = {
    Landscape: 0,
    Portrait: 1
};
MultiLobbyCategoriesManager.prototype = Object.create(XTLink.prototype);
MultiLobbyCategoriesManager.prototype.constructor = MultiLobbyCategoriesManager;

function MultiLobbyCategoriesManager() {
    XTLink.call(this);
    this.gameListType = MultiLobbyGamesListType.Landscape;
    this.show = null;
    this.hide = null;
    this.featured = null;
    this.noFeatured = null;
    this.scrollbars = null;
    this.minPageScrollLimits = null;
    this.minPageScrollLimitTypes = null;
    this.maxPageScrollLimits = null;
    this.maxPageScrollLimitTypes = null;
    this.searchMinPageScrollLimitType = MultiLobbyMinPageScrollLimitType.Default;
    this.pageDrag = null;
    this.pageScroll = null;
    this.gamesScroll = null;
    this.featuredScroll = null;
    this.categories =
        null;
    this.categoryIdx = 0;
    this.gamesIndices = null;
    this.gamesScrolls = null;
    this.pagePositions = null;
    this.defaultMinPageScrollLimit = null;
    this.defaultMaxPageScrollLimit = null;
    this.minPageScrollLimitType = MultiLobbyMinPageScrollLimitType.Default;
    this.maxPageScrollLimitType = MultiLobbyMaxPageScrollLimitType.Default;
    this.isInit = false;
    this.isOpen = false;
    this.isSearchOpen = false
}
MultiLobbyCategoriesManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(LobbyVars.LobbyCategories, this.OnCategoriesChanged, this);
    XT.RegisterCallbackInt(LobbyVars.LobbyCategoryIndex, this.OnCategoryIndexChanged, this);
    XT.RegisterCallbackInt(LobbyVars.LobbySubcategoryIndex, this.OnSubcategoryIndexChanged, this);
    XT.RegisterCallbackEvent(MultiLobbyVars.Evt_Internal_MultiLobby_SearchUpdated, this.OnSearchUpdated, this);
    XT.RegisterCallbackEvent(MultiLobbyVars.Evt_Internal_MultiLobby_SearchClosed,
        this.OnSearchClosed, this);
    XT.RegisterCallbackEvent(LobbyVars.Evt_DataToCode_ShowLobbyCategories, this.OnShowCategories, this);
    XT.RegisterCallbackEvent(LobbyVars.Evt_DataToCode_HideLobbyCategories, this.OnHideCategories, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_CodeToData_InterfaceWindowOpen, this.OnHideCategories, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_DataToCode_CloseAllInterfaceWindows, this.OnHideCategories, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ChangeVSGameState, this.OnVSGameStateChanged,
        this)
};
MultiLobbyCategoriesManager.prototype.OnCategoriesChanged = function(param) {
    this.categories = param;
    this.OnCategoryIndexChanged(XT.GetInt(LobbyVars.LobbyCategoryIndex))
};
MultiLobbyCategoriesManager.prototype.GetCategoryWithGamesIndex = function(index) {
    for (var i = index - 1; i >= 0; --i)
        if (!this.categories[i].isSubcategory && this.categories[i].hasGames) return i;
    for (var i = index + 1; i < this.categories.length; ++i)
        if (!this.categories[i].isSubcategory && this.categories[i].hasGames) return i;
    return -1
};
MultiLobbyCategoriesManager.prototype.GetSubcategoryWithGamesIndex = function(subcats, subcatIdx) {
    for (var i = subcatIdx - 1; i >= 0; --i)
        if (subcats[i].hasGames) return i;
    for (var i = subcatIdx + 1; i < subcats.length; ++i)
        if (subcats[i].hasGames) return i;
    return -1
};
MultiLobbyCategoriesManager.prototype.OnCategoryIndexChanged = function(index) {
    if (this.categories == null) return;
    if (!this.isInit) {
        this.isInit = true;
        this.pageDrag = this.scrollbars.pageDrag;
        this.pageScroll = this.scrollbars.pageScrollbar;
        this.gamesScroll = this.scrollbars.gamesScrollbar;
        this.featuredScroll = this.scrollbars.featuredScrollbar;
        this.defaultMinPageScrollLimit = this.pageScroll.simpleLocalPositionLimitMin;
        this.defaultMaxPageScrollLimit = this.pageScroll.simpleLocalPositionLimitMax;
        this.gamesScrolls = [];
        this.gamesIndices = [];
        this.pagePositions = [];
        for (var i = 0; i < this.categories.length; ++i) {
            this.gamesScrolls.push(0);
            this.gamesIndices.push(0);
            this.pagePositions.push(this.GetMinPageScrollLimit(this.categories[i], false))
        }
    } else this.SaveScrolls();
    var category = this.categories[index];
    if (!category.hasGames) {
        var idx = this.GetCategoryWithGamesIndex(index);
        if (idx > -1) XT.SetInt(LobbyVars.LobbyCategoryIndex, idx);
        return
    }
    if (category.subcategoriesIndex > -1) {
        var subcats = category.categories;
        var subcatIdx = category.subcategoryIndex;
        index = category.subcategoriesIndex + subcatIdx;
        category = this.categories[index];
        if (!category.hasGames) {
            var idx = this.GetSubcategoryWithGamesIndex(subcats, subcatIdx);
            if (idx > -1) XT.SetInt(LobbyVars.LobbySubcategoryIndex, idx);
            return
        }
    }
    this.categoryIdx = index;
    this.UpdateCategory(category, false)
};
MultiLobbyCategoriesManager.prototype.OnSubcategoryIndexChanged = function(index) {
    if (this.categories == null) return;
    var categoryIdx = XT.GetInt(LobbyVars.LobbyCategoryIndex);
    this.categories[categoryIdx].subcategoryIndex = index;
    this.OnCategoryIndexChanged(categoryIdx)
};
MultiLobbyCategoriesManager.prototype.OnSearchUpdated = function() {
    if (!this.isSearchOpen) {
        this.SaveScrolls();
        this.isSearchOpen = true
    }
    this.UpdateCategory(XT.GetObject(MultiLobbyVars.MultiLobby_SearchCategory), true)
};
MultiLobbyCategoriesManager.prototype.OnSearchClosed = function() {
    this.isSearchOpen = false;
    this.UpdateCategory(this.categories[this.categoryIdx], false)
};
MultiLobbyCategoriesManager.prototype.OnShowCategories = function() {
    if (!this.isOpen) {
        XT.TriggerEvent(InterfaceVars.Evt_CodeToData_InterfaceWindowOpen);
        this.show.Start();
        this.isOpen = true;
        XT.TriggerEvent(LobbyVars.Evt_Internal_LobbyCategoriesOpen)
    }
};
MultiLobbyCategoriesManager.prototype.OnHideCategories = function() {
    if (this.isOpen) {
        this.hide.Start();
        this.isOpen = false;
        XT.TriggerEvent(LobbyVars.Evt_Internal_LobbyCategoriesClosed)
    }
};
MultiLobbyCategoriesManager.prototype.OnVSGameStateChanged = function() {
    if (!this.isInit) return;
    var state = VSGameStateManager.GetState();
    if (state == VSGameState.Spin || state == VSGameState.SpinBonusRounds) this.hide.Start()
};
MultiLobbyCategoriesManager.prototype.SaveScrolls = function() {
    this.gamesIndices[this.categoryIdx] = this.gamesScroll.items[0].valueIdx;
    this.gamesScrolls[this.categoryIdx] = this.gamesScroll.scrollRemain;
    this.pagePositions[this.categoryIdx] = this.pageDrag.target.localPosition()
};
MultiLobbyCategoriesManager.prototype.UpdateCategory = function(category, forSearch) {
    (category.featured != null ? this.featured : this.noFeatured).Start();
    this.gamesScroll.SetValues(this.GetGames(category), false);
    this.gamesScroll.scrollRemain = forSearch ? 0 : this.gamesScrolls[this.categoryIdx];
    this.gamesScroll.UpdateValuesAndIndex(null, forSearch ? 0 : this.gamesIndices[this.categoryIdx], true);
    this.pageDrag.localPositionLimitMin = this.pageScroll.simpleLocalPositionLimitMin = this.GetMinPageScrollLimit(category, forSearch);
    this.pageDrag.localPositionLimitMax = this.pageScroll.simpleLocalPositionLimitMax = this.GetMaxPageScrollLimit();
    this.pageDrag.target.localPosition(forSearch ? this.pageDrag.localPositionLimitMin : this.pagePositions[this.categoryIdx]);
    this.featuredScroll.useMouseWheel = this.maxPageScrollLimitType != MultiLobbyMaxPageScrollLimitType.Default;
    XT.TriggerEvent(MultiLobbyVars.Evt_Internal_MultiLobby_CategoryUpdated)
};
MultiLobbyCategoriesManager.prototype.GetGames = function(category) {
    var list = this.GetGamesList(category);
    return list == null ? null : list.slice()
};
MultiLobbyCategoriesManager.prototype.GetGamesList = function(category) {
    if (this.gameListType == MultiLobbyGamesListType.Portrait) return category.listPortrait;
    return category.listLandscape
};
MultiLobbyCategoriesManager.prototype.GetMinPageScrollLimitType = function(category) {
    if (!category.hasGames) return MultiLobbyMinPageScrollLimitType.Default;
    if (category.featured != null) return MultiLobbyMinPageScrollLimitType.Featured;
    if (category.isSubcategory) return MultiLobbyMinPageScrollLimitType.CategoryAndGames;
    return MultiLobbyMinPageScrollLimitType.Games
};
MultiLobbyCategoriesManager.prototype.GetMaxPageScrollLimitType = function(minType) {
    if (minType == MultiLobbyMinPageScrollLimitType.Featured && (this.gamesScroll.itemValues == null || this.gamesScroll.itemValues.length == 0)) return MultiLobbyMaxPageScrollLimitType.FeaturedNoGames;
    if (minType == MultiLobbyMinPageScrollLimitType.CategoryAndGames && !this.gamesScroll.isEnabled) return MultiLobbyMaxPageScrollLimitType.CategoryAndGamesNoScroll;
    if (minType == MultiLobbyMinPageScrollLimitType.Search && !this.gamesScroll.isEnabled) return MultiLobbyMaxPageScrollLimitType.SearchNoScroll;
    return MultiLobbyMaxPageScrollLimitType.Default
};
MultiLobbyCategoriesManager.prototype.GetMinPageScrollLimit = function(category, forSearch) {
    this.minPageScrollLimitType = forSearch ? this.searchMinPageScrollLimitType : this.GetMinPageScrollLimitType(category);
    var index = this.minPageScrollLimitTypes.indexOf(this.minPageScrollLimitType);
    if (index > -1) return this.minPageScrollLimits[index];
    return this.defaultMinPageScrollLimit
};
MultiLobbyCategoriesManager.prototype.GetMaxPageScrollLimit = function() {
    this.maxPageScrollLimitType = this.GetMaxPageScrollLimitType(this.minPageScrollLimitType);
    var index = this.maxPageScrollLimitTypes.indexOf(this.maxPageScrollLimitType);
    if (index > -1) return this.maxPageScrollLimits[index];
    return this.defaultMaxPageScrollLimit
};
goog.require("UHT.LobbyConnection");

function LobbyVendor() {
    this.type = LobbyVendorType.Undefined;
    this.symbol = "";
    this.config = null;
    this.promoResponse = null;
    this.lastPlayed = null;
    this.landingPage = null;
    this.promo = null;
    this.categories = null;
    this.games = null
}
LobbyVendor.Config = function() {
    this.gameLaunchURL = "";
    this.gameIconsURL = "";
    this.dgaWS = "";
    this.casinoId = ""
};

function DgaTable() {
    this.tableId = "";
    this.tableName = "";
    this.tableType = "";
    this.tableSubtype = "";
    this.tableImage = "";
    this.tableOpen = false;
    this.newTable = false;
    this.tableLimits = null;
    this.dealer = null;
    this.currency = "";
    this.languageSpecificTableInfo = "";
    this.totalSeatedPlayers = 0;
    this.totalSeats = 0
}
DgaTable.TableLimits = function() {
    this.ranges = null;
    this.minBet = 0;
    this.maxBet = 0;
    this.maxPlayers = 0
};
DgaTable.Dealer = function() {
    this.name = ""
};
var MultiLobbyCategorySymbol = {
    LastPlayed: "lastPlayed",
    LandingPage: "landingPage",
    Promo: "promo"
};
var MultiLobbyVars = {
    MultiLobby_LiveCasinoGames: "MultiLobby_LiveCasinoGames",
    Evt_Internal_MultiLobby_CategoryUpdated: "Evt_Internal_MultiLobby_CategoryUpdated",
    MultiLobby_Search: "MultiLobby_Search",
    MultiLobby_SearchCategory: "MultiLobby_SearchCategory",
    Evt_Internal_MultiLobby_SearchUpdated: "Evt_Internal_MultiLobby_SearchUpdated",
    Evt_Internal_MultiLobby_SearchClosed: "Evt_Internal_MultiLobby_SearchClosed"
};
MultiLobbyConnection.prototype = Object.create(LobbyConnection.prototype);
MultiLobbyConnection.prototype.constructor = MultiLobbyConnection;

function MultiLobbyConnection() {
    LobbyConnection.call(this);
    this.multiCategoriesOrder = [MultiLobbyCategorySymbol.LandingPage, LobbyVendors.Slots, LobbyVendors.LiveCasino, MultiLobbyCategorySymbol.Promo];
    this.vendors = null;
    this.games = null;
    this.vendor = null;
    this.response = null;
    this.lobbyIsOpen = false;
    this.searchIsOpen = false;
    this.categoriesChanged = false;
    this.allSlotsUpdated = false;
    this.dgaWSUrl = "";
    this.useDgaWS = false;
    this.dgaIds = null;
    this.dgaTables = null;
    this.availableDgaTableIds = null;
    this.availableDgaTablesCount = -1;
    this.updatedDgaTableImgIds = null;
    this.isInitingDga = false;
    this.isDgaConnected = false;
    this.dgaTablesUpdated = false;
    this.dgaUpdateCategories = false;
    this.omitDgaVendorIfNotConnectedTime = 50;
    this.dgaVendor = null;
    this.searchCategory = null
}
MultiLobbyConnection.newSlotUids = null;
MultiLobbyConnection.hotSlotUids = null;
MultiLobbyConnection.MultiKeys = {
    data: "data",
    vendorConfig: "vendorConfig",
    activePromo: "activePromo",
    lastPlayed: "lastPlayed",
    landingPage: "landingPage",
    promo: "promo",
    vendorLobby: "vendorLobby",
    vendor: "vendor",
    dgaWS: "dgaWS",
    games: "games",
    id: "id",
    casinoId: "casinoId"
};
MultiLobbyConnection.DgaKeys = {
    error: "error",
    tableId: "tableId",
    tableKey: "tableKey",
    tableName: "tableName",
    tableType: "tableType",
    tableSubtype: "tableSubtype",
    tableImage: "tableImage",
    tableOpen: "tableOpen",
    newTable: "newTable",
    tableLimits: "tableLimits",
    ranges: "ranges",
    minBet: "minBet",
    maxBet: "maxBet",
    maxPlayers: "maxPlayers",
    dealer: "dealer",
    name: "name",
    currency: "currency",
    totalSeatedPlayers: "totalSeatedPlayers",
    languageSpecificTableInfo: "languageSpecificTableInfo",
    seat: "seat",
    availableSeats: "availableSeats"
};
MultiLobbyConnection.prototype.XTRegisterCallbacks = function() {
    LobbyConnection.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackEvent(LobbyVars.Evt_Internal_LobbyCategoriesOpen, this.OnLobbyCategoriesOpen, this);
    XT.RegisterCallbackEvent(LobbyVars.Evt_Internal_LobbyCategoriesClosed, this.OnLobbyCategoriesClosed, this);
    XT.RegisterCallbackString(MultiLobbyVars.MultiLobby_Search, this.OnSearch, this);
    XT.RegisterCallbackEvent(MultiLobbyVars.Evt_Internal_MultiLobby_SearchClosed, this.OnSearchClosed,
        this)
};
MultiLobbyConnection.prototype.XTInitVariablesAndEvents = function() {};
MultiLobbyConnection.prototype.OnLobbyCategoriesOpen = function() {
    this.ConnectDga();
    this.lobbyIsOpen = true
};
MultiLobbyConnection.prototype.OnLobbyCategoriesClosed = function() {
    this.DisconnectDga();
    this.lobbyIsOpen = false
};
MultiLobbyConnection.prototype.ConnectDga = function() {
    if (!this.useDgaWS) return;
    XT.RegisterCallbackEvent(DgaVars.Evt_Internal_DgaConnected, this.OnDgaConnected, this);
    XT.RegisterCallbackEvent(DgaVars.Evt_Internal_DgaMessage, this.OnDgaMessage, this);
    dga.connect(this.dgaWSUrl, null, null)
};
MultiLobbyConnection.prototype.DisconnectDga = function() {
    if (!this.useDgaWS) return;
    this.isDgaConnected = false;
    XT.UnregisterCallbackEvent(this.OnDgaConnected, this, DgaVars.Evt_Internal_DgaConnected);
    XT.UnregisterCallbackEvent(this.OnDgaMessage, this, DgaVars.Evt_Internal_DgaMessage);
    dga.disconnect()
};
MultiLobbyConnection.prototype.OnDgaConnected = function() {
    console.log("DGA connected");
    this.isDgaConnected = true;
    this.dgaTablesUpdated = false;
    this.updatedDgaTableImgIds.splice(0);
    this.availableDgaTableIds.splice(0);
    this.availableDgaTablesCount = -1;
    for (var i in this.dgaIds) dga.available(i)
};
MultiLobbyConnection.prototype.OnDgaMessage = function() {
    var data = XT.GetObject(DgaVars.DgaMessage);
    if (data == null) return;
    var DgaKeys = MultiLobbyConnection.DgaKeys;
    if (data[DgaKeys.error] != undefined) {
        console.error("DGA message error: " + data[DgaKeys.error]);
        return
    }
    if (data[DgaKeys.tableKey] != undefined) {
        var availableDgaTableKeys = data[DgaKeys.tableKey];
        var currency = ServerOptions.currency;
        for (var i in this.dgaIds) {
            var casinoId = i;
            var tableIds = this.dgaIds[i];
            for (var j = 0; j < tableIds.length; ++j) {
                var tableId = tableIds[j];
                if (availableDgaTableKeys.indexOf(tableId) < 0) continue;
                this.availableDgaTableIds.push(tableId);
                dga.subscribe(casinoId, tableId, currency)
            }
        }
        this.availableDgaTablesCount = this.availableDgaTableIds.length;
        return
    }
    this.UpdateDgaTable(data)
};
MultiLobbyConnection.prototype.FindDgaTable = function(tableId) {
    if (this.dgaTables != null)
        for (var i = 0; i < this.dgaTables.length; ++i)
            if (this.dgaTables[i].tableId == tableId) return this.dgaTables[i];
    return null
};
MultiLobbyConnection.prototype.UpdateDgaTable = function(data) {
    var DgaKeys = MultiLobbyConnection.DgaKeys;
    var tableId = "";
    if (data[DgaKeys.tableId] != undefined) tableId = data[DgaKeys.tableId];
    if (_string.IsNullOrEmpty(tableId)) return;
    var table = this.FindDgaTable(tableId);
    if (table == null) {
        table = new DgaTable;
        table.tableId = tableId;
        this.dgaTables.push(table)
    }
    if (data[DgaKeys.tableName] != undefined) table.tableName = data[DgaKeys.tableName];
    if (data[DgaKeys.tableType] != undefined) table.tableType = data[DgaKeys.tableType];
    if (data[DgaKeys.tableSubtype] != undefined) table.tableSubtype = data[DgaKeys.tableSubtype];
    var tableImage = table.tableImage;
    if (data[DgaKeys.tableImage] != undefined) table.tableImage = data[DgaKeys.tableImage];
    if (tableImage != table.tableImage) {
        this.AddTexture(this.textureSuffix, tableId, true, table.tableImage);
        this.updatedDgaTableImgIds.push(tableId)
    }
    if (data[DgaKeys.tableOpen] != undefined) table.tableOpen = data[DgaKeys.tableOpen];
    if (data[DgaKeys.newTable] != undefined) table.newTable = data[DgaKeys.newTable];
    if (data[DgaKeys.tableLimits] !=
        undefined) {
        var limits = table.tableLimits = new DgaTable.TableLimits;
        var dict = data[DgaKeys.tableLimits];
        if (dict[DgaKeys.ranges] != undefined) limits.ranges = dict[DgaKeys.ranges];
        if (dict[DgaKeys.minBet] != undefined) limits.minBet = dict[DgaKeys.minBet];
        if (dict[DgaKeys.maxBet] != undefined) limits.maxBet = dict[DgaKeys.maxBet];
        if (dict[DgaKeys.maxPlayers] != undefined) limits.maxPlayers = dict[DgaKeys.maxPlayers]
    }
    if (data[DgaKeys.dealer] != undefined) {
        var dealer = table.dealer = new DgaTable.Dealer;
        var dict = data[DgaKeys.dealer];
        if (dict[DgaKeys.name] != undefined) dealer.name = dict[DgaKeys.name]
    }
    if (data[DgaKeys.currency] != undefined) table.currency = data[DgaKeys.currency];
    if (data[DgaKeys.totalSeatedPlayers] != undefined) table.totalSeatedPlayers = data[DgaKeys.totalSeatedPlayers];
    if (data[DgaKeys.languageSpecificTableInfo] != undefined) table.languageSpecificTableInfo = data[DgaKeys.languageSpecificTableInfo];
    if (data[DgaKeys.availableSeats] != undefined) {
        var seat = 1;
        var totalSeats = 0;
        var availableSeats = data[DgaKeys.availableSeats];
        while (data[DgaKeys.seat +
                seat++] != undefined) totalSeats++;
        table.totalSeats = totalSeats;
        table.totalSeatedPlayers = totalSeats - availableSeats
    }
    this.dgaTablesUpdated = true
};
MultiLobbyConnection.prototype.AddDgaTableID = function(casinoId, tableId) {
    if (_string.IsNullOrEmpty(casinoId)) return;
    if (this.dgaIds[casinoId] == undefined) this.dgaIds[casinoId] = [];
    var list = this.dgaIds[casinoId];
    if (list.indexOf(tableId) < 0) list.push(tableId)
};
MultiLobbyConnection.prototype.OnInitReceived = function() {
    LobbyConnection.prototype.OnInitReceived.call(this);
    if (!this.isMultiLobby) return;
    this.errorMessage = "LobbyAPI Parsing Error (minilobby/common/games)";
    this.LoadCategories()
};
MultiLobbyConnection.prototype.OnCategoriesLoaded = function(param, statusCode) {
    if (statusCode != 200 && this.retryCount++ < 5) {
        this.LoadCategories();
        return
    }
    var dict = null;
    try {
        dict = JSON.parse(param)
    } catch (e) {
        console.error(e.message);
        return
    }
    this.response = TournamentProtocol.TournamentParser.ParseResponse(dict);
    if (this.response == null || this.response.error != TournamentProtocol.ErrorCode.None) {
        console.error(this.errorMessage);
        return
    }
    this.vendors = this.ParseVendors(dict);
    if (this.vendors == null) return;
    if (this.useDgaWS) {
        this.ConnectDga();
        this.isInitingDga = true;
        this.omitDgaVendorIfNotConnectedTime += Time.time
    } else this.SetupCategories(true)
};
MultiLobbyConnection.prototype.ParseVendors = function(dict) {
    var MultiKeys = MultiLobbyConnection.MultiKeys;
    if (dict[MultiKeys.data] == undefined) {
        console.error(this.errorMessage);
        return null
    }
    var list = dict[MultiKeys.data];
    if (list == null) {
        console.error(this.errorMessage);
        return null
    }
    var ret = [];
    for (var i = 0; i < list.length; ++i) {
        if (list[i].vendorLobby == undefined) list[i].vendorLobby = {};
        if (list[i].games != undefined)
            if (list[i].games.length > 0) {
                var vendor = this.ParseVendor(list[i]);
                if (vendor != null) ret.push(vendor)
            }
    }
    return ret
};
MultiLobbyConnection.prototype.ParseVendor = function(data) {
    if (data == null) {
        console.error(this.errorMessage);
        return null
    }
    var Keys = LobbyConnection.Keys;
    var MultiKeys = MultiLobbyConnection.MultiKeys;
    var ret = this.vendor = new LobbyVendor;
    if (data[MultiKeys.activePromo] != undefined) this.promoResponse = ret.promoResponse = TournamentProtocol.TournamentParser.ParseOnlyTournamentsResponse(this.response, data[MultiKeys.activePromo]);
    if (data[MultiKeys.vendor] != undefined) {
        ret.symbol = data[MultiKeys.vendor];
        ret.type = LobbyVendorTypeConverter.Convert(ret.symbol)
    }
    if (data[MultiKeys.vendorConfig] !=
        undefined) {
        var config = ret.config = new LobbyVendor.Config;
        var dict = data[MultiKeys.vendorConfig];
        if (dict[Keys.gameLaunchURL] != undefined) {
            var url = dict[Keys.gameLaunchURL];
            url += (url.indexOf("?") > -1 ? "&" : "?") + this.urlQuery + "&gameSymbol=";
            this.gameLaunchURL = config.gameLaunchURL = url
        }
        if (dict[Keys.gameIconsURL] != undefined) {
            var url = dict[Keys.gameIconsURL];
            if (url[url.length - 1] != "/") url += "/";
            this.gameIconsURL = config.gameIconsURL = url
        }
        if (dict[MultiKeys.dgaWS] != undefined) {
            this.dgaWSUrl = config.dgaWS = dict[MultiKeys.dgaWS];
            this.useDgaWS = !_string.IsNullOrEmpty(this.dgaWSUrl);
            if (this.useDgaWS) {
                this.dgaVendor = ret;
                this.dgaIds = {};
                this.dgaTables = [];
                this.updatedDgaTableImgIds = [];
                this.availableDgaTableIds = [];
                XT.SetObject(MultiLobbyVars.MultiLobby_LiveCasinoGames, this.dgaTables)
            }
        }
        if (dict[MultiKeys.casinoId] != undefined) config.casinoId = dict[MultiKeys.casinoId]
    }
    var games = ret.games = this.ParseVendorGames(data);
    if (games == null) return null;
    ret.lastPlayed = this.ParseCategory(data, MultiKeys.lastPlayed, MultiLobbyCategorySymbol.LastPlayed);
    ret.landingPage = this.ParseCategory(data, MultiKeys.landingPage, MultiLobbyCategorySymbol.LandingPage);
    ret.promo = this.ParseCategory(data, MultiKeys.promo, MultiLobbyCategorySymbol.Promo);
    ret.categories = this.ParseSubcategories(data, MultiKeys.vendorLobby);
    return ret
};
MultiLobbyConnection.prototype.ParseCategory = function(data, key, symbol) {
    if (data[key] == undefined) return null;
    var ret = new LobbyCategory;
    ret.symbol = symbol;
    ret.games = this.ParseCategoryGames(data[key]);
    return ret
};
MultiLobbyConnection.prototype.ParseSubcategories = function(data, key) {
    if (data[key] == undefined) return null;
    var list = data[key];
    if (list == null) {
        console.error(this.errorMessage);
        return null
    }
    var Keys = LobbyConnection.Keys;
    var MultiKeys = MultiLobbyConnection.MultiKeys;
    var ret = [];
    for (var i in list) {
        var dict = list[i];
        if (dict == null) continue;
        var category = new LobbyCategory;
        category.symbol = i;
        if (dict[Keys.name] != undefined) category.name = dict[Keys.name];
        if (dict[MultiKeys.games] != undefined) category.games = this.ParseCategoryGames(dict[MultiKeys.games]);
        ret.push(category)
    }
    return ret
};
MultiLobbyConnection.prototype.ParseGames = function(list) {
    if (list == null) {
        console.error(this.errorMessage);
        return null
    }
    var Keys = LobbyConnection.Keys;
    var MultiKeys = MultiLobbyConnection.MultiKeys;
    var ret = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null) {
            console.error(this.errorMessage);
            continue
        }
        var game = new LobbyGame;
        game.vendorType = this.vendor.type;
        if (dict[Keys.name] != undefined) game.name = dict[Keys.name];
        if (dict[Keys.symbol] != undefined) {
            game.symbol = game.uid = dict[Keys.symbol];
            game.launchURL =
                this.gameLaunchURL + game.symbol;
            this.AddTexture(this.textureSuffix, game.uid)
        }
        if (dict[MultiKeys.id] != undefined) {
            game.id = game.uid = dict[MultiKeys.id];
            game.casinoId = this.vendor.config.casinoId;
            game.launchURL = this.gameLaunchURL + game.id;
            this.AddDgaTableID(game.casinoId, game.id)
        }
        var promoKeys = game.promoKeys = this.GetPromoKeys(game.uid);
        if (promoKeys != null) game.displayStyle = this.GetDisplayStyle(game, false);
        ret.push(game)
    }
    return ret
};
MultiLobbyConnection.prototype.ParseVendorGames = function(dict) {
    var MultiKeys = MultiLobbyConnection.MultiKeys;
    if (dict[MultiKeys.games] == undefined) {
        console.error(this.errorMessage);
        return null
    }
    return this.ParseGames(dict[MultiKeys.games])
};
MultiLobbyConnection.prototype.ParseCategoryGames = function(list) {
    if (list == null) {
        console.error(this.errorMessage);
        return null
    }
    var ret = [];
    for (var i = 0; i < list.length; ++i) ret.push(this.vendor.games[list[i]]);
    return ret
};
MultiLobbyConnection.prototype.GetPromoKeys = function(uid) {
    var data = this.vendor.promoResponse;
    if (data == null) return null;
    var keys = [];
    this.FindPromoKeys(data.races, keys, uid);
    this.FindPromoKeys(data.tournaments, keys, uid);
    return keys.length > 0 ? keys : null
};
MultiLobbyConnection.prototype.FindPromoKeys = function(promos, keys, uid) {
    if (promos == null) return;
    for (var i = 0; i < promos.length; ++i) {
        var promo = promos[i];
        if (promo.games == null) continue;
        var idx = promo.games.indexOf(uid);
        if (idx < 0) continue;
        var key = new TournamentProtocol.PromoKey;
        key.id = promo.id;
        key.type = promo.type;
        keys.push(key)
    }
};
MultiLobbyConnection.prototype.ExtractDomain = function(url) {
    var domain = "";
    if (url.indexOf("://") > -1) domain = url.split("/")[2];
    else domain = url.split("/")[0];
    return domain
};
MultiLobbyConnection.prototype.UpdateCategory = function(symbol, category) {
    if (category == null) return;
    var target = this.FindCategory(symbol);
    if (target == null) this.AddCategory(symbol, category);
    else this.UpdateCategoryGames(target, category)
};
MultiLobbyConnection.prototype.UpdateFeaturedCategory = function(category) {
    if (category == null) return;
    if (this.featuredCategory == null) this.featuredCategory = new LobbyCategory(category);
    else this.UpdateCategoryGames(this.featuredCategory, category)
};
MultiLobbyConnection.prototype.CanUpdateAllSlots = function(vendor) {
    var count = 0;
    if (vendor.lastPlayed != null) count++;
    if (vendor.landingPage != null) count++;
    if (vendor.promo != null) count++;
    if (vendor.categories != null) count += vendor.categories.length;
    return vendor.type == LobbyVendorType.Slots && count > 1
};
MultiLobbyConnection.prototype.UpdateVendorCategory = function(vendor) {
    var categories = vendor.categories;
    if (categories == null) categories = [];
    if (!this.allSlotsUpdated && this.CanUpdateAllSlots(vendor)) {
        this.allSlotsUpdated = true;
        var allGames = [];
        var allGameSymbols = [];
        var categoryAll = this.FindCategory(LobbyCategorySymbol.All, categories);
        if (categoryAll != null) {
            this.FindUniqueGames(categoryAll, allGames, allGameSymbols);
            categories.splice(categories.indexOf(categoryAll), 1)
        }
        for (var i = 0; i < categories.length; ++i) this.FindUniqueGames(categories[i],
            allGames, allGameSymbols);
        this.FindUniqueGames(vendor.lastPlayed, allGames, allGameSymbols);
        this.FindUniqueGames(vendor.landingPage, allGames, allGameSymbols);
        this.FindUniqueGames(vendor.promo, allGames, allGameSymbols);
        categoryAll = new LobbyCategory;
        categoryAll.symbol = LobbyCategorySymbol.All;
        categoryAll.games = allGames;
        categories.push(categoryAll);
        this.AddTextures(this.textureSuffix, categoryAll);
        MultiLobbyConnection.newSlotUids = this.GetGameUids(this.FindCategory(LobbyCategorySymbol.New, categories));
        MultiLobbyConnection.hotSlotUids =
            this.GetGameUids(this.FindCategory(LobbyCategorySymbol.Hot, categories))
    }
    if (categories.length == 0) return;
    var symbol = vendor.symbol;
    var category = new LobbyCategory;
    category.symbol = symbol;
    category.categories = categories;
    this.AddCategory(symbol, category)
};
MultiLobbyConnection.prototype.AddCategory = function(symbol, category) {
    var idx = this.multiCategoriesOrder.indexOf(symbol);
    if (idx > -1) this.categories[idx] = new LobbyCategory(category)
};
MultiLobbyConnection.prototype.UpdateCategoryGames = function(target, category) {
    if (target.games == null) target.games = [];
    this.AddGames(target.games, category.games)
};
MultiLobbyConnection.prototype.AddGames = function(target, list) {
    if (list == null) return;
    if (this.games == null) this.games = [];
    this.games.splice(0);
    var count = Math.min(target.length, list.length);
    for (var i = 0; i < count; ++i) {
        this.games.push(target[i]);
        this.games.push(list[i])
    }
    for (var i = count; i < target.length; ++i) this.games.push(target[i]);
    for (var i = count; i < list.length; ++i) this.games.push(list[i]);
    target.splice(0);
    _array.AddRange(target, this.games);
    this.games.splice(0)
};
MultiLobbyConnection.prototype.UpdateCategoryLists = function(category, updateTextures) {
    var games = category.games;
    if (games == null) return;
    var listLand = category.listLandscape = [];
    var listPort = category.listPortrait = [];
    var listL = null;
    var listP = null;
    var textures = updateTextures ? this.GetTextures(this.textureSuffix) : null;
    for (var j = 0; j < games.length; ++j) {
        var game = games[j];
        if (updateTextures) this.UpdateTexture(textures, game);
        var idxL = j % this.gamesPerLineLandscape;
        var idxP = j % this.gamesPerLinePortrait;
        if (idxL == 0) {
            if (listL !=
                null) listLand.push(listL);
            listL = []
        }
        if (idxP == 0) {
            if (listP != null) listPort.push(listP);
            listP = []
        }
        listL.push(game);
        listP.push(game)
    }
    if (listL != null) listLand.push(listL);
    if (listP != null) listPort.push(listP)
};
MultiLobbyConnection.prototype.UpdateCategoriesLists = function(categories) {
    if (categories == null) return;
    for (var i = 0; i < categories.length; ++i) {
        var category = categories[i];
        if (category == null) continue;
        this.UpdateCategoryLists(category, true);
        this.UpdateCategoriesLists(category.categories)
    }
};
MultiLobbyConnection.prototype.UpdateDgaVendor = function(vendor) {
    if (vendor.type != LobbyVendorType.LiveCasino) return;
    this.UpdateDgaCategory(vendor.lastPlayed);
    this.UpdateDgaCategory(vendor.landingPage);
    this.UpdateDgaCategory(vendor.promo);
    var categories = vendor.categories;
    if (categories != null)
        for (var i = 0; i < categories.length; ++i) this.UpdateDgaCategory(categories[i])
};
MultiLobbyConnection.prototype.UpdateDgaCategory = function(category) {
    if (category == null) return;
    var games = category.games;
    if (games == null) return;
    var recGames = category.receivedGames;
    if (recGames == null) recGames = category.receivedGames = games.slice();
    games.splice(0);
    for (var i = 0; i < recGames.length; ++i) {
        var game = recGames[i];
        var table = this.FindDgaTable(game.id);
        if (table == null || !table.tableOpen) continue;
        game.name = table.tableName;
        games.push(game)
    }
};
MultiLobbyConnection.prototype.UpdateVendorPromo = function(vendor) {
    var games = [];
    var gameSymbols = [];
    var displayStyle = TournamentProtocol.DisplayStyle.DropsAndWins;
    this.FindUniqueGamesByDisplayStyle(vendor.lastPlayed, games, gameSymbols, displayStyle);
    this.FindUniqueGamesByDisplayStyle(vendor.landingPage, games, gameSymbols, displayStyle);
    this.FindUniqueGamesByDisplayStyle(vendor.promo, games, gameSymbols, displayStyle);
    var categories = vendor.categories;
    for (var i = 0; i < categories.length; ++i) this.FindUniqueGamesByDisplayStyle(categories[i],
        games, gameSymbols, displayStyle);
    if (games.length == 0) {
        vendor.promo = null;
        return
    }
    var category = vendor.promo;
    if (category == null) {
        category = vendor.promo = new LobbyCategory;
        category.symbol = MultiLobbyCategorySymbol.Promo
    }
    category.games = games;
    this.AddTextures(this.textureSuffix, category)
};
MultiLobbyConnection.prototype.FindUniqueGamesByDisplayStyle = function(category, list, found, displayStyle) {
    if (category == null) return;
    var games = category.games;
    if (games == null) return;
    for (var i = 0; i < games.length; ++i) {
        var game = games[i];
        if (game.displayStyles != null && game.displayStyles.indexOf(displayStyle) > -1 && game.displayStyle != displayStyle) {
            game = new LobbyGame(game);
            game.displayStyle = displayStyle
        }
        if (game.displayStyle != displayStyle) continue;
        if (found.indexOf(game.uid) > -1) continue;
        list.push(game);
        found.push(game.uid)
    }
};
MultiLobbyConnection.prototype.SetupCategories = function(loadTextures) {
    this.featuredCategory = null;
    this.categories = [];
    this.categoriesChanged = true;
    for (var i = 0; i < this.multiCategoriesOrder.length; ++i) {
        this.categories.push(new LobbyCategory);
        this.categories[i].symbol = this.multiCategoriesOrder[i]
    }
    for (var i = 0; i < this.vendors.length; ++i) {
        var vendor = this.vendors[i];
        this.UpdateDgaVendor(vendor);
        this.UpdateVendorCategory(vendor);
        this.UpdateVendorPromo(vendor);
        this.UpdateFeaturedCategory(vendor.lastPlayed);
        this.UpdateCategory(MultiLobbyCategorySymbol.LandingPage,
            vendor.landingPage);
        this.UpdateCategory(MultiLobbyCategorySymbol.Promo, vendor.promo)
    }
    if (loadTextures) {
        this.AddTextures(this.featuredTextureSuffix, this.featuredCategory);
        this.LoadTextures()
    }
};
MultiLobbyConnection.prototype.UpdateCategories = function() {
    this.SortCategoryAlphabetically(this.FindCategory(MultiLobbyCategorySymbol.Promo));
    this.UpdateCategoriesLists(this.categories);
    var symbols = [];
    var count = this.multiCategoriesOrder.length;
    for (var i = 0; i < count; ++i) {
        var category = this.categories[i];
        if (category == null) continue;
        category.categoryIndex = i;
        var searchGames = category.searchGames = [];
        var searchGameSymbols = category.searchGameSymbols = [];
        this.FindUniqueGames(category, searchGames, searchGameSymbols);
        if (category.symbol == MultiLobbyCategorySymbol.LandingPage) {
            category.featured = this.featuredCategory;
            this.FindUniqueGames(this.featuredCategory, searchGames, searchGameSymbols)
        }
        var subcats = category.categories;
        if (subcats != null && subcats.length > 0) {
            var subcatIdx = 0;
            for (var j = 0; j < subcats.length; ++j) {
                var subcat = subcats[j];
                if (this.categoriesChanged) {
                    if (subcatIdx == 0) category.subcategoriesIndex = this.categories.length;
                    this.categories.push(subcat);
                    subcat.categoryIndex = i;
                    subcat.isSubcategory = true;
                    subcat.subcategoryIndex =
                        subcatIdx++
                }
                subcat.hasGames = subcat.games != null && subcat.games.length > 0;
                if (subcat.hasGames) this.FindUniqueGames(subcat, searchGames, searchGameSymbols)
            }
        }
        category.hasGames = searchGames.length > 0;
        if (!category.hasGames) continue;
        symbols.push(category.symbol);
        for (var j = 0; j < searchGames.length; ++j) searchGames[j].nameLower = searchGames[j].name.toLowerCase()
    }
    if (!this.categoriesChanged) this.categories = this.categories.slice();
    this.categoriesChanged = false;
    XT.SetObject(LobbyVars.LobbyCategories, this.categories);
    XT.SetObject(LobbyVars.LobbyCategorySymbols,
        symbols)
};
MultiLobbyConnection.prototype.OmitDgaVendor = function() {
    this.DisconnectDga();
    this.useDgaWS = false;
    this.availableDgaTablesCount = this.dgaTables.length;
    this.vendors.splice(this.vendors.indexOf(this.dgaVendor), 1)
};
MultiLobbyConnection.prototype.Update = function() {
    if (this.isInitingDga) {
        if (!this.isDgaConnected && Time.time >= this.omitDgaVendorIfNotConnectedTime) this.OmitDgaVendor();
        if (this.dgaTables.length == this.availableDgaTablesCount) {
            this.isInitingDga = false;
            this.dgaTablesUpdated = false;
            this.updatedDgaTableImgIds.splice(0);
            this.SetupCategories(true);
            if (!this.lobbyIsOpen) this.DisconnectDga()
        }
    } else if (this.isDgaConnected) {
        if (this.updatedDgaTableImgIds.length > 0) {
            for (var i = 0; i < this.updatedDgaTableImgIds.length; ++i) {
                var tableId =
                    this.updatedDgaTableImgIds[i];
                this.LoadTexture(tableId, this.GetTexture(this.GetTextures(this.textureSuffix), tableId))
            }
            this.updatedDgaTableImgIds.splice(0)
        }
        if (this.dgaTablesUpdated && !this.searchIsOpen) {
            this.dgaTablesUpdated = false;
            this.dgaUpdateCategories = true;
            var prevCats = this.categories;
            this.SetupCategories(false);
            for (var i = 0; i < prevCats.length; ++i)
                if (!prevCats[i].isSubcategory) this.categories[i].subcategoryIndex = prevCats[i].subcategoryIndex
        }
    }
    if (this.searchIsOpen || !(this.texturesLoaded || this.dgaUpdateCategories)) return;
    this.texturesLoaded = this.dgaUpdateCategories = false;
    this.UpdateTextures(this.textureSuffix, this.featuredCategory);
    this.UpdateCategories()
};
MultiLobbyConnection.prototype.OnSearch = function(value) {
    if (_string.IsNullOrEmpty(value)) return;
    var index = XT.GetInt(LobbyVars.LobbyCategoryIndex);
    if (this.categories == null || index >= this.categories.length) return;
    var category = this.categories[index];
    if (category == null) return;
    if (this.searchCategory == null) {
        this.searchCategory = new LobbyCategory;
        this.searchCategory.games = [];
        XT.SetObject(MultiLobbyVars.MultiLobby_SearchCategory, this.searchCategory)
    }
    this.searchIsOpen = true;
    var wordsLower = value.toLowerCase().split(" ");
    this.searchCategory.symbol = category.symbol;
    this.searchCategory.games = category.searchGames.filter(function(e) {
        return this.SmartSearch(e, wordsLower)
    }.bind(this));
    this.UpdateCategoryLists(this.searchCategory, false);
    XT.TriggerEvent(MultiLobbyVars.Evt_Internal_MultiLobby_SearchUpdated)
};
MultiLobbyConnection.prototype.SmartSearch = function(game, wordsLower) {
    for (var i = 0; i < wordsLower.length; i++)
        if (game.nameLower.indexOf(wordsLower[i]) < 0) return false;
    return true
};
MultiLobbyConnection.prototype.OnSearchClosed = function() {
    this.searchIsOpen = false
};
MultiLobbyConnection.prototype.GetGameUids = function(category) {
    if (category == null) return null;
    var games = category.games;
    if (games == null || games.length == 0) return null;
    var ret = [];
    for (var i = 0; i < games.length; ++i) ret.push(games[i].uid);
    return ret
};
MultiLobbyConnection.IsNewSlot = function(uid) {
    var newSlotUids = MultiLobbyConnection.newSlotUids;
    return newSlotUids == null ? false : newSlotUids.indexOf(uid) > -1
};
MultiLobbyConnection.IsHotSlot = function(uid) {
    var hotSlotUids = MultiLobbyConnection.hotSlotUids;
    return hotSlotUids == null ? false : hotSlotUids.indexOf(uid) > -1
};
MultiLobbyConnection.prototype.SortCategoryAlphabetically = function(category) {
    if (category == null) return;
    var games = category.games;
    if (games != null && games.length > 1) games.sort(MultiLobbyConnection.SortGamesAlphabetically)
};
MultiLobbyConnection.SortGamesAlphabetically = function(x, y) {
    var a = x.name.toLowerCase();
    var b = y.name.toLowerCase();
    return a < b ? -1 : a > b ? 1 : 0
};
goog.require("UHT.XTLink");
MultiLobbyScrollbar.prototype = Object.create(XTLink.prototype);
MultiLobbyScrollbar.prototype.constructor = MultiLobbyScrollbar;

function MultiLobbyScrollbar() {
    XTLink.call(this);
    this.scrollbars = null;
    this.scrollbar = null;
    this.scrollbarThumb = null;
    this.minThumbHeightIsWidthX = 0;
    this.defaultHeight = 0;
    this.gamesScrollFollowers = null;
    this.isInit = false;
    this.isEnabled = false;
    this.categoryUpdated = false;
    this.pageScroll = null;
    this.pageDrag = null;
    this.pageShare = 0;
    this.gamesScroll = null;
    this.gamesScrollItemHeight = 0;
    this.gamesExtraHeight = 0;
    this.gamesShare = 0;
    this.thumbYMax = 0;
    this.numberError = .001;
    this.prevScroll = -1;
    this.prevGamesScroll = -1
}
MultiLobbyScrollbar.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(MultiLobbyVars.Evt_Internal_MultiLobby_CategoryUpdated, this.OnCategoryUpdated, this)
};
MultiLobbyScrollbar.prototype.OnCategoryUpdated = function() {
    this.categoryUpdated = true
};
MultiLobbyScrollbar.prototype.OnEnable = function() {
    if (!this.isInit) this.OnCategoryUpdated()
};
MultiLobbyScrollbar.prototype.LateUpdate = function() {
    if (!this.isInit) {
        this.isInit = true;
        this.pageScroll = this.scrollbars.pageScrollbar;
        this.pageDrag = this.pageScroll.simpleDragObject;
        this.gamesScroll = this.scrollbars.gamesScrollbar;
        var pageParent = this.pageScroll.simpleDragObject.target.parent;
        var gamesParent = this.gamesScroll.items[0].transform.parent;
        this.gamesScrollItemHeight = gamesParent._internal_get_scale().y / pageParent._internal_get_scale().y * this.gamesScroll.itemHeight
    }
    if (this.categoryUpdated) {
        this.categoryUpdated =
            false;
        var pageY = this.pageDrag.target.localPosition().y;
        var minPageY = this.pageDrag.localPositionLimitMin.y;
        var maxPageY = this.pageDrag.localPositionLimitMax.y;
        var scrollPage = UHTMath.inverseLerp(minPageY, maxPageY, pageY);
        if (pageY < maxPageY) {
            this.scrollbars.canScrollGamesNext = false;
            this.scrollbars.canScrollPagePrevious = true;
            this.pageDrag.gameObject.SetActive(true)
        }
        var pageExtraHeight = maxPageY - minPageY;
        this.gamesExtraHeight = this.gamesScroll.isEnabled ? (this.gamesScroll.itemValues.length - this.gamesScroll.items.length) *
            this.gamesScrollItemHeight : 0;
        var extraHeight = pageExtraHeight + this.gamesExtraHeight;
        this.pageShare = pageExtraHeight / extraHeight;
        this.gamesShare = this.gamesExtraHeight / extraHeight;
        this.isEnabled = extraHeight > this.numberError;
        if (this.isEnabled) {
            var thumbHeightMin = Math.floor(this.scrollbarThumb.width * this.minThumbHeightIsWidthX);
            var thumbHeight = Math.floor(this.scrollbar.height * this.defaultHeight / (this.defaultHeight + extraHeight));
            thumbHeight = Math.max(thumbHeight, thumbHeightMin);
            this.scrollbarThumb.height =
                thumbHeight;
            this.thumbYMax = this.scrollbar.height - thumbHeight
        }
        this.scrollbar.gameObject.SetActive(this.isEnabled);
        this.scrollbarThumb.gameObject.SetActive(this.isEnabled);
        this.prevScroll = -1;
        this.prevGamesScroll = -1;
        this.pageDrag.wheelDirection = 0;
        this.pageScroll.SetScroll(scrollPage)
    }
    if (this.isEnabled) {
        var scroll = this.pageScroll.GetScroll() * this.pageShare + this.gamesScroll.scroll * this.gamesShare;
        if (this.prevScroll != scroll) {
            this.prevScroll = scroll;
            var thumbY = UHTMath.lerp(0, this.thumbYMax, scroll);
            this.scrollbarThumb.gameObject.transform.localPosition(new UHTMath.Vector3(0, -thumbY, 0))
        }
    }
    if (this.prevGamesScroll != this.gamesScroll.scroll) {
        this.prevGamesScroll = this.gamesScroll.scroll;
        var gamesScrollY = this.gamesScroll.isEnabled ? this.gamesScroll.scroll * this.gamesExtraHeight : 0;
        var pos = new UHTMath.Vector3(0, gamesScrollY, 0);
        for (var i = 0; i < this.gamesScrollFollowers.length; ++i) this.gamesScrollFollowers[i].localPosition(pos)
    }
};
goog.require("UHT.XTLink");
MultiLobbySearch.prototype = Object.create(XTLink.prototype);
MultiLobbySearch.prototype.constructor = MultiLobbySearch;

function MultiLobbySearch() {
    XTLink.call(this);
    this.input = null;
    this.categories = null;
    this.localizedSymbols = null;
    this.show = null;
    this.hide = null;
    this.gamesFound = null;
    this.gamesNotFound = null;
    this.categoryChanged = null;
    this.isVisible = false;
    this.resetFrame = 0
}
MultiLobbySearch.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackInt(LobbyVars.LobbyCategoryIndex, this.OnLobbyCategoryIndex, this)
};
MultiLobbySearch.prototype.OnLobbyCategoryIndex = function(param) {
    this.categoryChanged.Start()
};
MultiLobbySearch.prototype.UpdateSearch = function() {
    var input = this.GetSelectedInput();
    if (input == null || this.resetFrame == Time.frameCount) return;
    var value = input.value;
    if (_string.IsNullOrEmpty(value)) return;
    XT.SetString(MultiLobbyVars.MultiLobby_Search, input.value);
    var category = XT.GetObject(MultiLobbyVars.MultiLobby_SearchCategory);
    if (!this.isVisible) {
        for (var i = 0; i < this.categories.length; ++i) this.categories[i].UpdateCategory(this.FindLocalizedSymbol(category.symbol));
        this.show.Start();
        this.isVisible = true
    }
    if (!this.isVisible) return;
    var count = category.games == null ? 0 : category.games.length;
    (count == 0 ? this.gamesNotFound : this.gamesFound).Start()
};
MultiLobbySearch.prototype.CloseSearch = function() {
    if (this.isVisible) {
        this.hide.Start();
        this.isVisible = false;
        XT.SetString(MultiLobbyVars.MultiLobby_Search, "");
        XT.TriggerEvent(MultiLobbyVars.Evt_Internal_MultiLobby_SearchClosed)
    }
};
MultiLobbySearch.prototype.FindLocalizedSymbol = function(name) {
    for (var i = 0; i < this.localizedSymbols.length; ++i)
        if (this.localizedSymbols[i].gameObject.name == name) return this.localizedSymbols[i];
    return null
};
MultiLobbySearch.prototype.GetSelectedInput = function() {
    if (this.input.isSelected) return this.input;
    var linked = this.input.linkedUIInput;
    if (linked != null && linked.isSelected) return linked;
    return null
};
MultiLobbySearch.prototype.ResetInput = function() {
    this.resetFrame = Time.frameCount;
    this.input.Reset()
};
goog.require("UHT.XTLink");
MultiLobbySubcategories.prototype = Object.create(XTLink.prototype);
MultiLobbySubcategories.prototype.constructor = MultiLobbySubcategories;

function MultiLobbySubcategories() {
    XTLink.call(this);
    this.subcategoriesPooler = null;
    this.subcategoryPoolID = 0;
    this.labelsAnchor = null;
    this.localizedLabels = null;
    this.maxSubcategoriesWidth = 0;
    this.subcategoriesScroll = null;
    this.searchOpen = null;
    this.searchClosed = null;
    this.enableScroll = null;
    this.disableScroll = null;
    this.bounds = null;
    this.scrollSampler = null;
    this.scrollSampledCategory = null;
    this.scrollSampledSubcategory = null;
    this.updateOnEnable = false;
    this.subcategoriesDrag = null;
    this.defaultMinScrollLimit = null;
    this.defaultMaxScrollLimit = null;
    this.isInit = false;
    this.isSearchOpen = false;
    this.categoryIdx = 0;
    this.categoryChangedFrame = 0;
    this.categories = null;
    this.subcategories = null;
    this.subcategoryPositions = null;
    this.subcategoriesUpdated = null
}
MultiLobbySubcategories.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(LobbyVars.LobbyCategories, this.OnLobbyCategories, this);
    XT.RegisterCallbackInt(LobbyVars.LobbyCategoryIndex, this.OnLobbyCategoryIndex, this);
    XT.RegisterCallbackInt(LobbyVars.LobbySubcategoryIndex, this.OnLobbySubcategoryIndex, this);
    XT.RegisterCallbackEvent(MultiLobbyVars.Evt_Internal_MultiLobby_SearchUpdated, this.OnSearchUpdated, this);
    XT.RegisterCallbackEvent(MultiLobbyVars.Evt_Internal_MultiLobby_SearchClosed,
        this.OnSearchClosed, this)
};
MultiLobbySubcategories.prototype.OnLobbyCategories = function(param) {
    this.categories = param;
    this.OnLobbyCategoryIndex(XT.GetInt(LobbyVars.LobbyCategoryIndex))
};
MultiLobbySubcategories.prototype.OnLobbyCategoryIndex = function(index) {
    if (this.categories == null || !this.gameObject.activeInHierarchy) return;
    var category = this.categories[index];
    if (!category.hasGames) return;
    if (!this.isInit) {
        this.isInit = true;
        this.subcategoriesDrag = this.subcategoriesScroll.simpleDragObject;
        this.defaultMinScrollLimit = this.subcategoriesScroll.simpleLocalPositionLimitMin;
        this.defaultMaxScrollLimit = this.subcategoriesScroll.simpleLocalPositionLimitMax;
        this.subcategories = [];
        this.subcategoryPositions = [];
        this.subcategoriesUpdated = [];
        for (var i = 0; i < this.categories.length; ++i) {
            if (this.categories[i].isSubcategory) continue;
            this.subcategoriesUpdated.push(false);
            this.subcategoryPositions.push(this.defaultMinScrollLimit)
        }
    } else this.subcategoryPositions[this.categoryIdx] = this.subcategoriesDrag.target.localPosition();
    this.categoryIdx = index;
    this.categoryChangedFrame = Time.frameCount;
    var subcats = category.categories;
    var subcatIdx = category.subcategoryIndex;
    var count = subcats == null ? 0 : subcats.length;
    var discardCache =
        false;
    for (var i = 0; i < count; ++i) {
        if (i == this.subcategories.length) {
            discardCache = true;
            this.subcategories.push(this.subcategoriesPooler.GetObject(this.subcategoryPoolID, this.labelsAnchor.gameObject));
            this.subcategories[i].index = i;
            this.labelsAnchor.labels.push(this.subcategories[i].label)
        }
        this.subcategories[i].UpdateSubcategory(subcats[i], this.FindLocalizedLabel(subcats[i].symbol))
    }
    for (var i = count; i < this.subcategories.length; ++i) this.subcategories[i].UpdateSubcategory(null, null);
    if (discardCache) this.labelsAnchor.DiscardCache();
    this.labelsAnchor.ForceNextUpdate();
    this.labelsAnchor.Update();
    var minLimit = this.defaultMinScrollLimit;
    var maxLimit = this.defaultMaxScrollLimit;
    var width = this.labelsAnchor.width;
    var difference = width - this.maxSubcategoriesWidth;
    var needScroll = difference > 0;
    if (needScroll) {
        var limit = difference * .5;
        minLimit = UHTMath.Vector3.sub(minLimit, new UHTMath.Vector3(limit, 0, 0));
        maxLimit = UHTMath.Vector3.add(maxLimit, new UHTMath.Vector3(limit, 0, 0))
    }
    if (!this.subcategoriesUpdated[this.categoryIdx]) {
        this.subcategoriesUpdated[this.categoryIdx] =
            true;
        this.subcategoryPositions[this.categoryIdx] = maxLimit
    }
    this.subcategoriesDrag.localPositionLimitMin = this.subcategoriesScroll.simpleLocalPositionLimitMin = this.scrollSampler.manualFrom = minLimit;
    this.subcategoriesDrag.localPositionLimitMax = this.subcategoriesScroll.simpleLocalPositionLimitMax = this.scrollSampler.manualTo = maxLimit;
    this.subcategoriesDrag.target.localPosition(this.subcategoryPositions[this.categoryIdx]);
    (needScroll ? this.enableScroll : this.disableScroll).Start();
    if (XT.GetInt(LobbyVars.LobbySubcategoryIndex) ==
        subcatIdx) this.OnLobbySubcategoryIndex(subcatIdx);
    XT.SetInt(LobbyVars.LobbySubcategoryIndex, subcatIdx)
};
MultiLobbySubcategories.prototype.OnLobbySubcategoryIndex = function(index) {
    if (this.subcategories == null || this.subcategories.length <= index) return;
    this.SampleScroll(this.subcategories[index].label);
    for (var i = 0; i < this.subcategories.length; ++i) this.subcategories[i].SetSelected(i == index)
};
MultiLobbySubcategories.prototype.SampleScroll = function(label) {
    var pos = this.bounds.inverseTransformPoint(label.transform.position());
    var half = label.width * .5;
    var bound = this.maxSubcategoriesWidth * .5;
    if (-bound < pos.x - half && pos.x + half < bound) return;
    var time = UHTMath.inverseLerp(this.scrollSampler.manualTo.x, this.scrollSampler.manualFrom.x, label.transform.localPosition().x);
    this.scrollSampler.Sample(time);
    (this.categoryChangedFrame == Time.frameCount ? this.scrollSampledCategory : this.scrollSampledSubcategory).Start()
};
MultiLobbySubcategories.prototype.OnSearchUpdated = function() {
    if (!this.isSearchOpen) {
        this.isSearchOpen = true;
        this.searchOpen.Start()
    }
};
MultiLobbySubcategories.prototype.OnSearchClosed = function() {
    this.isSearchOpen = false;
    this.searchClosed.Start()
};
MultiLobbySubcategories.prototype.FindLocalizedLabel = function(name) {
    for (var i = 0; i < this.localizedLabels.length; ++i)
        if (this.localizedLabels[i].gameObject.name == name) return this.localizedLabels[i];
    return null
};
MultiLobbySubcategories.prototype.OnEnable = function() {
    if (!this.isInit || this.updateOnEnable) this.OnLobbyCategories(XT.GetObject(LobbyVars.LobbyCategories))
};
goog.provide("UHT.GenericPoolObject");
goog.require("UHT.XTLink");
GenericPoolObject.prototype = Object.create(XTLink.prototype);
GenericPoolObject.prototype.constructor = GenericPoolObject;

function GenericPoolObject() {
    XTLink.call(this);
    this.Id = 0
}
GenericPoolObject.prototype.Reset = function() {};
goog.provide("UHT.LobbyCategoryDisplayer");
goog.require("UHT.GenericPoolObject");
LobbyCategoryDisplayer.prototype = Object.create(GenericPoolObject.prototype);
LobbyCategoryDisplayer.prototype.constructor = LobbyCategoryDisplayer;

function LobbyCategoryDisplayer() {
    GenericPoolObject.call(this);
    this.MLAnchors = null;
    this.applyLabelActive = false;
    this.MLASprites = []
}
LobbyCategoryDisplayer.prototype.UpdateCategory = function(src) {
    if (src != null)
        for (var i = 0; i < this.MLAnchors.length; ++i) this.UpdateMLAnchor(src, this.MLAnchors[i])
};
LobbyCategoryDisplayer.prototype.UpdateMLAnchor = function(src, dest) {
    for (var i = 0; i < src.labels.length; ++i) this.UpdateLabel(src.labels[i], dest.labels[i])
};
LobbyCategoryDisplayer.prototype.UpdateLabel = function(src, dest) {
    dest.text = src.text;
    dest.width = src.width;
    dest.fontName = src.fontName;
    dest.Prepare();
    if (this.applyLabelActive) dest.gameObject.SetActive(src.gameObject.activeSelf);
    this.UpdateSprites(src.GetComponentsInChildren(UISprite, true), dest.GetComponentsInChildren(UISprite, true))
};
LobbyCategoryDisplayer.prototype.UpdateSprites = function(src, dest) {
    this.MLASprites.push(dest);
    for (var i = 0; i < src.length; ++i) {
        GUIArranger.I.CopySprite(src[i], dest[i]);
        GUIArranger.I.CopySpriteSize(src[i], dest[i])
    }
};
goog.provide("UHT.LobbyCategoryButton");
goog.require("UHT.LobbyCategoryDisplayer");
LobbyCategoryButton.prototype = Object.create(LobbyCategoryDisplayer.prototype);
LobbyCategoryButton.prototype.constructor = LobbyCategoryButton;

function LobbyCategoryButton() {
    LobbyCategoryDisplayer.call(this);
    this.selected = null;
    this.unselected = null;
    this.disabled = null;
    this.enable = null;
    this.sprites = null;
    this.colliders = null;
    this.lastContents = null;
    this.notLastContents = null;
    this.useSpriteScale = false;
    this.spriteScale = null
}
LobbyCategoryButton.prototype.UpdateButton = function(source, width, textWidth, isLast) {
    if (source == null || width == 0) {
        this.StartCATLink(this.disabled);
        return
    }
    this.StartCATLink(this.enable);
    var slp = source.transform.localPosition();
    for (var i = 0; i < this.MLAnchors.length; ++i) {
        this.UpdateMLAnchor(source, this.MLAnchors[i]);
        this.MLAnchors[i].maxWidth = textWidth;
        var localPos = new UHTMath.Vector3(slp.x, slp.y, slp.z);
        if (this.MLAnchors[i].alignment == MultipleLabelAnchor.Alignment.Left) localPos.x += .5 * textWidth;
        if (this.MLAnchors[i].alignment ==
            MultipleLabelAnchor.Alignment.Right) localPos.x -= .5 * textWidth;
        this.MLAnchors[i].transform.localPosition(localPos)
    }
    for (var i = 0; i < this.sprites.length; ++i) this.sprites[i].width = Math.round(width * (this.useSpriteScale ? this.spriteScale[i] : 1));
    for (var i = 0; i < this.colliders.length; ++i) this.UpdateCollider(this.colliders[i], width);
    for (var i = 0; i < this.lastContents.length; ++i) this.lastContents[i].SetActive(isLast);
    for (var i = 0; i < this.notLastContents.length; ++i) this.notLastContents[i].SetActive(!isLast)
};
LobbyCategoryButton.prototype.UpdateCollider = function(collider, width) {
    collider.size = new UHTMath.Vector3(width, collider.size.y, collider.size.z);
    this.UpdateUIButtons(collider.GetComponentsInChildren(UIButton, true))
};
LobbyCategoryButton.prototype.UpdateUIButtons = function(buttons) {
    for (var i = 0; i < buttons.length; ++i) {
        var sprite = this.FindButtonSprite(buttons[i]);
        if (sprite != null) buttons[i].normal = sprite.spriteName
    }
};
LobbyCategoryButton.prototype.FindButtonSprite = function(button) {
    var sprite = button.target;
    if (!(sprite instanceof UISprite)) return null;
    for (var i = 0; i < this.MLASprites.length; ++i)
        for (var j = 0; j < this.MLASprites[i].length; ++j)
            if (sprite == this.MLASprites[i][j]) return this.MLASprites[i][j];
    return null
};
LobbyCategoryButton.prototype.SetSelected = function(isSelected) {
    this.StartCATLink(isSelected ? this.selected : this.unselected)
};
LobbyCategoryButton.prototype.SetEnabled = function(isEnabled) {
    this.StartCATLink(isEnabled ? this.enable : this.disabled)
};
LobbyCategoryButton.prototype.StartCATLink = function(link) {
    if (link != null && link.cat != null) link.Start()
};
goog.require("UHT.LobbyCategoryButton");
MultiLobbySubcategory.prototype = Object.create(LobbyCategoryButton.prototype);
MultiLobbySubcategory.prototype.constructor = MultiLobbySubcategory;

function MultiLobbySubcategory() {
    LobbyCategoryButton.call(this);
    this.label = null;
    this.clickPlayer = null;
    this.clickThreshold = 0;
    this.index = 0;
    this.pressPos = null;
    this.cachedCamera = null
}
MultiLobbySubcategory.prototype.UpdateSubcategory = function(category, localizedLabel) {
    if (category == null || !category.hasGames) {
        this.StartCATLink(this.disabled);
        return
    }
    this.StartCATLink(this.enable);
    var text = localizedLabel != null ? localizedLabel.text : category.name;
    if (_string.IsNullOrEmpty(text)) text = category.symbol;
    this.label.text = text;
    var width = this.label.GetWidth();
    for (var i = 0; i < this.colliders.length; ++i) this.UpdateCollider(this.colliders[i], width)
};
MultiLobbySubcategory.prototype.OnPress = function(isPressed) {
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    var pos = this.cachedCamera.transform.inverseTransformPoint(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition));
    if (isPressed) {
        this.pressPos = pos;
        return
    }
    if (this.pressPos == null) return;
    var posDelta = UHTMath.Vector3.sub(pos, this.pressPos);
    if (Math.abs(posDelta.x) > this.clickThreshold || Math.abs(posDelta.y) > this.clickThreshold) return;
    this.clickPlayer.PlaySound();
    XT.SetInt(LobbyVars.LobbySubcategoryIndex, this.index)
};
goog.provide("UHT.GenericObjectPooler");
goog.require("UHT.GenericPoolObject");
GenericObjectPooler.prototype = Object.create(XTLink.prototype);
GenericObjectPooler.prototype.constructor = GenericObjectPooler;

function GenericObjectPooler() {
    XTLink.call(this);
    this.pool = null;
    this.poolObjects = [];
    this.objectIdToIndexMap = null;
    this.pooledObjects = null;
    this.disablePoolNextFrame = false;
    this.defaultBufferAmount = 10;
    this.initializing = false;
    this.currentInitObject = -1
}
GenericObjectPooler.prototype.Init = function() {
    this.initializing = true;
    this.PerformSanityCheck();
    this.BuildObjectIdToIndexMap();
    this.pooledObjects = [];
    this.pool.SetActive(true)
};
GenericObjectPooler.prototype.Update = function() {
    if (this.initializing)
        if (this.currentInitObject < this.poolObjects.length) {
            if (this.currentInitObject >= 0) {
                var id = this.poolObjects[this.currentInitObject].Id;
                this.pooledObjects[id] = [];
                for (var n = 0; n < this.defaultBufferAmount; n++) {
                    var newObj = instantiate(this.poolObjects[this.currentInitObject].gameObject);
                    newObj.SetActive(true);
                    this.PoolObject(id, newObj.GetComponent(GenericPoolObject))
                }
            }
            this.currentInitObject++
        } else {
            this.disablePoolNextFrame = false;
            this.initializing =
                false
        }
};
GenericObjectPooler.prototype.PerformSanityCheck = function() {
    var foundIds = [];
    for (var i = 0; i < this.poolObjects.length; ++i) {
        var s = this.poolObjects[i];
        if (foundIds.indexOf(s.Id) != -1) console.error("More than one obj registered with ID = " + s.Id);
        foundIds.push(s.Id)
    }
};
GenericObjectPooler.prototype.BuildObjectIdToIndexMap = function() {
    this.objectIdToIndexMap = [];
    for (var i = 0; i < this.poolObjects.length; i++) this.objectIdToIndexMap[this.poolObjects[i].Id] = i
};
GenericObjectPooler.prototype.GetFromPool = function(id, parent) {
    if (this.pooledObjects[id].length == 0) {
        console.log("Object pool capacity is too small! ID = " + id);
        this.pooledObjects[id].push(instantiate(this.poolObjects[this.objectIdToIndexMap[id]].gameObject).GetComponent(GenericPoolObject));
        this.pooledObjects[id][this.pooledObjects[id].length - 1].gameObject.SetActive(true)
    }
    var pooledObject = this.pooledObjects[id][0];
    this.pooledObjects[id].splice(0, 1);
    pooledObject.gameObject.transform.SetParent(parent.transform,
        false);
    pooledObject.gameObject.transform.localPosition(UHTMath.Vector3.zero);
    pooledObject.gameObject.transform.localRotation(UHTMath.Quaternion.euler(UHTMath.Vector3.zero));
    pooledObject.gameObject.transform.localScale(UHTMath.Vector3.one);
    return pooledObject
};
GenericObjectPooler.prototype.PoolObject = function(id, obj) {
    obj.Reset();
    obj.gameObject.transform.SetParent(this.pool.transform, false);
    this.pooledObjects[id].push(obj)
};
GenericObjectPooler.prototype.GetObject = function(objId, parent) {
    return this.GetFromPool(objId, parent)
};
GenericObjectPooler.prototype.RecycleObject = function(obj) {
    this.PoolObject(obj.Id, obj)
};
GenericObjectPooler.prototype.LateUpdate = function() {
    if (this.pool.activeSelf && !this.initializing) {
        if (!this.disablePoolNextFrame) {
            this.disablePoolNextFrame = true;
            return
        }
        this.pool.SetActive(false)
    }
};
goog.provide("UHT.OfflineServer");
goog.require("UHT.Engine");
OfflineServer.prototype = Object.create(Component.prototype);
OfflineServer.prototype.constructor = OfflineServer;

function OfflineServer() {
    Component.call(this);
    this.configFile = null;
    this.responseLog = null;
    this.responseString = "";
    this.index = 0;
    this.slotHeight = 0;
    this.numberOfReels = 0;
    this.stopOffset = 1;
    this.coinValue = .01;
    this.lines = 0;
    this.balance = 1E5;
    this.reelSymbols = null;
    this.screenSymbols = null;
    this.payoutData = null;
    this.stopPositions = null;
    this.linesDef = null;
    this.totalWin = 0;
    this.isFreeSpins = false;
    this.currentFreeSpin = 0;
    this.maxFreeSpins = 0;
    this.totalFreeSpins = 0;
    this.freeSpinsCurrentMultiplier = 0;
    this.freeSpinsTotalMultiplier =
        0;
    this.freeSpinCurrentWin = 0;
    this.freeSpinTotalWin = 0;
    this.freeSpinCurrentWinMultiplied = 0;
    this.freeSpinTotalWinMultiplied = 0;
    this.scatterFSAwards = null;
    this.scatterFSMultipliers = null;
    this.scatterFSAdditional = null;
    this.linesDefString = "5,6,7,8,9~0,1,2,3,4~10,11,12,13,14~0,6,12,8,4~10,6,2,8,14~5,1,2,3,9~5,11,12,13,9~0,1,7,13,14~10,11,7,3,4~5,11,7,3,9~5,1,7,13,9~0,6,7,8,4~10,6,7,8,14~0,6,2,8,4~10,6,12,8,14~5,6,2,8,9~5,6,12,8,9~0,1,12,3,4~10,11,2,13,14~0,11,12,13,4~10,1,2,3,14~5,11,2,13,9~5,1,12,3,9~0,11,2,13,4~10,1,12,3,14";
    this.ID_DELIMITER = "::"
}
OfflineServer.prototype.Start = function() {
    RequestProvider.Instance.ParseOfflineResponse(this.responseLog.text, true);
    this.ProcessLinesDefinitions()
};
OfflineServer.prototype.ParseConfig = function() {
    var tempString = "";
    var parser = new DOMParser;
    var config = parser.parseFromString(this.configFile.text, "text/xml");
    var winLines = config.getElementsByTagName("slot")[0];
    this.lines = _number.otoi(winLines.getAttribute("lines"));
    this.AddParameterToResonse(GameProtocolDictionary.line + "=" + this.lines, false);
    var initScreenSymbols = config.getElementsByTagName("screen");
    this.AddParameterToResonse(GameProtocolDictionary.winSymbols + "=" + initScreenSymbols[0].getAttribute("array"),
        false);
    var reels = config.getElementsByTagName("reel");
    this.stopPositions = new Array;
    this.numberOfReels = reels.length;
    var reelsInitPositions = "";
    this.reelSymbols = new Array;
    for (var reelIdx = 0; reelIdx < reels.length; reelIdx++) {
        tempString = "";
        tempString += GameProtocolDictionary.reel(reelIdx) + "=" + reels[reelIdx].getAttribute("symbols");
        this.AddParameterToResonse(tempString, false);
        this.stopPositions.push(0);
        reelsInitPositions += this.stopPositions[reelIdx] + (reelIdx < reels.length - 1 ? "," : "");
        var currentReelSymbols = new Array;
        var values = reels[reelIdx].getAttribute("symbols").split(",");
        for (var symbolIdx = 0; symbolIdx < values.length; symbolIdx++) currentReelSymbols.push(_number.otoi(values[symbolIdx]));
        this.reelSymbols.push(currentReelSymbols)
    }
    this.AddParameterToResonse(GameProtocolDictionary.reelsPosition + "=" + reelsInitPositions, false);
    this.AddParameterToResonse(GameProtocolDictionary.slotHeight + "=" + initScreenSymbols[0].getAttribute("array").split(",").length / this.numberOfReels, false);
    this.slotHeight = initScreenSymbols[0].getAttribute("array").split(",").length /
        this.numberOfReels;
    this.screenSymbols = new Array;
    for (var i = 0; i < this.numberOfReels; i++) {
        this.screenSymbols.push(new Array);
        for (var j = 0; j < this.slotHeight; j++) this.screenSymbols[i].push(0)
    }
    var payouts = config.getElementsByTagName("symbol");
    tempString = "";
    tempString += GameProtocolDictionary.paytable + "=";
    this.payoutData = new Array;
    for (var symbolIdx = 0; symbolIdx < payouts.length; symbolIdx++) {
        var currentPayouts = new Array;
        var values = payouts[symbolIdx].getAttribute("payout").split(",");
        for (var i = 0; i < values.length /
            2; i++) {
            tempString += values[2 * i];
            currentPayouts.push(_number.otoi(values[2 * i]));
            if (i < values.length / 2 - 1) tempString += ","
        }
        if (symbolIdx < payouts.length - 1) tempString += ";";
        currentPayouts.reverse();
        this.payoutData.push(currentPayouts)
    }
    this.AddParameterToResonse(tempString, false);
    var scatterSettings = new Array;
    this.scatterFSAwards = JSON.parse("[" + config.getElementsByTagName("spin")[0].getAttribute("array") + "]");
    scatterSettings.push(config.getElementsByTagName("spin")[0]);
    this.scatterFSAwards.reverse();
    this.scatterFSMultipliers =
        JSON.parse("[" + config.getElementsByTagName("spin_mul")[0].getAttribute("array") + "]");
    scatterSettings.push(config.getElementsByTagName("spin_mul")[0]);
    this.scatterFSMultipliers.reverse();
    this.scatterFSAdditional = JSON.parse("[" + config.getElementsByTagName("more_spins")[0].getAttribute("array") + "]");
    scatterSettings.push(config.getElementsByTagName("more_spins")[0]);
    this.scatterFSAdditional.reverse();
    tempString = "";
    tempString += GameProtocolDictionary.scatters + "=";
    var scatterId = 1;
    for (var symbolIdx = 0; symbolIdx <
        payouts.length; symbolIdx++)
        if (payouts[symbolIdx].getAttribute["name"].toLowerCase() == "scatter") scatterId = _number.otoi(payouts[symbolIdx].getAttribute["i"]);
    tempString += scatterId;
    for (var scatterSettingsIdx = 0; scatterSettingsIdx < scatterSettings.length; scatterSettingsIdx++)
        if (scatterSettingsIdx < scatterSettings.length - 1) tempString += "~" + scatterSettings[scatterSettingsIdx].getAttribute("array");
    this.AddParameterToResonse(tempString, false)
};
OfflineServer.prototype.AddParameterToResonse = function(parameter, isLast) {
    this.responseString += parameter + (isLast ? "" : "&")
};
OfflineServer.prototype.HandleRequest = function(postData) {
    if (postData == null) {
        console.warn("Null post data");
        return
    }
    var args = postData.split("&");
    for (var i = 0; i < args.length; ++i) {
        var arg = args[i].split("=");
        if (arg[0] == GameProtocolDictionary.coin)
            if (arg.length > 1) this.coinValue = _number.otod(arg[1])
    }
    for (var i = 0; i < args.length; ++i) {
        var arg = args[i].split("=");
        if (arg[0] == GameProtocolDictionary.Actions.action)
            if (arg.length > 1) this.SendResponse(arg[1]);
            else console.warn("Invalid post data " + postData)
    }
};
OfflineServer.prototype.SendResponse = function(gameAction) {
    this.responseString = "";
    this.index++;
    switch (gameAction) {
        case GameProtocolDictionary.Actions.doInit:
            this.responseString = this.GenerateInitResponse();
            break;
        case GameProtocolDictionary.Actions.doSpin:
            this.responseString = this.GenerateSpinResponse();
            break;
        case GameProtocolDictionary.Actions.doCollect:
            this.responseString = this.GenerateCollectResponse();
            break;
        default:
            console.warn("Got response for unknown action " + gameAction);
            break
    }
    console.log(this.responseString);
    RequestProvider.Instance.ParseOfflineResponse(this.responseString, false)
};
OfflineServer.prototype.GenerateInitResponse = function() {
    this.AddParameterToResonse(GameProtocolDictionary.Actions.doInit + this.ID_DELIMITER, true);
    this.ParseConfig();
    this.AddParameterToResonse("bonuses=0&sc=0.01,0.02,0.05,0.10,0.25,0.50,1.00,3.00,5.00&defc=0.01", false);
    this.AddParameterToResonse(GameProtocolDictionary.coin + "=" + this.coinValue.toFixed(2), false);
    this.AddParameterToResonse(GameProtocolDictionary.balance + "=" + this.balance.toFixed(2), false);
    this.AddParameterToResonse(GameProtocolDictionary.index +
        "=" + this.index, false);
    this.AddParameterToResonse(GameProtocolDictionary.counter + "=" + 2 * this.index, false);
    this.AddParameterToResonse(GameProtocolDictionary.time + "=" + this.GenerateTimeStamp(), true);
    return this.responseString
};
OfflineServer.prototype.GenerateSpinResponse = function() {
    this.GenerateTimeStamp();
    this.AddParameterToResonse(GameProtocolDictionary.Actions.doSpin + this.ID_DELIMITER, true);
    if (!this.isFreeSpins) this.balance -= this.coinValue * this.lines;
    this.AddParameterToResonse(GameProtocolDictionary.coin + "=" + this.coinValue.toFixed(2), false);
    this.AddParameterToResonse(GameProtocolDictionary.balance + "=" + this.balance.toFixed(2), false);
    this.AddParameterToResonse(GameProtocolDictionary.line + "=" + this.lines, false);
    this.AddParameterToResonse("sver=5&sh=3&b=0",
        false);
    this.AddParameterToResonse(GameProtocolDictionary.index + "=" + this.index, false);
    this.AddParameterToResonse(GameProtocolDictionary.counter + "=" + 2 * this.index, false);
    var reelsStopPositions = "";
    for (var i = 0; i < this.numberOfReels; i++) {
        this.stopPositions[i] = Math.floor(Math.random() * this.reelSymbols[i].length);
        reelsStopPositions += this.stopPositions[i] + (i < this.numberOfReels - 1 ? "," : "")
    }
    this.AddParameterToResonse(GameProtocolDictionary.reelsPosition + "=" + reelsStopPositions, false);
    this.ComputeScreenSymbols();
    var screenWinList = this.ComputeScreenWins();
    this.totalWin = 0;
    for (var screenWinIdx = 0; screenWinIdx < screenWinList.length; screenWinIdx++) {
        var lineWin = this.payoutData[screenWinList[screenWinIdx].dominatingSymbol][screenWinList[screenWinIdx].Positions.length - 1] * this.coinValue;
        this.totalWin += lineWin;
        var lineWinString = "l" + screenWinIdx + "=" + (screenWinList[screenWinIdx].Id - 1) + "~" + lineWin + "~";
        for (var posIdx = 0; posIdx < screenWinList[screenWinIdx].Positions.length; posIdx++) lineWinString += screenWinList[screenWinIdx].Positions[posIdx] +
            (posIdx < screenWinList[screenWinIdx].Positions.length - 1 ? "~" : "");
        this.AddParameterToResonse(lineWinString, false)
    }
    var tmp = "";
    var scattersOnScreen = 0;
    for (var i = 0; i < this.slotHeight; i++)
        for (var j = 0; j < this.numberOfReels; j++) {
            tmp += this.screenSymbols[j][i] + (i == this.slotHeight - 1 && j == this.numberOfReels - 1 ? "" : ",");
            if (this.screenSymbols[j][i] == 1) scattersOnScreen++
        }
    if (scattersOnScreen > 2)
        if (!this.isFreeSpins) this.InitFreeSpins(scattersOnScreen);
    if (this.isFreeSpins) {
        this.AddParameterToResonse(GameProtocolDictionary.freeSpinCurrentNumber +
            "=" + this.currentFreeSpin, false);
        this.currentFreeSpin++;
        this.freeSpinTotalWin += this.totalWin;
        this.freeSpinCurrentWinMultiplied = this.totalWin * this.freeSpinsCurrentMultiplier;
        if (this.currentFreeSpin <= this.maxFreeSpins) {
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinCurrentMultiplier + "=" + this.freeSpinsCurrentMultiplier, false);
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinMaxNumber + "=" + this.maxFreeSpins, false);
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinCurrentWin +
                "=" + this.freeSpinTotalWin.toFixed(2), false);
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinCurrentWinMultiplied + "=" + this.freeSpinTotalWin.toFixed(2), false)
        } else {
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinTotalMultipl + "=" + this.freeSpinsCurrentMultiplier, false);
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinTotalNumber + "=" + this.maxFreeSpins, false);
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinTotalWin + "=" + this.freeSpinTotalWin.toFixed(2), false);
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinTotalWinMultiplied +
                "=" + this.freeSpinTotalWin.toFixed(2), false)
        }
    }
    if (this.totalWin > 0)
        if (this.isFreeSpins)
            if (this.currentFreeSpin - 1 == this.maxFreeSpins) this.AddParameterToResonse(GameProtocolDictionary.NextActions.nextAction + "=" + GameProtocolDictionary.NextActions.Collect, false);
            else this.AddParameterToResonse(GameProtocolDictionary.NextActions.nextAction + "=" + GameProtocolDictionary.NextActions.Spin, false);
    else this.AddParameterToResonse(GameProtocolDictionary.NextActions.nextAction + "=" + GameProtocolDictionary.NextActions.Collect,
        false);
    else this.AddParameterToResonse(GameProtocolDictionary.NextActions.nextAction + "=" + GameProtocolDictionary.NextActions.Spin, false);
    this.AddParameterToResonse(GameProtocolDictionary.winAmountShort + "=" + this.totalWin.toFixed(2), false);
    this.AddParameterToResonse(GameProtocolDictionary.spinCycleWin + "=" + (this.isFreeSpins ? this.freeSpinTotalWin.toFixed(2) : this.totalWin.toFixed(2)), false);
    this.AddParameterToResonse(GameProtocolDictionary.winSymbols + "=" + tmp, false);
    this.AddParameterToResonse(GameProtocolDictionary.time +
        "=" + this.GenerateTimeStamp(), true);
    if (this.currentFreeSpin - 1 == this.maxFreeSpins) this.ResetFreeSpins();
    return this.responseString
};
OfflineServer.prototype.GenerateCollectResponse = function() {
    this.AddParameterToResonse(GameProtocolDictionary.Actions.doCollect + this.ID_DELIMITER, true);
    this.balance += this.totalWin;
    this.AddParameterToResonse(GameProtocolDictionary.balance + "=" + this.balance.toFixed(2), false);
    this.AddParameterToResonse("a=0&gs=0&sver=5&sh=3", false);
    this.AddParameterToResonse(GameProtocolDictionary.index + "=" + this.index, false);
    this.AddParameterToResonse(GameProtocolDictionary.counter + "=" + 2 * this.index, false);
    this.AddParameterToResonse(GameProtocolDictionary.NextActions.nextAction +
        "=" + GameProtocolDictionary.NextActions.Spin, false);
    this.AddParameterToResonse(GameProtocolDictionary.winAmountShort + "=" + this.totalWin.toFixed(2), false);
    this.AddParameterToResonse(GameProtocolDictionary.time + "=" + this.GenerateTimeStamp(), true);
    return this.responseString
};
OfflineServer.prototype.GenerateTimeStamp = function() {
    var timeStamp = Math.round((new Date).getTime() / 1E3);
    return timeStamp
};
OfflineServer.prototype.ProcessLinesDefinitions = function() {
    var buf = this.linesDefString.split("~");
    this.linesDef = new Array;
    for (var lineIdx = 0; lineIdx < buf.length; lineIdx++) {
        var tmp = new Array;
        for (var posIdx = 0; posIdx < buf[lineIdx].split(",").length; posIdx++) tmp.push(_number.otoi(buf[lineIdx].split(",")[posIdx]));
        this.linesDef.push(tmp)
    }
};
OfflineServer.prototype.ComputeScreenSymbols = function() {
    for (var i = 0; i < this.screenSymbols.length; i++)
        for (var j = 0; j < this.screenSymbols[i].length; j++) {
            var currentIdx = (this.stopPositions[i] - this.stopOffset + j + (this.reelSymbols[i].length - 1)) % (this.reelSymbols[i].length - 1);
            this.screenSymbols[i][j] = this.reelSymbols[i][currentIdx]
        }
};
OfflineServer.prototype.GetSymbolFromReel = function(pos, reel) {
    return this.screenSymbols[reel][pos]
};
OfflineServer.prototype.SymbolIsWild = function(id) {
    return id == 2
};
OfflineServer.prototype.InitFreeSpins = function(numberOfScatters) {
    this.isFreeSpins = true;
    this.currentFreeSpin = 1;
    this.maxFreeSpins = this.scatterFSAwards[numberOfScatters - 1];
    this.totalFreeSpins = this.scatterFSAwards[numberOfScatters - 1];
    this.freeSpinsCurrentMultiplier = this.scatterFSMultipliers[numberOfScatters - 1];
    this.freeSpinsTotalMultiplier = this.scatterFSMultipliers[numberOfScatters - 1];
    this.freeSpinCurrentWin = 0;
    this.freeSpinTotalWin = 0;
    this.freeSpinCurrentWinMultiplied = 0;
    this.freeSpinTotalWinMultiplied =
        0
};
OfflineServer.prototype.ResetFreeSpins = function() {
    this.isFreeSpins = false;
    this.currentFreeSpin = 0;
    this.maxFreeSpins = 0;
    this.totalFreeSpins = 0;
    this.freeSpinsCurrentMultiplier = 0;
    this.freeSpinsTotalMultiplier = 0;
    this.freeSpinCurrentWin = 0;
    this.freeSpinTotalWin = 0;
    this.freeSpinCurrentWinMultiplied = 0;
    this.freeSpinTotalWinMultiplied = 0
};
OfflineServer.prototype.ComputeScreenWins = function() {
    var betLines = new Array;
    for (var i = 0; i < this.lines; i++) {
        betLines[i] = new WinLineInfo;
        betLines[i].Id = i + 1;
        betLines[i].Positions = new Array;
        betLines[i].containsWild = false;
        for (var j = 0; j < this.numberOfReels; j++) betLines[i].Positions.push(this.linesDef[i][j])
    }
    for (var betLinesIdx = 0; betLinesIdx < betLines.length; betLinesIdx++) {
        var winningsymbol = 2;
        var actualwinningsymbol = -1;
        var leadingWilds = 0;
        for (var i = 0; i < betLines[betLinesIdx].Positions.length; i++) {
            var pos = betLines[betLinesIdx].Positions[i];
            var reelIdx = pos % this.numberOfReels;
            var reelPosIdx = Math.floor(pos / this.numberOfReels);
            var symbol = this.GetSymbolFromReel(reelPosIdx, reelIdx);
            if (actualwinningsymbol == -1) actualwinningsymbol = symbol;
            if (!this.SymbolIsWild(symbol))
                if (symbol != winningsymbol && !this.SymbolIsWild(winningsymbol) || symbol < 2) {
                    var newLength = i;
                    if (leadingWilds > 0)
                        if (this.payoutData[2][leadingWilds - 1] > this.payoutData[winningsymbol][newLength - 1]) {
                            newLength = leadingWilds;
                            winningsymbol = 2
                        }
                    var newPos = new Array;
                    for (var j = 0; j < newLength; j++) newPos[j] =
                        betLines[betLinesIdx].Positions[j];
                    betLines[betLinesIdx].Positions = newPos
                } else {
                    winningsymbol = symbol;
                    actualwinningsymbol = symbol
                }
            else if (leadingWilds == i) leadingWilds++;
            if (!betLines[betLinesIdx].containsWild) betLines[betLinesIdx].containsWild = this.SymbolIsWild(symbol)
        }
        betLines[betLinesIdx].dominatingSymbol = winningsymbol
    }
    var lineWins = new Array;
    for (var betLinesIdx = 0; betLinesIdx < betLines.length; betLinesIdx++)
        if (betLines[betLinesIdx].Positions.length >= 3) lineWins.push(betLines[betLinesIdx]);
    return lineWins
};
goog.require("UHT.Component");
goog.require("UHT.XTLink");
ReplayAction.prototype = Object.create(XTLink.prototype);
ReplayAction.prototype.constructor = ReplayAction;
var ReplayActionType = {
    NONE: 0,
    ANTE_BET_ON: 1,
    ANTE_BET_OFF: 2,
    SPIN_START: 3,
    FS_START_CONFIRM: 4,
    FS_OPTION_PICK: 5,
    FS_END_CONFIRM: 6,
    BG_ITEM_PICK: 7,
    GAMBLE_COLLECT: 8,
    GAMBLE_TYPE: 9,
    GAMBLE_PICK: 10
};

function OptionList() {
    this.colliders = [];
    this.setInt;
    this.triggerEvent
}

function ReplayAction() {
    XTLink.call(this);
    this.delay = 0;
    this.type = ReplayActionType.NONE;
    this.options = [];
    this.bgMultiplePicks = [];
    this.checkOnUpdate = false;
    this.cachedIndex = -1;
    this.cachedCollider
}
ReplayAction.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(ReplaySessionVars.PrepareAction, this.OnPrepare, this)
};
ReplayAction.prototype.OnPrepare = function() {
    var type = XT.GetInt(ReplaySessionVars.PrepareActionType);
    if (this.type == type) {
        var rq = XT.GetObject(ReplaySessionVars.ReplayDirector_Queue);
        this.cachedIndex = XT.GetInt(ReplaySessionVars.PrepareActionIndex);
        switch (this.type) {
            case ReplayActionType.BG_ITEM_PICK:
                XT.RegisterCallbackEvent("Replay_CheckBonusPickItem", this.CheckBonusPickItem, this);
                rq.AddRoutineQueueItem(new RQIWaitForXTEventWithCallback("Replay_BonusPickItemReady", "Replay_CheckBonusPickItem"));
                if (this.delay >
                    0) rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.delay));
                rq.AddRoutineQueueItem(new RQITriggerCallback(this.Execute, null, this));
                break;
            default:
                if (this.delay > 0) rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.delay));
                rq.AddRoutineQueueItem(new RQITriggerCallback(this.Execute, null, this));
                break
        }
    }
};
ReplayAction.prototype.Execute = function(param) {
    var index = this.cachedIndex;
    switch (this.type) {
        case ReplayActionType.ANTE_BET_ON:
            this.AnteBetToggle(index);
            break;
        case ReplayActionType.ANTE_BET_OFF:
            this.AnteBetToggle(index);
            break;
        case ReplayActionType.SPIN_START:
            break;
        case ReplayActionType.FS_START_CONFIRM:
            break;
        case ReplayActionType.FS_OPTION_PICK:
            var fsOptions = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["FSOptions"], true)[0];
            var colliders = fsOptions["pickableOptions"][this.cachedIndex].GetComponentsInChildren(Collider,
                true);
            for (var i = 0; i < colliders.length; i++)
                if (colliders[i].enabled && colliders[i].gameObject.activeInHierarchy) {
                    colliders[i].gameObject.SendMessage("OnHover");
                    colliders[i].gameObject.SendMessage("OnClick")
                }
            break;
        case ReplayActionType.FS_END_CONFIRM:
            break;
        case ReplayActionType.BG_ITEM_PICK:
            this.cachedCollider.gameObject.SendMessage("OnHover");
            this.cachedCollider.gameObject.SendMessage("OnClick");
            break;
        case ReplayActionType.GAMBLE_COLLECT:
            break;
        case ReplayActionType.GAMBLE_TYPE:
            break;
        case ReplayActionType.GAMBLE_PICK:
            break
    }
    if (index <
        this.options.length) {
        for (var c = 0; c < this.options[index].colliders.length; c++) {
            var collider = this.options[index].colliders[c].GetComponent(Collider);
            collider.SendMessage("OnClick")
        }
        XT.SetInt(this.options[index].setInt.name, index);
        XT.TriggerEvent(this.options[index].triggerEvent.name)
    }
};
ReplayAction.prototype.AnteBetToggle = function(index) {
    var betLevelDisplayer = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["BetLevelDisplayer"], true)[0];
    if (betLevelDisplayer["showBetScale"][1 - index].cat.transform.children.length > 0) {
        var firstChild = betLevelDisplayer["showBetScale"][1 - index].cat.transform.children[0];
        if (firstChild.GetComponentsInChildren(CAT_Container, true).length > 0) {
            var buttonCATevents = firstChild.GetComponentsInChildren(CAT_Container, true)[0].events;
            for (var i = 0; i < buttonCATevents.length; i++)
                if (buttonCATevents[i].userFriendlyName ==
                    "Click") {
                    buttonCATevents[i].Start();
                    break
                }
        }
    }
};
ReplayAction.prototype.BonusPickItemCanBeClicked = function() {
    for (var i = 0; i < this.bgMultiplePicks.length; i++)
        if (this.bgMultiplePicks[i].xtEnabled && this.bgMultiplePicks[i]["pickItems"][this.cachedIndex].gameObject.activeInHierarchy) {
            var colliders = this.bgMultiplePicks[i]["pickItems"][this.cachedIndex].GetComponentsInChildren(Collider, true);
            for (var j = 0; j < colliders.length; j++)
                if (colliders[j].enabled) {
                    this.cachedCollider = colliders[j];
                    return true
                }
        }
    return false
};
ReplayAction.prototype.CheckBonusPickItem = function() {
    this.bgMultiplePicks = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["BonusGameMultiplePicks"], true);
    this.checkOnUpdate = true
};
ReplayAction.prototype.Update = function() {
    if (this.checkOnUpdate && this.type == ReplayActionType.BG_ITEM_PICK)
        if (this.BonusPickItemCanBeClicked()) {
            this.checkOnUpdate = false;
            XT.TriggerEvent("Replay_BonusPickItemReady");
            XT.UnregisterCallbackEvent(this.CheckBonusPickItem, this)
        }
};
goog.require("UHT.XTLink");
var ReplayAPI = {};
ReplayAPI.Keys = {
    replaySystemUrl: "replaySystemUrl",
    replaySystemContextPath: "replaySystemContextPath",
    environmentId: "environmentId",
    envID: "envID",
    error: "error",
    description: "description",
    topList: "topList",
    roundID: "roundID",
    playedDate: "playedDate",
    bet: "bet",
    base_bet: "base_bet",
    win: "win",
    rtp: "rtp",
    sharedLink: "sharedLink",
    token: "token"
};
ReplayAPI.ErrorCode = {
    Undefined: -1,
    None: 0,
    NotAuthorized: 10,
    ServerError: 100
};
ReplayAPI.WinningRound = function() {
    this.roundID = 0;
    this.playedDate = 0;
    this.bet = 0;
    this.base_bet = 0;
    this.win = 0;
    this.rtp = 0;
    this.sharedLink = ""
};
ReplayAPI.WinningRound.CompareByPlayedDate = function(x, y) {
    var ret = y.playedDate - x.playedDate;
    return ret == 0 ? 0 : ret > 0 ? 1 : -1
};
ReplayAPI.WinningRound.CompareByRTP = function(x, y) {
    var ret = Math.floor(y.rtp) - Math.floor(x.rtp);
    if (ret == 0) return ReplayAPI.WinningRound.CompareByPlayedDate(x, y);
    return ret
};
ReplayAPI.GameHistoryAction = function() {
    this.index = 0;
    this.request = "";
    this.response = ""
};
ReplayAPI.Response = function(response) {
    this.error = ReplayAPI.ErrorCode.Undefined;
    this.description = "";
    this.dictionary = null;
    if (response != undefined) {
        this.error = response.error;
        this.description = response.description
    }
};
ReplayAPI.WinningsResponse = function(response) {
    ReplayAPI.Response.call(this, response);
    this.winnings = null
};
ReplayAPI.WinningsResponse.prototype = Object.create(ReplayAPI.Response.prototype);
ReplayAPI.WinningsResponse.prototype.constructor = ReplayAPI.WinningsResponse;
ReplayAPI.ShareLinkResponse = function(response) {
    ReplayAPI.Response.call(this, response);
    this.sharedLink = ""
};
ReplayAPI.ShareLinkResponse.prototype = Object.create(ReplayAPI.Response.prototype);
ReplayAPI.ShareLinkResponse.prototype.constructor = ReplayAPI.ShareLinkResponse;
ReplayAPI.Parser = {};
ReplayAPI.Parser.ParseResponse = function(json) {
    var Keys = ReplayAPI.Keys;
    var ErrorCode = ReplayAPI.ErrorCode;
    var Response = ReplayAPI.Response;
    if (_string.IsNullOrEmpty(json)) return null;
    var dict = _JSON.TryParse(json);
    if (dict == null || dict[Keys.error] == undefined || dict[Keys.description] == undefined) return null;
    var res = new Response;
    res.dictionary = dict;
    res.description = String(dict[Keys.description]);
    var error = Number(dict[Keys.error]);
    XT.SetInt(ReplayVars.Replay_LastResponseErrorCode, error);
    for (var key in ErrorCode)
        if (ErrorCode.hasOwnProperty(key) &&
            ErrorCode[key] == error) {
            res.error = ErrorCode[key];
            break
        }
    if (res.error != ErrorCode.None) return null;
    return res
};
ReplayAPI.Parser.ParseWinningsResponse = function(json) {
    var Parser = ReplayAPI.Parser;
    var Keys = ReplayAPI.Keys;
    var WinningsResponse = ReplayAPI.WinningsResponse;
    var response = Parser.ParseResponse(json);
    if (XT.GetInt(ReplayVars.Replay_LastResponseErrorCode) == 10) {
        var res = new WinningsResponse(new ReplayAPI.Response);
        res.winnings = [];
        return res
    }
    if (response == null) return null;
    var dict = response.dictionary;
    if (dict[Keys.topList] == undefined) return null;
    var res = new WinningsResponse(response);
    res.winnings = Parser.ParseWinnings(dict[Keys.topList]);
    return res
};
ReplayAPI.Parser.ParseWinnings = function(list) {
    var Keys = ReplayAPI.Keys;
    var WinningRound = ReplayAPI.WinningRound;
    if (list == null) return null;
    var res = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null || dict[Keys.roundID] == undefined || dict[Keys.playedDate] == undefined || dict[Keys.bet] == undefined || dict[Keys.win] == undefined || dict[Keys.rtp] == undefined) continue;
        var item = new WinningRound;
        item.roundID = Number(dict[Keys.roundID]);
        item.playedDate = Number(dict[Keys.playedDate]);
        if (dict[Keys.base_bet] != undefined) {
            item.base_bet =
                Number(dict[Keys.bet]);
            item.bet = Number(dict[Keys.base_bet])
        } else item.bet = Number(dict[Keys.bet]);
        item.win = Number(dict[Keys.win]);
        item.rtp = Number(dict[Keys.rtp]);
        if (dict[Keys.sharedLink] != undefined) item.sharedLink = String(dict[Keys.sharedLink]);
        res.push(item)
    }
    return res
};
ReplayAPI.Parser.ParseSharedLinkResponse = function(json) {
    var Parser = ReplayAPI.Parser;
    var Keys = ReplayAPI.Keys;
    var ShareLinkResponse = ReplayAPI.ShareLinkResponse;
    var response = Parser.ParseResponse(json);
    if (response == null) return null;
    var dict = response.dictionary;
    if (dict[Keys.sharedLink] == undefined) return null;
    var res = new ShareLinkResponse(response);
    res.sharedLink = String(dict[Keys.sharedLink]);
    return res
};
var ReplayVars = {
    Replay_Winnings: "Replay_Winnings",
    Replay_WinningsEnabled: "Replay_WinningsEnabled",
    Evt_Internal_Replay_RequestWinnings: "Evt_Internal_Replay_RequestWinnings",
    Evt_Internal_Replay_RequestSharedLink: "Evt_Internal_Replay_RequestSharedLink",
    Replay_SharedLinkRound: "Replay_SharedLinkRound",
    Evt_Internal_Replay_RoundSharedLinkUpdated: "Evt_Internal_Replay_RoundSharedLinkUpdated",
    Evt_Internal_Replay_RoundSharedLinkCopied: "Evt_Internal_Replay_RoundSharedLinkCopied",
    Evt_DataToCode_Replay_OpenWinnings: "Evt_DataToCode_Replay_OpenWinnings",
    Evt_CodeToData_Replay_OpenSelectedRound: "Evt_CodeToData_Replay_OpenSelectedRound",
    Replay_SelectedRound: "Replay_SelectedRound",
    Replay_CategoryIndex: "Replay_CategoryIndex",
    Evt_DataToCode_Replay_CategoryIndexUpdated: "Evt_DataToCode_Replay_CategoryIndexUpdated",
    Evt_Internal_Replay_WatchSelectedRound: "Evt_Internal_Replay_WatchSelectedRound",
    Replay_LastResponseErrorCode: "Replay_LastResponseErrorCode"
};
ReplayConnection.prototype = Object.create(XTLink.prototype);
ReplayConnection.prototype.constructor = ReplayConnection;

function ReplayConnection() {
    XTLink.call(this);
    this.winningsURL = "";
    this.sharedLinkURL = "";
    this.sharedLinkRequests = [];
    this.sharedLinkRounds = [];
    this.winningsResponseHandler = new EventHandler(this, this.OnWinningsResponse);
    this.sharedLinkResponseHandler = new EventHandler(this, this.OnSharedLinkResponse)
}
ReplayConnection.watchURL = "";
ReplayConnection.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackEvent(ReplayVars.Evt_Internal_Replay_RequestWinnings, this.RequestWinnings, this);
    XT.RegisterCallbackEvent(ReplayVars.Evt_Internal_Replay_RequestSharedLink, this.RequestSharedLink, this)
};
ReplayConnection.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(ReplayVars.Replay_Winnings, null);
    XT.SetBool(ReplayVars.Replay_WinningsEnabled, false);
    XT.SetObject(ReplayVars.Replay_SelectedRound, null);
    XT.SetInt(ReplayVars.Replay_LastResponseErrorCode, 0)
};
ReplayConnection.prototype.OnGameInit = function() {
    if (window["UHT_REPLAY_DISABLED"]) return;
    var config = UHT_GAME_CONFIG_SRC;
    if (config == null || config[ReplayAPI.Keys.environmentId] == undefined || config[ReplayAPI.Keys.replaySystemUrl] == undefined) return;
    if (config["replayMode"] == true) {
        globalTracking.SendEvent("uht_behaviour_replay", "Shared_replay_started_watching", 1, "BehaviourTracker");
        return
    } else globalTracking.SendEvent("uht_behaviour_replay", "Ingame_replay_available", 1, "BehaviourTracker");
    var url = config[ReplayAPI.Keys.replaySystemUrl];
    var contextPath = "/ReplayService";
    if (config[ReplayAPI.Keys.replaySystemContextPath] != undefined) contextPath = config[ReplayAPI.Keys.replaySystemContextPath];
    var query = "?" + [GameProtocolDictionary.mgckey + "=" + ServerOptions.mgckey, ReplayAPI.Keys.envID + "=" + config[ReplayAPI.Keys.environmentId]].join("&");
    var watchQuery = "?" + [ReplayAPI.Keys.token + "=" + ServerOptions.mgckey, ReplayAPI.Keys.envID + "=" + config[ReplayAPI.Keys.environmentId]].join("&");
    ReplayConnection.watchURL = url + contextPath + "/replayGame.do" + watchQuery;
    this.winningsURL = url + contextPath + "/api/top/winnings/list" + query;
    this.sharedLinkURL = url + contextPath + "/api/top/share/link" + query;
    XT.SetBool(ReplayVars.Replay_WinningsEnabled, true)
};
var GA_SENT_REPLAY_OPENED = false;
ReplayConnection.prototype.RequestWinnings = function() {
    if (!GA_SENT_REPLAY_OPENED) {
        globalTracking.SendEvent("uht_behaviour_replay", "Ingame_replay_opened_window", 1, "BehaviourTracker");
        GA_SENT_REPLAY_OPENED = true
    }
    var req = new ServerRequest;
    req.Url = this.winningsURL;
    req.Handler = this.winningsResponseHandler;
    req.Method = "GET";
    RequestManager.AddRequest(req)
};
ReplayConnection.prototype.OnWinningsResponse = function(param, statusCode) {
    var response = ReplayAPI.Parser.ParseWinningsResponse(param);
    if (response == null) {
        console.error("ReplayAPI ERROR: could not parse /top/winnings/list");
        return
    }
    XT.SetObject(ReplayVars.Replay_Winnings, response.winnings)
};
ReplayConnection.prototype.RequestSharedLink = function() {
    var round = XT.GetObject(ReplayVars.Replay_SharedLinkRound);
    if (round == null) return;
    for (var i = 0; i < this.sharedLinkRounds.length; ++i)
        if (this.sharedLinkRounds[i].roundID == round.roundID) return;
    var req = new ServerRequest;
    req.Url = this.sharedLinkURL + "&" + ReplayAPI.Keys.roundID + "=" + round.roundID;
    req.Handler = this.sharedLinkResponseHandler;
    if (this.sharedLinkRequests.length == 0) RequestManager.AddRequest(req);
    this.sharedLinkRequests.push(req);
    this.sharedLinkRounds.push(round)
};
ReplayConnection.prototype.OnSharedLinkResponse = function(param, statusCode) {
    var response = ReplayAPI.Parser.ParseSharedLinkResponse(param);
    if (response != null) {
        var round = this.sharedLinkRounds[0];
        round.sharedLink = response.sharedLink;
        XT.SetObject(ReplayVars.Replay_SharedLinkRound, round);
        XT.TriggerEvent(ReplayVars.Evt_Internal_Replay_RoundSharedLinkUpdated)
    } else console.error("ReplayAPI ERROR: could not parse /top/share/link");
    this.sharedLinkRequests.splice(0, 1);
    this.sharedLinkRounds.splice(0, 1);
    if (this.sharedLinkRequests.length >
        0) RequestManager.AddRequest(this.sharedLinkRequests[0])
};
goog.require("UHT.XTLink");
ReplayDirector.prototype = Object.create(XTLink.prototype);
ReplayDirector.prototype.constructor = ReplayDirector;

function ReplayDirector() {
    XTLink.call(this);
    this.rq;
    this.RDLDhandled = false;
    this.currentStage = UHTStageName.No_Stage
}
ReplayDirector.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(ReplaySessionVars.ReplayDirector_Start, this.OnReplayDirectorStart, this)
};
ReplayDirector.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(ReplaySessionVars.Replay_Paused, false)
};
ReplayDirector.prototype.OnReplayDirectorStart = function() {
    this.rq = this.gameObject.GetComponent(RoutineQueue);
    XT.SetObject(ReplaySessionVars.ReplayDirector_Queue, this.rq);
    XT.RegisterCallbackBool(ReplaySessionVars.Replay_Paused, this.OnReplayPauseChanged, this);
    XT.RegisterCallbackObject(Vars.ToStageName, this.OnStageChange, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_LoopDone, this.OnResultDisplayerLoopDone,
        this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowFSBGPick, this.OnShowFSBGPick, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_FreeSpinsShowWindowWin, this.OnFreeSpinsShowWindowWin, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_BonusInitDone, this.OnBonusInitDone, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_BonusResponseReceived, this.OnSpinStarted, this);
    XT.RegisterCallbackEvent(BGVars.Evt_Internal_ShowLevel, this.OnShowBonusGame, this);
    this.PatchButtonAutoClickers(1)
};
ReplayDirector.prototype.OnReplayPauseChanged = function(paused) {
    Globals.InputBlocked = !paused;
    if (!paused) this.OnResultDisplayerLoopDone()
};
ReplayDirector.prototype.OnStageChange = function(stage) {
    this.currentStage = stage
};
ReplayDirector.prototype.OnShowFSBGPick = function() {
    this.Check(ReplayScenarioTriggerType.SHOW_FSBG_PICK)
};
ReplayDirector.prototype.OnShowBonusGame = function() {
    if (!window["BonusGameMultiplePicks"]) return;
    this.Check(ReplayScenarioTriggerType.SHOW_BG_MULTIPLE_ITEM_PICK);
    XT.UnregisterCallbackEvent(this.OnBonusPickItem, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_BonusResponseReceived, this.OnBonusPickItem, this)
};
ReplayDirector.prototype.OnBonusPickItem = function() {
    this.Check(ReplayScenarioTriggerType.SHOW_BG_MULTIPLE_ITEM_PICK)
};
ReplayDirector.prototype.OnFreeSpinsShowWindowWin = function() {
    this.Check(ReplayScenarioTriggerType.FS_SHOW_WINDOW_WIN);
    this.PatchButtonAutoClickers(2)
};
ReplayDirector.prototype.OnResultDisplayerLoopDone = function() {
    if (this.RDLDhandled || XT.GetBool(Vars.WaitInResultForBigWin) || XT.GetBool(Vars.LastWinIsCounting) || this.currentStage != UHTStageName.Result || XT.GetBool(Vars.SpinBlockingFeatureIsRunning) || XT.GetBool(Vars.MustOpenBonus)) return;
    if (RequestProvider.Instance.ReplayEnded()) XT.SetBool(ReplaySessionVars.Replay_Paused, true);
    if (XT.GetBool(ReplaySessionVars.Replay_Paused)) return;
    this.RDLDhandled = true;
    this.Check(ReplayScenarioTriggerType.IDLE_RESULT);
    this.PatchButtonAutoClickers(1)
};
ReplayDirector.prototype.OnSpinStarted = function() {
    this.RDLDhandled = false
};
ReplayDirector.prototype.OnBonusInitDone = function() {
    this.PatchRespinButtons(1)
};
ReplayDirector.prototype.Check = function(iType) {
    if (XT.GetBool(ReplaySessionVars.Replay_Paused)) return;
    XT.SetInt(ReplaySessionVars.PrepareScenarioType, iType);
    XT.TriggerEvent(ReplaySessionVars.PrepareScenario);
    if (this.rq.rqiList.length > 0) this.rq.StartRoutines()
};
ReplayDirector.prototype.PatchButtonAutoClickers = function(delayMultiplier) {
    var hotKeyClicker = globalRuntime.sceneRoots[1].GetComponentsInChildren(HotKeyClicker, true);
    for (var i = 0; i < hotKeyClicker.length; i++) {
        if (hotKeyClicker[i].transform.parent.gameObject.name == "ReplayLBLSkipper") continue;
        if (hotKeyClicker[i].transform.GetComponentsInChildren(ButtonAutoClicker, true).length == 0) hotKeyClicker[i].gameObject.AddComponent("ButtonAutoClicker");
        var buttons = hotKeyClicker[i].transform.GetComponentsInChildren(ButtonAutoClicker,
            true);
        for (var j = 0; j < buttons.length; j++) {
            buttons[j].transform.GetComponentsInChildren(ButtonAutoClicker, true)[0].delay = 3;
            buttons[j].transform.GetComponentsInChildren(ButtonAutoClicker, true)[0].delayInAutoplay = 3
        }
    }
    var clickers = globalRuntime.sceneRoots[1].GetComponentsInChildren(ButtonAutoClicker, true);
    for (var i = 0; i < clickers.length; i++) clickers[i].delay = clickers[i].delayInAutoplay * delayMultiplier
};
ReplayDirector.prototype.PatchRespinButtons = function(delay) {
    if (!window["BonusRespinLink_base"]) return;
    var bonusRespin = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["BonusRespinLink_base"], true);
    for (var i = 0; i < bonusRespin.length; i++) {
        var buttons = bonusRespin[i].transform.GetComponentsInChildren(CATButton, true);
        for (var j = 0; j < buttons.length; j++) {
            if (buttons[j].transform.GetComponentsInChildren(ButtonAutoClicker, true).length == 0) buttons[j].gameObject.AddComponent("ButtonAutoClicker");
            buttons[j].transform.GetComponentsInChildren(ButtonAutoClicker,
                true)[0].delay = delay;
            buttons[j].transform.GetComponentsInChildren(ButtonAutoClicker, true)[0].delayInAutoplay = delay
        }
    }
};
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
ReplayLineByLineSkipper.prototype = Object.create(XTLink.prototype);
ReplayLineByLineSkipper.prototype.constructor = ReplayLineByLineSkipper;

function ReplayLineByLineSkipper() {
    XTLink.call(this);
    this.handledCurrentResult = false
}
ReplayLineByLineSkipper.prototype.XTRegisterCallbacks = function() {
    if (!ServerOptions.isReplay) return;
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop, this.OnDoLoop, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_LoopDone, this.OnLoopDone, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_InjectRQIBeforeEndOfDisplayLoop, this.OnBeforeEndOfDisplayLoop, this)
};
ReplayLineByLineSkipper.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnSpinStarted, this);
    XT.UnregisterCallbackEvent(this.OnDoLoop, this);
    XT.UnregisterCallbackEvent(this.OnLoopDone, this);
    XT.UnregisterCallbackEvent(this.OnBeforeEndOfDisplayLoop, this)
};
ReplayLineByLineSkipper.prototype.ClickedLineByLineSkipperCollider = function() {
    var rqm = XT.GetObject(Vars.RQManagerObject);
    var markerIndexes = [];
    for (var i = 0; i < rqm.rqiList.length; i++)
        if (rqm.rqiList[i].constructor.name == "RQIMarker") markerIndexes.push(i);
    while (markerIndexes.length > 0) {
        var tmp = rqm.rqiList[markerIndexes[0]];
        if (tmp.type == RQIMarker.MarkerType.StartLineByLine) {
            rqm.rqiList.splice(markerIndexes[0], markerIndexes[1] - markerIndexes[0] + 1);
            markerIndexes.splice(0, 2)
        } else {
            rqm.rqiList.splice(0, markerIndexes[0]);
            markerIndexes.splice(0, 1)
        }
    }
    XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    this.handledCurrentResult = true
};
ReplayLineByLineSkipper.prototype.OnSpinStarted = function() {
    this.gameObject.SetActive(false);
    this.handledCurrentResult = false
};
ReplayLineByLineSkipper.prototype.OnDoLoop = function() {
    this.gameObject.SetActive(true)
};
ReplayLineByLineSkipper.prototype.OnLoopDone = function() {
    this.gameObject.SetActive(false)
};
ReplayLineByLineSkipper.prototype.OnBeforeEndOfDisplayLoop = function() {
    if (this.handledCurrentResult) this.ClickedLineByLineSkipperCollider()
};
goog.require("UHT.XTLink");
ReplayLocationAwareButtonController.prototype = Object.create(XTLink.prototype);
ReplayLocationAwareButtonController.prototype.constructor = ReplayLocationAwareButtonController;

function ReplayLocationAwareButtonController() {
    XTLink.call(this);
    this.createLinkButtons = null;
    this.copyLinkButtons = null;
    this.sharedLink = "";
    this.sharedLinkReceived = false
}
ReplayLocationAwareButtonController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(ReplaySessionVars.Replay_Paused, this.OnReplayPauseChanged, this)
};
ReplayLocationAwareButtonController.prototype.OnReplayPauseChanged = function(param) {
    if (param == false) return;
    if (location.href.indexOf("envID") != -1 || location.href.indexOf("roundID") != -1) {
        this.sharedLink = "";
        for (var i = 0; i < this.createLinkButtons.length; i++) this.createLinkButtons[i].SetActive(true);
        for (var i = 0; i < this.copyLinkButtons.length; i++) this.copyLinkButtons[i].SetActive(false)
    } else {
        this.sharedLink = location.href;
        for (var i = 0; i < this.createLinkButtons.length; i++) this.createLinkButtons[i].SetActive(false);
        for (var i = 0; i < this.copyLinkButtons.length; i++) this.copyLinkButtons[i].SetActive(true)
    }
};
var GA_SENT_REPLAYED_CREATED = false;
ReplayLocationAwareButtonController.prototype.CreateLink = function() {
    globalTracking.SendEvent("uht_behaviour_replay", "Shared_replay_created_link", GA_SENT_REPLAYED_CREATED ? 0 : 1, "BehaviourTracker");
    GA_SENT_REPLAYED_CREATED = true;
    var url = UHT_GAME_CONFIG_SRC["replaySystemUrl"] + "/ReplayService/api/top/share/link?mgckey=" + UHT_GAME_CONFIG_SRC["mgckey"] + "&roundID=" + UHT_GAME_CONFIG_SRC["replayRoundId"] + "&envID=" + UHT_GAME_CONFIG_SRC["environmentId"];
    var self = this;
    var xhr = new XMLHttpRequest;
    xhr.onreadystatechange =
        function(event) {
            var xhr = event.target;
            if (xhr.readyState == 4)
                if (xhr.status == 200) try {
                    var response = JSON.parse(xhr.responseText);
                    if (response != null) {
                        self.sharedLink = response.sharedLink;
                        self.sharedLinkReceived = true
                    }
                } catch (e) {}
        };
    xhr.open("GET", url, true);
    xhr.send(null)
};
var GA_SENT_REPLAYED_COPIED = false;
ReplayLocationAwareButtonController.prototype.CopyLink = function() {
    globalTracking.SendEvent("uht_behaviour_replay", "Shared_replay_copied_link", GA_SENT_REPLAYED_COPIED ? 0 : 1, "BehaviourTracker");
    GA_SENT_REPLAYED_COPIED = true;
    if (!_Clipboard.CopyText(this.sharedLink)) prompt("", this.sharedLink)
};
ReplayLocationAwareButtonController.prototype.Update = function() {
    if (this.sharedLinkReceived) {
        for (var i = 0; i < this.createLinkButtons.length; i++) this.createLinkButtons[i].SetActive(false);
        for (var i = 0; i < this.copyLinkButtons.length; i++) this.copyLinkButtons[i].SetActive(true);
        this.sharedLinkReceived = false
    }
};
goog.require("UHT.XTLink");
var ReplaySessionVars = {
    ReplayDirector_Start: "ReplayDirector_Start",
    ReplayDirector_Queue: "ReplayDirector_Queue",
    PrepareScenario: "PrepareScenario",
    PrepareScenarioType: "PrepareScenarioType",
    PrepareAction: "PrepareAction",
    PrepareActionType: "PrepareActionType",
    PrepareActionIndex: "PrepareActionIndex",
    ShowReplayTitle: "ShowReplayTitle",
    Replay_Paused: "Replay_Paused",
    Replay_UserClicked: "Replay_UserClicked"
};
ReplayManager.prototype = Object.create(XTLink.prototype);
ReplayManager.prototype.constructor = ReplayManager;

function ReplayManager() {
    XTLink.call(this)
}
ReplayManager.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(ReplaySessionVars.ShowReplayTitle, false)
};
ReplayManager.prototype.XTRegisterCallbacks = function() {
    if (!ServerOptions.isReplay) return;
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Init_SymbolManager, this.OnInitSymbolManager, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ShowBigWin, this.OnShowBigWin, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_BigWinHasFinished, this.OnBigWinHasFinished, this)
};
ReplayManager.prototype.OnInitSymbolManager = function() {
    XT.SetBool(Vars.DisableIntroScreen, true);
    XT.SetFloat(Vars.SoundVolume, .5);
    createjs.Sound.setVolume(.5)
};
ReplayManager.prototype.OnGameInit = function() {
    XT.TriggerEvent(ReplaySessionVars.ReplayDirector_Start);
    Globals.InputBlocked = true;
    XT.SetBool(Vars.Jurisdiction_GameTitle, false);
    this.HideClocks();
    this.HidePragmaticPlayLabels();
    this.HideBalance();
    this.HideMenuItems();
    this.MarkSoundButtonColliders();
    this.MarkLineByLineSkipperColliders();
    XT.SetBool(ReplaySessionVars.ShowReplayTitle, true)
};
ReplayManager.prototype.OnShowBigWin = function() {
    Globals.InputBlocked = false
};
ReplayManager.prototype.OnBigWinHasFinished = function() {
    Globals.InputBlocked = true
};
ReplayManager.prototype.HideClocks = function() {
    var clocks = globalRuntime.sceneRoots[1].GetComponentsInChildren(ClockDisplayer, true);
    for (var i = 0; i < clocks.length; i++) clocks[i].gameObject.SetActive(false)
};
ReplayManager.prototype.HidePragmaticPlayLabels = function() {
    var labels = globalRuntime.sceneRoots[1].GetComponentsInChildren(UILabel, true);
    for (var i = 0; i < labels.length; i++)
        if (labels[i].text == "PRAGMATIC PLAY") labels[i].text = ""
};
ReplayManager.prototype.HideBalance = function() {
    var balanceParents;
    if (!Globals.isMobile) {
        var ic = globalRuntime.sceneRoots[1].GetComponentInChildren(window["InterfaceController"], true);
        balanceParents = [ic.balanceParent, ic.bonusBalanceParent];
        for (var i = 0; i < ic.visibleInSpecialFeatures.length; i++)
            for (var j = 0; j < ic.visibleInSpecialFeatures[i].transform.children.length; j++) {
                var child = ic.visibleInSpecialFeatures[i].transform.children[j];
                if (child.gameObject.name == "Information") balanceParents.push(child.gameObject)
            }
    } else {
        var ic1 =
            globalRuntime.sceneRoots[1].GetComponentInChildren(window["InterfaceControllerMobile_1"], true);
        var ic2 = globalRuntime.sceneRoots[1].GetComponentInChildren(window["InterfaceControllerMobile_2"], true);
        balanceParents = [ic1.balanceParent, ic1.bonusBalanceParent, ic2.balanceParent, ic2.bonusBalanceParent];
        for (var i = 0; i < ic1["toggledInBonusGame"].active.length; i++)
            if (ic1["toggledInBonusGame"].active[i].name.indexOf("Balance") != -1) balanceParents.push(ic1["toggledInBonusGame"].active[i])
    }
    for (var i = 0; i < balanceParents.length; i++)
        for (var j =
                0; j < balanceParents[i].transform.children.length; j++) {
            var child = balanceParents[i].transform.children[j];
            if (child.gameObject.name.indexOf("Balance") != -1) child.gameObject.SetActive(false)
        }
};
ReplayManager.prototype.HideMenuItems = function() {
    var menuItems;
    if (!Globals.isMobile) {
        var ic = globalRuntime.sceneRoots[1].GetComponentInChildren(window["InterfaceController"], true);
        menuItems = [ic.payTableBtn.closed.transform.parent.gameObject, ic.settingsBtns[0].closed.transform.parent.gameObject, ic.settingsBtns[1].closed.transform.parent.gameObject];
        var filteredToggledInHiddenMode = new Array(ic.toggledInHiddenMode.length - 1);
        var filteredIndex = 0;
        for (var i = 0; i < ic.toggledInHiddenMode.length; i++)
            if (ic.toggledInHiddenMode[i].name !=
                "Paytable") {
                filteredToggledInHiddenMode[filteredIndex] = ic.toggledInHiddenMode[i];
                filteredIndex++
            }
        ic.toggledInHiddenMode = filteredToggledInHiddenMode;
        var soundButtonControllers = ic.GetComponentsInChildren(SoundButtonControllerMobile, true);
        for (var i = 0; i < soundButtonControllers.length; i++) soundButtonControllers[i].gameObject.SetActive(false);
        for (var i = 0; i < ic.visibleInSpecialFeatures.length; i++)
            for (var j = 0; j < ic.visibleInSpecialFeatures[i].transform.children.length; j++) {
                var child = ic.visibleInSpecialFeatures[i].transform.children[j];
                if (child.gameObject.name == "Paytable") menuItems.push(child.gameObject)
            }
    } else {
        var ic1 = globalRuntime.sceneRoots[1].GetComponentInChildren(window["InterfaceControllerMobile_1"], true);
        var ic2 = globalRuntime.sceneRoots[1].GetComponentInChildren(window["InterfaceControllerMobile_2"], true);
        menuItems = [ic1["menuButtonsParent"], ic2["menuButtonsParent"]];
        var arranger = globalRuntime.sceneRoots[1].GetComponentInChildren(GUIArranger, true);
        var bottomBars = [arranger.landscapeObjects.BottomBar];
        for (var i = 0; i < ic2["contentInterface"].transform.children.length; i++) {
            var child =
                ic2["contentInterface"].transform.children[i];
            if (child.gameObject.name == "BottomBar") {
                bottomBars.push(child.gameObject);
                break
            }
        }
        for (var i = 0; i < bottomBars.length; i++)
            for (var j = 0; j < bottomBars[i].transform.children.length; j++) {
                var child = bottomBars[i].transform.children[j];
                if (child.gameObject.name == "AnchoredRight") menuItems.push(child.gameObject)
            }
    }
    for (var i = 0; i < menuItems.length; i++) menuItems[i].SetActive(false)
};
ReplayManager.prototype.MarkSoundButtonColliders = function() {
    var soundControllers = this.transform.GetComponentsInChildren(SoundButtonControllerMobile, true);
    for (var i = 0; i < soundControllers.length; i++) {
        var colliders = soundControllers[i].transform.GetComponentsInChildren(Collider, true);
        for (var j = 0; j < colliders.length; j++) colliders[j].usedForReplay = true
    }
};
ReplayManager.prototype.MarkLineByLineSkipperColliders = function() {
    var skippers = this.transform.GetComponentsInChildren(ReplayLineByLineSkipper, true);
    for (var i = 0; i < skippers.length; i++) {
        var colliders = skippers[i].transform.GetComponentsInChildren(Collider, true);
        for (var j = 0; j < colliders.length; j++) colliders[j].usedForReplay = true
    }
};
goog.require("UHT.Component");
goog.require("UHT.XTLink");
ReplayScenario.prototype = Object.create(XTLink.prototype);
ReplayScenario.prototype.constructor = ReplayScenario;
var ReplayScenarioTriggerType = {
    NONE: 0,
    IDLE_RESULT: 1,
    SHOW_FSBG_PICK: 2,
    FS_SHOW_WINDOW_WIN: 3,
    SHOW_BG_MULTIPLE_ITEM_PICK: 4,
    REPLAY_SCENARIO_TYPES_COUNT: 5
};

function ReplayScenarioCondition() {
    this.whenIsPresent = "";
    this.hasValue = "";
    this.usingParamIndex = ""
}

function ReplayScenario() {
    XTLink.call(this);
    this.type = ReplayActionType.NONE;
    this.options = [];
    this.checkOn = ReplayScenarioTriggerType.IDLE_RESULT;
    this.serverParams = [];
    this.actions = []
}
ReplayScenario.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(ReplaySessionVars.PrepareScenario, this.OnPrepare, this)
};
ReplayScenario.prototype.OnPrepare = function() {
    var type = XT.GetInt(ReplaySessionVars.PrepareScenarioType);
    if (this.checkOn == type) {
        var reqParams = RequestProvider.Instance.GetNextReplayRequestParams();
        var shouldAdd = false;
        var serverindex = 0;
        for (var sp = 0; sp < this.serverParams.length; sp++) {
            var svParam = this.serverParams[sp];
            if (reqParams[svParam.whenIsPresent] != undefined)
                if (svParam.hasValue == "" || svParam.hasValue == reqParams[svParam.whenIsPresent]) {
                    if (svParam.usingParamIndex != "")
                        if (reqParams[svParam.usingParamIndex] !=
                            undefined) serverindex = _number.otoi(reqParams[svParam.usingParamIndex]);
                    shouldAdd = true
                }
        }
        if (shouldAdd)
            for (var i = 0; i < this.actions.length; i++) {
                XT.SetInt(ReplaySessionVars.PrepareActionType, this.actions[i]);
                XT.SetInt(ReplaySessionVars.PrepareActionIndex, serverindex);
                XT.TriggerEvent(ReplaySessionVars.PrepareAction)
            }
    }
};
goog.provide("UHT.ReplaySelectedWinningButton");
goog.require("UHT.XTLink");
ReplaySelectedWinningButton.prototype = Object.create(XTLink.prototype);
ReplaySelectedWinningButton.prototype.constructor = ReplaySelectedWinningButton;

function ReplaySelectedWinningButton() {
    XTLink.call(this);
    this.winning = null;
    this.round = null
}
ReplaySelectedWinningButton.prototype.Awake = function() {
    globalColliderInputManager.addEventHandler(ColliderEvent.ButtonUp, new EventHandler(this, this.OnButtonUp))
};
ReplaySelectedWinningButton.prototype.OnButtonUp = function() {
    if (!this.gameObject.activeInHierarchy) return;
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    var mask = new LayerMask;
    mask.mask = 1 << this.gameObject.layer;
    if (this.gameObject.collider != globalColliderInputManager.getHoveredCollider(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition), mask)) return;
    this.OnRelease()
};
ReplaySelectedWinningButton.prototype.UpdateValue = function(round) {
    this.round = round
};
ReplaySelectedWinningButton.prototype.OnRelease = function() {};
goog.require("UHT.ReplaySelectedWinningButton");
ReplaySelectedWinningButtonLink.prototype = Object.create(ReplaySelectedWinningButton.prototype);
ReplaySelectedWinningButtonLink.prototype.constructor = ReplaySelectedWinningButtonLink;

function ReplaySelectedWinningButtonLink() {
    ReplaySelectedWinningButton.call(this);
    this.sharedLinkContent = null;
    this.noSharedLinkContent = null;
    this.showLinkCopied = null;
    this.hideLinkCopied = null;
    this.linkCopied = false;
    this.winningPos = null
}
ReplaySelectedWinningButtonLink.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(ReplayVars.Evt_Internal_Replay_RoundSharedLinkUpdated, this.OnSharedLinkUpdated, this);
    XT.RegisterCallbackEvent(ReplayVars.Evt_Internal_Replay_RoundSharedLinkCopied, this.HideLinkCopied, this)
};
ReplaySelectedWinningButtonLink.prototype.HideLinkCopied = function() {
    if (this.showLinkCopied.IsRunning()) this.showLinkCopied.Stop();
    if (this.hideLinkCopied.IsRunning()) this.hideLinkCopied.Stop();
    this.hideLinkCopied.Start()
};
ReplaySelectedWinningButtonLink.prototype.OnSharedLinkUpdated = function() {
    var sharedRound = XT.GetObject(ReplayVars.Replay_SharedLinkRound);
    if (sharedRound == this.round) this.UpdateValue(sharedRound)
};
ReplaySelectedWinningButtonLink.prototype.UpdateValue = function(round) {
    if (!this.RoundsEqual(this.round, round)) this.HideLinkCopied();
    ReplaySelectedWinningButton.prototype.UpdateValue.call(this, round);
    if (round == null) return;
    var hasSharedLink = !_string.IsNullOrEmpty(round.sharedLink);
    this.sharedLinkContent.SetActive(hasSharedLink);
    this.noSharedLinkContent.SetActive(!hasSharedLink)
};
var GA_SENT_REPLAY_CREATED_LINK = false;
var GA_SENT_REPLAY_COPIED_LINK = false;
ReplaySelectedWinningButtonLink.prototype.OnRelease = function() {
    var link = this.round.sharedLink;
    if (_string.IsNullOrEmpty(link)) {
        XT.SetObject(ReplayVars.Replay_SharedLinkRound, this.round);
        XT.TriggerEvent(ReplayVars.Evt_Internal_Replay_RequestSharedLink);
        globalTracking.SendEvent("uht_behaviour_replay", "Ingame_replay_created_link", GA_SENT_REPLAY_CREATED_LINK ? 0 : 1, "BehaviourTracker");
        GA_SENT_REPLAY_CREATED_LINK = true
    } else {
        globalTracking.SendEvent("uht_behaviour_replay", "Ingame_replay_copied_link", GA_SENT_REPLAY_COPIED_LINK ?
            0 : 1, "BehaviourTracker");
        GA_SENT_REPLAY_COPIED_LINK = true;
        this.linkCopied = _Clipboard.CopyText(link);
        if (!this.linkCopied) prompt("", link)
    }
};
ReplaySelectedWinningButtonLink.prototype.Update = function() {
    if (this.linkCopied) {
        this.linkCopied = false;
        XT.TriggerEvent(ReplayVars.Evt_Internal_Replay_RoundSharedLinkCopied);
        this.showLinkCopied.Start()
    }
};
ReplaySelectedWinningButtonLink.prototype.LateUpdate = function() {
    if (this.winning == null) return;
    var pos = this.winning.transform.localPosition();
    if (UHTMath.Vector3.equal(this.winningPos, pos)) return;
    this.winningPos = pos;
    this.HideLinkCopied()
};
ReplaySelectedWinningButtonLink.prototype.OnDisable = function() {
    this.HideLinkCopied()
};
ReplaySelectedWinningButtonLink.prototype.RoundsEqual = function(x, y) {
    if (x == null) return y == null;
    if (y == null) return x == null;
    return x.roundID == y.roundID
};
goog.require("UHT.ReplaySelectedWinningButton");
ReplaySelectedWinningButtonWatch.prototype = Object.create(ReplaySelectedWinningButton.prototype);
ReplaySelectedWinningButtonWatch.prototype.constructor = ReplaySelectedWinningButtonWatch;

function ReplaySelectedWinningButtonWatch() {
    ReplaySelectedWinningButton.call(this)
}
var GA_SENT_REPLAY_STARTED = false;
ReplaySelectedWinningButtonWatch.prototype.OnRelease = function() {
    globalTracking.SendEvent("uht_behaviour_replay", "Ingame_replay_started_watching", GA_SENT_REPLAY_STARTED ? 0 : 1, "BehaviourTracker");
    GA_SENT_REPLAY_STARTED = true;
    XT.SetObject(ReplayVars.Replay_SelectedRound, this.round);
    XT.TriggerEvent(ReplayVars.Evt_Internal_Replay_WatchSelectedRound)
};
goog.require("UHT.ArrangeableBase");

function ReplayWatchWinningStyle() {
    this.defaultWidth = 0;
    this.defaultBorderRadius = 0
}
ReplayWatchWinning.prototype = Object.create(ArrangeableBase.prototype);
ReplayWatchWinning.prototype.constructor = ReplayWatchWinning;

function ReplayWatchWinning() {
    ArrangeableBase.call(this);
    this.open = null;
    this.anchorTopLeft = null;
    this.anchorBottomRight = null;
    this.styleLandscape = null;
    this.stylePortrait = null;
    this.collidersCamera = null;
    this.notificationsCamera = null;
    this.notificationsCameraDepth = 0;
    this.mustOpen = false;
    this.isRoundOpen = false;
    this.isNotificationOpen = false;
    this.cachedCamera = null;
    this.style = null;
    this.posC = null;
    this.posTL = null;
    this.posBR = null;
    this.replayRoot = null;
    this.replayFrame = null;
    this.css = "width:{0}px;height:{1}px;left:{2}px;top:{3}px;border-radius:0 0 BRpx BRpx;"
}
ReplayWatchWinning.prototype.XTRegisterCallbacks = function() {
    ArrangeableBase.prototype.XTRegisterCallbacks.call(this);
    EventManager.AddHandler("EVT_UHT_RESIZE", this.OnGameSizeChanged, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_Internal_BlackBandsUpdated, this.OnGameSizeChanged, this);
    XT.RegisterCallbackEvent(ReplayVars.Evt_Internal_Replay_WatchSelectedRound, this.OpenRound, this);
    XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_ShowIntrusiveNotification, this.OnShowNotification, this);
    XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_ShowNonIntrusiveNotification,
        this.OnShowNotification, this);
    XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_HideIntrusiveNotification, this.OnHideNotification, this);
    XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_HideNonIntrusiveNotification, this.OnHideNotification, this)
};
ReplayWatchWinning.prototype.OnShowNotification = function() {
    this.isNotificationOpen = true;
    this.UpdateCameras()
};
ReplayWatchWinning.prototype.OnHideNotification = function() {
    this.isNotificationOpen = false;
    this.UpdateCameras()
};
ReplayWatchWinning.prototype.OnGameSizeChanged = function() {
    if (this.isRoundOpen) this.UpdateRoundSize(true)
};
ReplayWatchWinning.prototype.OnSwitchToLandscape = function() {
    this.style = this.styleLandscape
};
ReplayWatchWinning.prototype.OnSwitchToPortrait = function() {
    this.style = this.stylePortrait
};
ReplayWatchWinning.prototype.OpenRound = function() {
    if (this.isRoundOpen) return;
    var round = XT.GetObject(ReplayVars.Replay_SelectedRound);
    var link = round.sharedLink;
    if (_string.IsNullOrEmpty(link)) link = ReplayConnection.watchURL + "&" + ReplayAPI.Keys.roundID + "=" + round.roundID;
    var frame = _HTML.CreateElement("iframe", {
        "src": link,
        "class": "replay-frame",
        "frameborder": "0"
    }, false);
    var root = _HTML.CreateElement("div", {
        "class": "replay-root"
    }, true);
    root.appendChild(frame);
    var volume = Globals.isMobile ? 1 : XT.GetFloat(Vars.SoundVolume);
    volume = isFinite(volume) && !isNaN(volume) ? volume : 1;
    createjs.Sound.setVolume(1E-5);
    Globals.WatchingReplay = true;
    _HTML.AddClass(document.documentElement, "replay-visible");
    this.mustOpen = true;
    this.isRoundOpen = true;
    this.replayRoot = root;
    this.replayFrame = frame;
    this.UpdateRoundSize(true);
    this.UpdateCameras()
};
ReplayWatchWinning.prototype.CloseRound = function() {
    if (!this.isRoundOpen) return;
    XT.TriggerEvent(ReplayVars.Evt_Internal_Replay_RequestWinnings);
    var volume = Globals.isMobile ? 1 : XT.GetFloat(Vars.SoundVolume);
    volume = isFinite(volume) && !isNaN(volume) ? volume : 1;
    createjs.Sound.setVolume(volume);
    Globals.WatchingReplay = false;
    _HTML.RemoveClass(document.documentElement, "replay-visible");
    document.body.removeChild(this.replayRoot);
    this.isRoundOpen = false;
    this.replayRoot = null;
    this.replayFrame = null;
    this.UpdateCameras()
};
ReplayWatchWinning.prototype.UpdateRoundSize = function(force) {
    if (!this.isRoundOpen) return;
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    var pC = this.cachedCamera.transform.position();
    var pTL = this.anchorTopLeft.position();
    var pBR = this.anchorBottomRight.position();
    if (!force)
        if (UHTMath.Vector3.equal(pC, this.posC) && UHTMath.Vector3.equal(pTL, this.posTL) && UHTMath.Vector3.equal(pBR, this.posBR)) return;
    var pixelRatio = window.devicePixelRatio || window.screen.deviceXDPI /
        window.screen.logicalXDPI;
    if (UHT_DEVICE_TYPE.DESKTOP == true)
        if (pixelRatio > 1.5) pixelRatio = 1.5;
    if (pixelRatio > 2) pixelRatio = 2;
    var scale = 1 / pixelRatio;
    var tl = UHTMath.Vector3.scale(this.cachedCamera.WorldToScreenPoint(pTL), scale);
    var br = UHTMath.Vector3.scale(this.cachedCamera.WorldToScreenPoint(pBR), scale);
    var width = br.x - tl.x;
    var height = br.y - tl.y;
    scale = width / this.style.defaultWidth;
    var borderRadius = this.style.defaultBorderRadius * scale;
    var style = this.css.replace("{0}", String(width)).replace("{1}", String(height)).replace("{2}",
        String(tl.x)).replace("{3}", String(tl.y)).replace(new RegExp("BR", "g"), String(borderRadius));
    this.replayRoot.setAttribute("style", style);
    this.replayFrame.setAttribute("style", style);
    this.posC = pC;
    this.posTL = pTL;
    this.posBR = pBR
};
ReplayWatchWinning.prototype.UpdateCameras = function() {
    if (this.isRoundOpen && this.isNotificationOpen) {
        this.notificationsCamera.SetCameraDepth(this.notificationsCameraDepth);
        this.collidersCamera.ignoreInputBlocked = true
    } else {
        this.notificationsCamera.ResetCameraDepth();
        this.collidersCamera.ignoreInputBlocked = false
    }
};
ReplayWatchWinning.prototype.Update = function() {
    if (this.mustOpen) {
        this.mustOpen = false;
        this.open.Start()
    }
};
ReplayWatchWinning.prototype.LateUpdate = function() {
    if (this.isRoundOpen) this.UpdateRoundSize(false)
};
goog.require("UHT.XTLink");
var ReplayWinningsCategory = {
    LastWins: 0,
    TopWins: 1
};
ReplayWinnings.prototype = Object.create(XTLink.prototype);
ReplayWinnings.prototype.constructor = ReplayWinnings;

function ReplayWinnings() {
    XTLink.call(this);
    this.contents = null;
    this.close = null;
    this.open = null;
    this.scrollables = null;
    this.winnings = null;
    this.winSteps = null;
    this.betFormat = "";
    this.dateFormat = "";
    this.timeFormat = "";
    this.categories = null;
    this.CATCategories = null;
    this.defaultCategory = 0;
    this.openFrame = 0;
    this.categoryIndex = 0;
    this.categoriesDesc = null;
    this.rounds = null
}
ReplayWinnings.CategoryDesc = function() {
    this.valueIndex = null;
    this.scrollRemain = null
};
ReplayWinnings.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_CodeToData_InterfaceWindowOpen, this.CloseWinnings, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_DataToCode_CloseAllInterfaceWindows, this.OnCloseAllInterfaceWindows, this);
    XT.RegisterCallbackEvent(ReplayVars.Evt_DataToCode_Replay_OpenWinnings, this.OpenWinnings, this);
    XT.RegisterCallbackObject(ReplayVars.Replay_Winnings, this.OnReplayWinnings,
        this);
    XT.RegisterCallbackInt(ReplayVars.Replay_CategoryIndex, this.OnCategoryIndex, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ChangeVSGameState, this.OnVSGameStateChanged, this)
};
ReplayWinnings.prototype.XTInitVariablesAndEvents = function() {
    XT.SetInt(ReplayVars.Replay_CategoryIndex, this.defaultCategory)
};
ReplayWinnings.prototype.OnGameInit = function() {
    for (var i = 0; i < this.scrollables.length; ++i) {
        var items = this.scrollables[i].items;
        for (var j = 0; j < items.length; ++j) items[j]["manager"] = this
    }
    for (var i = 0; i < this.winnings.length; ++i) this.winnings[i].manager = this
};
ReplayWinnings.prototype.OnReplayWinnings = function(param) {
    this.rounds = param;
    this.OnCategoryIndex(this.categoryIndex)
};
ReplayWinnings.prototype.OpenWinnings = function() {
    this.openFrame = Time.frameCount;
    this.open.Start();
    XT.TriggerEvent(InterfaceVars.Evt_DataToCode_CloseAllInterfaceWindows);
    XT.TriggerEvent(ReplayVars.Evt_Internal_Replay_RequestWinnings);
    window["globalMustStopAutoplay"] = true
};
ReplayWinnings.prototype.CloseWinnings = function() {
    for (var i = 0; i < this.contents.length; ++i)
        if (this.contents[i].activeInHierarchy) {
            this.close.Start();
            break
        }
};
ReplayWinnings.prototype.OnCloseAllInterfaceWindows = function() {
    if (this.openFrame < Time.frameCount) this.CloseWinnings()
};
ReplayWinnings.prototype.OnCategoryIndex = function(index) {
    if (this.categoriesDesc == null) {
        this.categoriesDesc = [];
        for (var i = 0; i < this.categories.length; ++i) {
            var desc = new ReplayWinnings.CategoryDesc;
            desc.valueIndex = [];
            desc.scrollRemain = [];
            this.categoriesDesc.push(desc);
            for (var j = 0; j < this.scrollables.length; ++j) {
                desc.valueIndex.push(-1);
                desc.scrollRemain.push(0)
            }
        }
    }
    var categoryDesc = this.categoriesDesc[this.categoryIndex];
    for (var i = 0; i < this.scrollables.length; ++i) {
        categoryDesc.valueIndex[i] = this.scrollables[i].items[0].valueIdx;
        categoryDesc.scrollRemain[i] = this.scrollables[i].scrollRemain
    }
    if (this.rounds != null) {
        var category = this.categories[index];
        if (category == ReplayWinningsCategory.LastWins) this.rounds.sort(ReplayAPI.WinningRound.CompareByPlayedDate);
        else if (category == ReplayWinningsCategory.TopWins) this.rounds.sort(ReplayAPI.WinningRound.CompareByRTP)
    }
    categoryDesc = this.categoriesDesc[index];
    var values = this.rounds == null ? null : this.rounds.slice();
    for (var i = 0; i < this.scrollables.length; ++i) {
        this.scrollables[i].scrollRemain = categoryDesc.scrollRemain[i];
        this.scrollables[i].UpdateValuesAndIndex(values, categoryDesc.valueIndex[i])
    }
    this.CATCategories[index].Start();
    this.categoryIndex = index
};
ReplayWinnings.prototype.OnVSGameStateChanged = function() {
    var state = VSGameStateManager.GetState();
    if (state == VSGameState.Spin || state == VSGameState.SpinBonusRounds) this.CloseWinnings()
};
goog.provide("UHT.UHTAction");
goog.require("UHT.Engine");
var UHTStageName = {
    No_Stage: 0,
    Init: 1,
    Result: 2,
    Spin: 3,
    ResultFreeSpin: 4,
    Gamble: 5,
    Bonus: 6,
    FSBG: 7,
    Transition: 8,
    Jackpot: 9
};

function UHTAction(_continue, _next) {
    this.continueRunning = _continue;
    this.nextStage = _next
}
UHTAction.NoAction = function() {
    return new UHTAction(true, UHTStageName.No_Stage)
};
UHTAction.ChangeStage = function(nextStage) {
    return new UHTAction(false, nextStage)
};
GameLogicRuntime.prototype = Object.create(Component.prototype);
GameLogicRuntime.prototype.constructor = GameLogicRuntime;

function GameLogicRuntime() {
    Component.call(this);
    this.listOfStages = [];
    this.startingStage = UHTStageName.No_Stage;
    this.debugHistory = [];
    this.dict = [];
    this.currentStage = null;
    this.currentStageStarted = false
}
GameLogicRuntime.prototype.Start = function() {
    this.dict = [];
    for (var i = 0; i < this.listOfStages.length; i++) {
        var stageName = this.listOfStages[i].GetStageName();
        if (this.dict[stageName] == undefined) this.dict[stageName] = [];
        this.listOfStages[i].UHTInit();
        this.dict[stageName].push(this.listOfStages[i])
    }
    this.currentStage = this.GetStage(this.startingStage);
    this.currentStageStarted = false
};
GameLogicRuntime.prototype.Update = function() {
    if (Globals.GamePaused) return;
    var act = this.currentStage.UHTUpdateBase(!this.currentStageStarted);
    if (this.currentStage.GetStageName() == UHTStageName.Bonus && !this.currentStageStarted && XT.GetBool(Vars.MustOpenAnotherBonus)) {
        XT.SetBool(Vars.MustOpenBonus, true);
        XT.SetBool(Vars.MustOpenAnotherBonus, false)
    }
    this.currentStageStarted = true;
    if (act.continueRunning == false) {
        this.currentStage.UHTFinish();
        if (this.dict[act.nextStage] == undefined) console.error("GameLogicRuntime: Trying to start an invalid stage (" +
            act.nextStage + ")");
        this.currentStage = this.GetStage(act.nextStage);
        this.currentStageStarted = false
    }
};
GameLogicRuntime.prototype.GetStage = function(stageName) {
    if (this.dict[stageName].length > 1) {
        var featureID = 0;
        if (stageName == UHTStageName.Bonus) featureID = XT.GetObject(Vars.BonusData).GameID;
        for (var i = 0; i < this.dict[stageName].length; ++i)
            if (this.dict[stageName][i].featureID == featureID) return this.dict[stageName][i]
    }
    return this.dict[stageName][0]
};
goog.require("UHT.XTLink");
goog.require("UHT.UHTAction");
goog.provide("UHT.UHTStage");
UHTStage.prototype = Object.create(XTLink.prototype);
UHTStage.prototype.constructor = UHTStage;

function UHTStage() {
    XTLink.call(this);
    this.featureID = 0;
    this.catBeforeFirstUpdate = null
}
UHTStage.prototype.GetStageName = function() {
    return UHTStageName.No_Stage
};
UHTStage.prototype.UHTInit = function() {};
UHTStage.prototype.UHTUpdateBase = function(isFirstFrame) {
    if (isFirstFrame && this.catBeforeFirstUpdate != null) this.catBeforeFirstUpdate.Start();
    return this.UHTUpdate(isFirstFrame)
};
UHTStage.prototype.UHTUpdate = function(isFirstFrame) {
    return UHTAction.NoAction()
};
UHTStage.prototype.UHTFinish = function() {};
goog.require("UHT.Engine");
goog.require("UHT.BaseDataStructures");

function JackpotInformation(data) {
    this.JackpotID = -1;
    this.JackpotOrder = -1;
    this.JackpotAmount = 0;
    this.JackpotAmountUSD = 0;
    this.JackpotName = "";
    this.JackpotGroupType = "";
    this.JackpotStatus = "";
    this.JackpotMinBet = -69;
    this.JackpotMinBetUSD = -69;
    this.JackpotRTP = -69;
    this.JackpotInstance = -1;
    this.JackpotMultipliers = null;
    this.JackpotCommunityDetails = null;
    this.multipliersRTP = 0;
    this.prevWonAmount = 0;
    this.prevWonAmountUSD = 0;
    this.nextSeedAmount = 0;
    this.nextSeedAmountUSD = 0;
    this.contributePercent = 0;
    this.babyContributeInitialPercent =
        0;
    this.babyContributePercent = 0;
    this.babyAmount = 0;
    this.babyAmountUSD = 0;
    this.startNextFromSeed = false;
    if (data != undefined) {
        this.JackpotID = data.JackpotID;
        this.JackpotOrder = data.JackpotOrder;
        this.JackpotAmount = data.JackpotAmount;
        this.JackpotAmountUSD = data.JackpotAmountUSD;
        this.JackpotName = data.JackpotName;
        this.JackpotGroupType = data.JackpotGroupType;
        this.JackpotStatus = data.JackpotStatus;
        this.JackpotMinBet = data.JackpotMinBet;
        this.JackpotMinBetUSD = data.JackpotMinBetUSD;
        this.JackpotRTP = data.JackpotRTP;
        this.JackpotInstance =
            data.JackpotInstance;
        this.multipliersRTP = data.multipliersRTP;
        this.prevWonAmount = data.prevWonAmount;
        this.prevWonAmountUSD = data.prevWonAmountUSD;
        this.nextSeedAmount = data.nextSeedAmount;
        this.nextSeedAmountUSD = data.nextSeedAmountUSD;
        this.contributePercent = data.contributePercent;
        this.babyContributeInitialPercent = data.babyContributeInitialPercent;
        this.babyContributePercent = data.babyContributePercent;
        this.babyAmount = data.babyAmount;
        this.babyAmountUSD = data.babyAmountUSD;
        this.startNextFromSeed = data.startNextFromSeed;
        if (data.JackpotMultipliers != null) this.JackpotMultipliers = data.JackpotMultipliers.slice();
        if (data.JackpotCommunityDetails != null) this.JackpotCommunityDetails = new JackpotInformation.CommunityDetails(data.JackpotCommunityDetails)
    }
}
JackpotInformation.prototype.Clone = function() {
    return new JackpotInformation(this)
};
JackpotInformation.CommunityDetails = function(data) {
    this.winnerAmount = 0;
    this.winnerAmountUSD = 0;
    this.shareAmount = 0;
    this.shareAmountUSD = 0;
    this.sharedPercentage = 0;
    this.minWinLimit = 0;
    this.minWinLimitUSD = 0;
    this.detectingPeriodInSec = 0;
    this.distributionType = "";
    this.minBet = 0;
    this.minBetUSD = 0;
    this.minTotalBet = 0;
    this.minTotalBetUSD = 0;
    if (data != undefined) {
        this.winnerAmount = data.winnerAmount;
        this.winnerAmountUSD = data.winnerAmountUSD;
        this.shareAmount = data.shareAmount;
        this.shareAmountUSD = data.shareAmountUSD;
        this.sharedPercentage =
            data.sharedPercentage;
        this.minWinLimit = data.minWinLimit;
        this.minWinLimitUSD = data.minWinLimitUSD;
        this.detectingPeriodInSec = data.detectingPeriodInSec;
        this.distributionType = data.distributionType;
        this.minBet = data.minBet;
        this.minBetUSD = data.minBetUSD;
        this.minTotalBet = data.minTotalBet;
        this.minTotalBetUSD = data.minTotalBetUSD
    }
};

function JackpotStatus() {
    this.status = "";
    this.amount = 0;
    this.prevWonAmount = 0;
    this.nextSeedAmount = 0;
    this.jackpotBabyAmount = 0
}
goog.require("UHT.Engine");
goog.provide("UHT.Adapter");
goog.require("UHT.BalanceManager");
goog.require("UHT.EventManager");
goog.require("UHT.Globals");

function Adapter() {
    this.methods = {};
    this.messageOpen = false;
    this.fullscreenOverlayShown = false;
    UHTEventBroker.AddHandler(UHTEventBroker.Type.Game, new UHTEventBroker.Handler(this, this.Endpoint))
}
Adapter.prototype.Init = function() {
    this.InitAdapterMethods();
    EventManager.AddHandler(ApplicationEvents.evtRequestAppConfiguration, this.OnRequestConfiguration, this);
    EventManager.AddHandler(ApplicationEvents.evtGameLoadingFinished, this.HandleGameReady, this);
    EventManager.AddHandler(ApplicationEvents.evtServerResponse, this.HandleServerResponse, this);
    EventManager.AddHandler(AdapterEvents.evtGetConfiguration, this.HandleGetConfiguration, this);
    EventManager.AddHandler(AdapterEvents.evtOpenCashier, this.HandleOpenCashier,
        this);
    EventManager.AddHandler(AdapterEvents.evtServerRequest, this.HandleServerRequest, this);
    EventManager.AddHandler(AdapterEvents.evtShowMessage, this.HandleShowMessage, this);
    EventManager.AddHandler(AdapterEvents.evtCloseGame, this.HandleCloseGame, this);
    EventManager.AddHandler(AdapterEvents.evtReload, this.HandleReloadGame, this)
};
Adapter.prototype.OnRequestConfiguration = function(param) {
    this.ExternalCall(AdapterEvents.evtGetConfiguration, null)
};
Adapter.prototype.ExternalCall = function(notification, args) {
    var mainArgs = {};
    mainArgs[AdapterParameters.Notify] = notification;
    mainArgs[AdapterParameters.Arguments] = args;
    mainArgs[AdapterParameters.type] = AdapterParameters.unity;
    var serializedArgs = JSON.stringify(mainArgs);
    UHTEventBroker.Trigger(UHTEventBroker.Type.Adapter, serializedArgs)
};
Adapter.prototype.ExternalEvent = function(notification, args) {
    var mainArgs = {};
    mainArgs[AdapterParameters.Notify] = notification;
    mainArgs[AdapterParameters.Arguments] = args;
    var serializedArgs = JSON.stringify(mainArgs);
    UHTEventBroker.Trigger(UHTEventBroker.Type.Wrapper, serializedArgs)
};
Adapter.prototype.InitAdapterMethods = function() {
    this.methods[AdapterEvents.evtGetConfiguration] = new EventHandler(this, this.OnConfigReceived);
    this.methods[AdapterEvents.evtUpdateBalance] = new EventHandler(this, this.OnUpdateBalance);
    this.methods[AdapterEvents.evtSound] = new EventHandler(this, this.OnSoundStateChanged);
    this.methods[AdapterEvents.evtGameStatus] = new EventHandler(this, this.OnGameStatusChanged);
    this.methods[AdapterEvents.evtMessageOpened] = new EventHandler(this, this.OnFlashMessageOpened);
    this.methods[AdapterEvents.evtMessageClosed] =
        new EventHandler(this, this.OnFlashMessageClosed);
    this.methods[AdapterEvents.evtFullscreenOverlayShown] = new EventHandler(this, this.OnFullscreenOverlayShown);
    this.methods[AdapterEvents.evtFullscreenOverlayHidden] = new EventHandler(this, this.OnFullscreenOverlayHidden)
};
Adapter.prototype.NIYMethod = function(param) {};
Adapter.prototype.OnConfigReceived = function(parsedArgs) {
    if (parsedArgs[AdapterParameters.Config] != null) this.HandleGetConfiguration(parsedArgs[AdapterParameters.Config]);
    else console.error("OnConfigReceived - config xml is missing!")
};
Adapter.prototype.Endpoint = function(param) {
    console.warn("Endpoint " + param);
    var parsedArgs = JSON.parse(param);
    if (parsedArgs == null) {
        console.error("ParseExternalCall - parsedArgs are null!");
        UHTEventBroker.Trigger(UHTEventBroker.Type.Wrapper, param);
        return
    }
    if (parsedArgs[AdapterParameters.Notify] === undefined) {
        console.error("ParseExternalCall - no action was specified!");
        UHTEventBroker.Trigger(UHTEventBroker.Type.Wrapper, param);
        return
    }
    if (parsedArgs[AdapterParameters.Arguments] === undefined) {
        console.error("ParseExternalCall - no parameters were specified!");
        UHTEventBroker.Trigger(UHTEventBroker.Type.Wrapper, param);
        return
    }
    var actionName = _string.Trim(parsedArgs[AdapterParameters.Notify]);
    var parameters = parsedArgs[AdapterParameters.Arguments];
    if (this.methods[actionName] != undefined) this.methods[actionName].call(parameters);
    else {
        console.info("Unhandled method " + actionName + " ... sending to wapper");
        UHTEventBroker.Trigger(UHTEventBroker.Type.Wrapper, param)
    }
};
Adapter.prototype.HandleBalanceUpdate = function(bd) {
    if (bd != null) {
        var data = {};
        data[AdapterParameters.Balance] = String(bd.Balance);
        data[AdapterParameters.BalanceUpdateTime] = String(bd.Time);
        this.ExternalCall(AdapterEvents.evtUpdateBalance, data)
    }
};
Adapter.prototype.HandleGetConfiguration = function(configStr) {
    console.info("HandleGetConfiguration", configStr);
    EventManager.Trigger(ApplicationEvents.evtAppConfigurationReceived, configStr)
};
Adapter.prototype.HandleCloseGame = function(args) {
    this.ExternalCall(AdapterEvents.evtCloseGame, null)
};
Adapter.prototype.HandleReloadGame = function(args) {
    this.ExternalCall(AdapterEvents.evtReload, null)
};
Adapter.prototype.OnUpdateBalance = function(args) {
    var data = {};
    for (var pair in args) data[pair] = String(args[pair]);
    var balanceData;
    if (XT.GetBool(Vars.Jurisdiction_SplitBalance)) balanceData = GameProtocolCommonParser.BuildBalanceData(_number.otod(args[GameProtocolDictionary.cashBalance]), _number.otod(args[GameProtocolDictionary.bonusBalance]), _number.otod(args[GameProtocolDictionary.time]));
    else balanceData = GameProtocolCommonParser.BuildBalanceData(_number.otod(args[GameProtocolDictionary.balance]), 0, _number.otod(args[GameProtocolDictionary.time]));
    if (balanceData != null) EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData)
};
Adapter.prototype.OnSoundStateChanged = function(args) {
    if (args[AdapterParameters.GameSymbol] != undefined && args[AdapterParameters.SoundState] != undefined) {
        var gameSymbol = args[AdapterParameters.GameSymbol];
        var soundState = new CasinoSoundState;
        soundState.state = _number.otoi(args[AdapterParameters.SoundState]);
        EventManager.Trigger(GameEvents.evtSoundState + gameSymbol, soundState)
    }
};
Adapter.prototype.OnGameStatusChanged = function(args) {
    if (args[AdapterParameters.GameSymbol] != undefined && args[AdapterParameters.GameActive] != undefined) {
        var gameSymbol = String(args[AdapterParameters.GameSymbol]);
        var active = _number.otoi(args[AdapterParameters.GameActive]);
        var isGameActive = active == 1;
        EventManager.Trigger(GameEvents.evtGameStatus + gameSymbol, isGameActive)
    }
};
Adapter.prototype.HandleServerRequest = function(request) {
    var data = {};
    data[AdapterParameters.MethodType] = request.Fields[GameProtocolDictionary.Actions.action];
    data[AdapterParameters.GameSymbol] = request.Fields[GameProtocolDictionary.symbol];
    this.ExternalCall(AdapterEvents.evtServerRequest, data)
};
Adapter.prototype.HandleGameReady = function(param) {
    var gameSymbol = param;
    var data = {};
    data[AdapterParameters.GameSymbol] = gameSymbol;
    this.ExternalCall(AdapterEvents.evtGameLoadComplited, data);
    FlashWrapperHelper.HandleGameReady(gameSymbol)
};
Adapter.prototype.HandleOpenCashier = function(param) {
    this.ExternalCall(AdapterEvents.evtOpenCashier, null)
};
Adapter.prototype.HandleServerResponse = function(param) {
    FlashWrapperHelper.HandleServerResponse(param)
};
Adapter.prototype.OnFlashMessageOpened = function(param) {
    this.messageOpen = true;
    Globals.InputBlocked = true;
    console.info("OnFlashMessageOpened - Globals.InputBlocked " + String(Globals.InputBlocked))
};
Adapter.prototype.OnFlashMessageClosed = function(param) {
    this.messageOpen = false;
    if (!this.IsGlobalInputBlocked()) Globals.InputBlocked = false;
    console.info("OnFlashMessageClosed - Globals.InputBlocked " + String(Globals.InputBlocked))
};
Adapter.prototype.OnFullscreenOverlayShown = function(param) {
    this.fullscreenOverlayShown = true;
    Globals.InputBlocked = true;
    console.info("OnFullscreenOverlayShown - Globals.InputBlocked " + String(Globals.InputBlocked))
};
Adapter.prototype.OnFullscreenOverlayHidden = function(param) {
    this.fullscreenOverlayShown = false;
    if (!this.IsGlobalInputBlocked()) Globals.InputBlocked = false;
    console.info("OnFullscreenOverlayHidden - Globals.InputBlocked " + String(Globals.InputBlocked))
};
Adapter.prototype.IsGlobalInputBlocked = function() {
    return this.messageOpen || this.fullscreenOverlayShown
};
Adapter.prototype.HandleShowMessage = function(param) {
    console.info("HandleShowMessage " + param);
    FlashWrapperHelper.HandleShowMessage(param)
};
var FlashWrapperHelper = {};
FlashWrapperHelper.ExternalEvent = function(notification, args) {
    var mainArgs = {};
    mainArgs[AdapterParameters.Notify] = notification;
    mainArgs[AdapterParameters.Arguments] = args;
    var serializedArgs = JSON.stringify(mainArgs);
    UHTEventBroker.Trigger(UHTEventBroker.Type.Wrapper, serializedArgs)
};
FlashWrapperHelper.HandleGameReady = function(param) {
    FlashWrapperHelper.ExternalEvent(AdapterEvents.evtGameReady, null)
};
FlashWrapperHelper.HandleServerResponse = function(resp) {
    if (resp == null) return;
    var args = {};
    args[AdapterParameters.ResponseData] = resp.Response;
    args[AdapterParameters.ResponseStatusCode] = resp.StatusCode;
    FlashWrapperHelper.ExternalEvent(AdapterEvents.evtServerResponse, args)
};
FlashWrapperHelper.HandleShowMessage = function(messageType) {
    if (messageType != null) {
        var args = {};
        args[AdapterParameters.messageType] = messageType;
        FlashWrapperHelper.ExternalEvent(AdapterEvents.evtShowMessage, args)
    }
};
goog.require("UHT.ServerOptions");
goog.require("UHT.Component");
goog.require("UHT.OfflineRequest");
goog.require("UHT.OfflineServer");
RequestProvider.prototype = Object.create(Component.prototype);
RequestProvider.prototype.constructor = RequestProvider;

function RequestProvider() {
    Component.call(this);
    this.log = null;
    this.responseDelay = .5;
    this.offlineServer = null;
    this.replayLog = null;
    this.requests = null;
    this.requestIDs = null;
    this.responses = null;
    this.replayRequests = [];
    this.nextRequestParams = null;
    this.replayJustEnded = false;
    this.replayRequestsIndex = -1;
    this.responseIndices = null;
    this.ID_DELIMITER = "::";
    this.RESPONSE_DELIMITER = "\n";
    this.firstRequest = true
}
RequestProvider.Instance = null;
RequestProvider.prototype.Start = function() {
    RequestProvider.Instance = this;
    if (ServerOptions.isOnline);
    else if (ServerOptions.isReplay || UHT_LOCAL && this.replayLog != null)
        if (UHT_LOCAL) this.ParseReplay(this.replayLog.text);
        else this.ParseReplay(window["UHT_REPLAY_DATA"]);
    else this.ParseLog()
};
RequestProvider.prototype.NewRequest = function(settings) {
    return ServerOptions.isOnline ? new SimpleWebRequest(settings) : new OfflineRequest(settings)
};
RequestProvider.prototype.OfflineRequest = function(url, postData, request) {
    var self = this;
    setTimeout(function() {
        self.CompleteOfflineRequest(url, postData, request)
    }, self.responseDelay * 1E3);
    if (this.offlineServer != null) this.offlineServer.HandleRequest(postData)
};
RequestProvider.prototype.CompleteOfflineRequest = function(url, postData, request) {
    var id = url.indexOf(ServerOptions.gameServiceUri) >= 0 ? this.GameServiceRequestID(postData) : this.OtherRequestID(url);
    if (this.responses[id] != undefined) {
        var data = this.responses[id][this.responseIndices[id]];
        if (/_JSON$/.test(id)) data = atob(data);
        request.OnRequestDone(data, 200);
        this.responseIndices[id]++;
        if (this.offlineServer == null) this.responseIndices[id] %= this.responses[id].length;
        if (ServerOptions.isReplay) {
            this.replayRequestsIndex++;
            if (this.replayRequestsIndex >= this.replayRequests.length) this.replayJustEnded = true;
            this.replayRequestsIndex %= this.replayRequests.length;
            this.nextRequestParams = null
        }
    } else {
        console.error("Response not found for id " + id);
        request.OnRequestDone("404 Not Found", 404)
    }
};
RequestProvider.prototype.GameServiceRequestID = function(postData) {
    var args = (postData || "").split("&");
    for (var i = 0; i < args.length; ++i) {
        var arg = args[i].split("=");
        if (arg[0] == GameProtocolDictionary.Actions.action) return arg.length > 1 ? arg[1] : null
    }
    return null
};
RequestProvider.prototype.OtherRequestID = function(url) {
    var urlNoParams = url.split("?")[0];
    var parts = urlNoParams.split("/");
    if (parts.indexOf("promo") > -1 || parts.indexOf("lobby") > -1) {
        var split = urlNoParams.split("gs2c");
        if (split.length > 1) return split[1].replace(/^\/+|\/+$/g, "").split("/").join("_") + "_JSON"
    }
    for (var i = parts.length - 1; i >= 0; --i)
        if (!_string.IsNullOrEmpty(parts[i])) return parts[i];
    return null
};
RequestProvider.prototype.ParseReplay = function(replayData) {
    this.responses = {};
    this.responseIndices = {};
    var replay = JSON.parse(replayData);
    var initList = [];
    initList.push(replay["init"]);
    initList[0] = "c=" + GameProtocolCommonParser.SplitResponseContent(replay.log[0]["cr"].split("&"))["c"] + "&" + initList[0];
    this.responses["doInit"] = initList;
    this.responseIndices["doInit"] = 0;
    this.replayRequests = [];
    var req_resp_list = replay["log"];
    for (var rr in req_resp_list) {
        var entry = req_resp_list[rr];
        var clientRequest = entry["cr"];
        var serverResponse = entry["sr"];
        this.replayRequests.push(clientRequest);
        var id = this.GameServiceRequestID(clientRequest);
        var list = this.responses[id] != undefined ? this.responses[id] : [];
        list.push(serverResponse);
        if (this.responses[id] == undefined) {
            this.responses[id] = list;
            this.responseIndices[id] = 0
        }
    }
};
RequestProvider.prototype.ParseLog = function() {
    this.responses = {};
    this.responseIndices = {};
    var str_responses = this.log.text.split(this.RESPONSE_DELIMITER);
    for (var i = 0; i < str_responses.length; ++i)
        if (!_string.IsNullOrEmpty(str_responses[i])) {
            var str_response = str_responses[i].split(this.ID_DELIMITER);
            var id = str_response[0];
            var data = str_response.length > 1 ? str_response[1] : "";
            var list = this.responses[id] != undefined ? this.responses[id] : [];
            list.push(data);
            if (this.responses[id] == undefined) {
                this.responses[id] = list;
                this.responseIndices[id] = 0
            }
        }
};
RequestProvider.prototype.ParseOfflineResponse = function(response, isInit) {
    if (isInit) {
        this.responses = {};
        this.responseIndices = {}
    }
    var str_responses = response.split(this.RESPONSE_DELIMITER);
    for (var i = 0; i < str_responses.length; ++i)
        if (!_string.IsNullOrEmpty(str_responses[i])) {
            var str_response = str_responses[i].split(this.ID_DELIMITER);
            var id = str_response[0];
            var data = str_response.length > 1 ? str_response[1] : "";
            var list = this.responses[id] != undefined ? this.responses[id] : [];
            list.push(data);
            if (this.responses[id] == undefined) {
                this.responses[id] =
                    list;
                this.responseIndices[id] = 0
            }
        }
};
RequestProvider.prototype.GetNextReplayRequestParams = function() {
    if (this.nextRequestParams == null) this.nextRequestParams = GameProtocolCommonParser.SplitResponseContent(this.replayRequests[this.replayRequestsIndex].split("&"));
    return this.nextRequestParams
};
RequestProvider.prototype.ReplayEnded = function() {
    if (this.replayJustEnded) {
        this.replayJustEnded = false;
        return true
    }
    return false
};
goog.require("UHT.XTLink");
DropsAndWinsIconOpt.prototype = Object.create(XTLink.prototype);
DropsAndWinsIconOpt.prototype.constructor = DropsAndWinsIconOpt;

function DropsAndWinsIconOpt() {
    XTLink.call(this);
    this.dnwSpriteName = ""
}
DropsAndWinsIconOpt.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
};
DropsAndWinsIconOpt.prototype.OnGameInit = function() {
    this.GetComponent(UISprite).SetSpriteName(this.GetDropsAndWinsSpriteName())
};
DropsAndWinsIconOpt.prototype.GetDNWSpriteName = function() {
    var ret = this.gameObject.GetComponent(UISprite).spriteName;
    var key = "region";
    if (UHT_GAME_CONFIG_SRC[key] == undefined || UHT_GAME_CONFIG_SRC[key] != "Asia") return ret;
    ret += "_as";
    return ret
};
DropsAndWinsIconOpt.prototype.GetDropsAndWinsSpriteName = function() {
    if (_string.IsNullOrEmpty(this.dnwSpriteName)) this.dnwSpriteName = this.GetDNWSpriteName();
    return this.dnwSpriteName
};
goog.require("UHT.XTLink");

function PromotionPrizeTypeContents() {
    this.prizeTypes = null;
    this.contents = null
}
PromotionContentSwitcher.prototype = Object.create(XTLink.prototype);
PromotionContentSwitcher.prototype.constructor = PromotionContentSwitcher;

function PromotionContentSwitcher() {
    XTLink.call(this);
    this.switchesByStatus = true;
    this.startsSoonContent = null;
    this.startsSoonContents = null;
    this.openContent = null;
    this.openContents = null;
    this.closedContent = null;
    this.closedContents = null;
    this.switchesByType = true;
    this.raceContents = null;
    this.tournamentContents = null;
    this.switchesByStyle = true;
    this.asiaContents = null;
    this.europeContents = null;
    this.switchOnPromoSelectionChange = false;
    this.onlyIfActive = false;
    this.onlyIfHideWinnersList = false;
    this.switchesByPrizeType =
        false;
    this.prizeTypeContents = null
}
PromotionContentSwitcher.prototype.XTRegisterCallbacks = function() {
    if (!this.switchOnPromoSelectionChange) return;
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_TournamentsUpdated, this.OnTournamentsUpdated, this);
    XT.RegisterCallbackString(TournamentVars.SelectedTournamentID, this.OnSelectedTournamentIDChanged, this)
};
PromotionContentSwitcher.prototype.OnTournamentsUpdated = function() {
    this.OnSelectedTournamentIDChanged(XT.GetString(TournamentVars.SelectedTournamentID))
};
PromotionContentSwitcher.prototype.OnSelectedTournamentIDChanged = function(uid) {
    if (!this.CanSwitch(this.switchOnPromoSelectionChange)) return;
    var t = PromotionsHelper.FindPromotion(uid);
    if (t == null) return;
    if (this.onlyIfHideWinnersList && t.type == TournamentProtocol.PromoType.Race && t.showWinnersList) return;
    this.SwitchByStatus(t.status);
    this.SwitchByType(t.type);
    this.SwitchByStyle(t.clientStyle)
};
PromotionContentSwitcher.prototype.SwitchByStatus = function(status) {
    if (!this.CanSwitch(this.switchesByStatus)) return;
    this.startsSoonContent.SetActive(status == TournamentProtocol.StatusCode.StartsSoon);
    if (this.startsSoonContents != null)
        for (var i = 0; i < this.startsSoonContents.length; ++i) this.startsSoonContents[i].SetActive(this.startsSoonContent.activeSelf);
    this.openContent.SetActive(status == TournamentProtocol.StatusCode.Open);
    if (this.openContents != null)
        for (var i = 0; i < this.openContents.length; ++i) this.openContents[i].SetActive(this.openContent.activeSelf);
    this.closedContent.SetActive(status == TournamentProtocol.StatusCode.Closed);
    if (this.closedContents != null)
        for (var i = 0; i < this.closedContents.length; ++i) this.closedContents[i].SetActive(this.closedContent.activeSelf)
};
PromotionContentSwitcher.prototype.SwitchByType = function(type) {
    if (!this.CanSwitch(this.switchesByType)) return;
    for (var i = 0; i < this.tournamentContents.length; ++i) this.tournamentContents[i].SetActive(type == TournamentProtocol.PromoType.Tournament);
    for (var i = 0; i < this.raceContents.length; ++i) this.raceContents[i].SetActive(type == TournamentProtocol.PromoType.Race)
};
PromotionContentSwitcher.prototype.SwitchByStyle = function(style) {
    if (!this.CanSwitch(this.switchesByStyle)) return;
    for (var i = 0; i < this.asiaContents.length; ++i) this.asiaContents[i].SetActive(style == TournamentProtocol.ClientStyle.Asia);
    for (var i = 0; i < this.europeContents.length; ++i) this.europeContents[i].SetActive(style == TournamentProtocol.ClientStyle.Europe)
};
PromotionContentSwitcher.prototype.SwitchByPrizeType = function(type) {
    if (!this.CanSwitch(this.switchesByPrizeType)) return;
    for (var i = 0; i < this.prizeTypeContents.length; ++i) {
        var isActive = this.prizeTypeContents[i].prizeTypes.indexOf(type) > -1;
        var contents = this.prizeTypeContents[i].contents;
        for (var j = 0; j < contents.length; ++j) contents[j].SetActive(isActive)
    }
};
PromotionContentSwitcher.prototype.CanSwitch = function(condition) {
    return (!this.onlyIfActive || this.gameObject.activeInHierarchy) && condition
};
goog.require("UHT.GenericPoolObject");
PromotionRuleUnit.prototype = Object.create(GenericPoolObject.prototype);
PromotionRuleUnit.prototype.constructor = PromotionRuleUnit;

function PromotionRuleUnit() {
    GenericPoolObject.call(this);
    this.labels = null;
    this.textContent = null;
    this.linkContentVisited = null;
    this.linkContentUnvisited = null;
    this.isVisible = false;
    this.data = null;
    this.mustUpdateLinkContent = false
}
PromotionRuleUnit.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionRuleLink_Visited, this.OnPromotionRuleLinkVisited, this)
};
PromotionRuleUnit.prototype.OnPromotionRuleLinkVisited = function() {
    this.mustUpdateLinkContent = this.gameObject.activeInHierarchy && this.data.isLink
};
PromotionRuleUnit.prototype.UpdateValue = function(unit) {
    this.data = unit;
    for (var i = 0; i < this.labels.length; ++i) this.labels[i].text = unit.text;
    this.textContent.SetActive(!unit.isLink);
    this.UpdateLinkContent()
};
PromotionRuleUnit.prototype.UpdateLinkContent = function() {
    this.data.CheckVisited();
    this.linkContentVisited.SetActive(this.data.isLink && this.data.isVisited);
    this.linkContentUnvisited.SetActive(this.data.isLink && !this.data.isVisited)
};
PromotionRuleUnit.prototype.Update = function() {
    if (this.mustUpdateLinkContent) {
        this.mustUpdateLinkContent = false;
        this.UpdateLinkContent()
    }
};
PromotionRuleUnit.prototype.UnitButtonClicked = function() {
    if (this.data.isLink && this.isVisible) {
        window.open(this.data.url, encodeURIComponent(this.data.url));
        if (!this.data.isVisited) {
            this.data.SetVisited();
            XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionRuleLink_Visited)
        }
    }
};
goog.require("UHT.XTLink");
PromotionRuleUnitButton.prototype = Object.create(XTLink.prototype);
PromotionRuleUnitButton.prototype.constructor = PromotionRuleUnitButton;

function PromotionRuleUnitButton() {
    XTLink.call(this);
    this.unit = null;
    this.hoveredFrame = 0;
    this.pressedFrame = 0;
    this.cachedCamera = null
}
PromotionRuleUnitButton.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionRuleLink_HoveredOn, this.OnPromotionLinkHoveredOn, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionRuleLink_HoveredOff, this.OnPromotionLinkHoveredOff, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionRuleLink_Pressed, this.OnPromotionLinkPressed, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionRuleLink_Released, this.OnPromotionLinkReleased,
        this);
    globalColliderInputManager.addEventHandler(ColliderEvent.ButtonUp, new EventHandler(this, this.OnTouchEnd))
};
PromotionRuleUnitButton.prototype.OnPromotionLinkHoveredOn = function() {
    this.InternalSendMessage(false, true)
};
PromotionRuleUnitButton.prototype.OnPromotionLinkHoveredOff = function() {
    this.InternalSendMessage(false, false)
};
PromotionRuleUnitButton.prototype.OnPromotionLinkPressed = function() {
    this.InternalSendMessage(true, true)
};
PromotionRuleUnitButton.prototype.OnPromotionLinkReleased = function() {
    this.InternalSendMessage(true, false)
};
PromotionRuleUnitButton.prototype.InternalSendMessage = function(isPressed, value) {
    if (this.gameObject.activeInHierarchy && XT.GetString(TournamentVars.PromotionRuleLinkID) == this.unit.data.uid) this.gameObject.SendMessage(isPressed ? "OnPress" : "OnHover", value)
};
PromotionRuleUnitButton.prototype.OnTouchEnd = function() {
    if (!this.gameObject.activeInHierarchy) return;
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    var mask = new LayerMask;
    mask.mask = 1 << this.gameObject.layer;
    if (this.gameObject.collider != globalColliderInputManager.getHoveredCollider(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition), mask)) return;
    this.unit.UnitButtonClicked()
};
PromotionRuleUnitButton.prototype.OnHover = function(value) {
    if (this.hoveredFrame == Time.frameCount) return;
    this.hoveredFrame = Time.frameCount;
    XT.SetString(TournamentVars.PromotionRuleLinkID, this.unit.data.uid);
    XT.TriggerEvent(value ? TournamentVars.Evt_Internal_PromotionRuleLink_HoveredOn : TournamentVars.Evt_Internal_PromotionRuleLink_HoveredOff)
};
PromotionRuleUnitButton.prototype.OnPress = function(value) {
    if (this.pressedFrame == Time.frameCount) return;
    this.pressedFrame = Time.frameCount;
    XT.SetString(TournamentVars.PromotionRuleLinkID, this.unit.data.uid);
    XT.TriggerEvent(value ? TournamentVars.Evt_Internal_PromotionRuleLink_Pressed : TournamentVars.Evt_Internal_PromotionRuleLink_Released)
};
goog.require("UHT.GenericObjectPooler");
PromotionRuleUnitsPooler.prototype = Object.create(GenericObjectPooler.prototype);
PromotionRuleUnitsPooler.prototype.constructor = PromotionRuleUnitsPooler;

function PromotionRuleUnitsPooler() {
    GenericObjectPooler.call(this)
}
PromotionRuleUnitsPooler.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.Init, this)
};
PromotionRuleUnitsPooler.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(TournamentVars.PromotionRuleUnitsPooler, this)
};
goog.require("UHT.XTLink");

function PromotionsAnnouncerExtraLayout() {
    this.displayer = null;
    this.rules = null;
    this.label = null
}
PromotionsAnnouncer.prototype = Object.create(XTLink.prototype);
PromotionsAnnouncer.prototype.constructor = PromotionsAnnouncer;

function PromotionsAnnouncer() {
    XTLink.call(this);
    this.displayer = null;
    this.rules = null;
    this.label = null;
    this.secondaryDisplayers = null;
    this.secondaryRules = null;
    this.secondaryLabels = null;
    this.catShow = null;
    this.catShowFull = null;
    this.catHide = null;
    this.secondaryCatShow = null;
    this.secondaryCatShowFull = null;
    this.secondaryCatHide = null;
    this.hasExtraLayout = false;
    this.extraLayout = null;
    this.secondaryExtraDisplayer = null;
    this.secondaryExtraRules = null;
    this.secondaryExtraLabels = null;
    this.catShowWin = null;
    this.winContentSwitcher =
        null;
    this.resultDisplayerLoopStartsPriority = 0;
    this.styleSwitcher = null;
    this.tournamentSimpleOptIn = null;
    this.announcements = [];
    this.uid = "";
    this.secondaryUID = "";
    this.isVisible = false;
    this.mustShowWin = false;
    this.rq = null;
    this.spinBlocked = false;
    this.showMerged = false
}
PromotionsAnnouncer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_Prepare, this.OnPrepare, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_Announce, this.OnAnnounce, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_PrepareForWin, this.OnPrepareForWin, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_ShowWin, this.OnShowWin, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_InjectRQIOnResultDisplayerLoopStarts,
        this.OnResultDisplayerLoopStarts, this, this.resultDisplayerLoopStartsPriority);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_TournamentsUpdated, this.OnTournamentsUpdated, this)
};
PromotionsAnnouncer.prototype.Update = function() {
    this.OnTournamentsUpdated()
};
PromotionsAnnouncer.prototype.OnTournamentsUpdated = function() {
    if (this.isVisible && !PromotionsHelper.PromotionAvailable(this.uid)) this.NextAnnouncement()
};
PromotionsAnnouncer.prototype.OnResultDisplayerLoopStarts = function() {
    if (this.mustShowWin) {
        if (this.rq == null) this.rq = XT.GetObject(Vars.RQManagerObject);
        this.rq.AddRoutineQueueItem(new RQIWaitForXTEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_WinShown))
    }
};
PromotionsAnnouncer.prototype.OnPrepare = function() {
    this.BlockSpin()
};
PromotionsAnnouncer.prototype.OnPrepareForWin = function() {
    this.OnPrepare();
    this.mustShowWin = true
};
PromotionsAnnouncer.prototype.OnAnnounce = function() {
    this.BlockSpin();
    var list = PromotionsHelper.GetAnnouncements();
    for (var i = 0; i < list.length; ++i) this.announcements.push(list[i]);
    if (!this.isVisible) this.NextAnnouncement()
};
PromotionsAnnouncer.prototype.NextAnnouncement = function() {
    if (this.announcements.length == 0) {
        this.rules.SetVisible(false);
        if (this.hasExtraLayout) {
            this.extraLayout.rules.SetVisible(false);
            this.secondaryExtraRules.SetVisible(false)
        }
        this.catHide.Start();
        this.isVisible = false;
        this.UnblockSpin();
        return
    }
    this.uid = this.announcements[0].uid;
    this.secondaryUID = "";
    var currentPromoHolder = TournamentConnection.instance.FindPromoHolder(this.uid);
    this.showMerged = false;
    if (currentPromoHolder.type == TournamentProtocol.PromoType.Tournament &&
        currentPromoHolder.promotion.displayStyle == TournamentProtocol.DisplayStyle.DropsAndWins && this.announcements.length > 1) {
        var nextPromoHolder = TournamentConnection.instance.FindPromoHolder(this.announcements[1].uid);
        if (nextPromoHolder.type == TournamentProtocol.PromoType.Race && nextPromoHolder.promotion.displayStyle == TournamentProtocol.DisplayStyle.DropsAndWins) {
            this.showMerged = true;
            this.secondaryUID = this.announcements[1].uid
        }
    }
    if (Globals.isMini) this.showMerged = false;
    if (this.tournamentSimpleOptIn != null) {
        this.tournamentSimpleOptIn.isMergedDDW =
            this.showMerged;
        this.tournamentSimpleOptIn.OnAnnounce()
    }
    if (!this.showMerged) {
        this.displayer.UpdateTournament(this.uid);
        this.label.text = this.announcements[0].description;
        this.rules.SetVisible(false)
    } else {
        for (var i = 0; i < this.secondaryDisplayers.length; i++) {
            this.secondaryDisplayers[i].UpdateTournament(this.uid);
            this.secondaryLabels[i].text = this.announcements[i].description
        }
        this.secondaryRules.SetVisible(false)
    }
    if (this.hasExtraLayout) {
        this.extraLayout.label.text = this.label.text;
        this.extraLayout.displayer.UpdateTournament(this.uid);
        this.extraLayout.rules.SetVisible(false);
        if (this.showMerged) {
            for (var i = 0; i < this.secondaryExtraLabels.length; i++) this.secondaryExtraLabels[i].text = this.announcements[i].description;
            this.secondaryExtraDisplayer.UpdateTournament(this.uid);
            this.secondaryExtraRules.SetVisible(false)
        }
    }
    if (this.styleSwitcher != null) this.styleSwitcher.SwitchByDisplayStyle(this.uid);
    PromotionsHelper.PromotionCheckTournamentOptOut(this.uid);
    if (!this.showMerged) {
        this.catShow.Start();
        this.isVisible = true;
        this.announcements.splice(0,
            1)
    } else {
        this.secondaryCatShow.Start();
        this.isVisible = true;
        this.announcements.splice(0, 1);
        this.announcements.splice(0, 1)
    }
};
PromotionsAnnouncer.prototype.OnShowWin = function() {
    this.BlockSpin();
    XT.SetDouble(TournamentVars.Promotion_WinDisplayed, 0);
    var promo = PromotionsHelper.FindPromotion(XT.GetString(TournamentVars.Promotion_WinID));
    var style = promo.clientStyle;
    var details = PromotionsHelper.FindDetails(XT.GetString(TournamentVars.Promotion_WinID));
    if (XT.GetInt(TournamentVars.PrizeDropWin_PrizeType) == TournamentProtocol.PrizeType.FreeRounds && details != null && details.freeRoundSettings != null && details.freeRoundSettings["availableGameNames"] !=
        null) {
        var availableGamesNames = details.freeRoundSettings["availableGameNames"];
        if (availableGamesNames.length == 1) {
            var trimmedGameTitleFromPromo = availableGamesNames[0].replace(/GR\sCV/, "").replace(/\sCV/, "").replace(/\sJP/, "").replace(/\s/g, "").toLowerCase();
            var trimmedGameTitle = XT.GetString(Vars.GameTitle).replace("", "").replace(/\s/g, "").toLowerCase();
            var pageTitle = document.title.replace(/GR\sCV/, "").replace(/\sCV/, "").replace(/\sJP/, "").replace(/\s/g, "").toLowerCase();
            if (trimmedGameTitleFromPromo ==
                trimmedGameTitle || pageTitle == trimmedGameTitleFromPromo) availableGamesNames = []
        }
        XT.SetString(TournamentVars.PrizeDropWin_FreeRoundGames, availableGamesNames.join(", ").toUpperCase())
    }
    if (promo.displayStyle == TournamentProtocol.DisplayStyle.IDNSM || promo.displayStyle == TournamentProtocol.DisplayStyle.IDNCSM || promo.displayStyle == TournamentProtocol.DisplayStyle.DropsAndWins) style = TournamentProtocol.ClientStyle.Europe;
    this.winContentSwitcher.SwitchByStyle(style);
    this.winContentSwitcher.SwitchByPrizeType(XT.GetInt(TournamentVars.PrizeDropWin_PrizeType));
    if (this.styleSwitcher != null) this.styleSwitcher.SwitchByDisplayStyle(promo.uid);
    this.catShowWin.Start()
};
PromotionsAnnouncer.prototype.ShowWinEnded = function() {
    this.mustShowWin = false;
    XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_WinShown);
    XT.SetString(TournamentVars.PrizeDropWin_FreeRoundGames, "");
    this.UnblockSpin()
};
PromotionsAnnouncer.prototype.UpdateDisplayedWin = function() {
    XT.SetDouble(TournamentVars.Promotion_WinDisplayed, XT.GetDouble(TournamentVars.Promotion_WinReceived))
};
PromotionsAnnouncer.prototype.OptIn = function() {
    PromotionsHelper.OptIn(this.uid);
    if (this.showMerged) PromotionsHelper.OptIn(this.secondaryUID)
};
PromotionsAnnouncer.prototype.OptOut = function() {
    PromotionsHelper.OptOut(this.uid);
    if (this.showMerged) PromotionsHelper.OptOut(this.secondaryUID)
};
PromotionsAnnouncer.prototype.FullRules = function() {
    if (!this.showMerged) {
        this.rules.SetVisible(true);
        this.rules.ForceUpdate();
        this.rules.UpdateRulesManually(this.uid);
        if (this.hasExtraLayout) {
            this.extraLayout.rules.SetVisible(true);
            this.extraLayout.rules.ForceUpdate();
            this.extraLayout.rules.UpdateRulesManually(this.uid)
        }
        this.catShowFull.Start()
    } else {
        this.secondaryRules.SetVisible(true);
        this.secondaryRules.ForceUpdate();
        this.secondaryRules.UpdateRulesManually(this.uid);
        if (this.hasExtraLayout) {
            this.extraLayout.rules.SetVisible(true);
            this.extraLayout.rules.ForceUpdate();
            this.extraLayout.rules.UpdateRulesManually(this.uid);
            this.secondaryExtraRules.SetVisible(true);
            this.secondaryExtraRules.ForceUpdate();
            this.secondaryExtraRules.UpdateRulesManually(this.uid)
        }
        this.secondaryCatShowFull.Start()
    }
};
PromotionsAnnouncer.prototype.BlockSpin = function() {
    if (!this.spinBlocked) {
        this.spinBlocked = true;
        XT.TriggerEvent(Vars.Evt_DataToCode_BlockSpin)
    }
};
PromotionsAnnouncer.prototype.UnblockSpin = function() {
    if (this.spinBlocked) {
        this.spinBlocked = false;
        XT.TriggerEvent(Vars.Evt_DataToCode_UnblockSpin)
    }
};
goog.require("UHT.XTLink");

function PromotionStyleSpriteColor() {
    this.name = "";
    this.colors = null;
    this.sprites = null
}

function PromotionStyleSpriteName() {
    this.name = "";
    this.names = null;
    this.sprites = null
}

function PromotionStyleButtonColors() {
    this.name = "";
    this.normalColors = null;
    this.hoverColors = null;
    this.pressedColors = null;
    this.disabledColors = null;
    this.buttons = null;
    this.targets = null
}
PromotionStyleSwitcher.prototype = Object.create(XTLink.prototype);
PromotionStyleSwitcher.prototype.constructor = PromotionStyleSwitcher;

function PromotionStyleSwitcher() {
    XTLink.call(this);
    this.styles = null;
    this.CATLinks = null;
    this.spriteColors = null;
    this.spriteNames = null;
    this.buttonColors = null;
    this.switchesByRegion = true;
    this.regions = null;
    this.displayStyles = null;
    PromotionStyleSwitcher.I = this
}
PromotionStyleSwitcher.I = null;
PromotionStyleSwitcher.prototype.XTRegisterCallbacks = function() {
    if (this.switchesByRegion) XT.RegisterCallbackObject(TournamentVars.Tournaments, this.OnPromotions, this)
};
PromotionStyleSwitcher.prototype.OnPromotions = function(promotions) {
    if (promotions == null) return;
    XT.UnregisterCallbackObject(this.OnPromotions, this, TournamentVars.Tournaments);
    for (var i = 0; i < promotions.length; ++i)
        if (promotions[i].displayStyle == TournamentProtocol.DisplayStyle.IDNSM || promotions[i].displayStyle == TournamentProtocol.DisplayStyle.IDNCSM || promotions[i].displayStyle == TournamentProtocol.DisplayStyle.DropsAndWins) return;
    this.SwitchByRegion()
};
PromotionStyleSwitcher.prototype.SwitchByRegion = function() {
    var region = UHT_GAME_CONFIG_SRC["region"];
    if (region == undefined) return;
    var idx = this.regions.indexOf(region);
    if (idx > -1) this.SwitchPromotionStyle(idx)
};
PromotionStyleSwitcher.prototype.SwitchByDisplayStyle = function(uid) {
    var promo = PromotionsHelper.FindPromotion(uid);
    if (promo == null) return;
    var idx = this.displayStyles.indexOf(promo.displayStyle);
    if (idx > -1) this.SwitchPromotionStyle(idx)
};
PromotionStyleSwitcher.prototype.SwitchPromotionStyle = function(idx) {
    this.CATLinks[idx].Start();
    for (var i = 0; i < this.spriteColors.length; ++i) {
        var color = this.spriteColors[i].colors[idx];
        var sprites = this.spriteColors[i].sprites;
        for (var j = 0; j < sprites.length; ++j) sprites[j].color = color
    }
    for (var i = 0; i < this.spriteNames.length; ++i) {
        var spriteName = this.spriteNames[i].names[idx];
        var sprites = this.spriteNames[i].sprites;
        for (var j = 0; j < sprites.length; ++j) sprites[j].SetSpriteName(spriteName)
    }
    for (var i = 0; i < this.buttonColors.length; ++i) {
        var normalColor =
            this.buttonColors[i].normalColors[idx];
        var hoverColor = this.buttonColors[i].hoverColors[idx];
        var pressedColor = this.buttonColors[i].pressedColors[idx];
        var disabledColor = this.buttonColors[i].disabledColors[idx];
        var buttons = this.buttonColors[i].buttons;
        var targets = this.buttonColors[i].targets;
        for (var j = 0; j < buttons.length; ++j) {
            var button = this.FindButtonByTarget(buttons[j], targets[j]);
            button.color_normal = normalColor;
            button.color_hover = hoverColor;
            button.color_pressed = pressedColor;
            button.color_disabled = disabledColor;
            var sprite = button.target;
            if (button.curState == UIButton.State.Hover) sprite.color = hoverColor;
            else if (button.curState == UIButton.State.Pressed) sprite.color = pressedColor;
            else if (button.curState == UIButton.State.Disabled) sprite.color = disabledColor;
            else sprite.color = normalColor
        }
    }
};
PromotionStyleSwitcher.prototype.FindButtonByTarget = function(button, target) {
    var buttons = button.GetComponentsInChildren(UIButton, true);
    for (var i = 0; i < buttons.length; ++i)
        if (buttons[i].target != null && buttons[i].target.gameObject == target) return buttons[i];
    return null
};
goog.require("UHT.XTLink");
PromotionsWarning.prototype = Object.create(XTLink.prototype);
PromotionsWarning.prototype.constructor = PromotionsWarning;

function PromotionsWarning() {
    XTLink.call(this);
    this.show = null;
    this.hide = null;
    this.promoTitleLabel = null;
    this.label = null;
    this.labelLocalized = null;
    this.handleMessage = false;
    this.details = null;
    this.isVisible = false;
    this.wasVisible = false
}
PromotionsWarning.I = null;
PromotionsWarning.formatOptions = new FormatOptions;
PromotionsWarning.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(TournamentVars.TournamentDetails, this.OnTournamentDetailsUpdated, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_BetChanged, this.OnBetChanged, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_UpdatePromotionWarning, this.OnBetChanged, this);
    if (this.handleMessage) PromotionsWarning.I = this
};
PromotionsWarning.prototype.OnTournamentDetailsUpdated = function(param) {
    this.details = param;
    this.OnBetChanged()
};
PromotionsWarning.prototype.OnBetChanged = function() {
    if (this.details == null) return;
    var totalBet = XT.GetDouble(Vars.TotalBetDisplayed);
    if (isNaN(totalBet)) return;
    var minBetLimit = -1;
    var promoTitle = "";
    for (var i = 0; i < this.details.length; ++i) {
        var promo = PromotionsHelper.FindPromotion(this.details[i].uid);
        var isConsidered = promo != null && promo.clientMode == TournamentProtocol.ClientMode.Visible && promo.status == TournamentProtocol.StatusCode.Open && PromotionsHelper.currentPromotionsUUID == this.details[i].uid;
        var prizePool =
            this.details[i].prizePoolTotal != null ? this.details[i].prizePoolTotal : this.details[i].prizePool;
        if (prizePool != null && isConsidered)
            if (minBetLimit < 0 || minBetLimit < prizePool.minBetLimit) {
                minBetLimit = prizePool.minBetLimit;
                promoTitle = promo.name
            }
    }
    var visible = totalBet < minBetLimit;
    if (visible) {
        this.label.text = PromotionsWarning.GetMessage(minBetLimit);
        this.promoTitleLabel.text = promoTitle
    }
    this.SetVisible(visible)
};
PromotionsWarning.prototype.SetVisible = function(visible) {
    if (this.isVisible == visible) return;
    this.isVisible = visible
};
PromotionsWarning.prototype.LateUpdate = function() {
    if (this.wasVisible == this.isVisible) return;
    this.wasVisible = this.isVisible;
    if (this.show.IsRunning()) this.show.Stop();
    if (this.hide.IsRunning()) this.hide.Stop();
    (this.isVisible ? this.show : this.hide).Start()
};
PromotionsWarning.GetMessage = function(value) {
    return PromotionsWarning.I.labelLocalized.text.replace("{0}", LocaleManager.FormatValue(value, PromotionsWarning.formatOptions))
};
goog.provide("UHT.PromotionWarning");
goog.require("UHT.XTLink");
PromotionWarning.prototype = Object.create(XTLink.prototype);
PromotionWarning.prototype.constructor = PromotionWarning;

function PromotionWarning() {
    XTLink.call(this);
    this.label = null;
    this.details = null;
    this.isVisible = false;
    this.uid = ""
}
PromotionWarning.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_BetChanged, this.OnBetChanged, this);
    XT.RegisterCallbackObject(TournamentVars.TournamentDetails, this.OnTournamentDetailsUpdated, this)
};
PromotionWarning.prototype.OnTournamentDetailsUpdated = function(param) {
    this.UpdatePromotion(this.uid)
};
PromotionWarning.prototype.UpdatePromotion = function(uid) {
    this.uid = uid;
    this.details = PromotionsHelper.FindDetails(this.uid);
    this.OnBetChanged()
};
PromotionWarning.prototype.OnBetChanged = function() {
    if (this.details == null) return;
    var totalBet = XT.GetDouble(Vars.TotalBetDisplayed);
    if (isNaN(totalBet)) return;
    var promo = PromotionsHelper.FindPromotion(this.uid);
    var isConsidered = promo != null && promo.clientMode == TournamentProtocol.ClientMode.Visible && promo.status == TournamentProtocol.StatusCode.Open;
    var minBetLimit = -1;
    var prizePool = this.details.prizePoolTotal != null ? this.details.prizePoolTotal : this.details.prizePool;
    if (prizePool != null && isConsidered) minBetLimit =
        prizePool.minBetLimit;
    var visible = totalBet < minBetLimit;
    if (this.label != null && visible) this.label.text = PromotionsWarning.GetMessage(minBetLimit);
    this.SetVisible(visible)
};
PromotionWarning.prototype.SetVisible = function(visible) {
    if (this.isVisible == visible) return;
    this.isVisible = visible;
    this.UpdateVisual(visible)
};
PromotionWarning.prototype.UpdateVisual = function(visible) {
    this.gameObject.SetActive(visible)
};
goog.provide("UHT.PromotionWinningsActive");
goog.require("UHT.XTLink");
PromotionWinningsActive.prototype = Object.create(XTLink.prototype);
PromotionWinningsActive.prototype.constructor = PromotionWinningsActive;

function PromotionWinningsActive() {
    XTLink.call(this)
}
PromotionWinningsActive.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_TournamentsUpdated, this.OnTournamentsUpdated, this);
    XT.RegisterCallbackString(TournamentVars.SelectedTournamentID, this.OnSelectedTournamentIDChanged, this)
};
PromotionWinningsActive.prototype.OnTournamentsUpdated = function() {
    this.OnSelectedTournamentIDChanged(XT.GetString(TournamentVars.SelectedTournamentID))
};
PromotionWinningsActive.prototype.OnSelectedTournamentIDChanged = function(uid) {
    var promo = PromotionsHelper.FindPromotion(uid);
    if (promo == null) return;
    this.gameObject.SetActive(promo.showWinnersList)
};
goog.require("UHT.PromotionWinningsActive");
PromotionWinningsActiveMini.prototype = Object.create(PromotionWinningsActive.prototype);
PromotionWinningsActiveMini.prototype.constructor = PromotionWinningsActiveMini;

function PromotionWinningsActiveMini() {
    PromotionWinningsActive.call(this);
    this.transforms = null;
    this.positionWinners = null;
    this.positionNoWinners = null;
    this.colliders = null;
    this.sizeWinners = null;
    this.sizeNoWinners = null;
    this.contentWinners = null;
    this.contentNoWinners = null
}
PromotionWinningsActiveMini.prototype.OnSelectedTournamentIDChanged = function(uid) {
    var promo = PromotionsHelper.FindPromotion(uid);
    if (promo == null) return;
    var showWinners = promo.showWinnersList;
    var positions = showWinners ? this.positionWinners : this.positionNoWinners;
    for (var i = 0; i < positions.length; ++i) this.transforms[i].localPosition(positions[i]);
    var sizes = showWinners ? this.sizeWinners : this.sizeNoWinners;
    for (var i = 0; i < sizes.length; ++i) this.colliders[i].size = sizes[i];
    for (var i = 0; i < this.contentWinners.length; ++i) this.contentWinners[i].SetActive(showWinners);
    for (var i = 0; i < this.contentNoWinners.length; ++i) this.contentNoWinners[i].SetActive(!showWinners)
};
goog.require("UHT.Engine");
var ScrollableListUpdateMethod = {
    Update: 0,
    LateUpdate: 1
};
ScrollableList.prototype = Object.create(Component.prototype);
ScrollableList.prototype.constructor = ScrollableList;

function ScrollableList() {
    Component.call(this);
    this.itemHeight = 0;
    this.mouseWheelItems = 0;
    this.useMouseWheel = true;
    this.buttonItems = 0;
    this.items = null;
    this.itemValues = null;
    this.scrollbar = null;
    this.scrollbarThumb = null;
    this.clickThreshold = 0;
    this.clickEvents = null;
    this.hasExtraItem = false;
    this.numberOfExtraItemsToAdd = 0;
    this.enabledContent = null;
    this.enabledContents = null;
    this.enabledColliders = null;
    this.hasInertia = false;
    this.inertiaCurve = null;
    this.useMinValueReached = false;
    this.minValueReached = null;
    this.minValueNotReached =
        null;
    this.strictMinValue = false;
    this.minValueReachedIfEmpty = false;
    this.useMaxValueReached = false;
    this.maxValueReached = null;
    this.maxValueNotReached = null;
    this.strictMaxValue = false;
    this.maxValueReachedIfEmpty = false;
    this.buttonAnimator = null;
    this.updateOn = ScrollableListUpdateMethod.Update;
    this.scrollConfirmation = null;
    this.separateScrollConfirmation = false;
    this.isSpringy = false;
    this.springAnimator = null;
    this.springAmount = 0;
    this.minThumbHeightIsWidthX = 0;
    this.inertiaTime = 0;
    this.isInertia = false;
    this.cachedCamera =
        null;
    this.wasPressed = false;
    this.wasHover = false;
    this.startMousePos = UHTMath.Vector3.zero;
    this.prevMousePos = UHTMath.Vector3.zero;
    this.firstItemPos = null;
    this.firstItemPosInited = false;
    this.isEnabled = false;
    this.scrollRemain = 0;
    this.wheelDelta = 0;
    this.scrollDelta = 0;
    this.scroll = 0;
    this.reachedMin = false;
    this.reachedMinInit = false;
    this.reachedMax = false;
    this.reachedMaxInit = false;
    this.enableFrame = -1;
    this.numberError = .001;
    this.thumbYMax = 0;
    this.thumbYMaxCurrent = 0;
    this.itemValuesSrc = null;
    this.shrinkAmount = 0;
    this.numItemsToShrink =
        0
}
ScrollableList.prototype.scriptUpdatePriority = 6;

function registerScrollableListAsListener(a, b, c) {
    window.addEventListener(a, b, c)
}
ScrollableList.prototype.Awake = function() {
    var self = this;
    var mwl = function(e) {
        return self.OnMouseWheel(e)
    };
    registerScrollableListAsListener("mousewheel", mwl, {
        passive: false
    });
    registerScrollableListAsListener("DOMMouseScroll", mwl, {
        passive: false
    })
};
ScrollableList.prototype.OnMouseWheel = function(e) {
    e.preventDefault();
    if (!this.isEnabled || !this.wasHover || Globals.InputBlocked && !(this.cachedCamera != null && this.cachedCamera.ignoreInputBlocked)) return;
    this.wheelDelta = e.wheelDelta ? -e.wheelDelta : e.detail;
    this.wheelDelta = UHTMath.clamp(this.wheelDelta, -1, 1);
    this.scrollDelta = 0
};
ScrollableList.prototype.CachedCamera = function() {
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    return this.cachedCamera
};
ScrollableList.prototype.OnDisable = function() {
    if (this.wasPressed) this.OnPress(false)
};
ScrollableList.prototype.OnHover = function(isHover) {
    this.wasHover = isHover;
    if (this.wasPressed && !isHover) this.OnPress(false)
};
ScrollableList.prototype.OnPress = function(isPressed) {
    this.wasPressed = isPressed;
    if (!this.hasInertia) this.scrollRemain = 0;
    if (isPressed) {
        this.StopSpring();
        this.StopInertia();
        this.startMousePos = this.prevMousePos = this.gameObject.transform.inverseTransformPoint(this.CachedCamera().ScreenToWorldPoint(Input.mousePosition));
        return
    } else if (this.isEnabled && this.hasInertia && this.scrollDelta != 0) {
        this.inertiaTime = 0;
        this.isInertia = true
    }
    this.UpdateItems(this.items[0].valueIdx);
    if (this.clickEvents.length == 0) return;
    var pos = this.gameObject.transform.inverseTransformPoint(this.CachedCamera().ScreenToWorldPoint(Input.mousePosition));
    var posDelta = UHTMath.Vector3.sub(pos, this.startMousePos);
    if (Math.abs(posDelta.y) > this.clickThreshold) return;
    if (!this.firstItemPosInited) {
        this.firstItemPosInited = true;
        this.firstItemPos = this.gameObject.transform.inverseTransformPoint(this.items[0].gameObject.transform.position())
    }
    var clickedIdx = -1;
    for (var i = 0; i < this.items.length; ++i) {
        var itemY = this.firstItemPos.y - this.itemHeight * i;
        if (pos.y <=
            itemY && pos.y > itemY - this.itemHeight) {
            clickedIdx = i;
            break
        }
    }
    if (clickedIdx < 0) return;
    var paramString = String(clickedIdx);
    for (var i = 0; i < this.clickEvents.length; ++i) {
        if (this.clickEvents[i].useParam) this.clickEvents[i].paramString = paramString;
        MessageSender.SendMessage(this.clickEvents[i])
    }
};
ScrollableList.prototype.InternalUpdate = function() {
    if (!this.isEnabled) return;
    var isWheelScroll = false;
    if (this.wasHover)
        if (this.wheelDelta != 0) {
            if (this.useMouseWheel) this.ScrollItems(this.wheelDelta * this.mouseWheelItems * this.itemHeight, true);
            this.wheelDelta = 0;
            isWheelScroll = true
        }
    if (this.wasPressed) {
        var pos = this.gameObject.transform.inverseTransformPoint(this.CachedCamera().ScreenToWorldPoint(Input.mousePosition));
        var posDelta = UHTMath.Vector3.sub(pos, this.prevMousePos);
        this.prevMousePos = pos;
        if (posDelta.y !=
            0) this.ScrollItems(posDelta.y)
    } else if (!isWheelScroll)
        if (this.isInertia) {
            var scrollAmount = this.inertiaCurve.Evaluate(this.inertiaTime) * this.scrollDelta;
            if (Math.abs(scrollAmount) < .001 || this.inertiaTime > this.inertiaCurve.keys[this.inertiaCurve.keys.length - 1].time) {
                this.isInertia = false;
                this.scrollDelta = 0
            }
            this.ScrollItems(scrollAmount);
            this.inertiaTime += Time.deltaTime
        }
};
ScrollableList.prototype.Update = function() {
    if (this.updateOn == ScrollableListUpdateMethod.Update) this.InternalUpdate()
};
ScrollableList.prototype.LateUpdate = function() {
    if (this.updateOn == ScrollableListUpdateMethod.LateUpdate) this.InternalUpdate();
    if (this.useMinValueReached) {
        var minReached = this.items[0].valueIdx == 0 && (!this.strictMinValue || Math.abs(this.scrollRemain) < this.numberError);
        if (this.minValueReachedIfEmpty && this.itemValues.length == 0) minReached = true;
        if (minReached != this.reachedMin || !this.reachedMinInit) {
            this.reachedMin = minReached;
            this.StartCATLink(this.reachedMin ? this.minValueReached : this.minValueNotReached)
        }
        this.reachedMinInit =
            true
    }
    if (this.useMaxValueReached) {
        var maxReached = this.items[0].valueIdx + this.items.length == this.itemValues.length && (!this.strictMaxValue || Math.abs(this.scrollRemain) < this.numberError);
        if (this.maxValueReachedIfEmpty && this.itemValues.length == 0) maxReached = true;
        if (maxReached != this.reachedMax || !this.reachedMaxInit) {
            this.reachedMax = maxReached;
            this.StartCATLink(this.reachedMax ? this.maxValueReached : this.maxValueNotReached)
        }
        this.reachedMaxInit = true
    }
    if (this.CanSpring()) {
        var minReached = this.items[0].valueIdx ==
            0;
        var maxReached = this.items[0].valueIdx + this.items.length == this.itemValues.length;
        if ((minReached || maxReached) && Math.abs(this.scrollRemain) < this.springAmount) this.Spring(minReached ? 1 : -1)
    }
};
ScrollableList.prototype.ScrollItems = function(scrollAmount, isWheelScroll) {
    if (!this.CanScroll(scrollAmount)) {
        this.scrollDelta = 0;
        return
    }
    if (isWheelScroll != true) this.scrollDelta = scrollAmount;
    this.scrollRemain += scrollAmount;
    if (this.items[0].valueIdx == 0 && this.scrollRemain < 0 || this.items[0].valueIdx + this.items.length == this.itemValues.length && this.scrollRemain > 0) this.scrollRemain = 0;
    var numItems = Math.round(this.scrollRemain / this.itemHeight);
    this.scrollRemain -= numItems * this.itemHeight;
    if (numItems < 0)
        for (var i =
                0; i < Math.abs(numItems); ++i) {
            var idx = this.items[0].valueIdx - 1;
            if (idx >= 0) {
                this.items[this.items.length - 1].UpdateIndexAndValue(idx, this.itemValues[idx]);
                this.items.unshift(this.items[this.items.length - 1]);
                this.items.pop()
            }
        } else if (numItems > 0)
            for (var i = 0; i < numItems; ++i) {
                var idx = this.items[this.items.length - 1].valueIdx + 1;
                if (idx < this.itemValues.length) {
                    this.items[0].UpdateIndexAndValue(idx, this.itemValues[idx]);
                    this.items.push(this.items[0]);
                    this.items.shift()
                }
            }
    this.UpdateItems(this.items[0].valueIdx)
};
ScrollableList.prototype.UpdateItems = function(startValIdx) {
    if (startValIdx < 0) startValIdx = 0;
    var minY = -this.itemHeight * (this.items.length - 1);
    for (var i = 0; i < this.items.length; ++i) {
        var idx = startValIdx + i;
        if (idx < this.itemValues.length) this.items[i].UpdateIndexAndValue(idx, this.itemValues[idx]);
        else this.items[i].UpdateIndexAndValue(idx, null);
        var y = i * -this.itemHeight + (this.isEnabled ? this.scrollRemain : 0);
        this.items[i].gameObject.transform.localPosition(new UHTMath.Vector3(0, y, 0));
        this.items[i].SetVisible(y >
            minY)
    }
    if (this.isEnabled) {
        var extraY = this.hasInertia ? this.scrollRemain / this.itemHeight : 0;
        var thumbY = this.scrollbar.height * (startValIdx + extraY) / (this.itemValues.length - 1);
        this.scroll = thumbY / this.thumbYMax;
        thumbY = UHTMath.lerp(0, this.thumbYMaxCurrent, this.scroll);
        this.scrollbarThumb.gameObject.transform.localPosition(new UHTMath.Vector3(0, -thumbY, 0))
    }
};
ScrollableList.prototype.InternalSetValues = function(values) {
    if (values != null && values.length > 0) {
        this.itemValuesSrc = values;
        this.itemValues = values.slice();
        if (this.itemValues[this.itemValues.length - 1] != null) {
            this.itemValues.push(null);
            if (this.hasExtraItem) this.itemValues.unshift(null);
            for (var i = 0; i < this.numberOfExtraItemsToAdd; ++i) this.itemValues.push(null);
            for (var i = 0; i < this.numItemsToShrink; ++i) this.itemValues.push(null)
        }
        this.isEnabled = this.items.length < this.itemValues.length
    } else {
        this.itemValues = [];
        this.isEnabled = false
    }
    if (this.isEnabled) {
        var thumbHeight = Math.floor(this.scrollbar.height * (this.items.length - 1) / (this.itemValues.length - 1));
        this.thumbYMax = this.scrollbar.height - thumbHeight;
        var thumbHeightMin = Math.floor(this.scrollbarThumb.width * this.minThumbHeightIsWidthX);
        thumbHeight = Math.max(thumbHeight, thumbHeightMin);
        this.scrollbarThumb.height = thumbHeight;
        this.thumbYMaxCurrent = this.scrollbar.height - thumbHeight
    }
    this.scrollbar.gameObject.SetActive(this.isEnabled);
    this.scrollbarThumb.gameObject.SetActive(this.isEnabled);
    if (this.enabledContent != null) this.enabledContent.SetActive(this.isEnabled);
    if (this.enabledContents != null)
        for (var i = 0; i < this.enabledContents.length; ++i) this.enabledContents[i].SetActive(this.isEnabled);
    if (this.enabledColliders != null)
        for (var i = 0; i < this.enabledColliders.length; ++i) this.enabledColliders[i].enabled = this.isEnabled
};
ScrollableList.prototype.SetValues = function(values, updateItems) {
    if (updateItems == undefined) updateItems = true;
    this.InternalSetValues(values);
    if (updateItems) this.UpdateItems(0)
};
ScrollableList.prototype.UpdateValues = function(values) {
    this.InternalSetValues(values);
    this.UpdateItems(this.items[0].valueIdx)
};
ScrollableList.prototype.UpdateValuesAndIndex = function(values, valueIndex, justUpdateItems) {
    if (justUpdateItems == undefined) justUpdateItems = false;
    if (!justUpdateItems) this.InternalSetValues(values);
    this.UpdateItems(valueIndex)
};
ScrollableList.prototype.isScrollable = function() {
    return this.isEnabled
};
ScrollableList.prototype.ThumbDragged = function(scrollAmount) {
    this.ScrollItems(-scrollAmount / this.scrollbar.height * this.itemHeight * (this.itemValues.length - 1))
};
ScrollableList.prototype.BarClicked = function() {
    var clickedPos = this.scrollbarThumb.gameObject.transform.parent.inverseTransformPoint(this.CachedCamera().ScreenToWorldPoint(Input.mousePosition));
    var thumbPos = this.scrollbarThumb.gameObject.transform.localPosition();
    this.ScrollItems(this.itemHeight * (this.items.length - 1) * (clickedPos.y < thumbPos.y ? 1 : -1))
};
ScrollableList.prototype.ButtonClicked = function(direction) {
    this.ButtonClickedInternal(direction * this.buttonItems * this.itemHeight)
};
ScrollableList.prototype.ButtonClickedPrevious = function() {
    this.ButtonClicked(-1)
};
ScrollableList.prototype.ButtonClickedNext = function() {
    this.ButtonClicked(1)
};
ScrollableList.prototype.CanScroll = function(scrollAmount) {
    if (this.scrollConfirmation == null) return true;
    if (!this.separateScrollConfirmation) return this.scrollConfirmation.CanScroll();
    if (scrollAmount > 0) return this.scrollConfirmation.CanScrollNext();
    return this.scrollConfirmation.CanScrollPrevious()
};
ScrollableList.prototype.StartCATLink = function(link) {
    if (link != null && link.cat != null) link.Start()
};
ScrollableList.prototype.StopInertia = function() {
    this.isInertia = false;
    this.scrollDelta = 0
};
ScrollableList.prototype.CanSpring = function() {
    return this.isSpringy && this.isEnabled && !this.wasPressed && !this.springAnimator.isPlaying
};
ScrollableList.prototype.Spring = function(direction) {
    this.StopInertia();
    var amount = (this.springAmount - Math.abs(this.scrollRemain)) * direction;
    if (this.enableFrame == Time.frameCount) this.ScrollItems(amount);
    else this.springAnimator.Play(amount)
};
ScrollableList.prototype.StopSpring = function() {
    if (!this.isSpringy) return;
    this.springAnimator.Stop()
};
ScrollableList.prototype.OnEnable = function() {
    this.enableFrame = Time.frameCount
};
ScrollableList.prototype.ButtonClickedInternal = function(scrollAmount) {
    if (this.buttonAnimator != null) this.buttonAnimator.Play(scrollAmount);
    else this.ScrollItems(scrollAmount, true)
};
ScrollableList.prototype.ButtonClickedFirst = function() {
    this.ButtonClickedInternal(-(this.items[0].valueIdx * this.itemHeight + this.scrollRemain))
};
ScrollableList.prototype.ButtonClickedLast = function() {
    this.ButtonClickedInternal((this.itemValues.length - 1 - this.items[0].valueIdx) * this.itemHeight + this.scrollRemain)
};
ScrollableList.prototype.Shrink = function(shrink, worldAmount) {
    var vI = this.transform.parent.inverseTransformVector(worldAmount);
    var vB = this.scrollbar.transform.parent.inverseTransformVector(worldAmount);
    if (shrink) {
        this.shrinkAmount -= vI.y;
        this.scrollbar.height += Math.round(vB.y)
    } else {
        this.shrinkAmount += vI.y;
        this.scrollbar.height -= Math.round(vB.y)
    }
    this.numItemsToShrink = Math.ceil(this.shrinkAmount / this.itemHeight);
    if (this.itemValuesSrc != null) {
        this.InternalSetValues(this.itemValuesSrc);
        if (shrink) this.ScrollItems(-vI.y,
            true);
        else this.ScrollItems(vI.y, true)
    }
};
goog.require("UHT.Engine");
ScrollableListAnimator.prototype = Object.create(Component.prototype);
ScrollableListAnimator.prototype.constructor = ScrollableListAnimator;

function ScrollableListAnimator() {
    Component.call(this);
    this.target = null;
    this.animationCurve = null;
    this.animationTime = 0;
    this.isAccumulative = false;
    this.isPlaying = false;
    this.valueFrom = 0;
    this.valueTo = 0;
    this.currentTime = 0;
    this.currentValue = 0;
    this.totalTime = 0
}
ScrollableListAnimator.prototype.Play = function(value) {
    if (this.isAccumulative && this.isPlaying) {
        var prevValueTo = this.valueTo;
        this.valueTo += value;
        this.valueFrom = this.currentValue - (this.currentValue - this.valueFrom) * (this.valueTo - this.currentValue) / (prevValueTo - this.currentValue);
        var prevTotalTime = this.totalTime;
        this.totalTime += this.animationTime;
        this.currentTime *= this.totalTime / prevTotalTime
    } else {
        this.totalTime = this.animationTime;
        this.currentTime = 0;
        this.valueFrom = this.currentValue = 0;
        this.valueTo = value
    }
    this.isPlaying =
        true
};
ScrollableListAnimator.prototype.Stop = function() {
    this.isPlaying = false
};
ScrollableListAnimator.prototype.Update = function() {
    if (!this.isPlaying) return;
    var time = UHTMath.clamp(this.currentTime / this.totalTime, 0, 1);
    time *= this.animationCurve.keys[this.animationCurve.keys.length - 1].time;
    var value = UHTMath.lerp(this.valueFrom, this.valueTo, this.animationCurve.Evaluate(time));
    this.target.ScrollItems(value - this.currentValue, true);
    if (this.currentTime >= this.totalTime) this.isPlaying = false;
    this.currentValue = value;
    this.currentTime += Time.deltaTime
};
goog.provide("UHT.ScrollableListItem");
goog.require("UHT.XTLink");
ScrollableListItem.prototype = Object.create(XTLink.prototype);
ScrollableListItem.prototype.constructor = ScrollableListItem;

function ScrollableListItem() {
    XTLink.call(this);
    this.valueIdx = -1;
    this.valueObj = null;
    this.needUpdate = true
}
ScrollableListItem.prototype.UpdateIndexAndValue = function(idx, value) {
    this.valueIdx = idx;
    if (!this.needUpdate && this.valueObj == value) return;
    this.valueObj = value;
    this.needUpdate = false;
    this.UpdateValue(value)
};
ScrollableListItem.prototype.UpdateValue = function(value) {};
ScrollableListItem.prototype.SetVisible = function(isVisible) {};
goog.provide("UHT.LobbyGameButton");
goog.require("UHT.ScrollableListItem");
LobbyGameButton.prototype = Object.create(ScrollableListItem.prototype);
LobbyGameButton.prototype.constructor = LobbyGameButton;

function LobbyGameButton() {
    ScrollableListItem.call(this);
    this.icon = null;
    this.altIcon = null;
    this.label = null;
    this.threshold = 0;
    this.confirmation = null;
    this.IDNSM = null;
    this.IDNCSM = null;
    this.dropsAndWins = null;
    this.gameData = null;
    this.cachedCamera = null;
    this.pressPos = null;
    this.dnwIconUpdated = false
}
LobbyGameButton.confirmationButton = null;
LobbyGameButton.dnwSpriteName = "";
LobbyGameButton.GetDNWinsSpriteName = function() {
    var ret = "drop_win_lobby";
    var key = "region";
    if (UHT_GAME_CONFIG_SRC["region"] == undefined || UHT_GAME_CONFIG_SRC["region"] != "Asia") return ret;
    ret += "_as";
    var language = ServerOptions.language;
    if (language == "zh" || language == "zt") ret += "_zh_zt";
    return ret
};
LobbyGameButton.GetDropsAndWinsSpriteName = function() {
    if (_string.IsNullOrEmpty(LobbyGameButton.dnwSpriteName)) LobbyGameButton.dnwSpriteName = LobbyGameButton.GetDNWinsSpriteName();
    return LobbyGameButton.dnwSpriteName
};
LobbyGameButton.prototype.XTRegisterCallbacks = function() {
    ScrollableListItem.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackEvent(LobbyVars.Evt_Internal_LobbyGameButton_ConfirmationButtonChanged, this.OnConfirmationButtonChanged, this)
};
LobbyGameButton.prototype.OnConfirmationButtonChanged = function() {
    if (LobbyGameButton.confirmationButton != this) this.OnHover(false)
};
LobbyGameButton.prototype.UpdateValue = function(value) {
    this.gameData = value;
    this.gameObject.SetActive(value != null);
    if (value == null) return;
    if (value.atlas != null) {
        this.icon.atlas = value.atlas;
        this.icon.SetSpriteName(value.uid)
    }
    this.icon.gameObject.SetActive(value.atlas != null);
    this.altIcon.SetActive(value.atlas == null);
    this.label.text = value.name;
    if (this.dropsAndWins != null) {
        this.dropsAndWins.SetActive(value.displayStyle == TournamentProtocol.DisplayStyle.DropsAndWins);
        if (!this.dnwIconUpdated) {
            this.dnwIconUpdated =
                true;
            var dnvIcon = this.dropsAndWins.GetComponent(UISprite);
            if (dnvIcon != null) dnvIcon.SetSpriteName(LobbyGameButton.GetDropsAndWinsSpriteName())
        }
    }
    if (this.IDNSM != null) this.IDNSM.SetActive(value.displayStyle == TournamentProtocol.DisplayStyle.IDNSM);
    if (this.IDNCSM != null) this.IDNCSM.SetActive(value.displayStyle == TournamentProtocol.DisplayStyle.IDNCSM)
};
LobbyGameButton.prototype.OnPress = function(isPressed) {
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    var pos = this.cachedCamera.gameObject.transform.inverseTransformPoint(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition));
    if (isPressed) {
        this.pressPos = pos;
        return
    }
    var posDelta = UHTMath.Vector3.sub(pos, this.pressPos);
    if (Math.abs(posDelta.x) > this.threshold || Math.abs(posDelta.y) > this.threshold) return;
    if (this.confirmation != null && !this.confirmation.activeSelf) {
        this.confirmation.SetActive(true);
        LobbyGameButton.confirmationButton = this;
        XT.TriggerEvent(LobbyVars.Evt_Internal_LobbyGameButton_ConfirmationButtonChanged);
        return
    }
    if (this instanceof MultiLobbyGameButton)
        if (this.gameData.symbol != "") globalTracking.SendEvent("uht_behaviour", "OpenedFromMultiLobby_" + this.gameData.symbol, Time.time | 0, "BehaviourTracker");
        else globalTracking.SendEvent("uht_behaviour", "OpenedFromMultiLobby_LC_" + this.gameData.casinoId, Time.time | 0, "BehaviourTracker");
    else globalTracking.SendEvent("uht_behaviour", "OpenedFromLobby_" +
        this.gameData.symbol, Time.time | 0, "BehaviourTracker");
    console.log("Lobby game clicked. URL: " + this.gameData.launchURL);
    var gameCanvas = document.getElementsByTagName("canvas")[0];
    if (gameCanvas != undefined) gameCanvas.style.display = "none";
    if (createjs.WebAudioSoundInstance != null && createjs.WebAudioSoundInstance.context != null) createjs.WebAudioSoundInstance.context.suspend();
    this.StartGame(this.gameData)
};
LobbyGameButton.prototype.StartGame = function(gameData) {
    location.assign(gameData.launchURL)
};
LobbyGameButton.TrackLobbyOpenedSent = false;
LobbyGameButton.prototype.OnEnable = function() {
    if (!LobbyGameButton.TrackLobbyOpenedSent) globalTracking.SendEvent("uht_behaviour", "Lobby_opened", Time.time | 0, "BehaviourTracker");
    LobbyGameButton.TrackLobbyOpenedSent = true
};
LobbyGameButton.prototype.OnHover = function(isOver) {
    if (!isOver && this.confirmation != null && this.confirmation.activeSelf) this.confirmation.SetActive(false)
};
LobbyGameButton.prototype.OnDisable = function() {
    this.OnHover(false)
};
goog.require("UHT.ScrollableListItem");
LobbyGameButtons.prototype = Object.create(ScrollableListItem.prototype);
LobbyGameButtons.prototype.constructor = LobbyGameButtons;

function LobbyGameButtons() {
    ScrollableListItem.call(this);
    this.animator = null;
    this.buttons = null
}
LobbyGameButtons.prototype.UpdateValue = function(list) {
    var i = 0;
    if (list != null) {
        for (i = 0; i < list.length; ++i) this.buttons[i].UpdateValue(list[i]);
        this.animator.Sample(list.length / this.buttons.length)
    }
    for (; i < this.buttons.length; ++i) this.buttons[i].UpdateValue(null)
};
goog.require("UHT.LobbyGameButton");
MultiLobbyGameButton.prototype = Object.create(LobbyGameButton.prototype);
MultiLobbyGameButton.prototype.constructor = MultiLobbyGameButton;

function MultiLobbyGameButton() {
    LobbyGameButton.call(this);
    this.slot = null;
    this.slotNew = null;
    this.slotHot = null;
    this.live = null;
    this.liveNew = null;
    this.liveIcon = null;
    this.liveName = null;
    this.liveDealer = null;
    this.liveNameDealerSpace = null;
    this.liveNameDealerSpaceMinWidth = 0;
    this.liveNameDealerAnchor = null;
    this.livePlayers = null;
    this.liveBetLimits = null;
    this.liveBetLimitsPlayersSpace = null;
    this.liveBetLimitsPlayersSpaceMinWidth = 0;
    this.liveBetLimitsPlayersAnchor = null;
    this.liveIDNSM = null;
    this.liveIDNCSM = null;
    this.liveDropsAndWins =
        null;
    this.widgetsMask = null;
    this.updateLiveOnEnable = false;
    this.liveDnwIconUpdated = false
}
MultiLobbyGameButton.liveBetLimitsSeparator = " - ";
MultiLobbyGameButton.livePlayersSeparator = "/";
MultiLobbyGameButton.dgaTables = null;
MultiLobbyGameButton.GetDgaTable = function(tableId) {
    var dgaTables = MultiLobbyGameButton.dgaTables;
    if (dgaTables == null) dgaTables = MultiLobbyGameButton.dgaTables = XT.GetObject(MultiLobbyVars.MultiLobby_LiveCasinoGames);
    if (dgaTables != null)
        for (var i = 0; i < dgaTables.length; ++i)
            if (dgaTables[i].tableId == tableId) return dgaTables[i];
    return null
};
MultiLobbyGameButton.FormatValueTrimZeroDecimals = function(value, currency) {
    var ret = LocaleManager.FormatValueWithCustomCurrency(value, currency);
    var currencyInfo = LocaleManager.currencyInfo;
    if (LocaleManager.customCurrencyInfo[currency] != undefined) currencyInfo = LocaleManager.customCurrencyInfo[currency];
    var decDigits = currencyInfo.CurrencyDecimalDigits;
    var decSep = currencyInfo.CurrencyDecimalSeparator;
    var decSepLength = decSep.length;
    var dec = ret.substr(ret.indexOf(decSep), decDigits + decSepLength);
    var decTrimmed =
        _string.TrimEnd(dec, "0");
    if (decTrimmed.length == decSepLength) decTrimmed = "";
    return ret.replace(dec, decTrimmed)
};
MultiLobbyGameButton.prototype.UpdateValue = function(value) {
    LobbyGameButton.prototype.UpdateValue.call(this, value);
    if (value == null) return;
    var isLive = value.vendorType == LobbyVendorType.LiveCasino;
    this.slot.SetActive(!isLive);
    this.live.SetActive(isLive);
    if (isLive) this.UpdateLive(value);
    else {
        this.slotNew.SetActive(MultiLobbyConnection.IsNewSlot(value.uid) && value.displayStyle == TournamentProtocol.DisplayStyle.Default);
        this.slotHot.SetActive(MultiLobbyConnection.IsHotSlot(value.uid));
        this.UpdateWidgetsMask()
    }
};
MultiLobbyGameButton.prototype.UpdateLive = function(value) {
    this.updateLiveOnEnable = !this.gameObject.activeInHierarchy;
    if (this.updateLiveOnEnable) return;
    var table = MultiLobbyGameButton.GetDgaTable(value.id);
    if (table == null) return;
    var limits = table.tableLimits;
    if (limits != null) {
        var currency = table.currency;
        var min = MultiLobbyGameButton.FormatValueTrimZeroDecimals(limits.minBet, currency);
        var max = MultiLobbyGameButton.FormatValueTrimZeroDecimals(limits.maxBet, currency);
        this.liveBetLimits.text = min + MultiLobbyGameButton.liveBetLimitsSeparator +
            max
    }
    var playersText = table.totalSeatedPlayers.toString();
    if (table.totalSeats > 0) playersText += MultiLobbyGameButton.livePlayersSeparator + table.totalSeats.toString();
    if (value.atlas != null) {
        this.liveIcon.atlas = value.atlas;
        this.liveIcon.SetSpriteName(value.uid)
    }
    this.liveIcon.gameObject.SetActive(value.atlas != null);
    this.liveName.text = table.tableName;
    this.livePlayers.text = playersText;
    this.liveNew.SetActive(table.newTable && value.displayStyle == TournamentProtocol.DisplayStyle.Default);
    this.liveDealer.text = table.dealer ==
        null ? "" : table.dealer.name;
    var width = this.liveNameDealerAnchor.maxWidth - this.liveName.GetWidth() - this.liveDealer.GetWidth();
    this.liveNameDealerSpace.SetWidth(width > this.liveNameDealerSpaceMinWidth ? width : this.liveNameDealerSpaceMinWidth);
    width = this.liveBetLimitsPlayersAnchor.maxWidth - this.liveBetLimits.GetWidth() - this.livePlayers.GetWidth();
    this.liveBetLimitsPlayersSpace.SetWidth(width > this.liveBetLimitsPlayersSpaceMinWidth ? width : this.liveBetLimitsPlayersSpaceMinWidth);
    if (this.liveDropsAndWins != null) {
        this.liveDropsAndWins.SetActive(value.displayStyle ==
            TournamentProtocol.DisplayStyle.DropsAndWins);
        if (!this.liveDnwIconUpdated) {
            this.liveDnwIconUpdated = true;
            var dnvIcon = this.liveDropsAndWins.GetComponent(UISprite);
            if (dnvIcon != null) dnvIcon.SetSpriteName(LobbyGameButton.GetDropsAndWinsSpriteName())
        }
    }
    if (this.liveIDNSM != null) this.liveIDNSM.SetActive(value.displayStyle == TournamentProtocol.DisplayStyle.IDNSM);
    if (this.liveIDNCSM != null) this.liveIDNCSM.SetActive(value.displayStyle == TournamentProtocol.DisplayStyle.IDNCSM);
    this.UpdateWidgetsMask()
};
MultiLobbyGameButton.TrackLobbyOpenedSent = false;
MultiLobbyGameButton.prototype.OnEnable = function() {
    if (!MultiLobbyGameButton.TrackLobbyOpenedSent) globalTracking.SendEvent("uht_behaviour", "MultiLobby_opened", Time.time | 0, "BehaviourTracker");
    MultiLobbyGameButton.TrackLobbyOpenedSent = true;
    if (this.updateLiveOnEnable) {
        this.updateLiveOnEnable = false;
        this.UpdateLive(this.gameData)
    }
};
MultiLobbyGameButton.prototype.UpdateWidgetsMask = function() {
    if (this.widgetsMask != null) this.widgetsMask.ForceNextUpdate()
};
goog.provide("UHT.ReplayWinning");
goog.require("UHT.ScrollableListItem");
ReplayWinning.prototype = Object.create(ScrollableListItem.prototype);
ReplayWinning.prototype.constructor = ReplayWinning;

function ReplayWinning() {
    ScrollableListItem.call(this);
    this.date = null;
    this.time = null;
    this.roundID = null;
    this.bet = null;
    this.betMultipliers = null;
    this.win = null;
    this.winLevels = null;
    this.odd = null;
    this.clickThreshold = 20;
    this.buttons = null;
    this.manager = null;
    this.round = null;
    this.cachedCamera = null;
    this.pressPos = null
}
ReplayWinning.prototype.Start = function() {
    for (var i = 0; i < this.buttons.length; ++i) this.buttons[i].winning = this
};
ReplayWinning.prototype.UpdateValue = function(value) {
    this.round = value;
    this.gameObject.SetActive(this.round != null);
    if (this.round == null) return;
    var winLevel = 0;
    for (var i = 0; i < this.manager.winSteps.length; i++)
        if (this.round.rtp >= this.manager.winSteps[i]) winLevel = i;
    for (var i = 0; i < this.winLevels.length; i++) this.winLevels[i].SetActive(i == winLevel);
    if (this.win != null) this.win.SetValueManually(this.round.win);
    var text = this.manager.betFormat.replace("{0}", Math.floor(this.round.rtp).toString());
    for (var i = 0; i < this.betMultipliers.length; ++i) this.betMultipliers[i].text =
        text;
    var playedDate = new Date(this.round.playedDate);
    if (this.date != null) this.date.text = DateTime.ToString(playedDate, this.manager.dateFormat);
    if (this.time != null) this.time.text = DateTime.ToString(playedDate, this.manager.timeFormat);
    if (this.odd != null) this.odd.SetActive(this.valueIdx % 2 == 1);
    if (this.bet != null) this.bet.SetValueManually(this.round.bet);
    if (this.roundID != null) this.roundID.text = this.round.roundID.toString();
    for (var i = 0; i < this.buttons.length; ++i) this.buttons[i].UpdateValue(this.round)
};
ReplayWinning.prototype.OnPress = function(isPressed) {
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    var pos = this.cachedCamera.transform.inverseTransformPoint(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition));
    if (isPressed) {
        this.pressPos = pos;
        return
    }
    var posDelta = UHTMath.Vector3.sub(pos, this.pressPos);
    if (Math.abs(posDelta.y) > this.clickThreshold) return;
    XT.SetObject(ReplayVars.Replay_SelectedRound, this.round);
    XT.TriggerEvent(ReplayVars.Evt_CodeToData_Replay_OpenSelectedRound)
};
goog.require("UHT.ReplayWinning");
ReplaySelectedWinning.prototype = Object.create(ReplayWinning.prototype);
ReplaySelectedWinning.prototype.constructor = ReplaySelectedWinning;

function ReplaySelectedWinning() {
    ReplayWinning.call(this)
}
ReplaySelectedWinning.prototype.XTRegisterCallbacks = function() {
    ReplayWinning.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackObject(ReplayVars.Replay_SelectedRound, this.UpdateValue, this)
};
goog.require("UHT.ScrollableListItem");
PromotionRuleLine.prototype = Object.create(ScrollableListItem.prototype);
PromotionRuleLine.prototype.constructor = PromotionRuleLine;

function PromotionRuleLine() {
    ScrollableListItem.call(this);
    this.labelsAnchor = null;
    this.unitId = 0;
    this.unitsPooler = null;
    this.units = []
}
PromotionRuleLine.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(TournamentVars.PromotionRuleUnitsPooler, this.OnPromotionRuleUnitsPooler, this)
};
PromotionRuleLine.prototype.OnPromotionRuleUnitsPooler = function(param) {
    this.unitsPooler = param
};
PromotionRuleLine.prototype.UpdateValue = function(value) {
    this.gameObject.SetActive(value != null);
    if (value == null) {
        this.RecycleUnits(this.units.length);
        return
    }
    var line = value;
    var prevCount = this.units.length;
    this.RecycleUnits(this.units.length - line.units.length);
    for (var i = 0; i < this.units.length; ++i) this.units[i].UpdateValue(line.units[i]);
    for (var i = this.units.length; i < line.units.length; ++i) {
        this.units.push(this.unitsPooler.GetObject(this.unitId, this.gameObject));
        this.units[i].UpdateValue(line.units[i]);
        this.labelsAnchor.labels = this.labelsAnchor.labels.concat(this.units[i].labels)
    }
    if (prevCount != this.units.length) this.labelsAnchor.DiscardCache()
};
PromotionRuleLine.prototype.SetVisible = function(isVisible) {
    for (var i = 0; i < this.units.length; ++i) this.units[i].isVisible = isVisible
};
PromotionRuleLine.prototype.RecycleUnits = function(count) {
    if (count < 0) return;
    for (var i = 0; i < count; ++i) {
        this.unitsPooler.RecycleObject(this.units[i]);
        this.labelsAnchor.labels.splice(0, this.units[i].labels.length)
    }
    var rest = [];
    for (var i = count; i < this.units.length; ++i) rest.push(this.units[i]);
    this.units = rest
};
goog.require("UHT.Engine");
ScrollableListThumb.prototype = Object.create(Component.prototype);
ScrollableListThumb.prototype.constructor = ScrollableListThumb;

function ScrollableListThumb() {
    Component.call(this);
    this.scrollableList = null;
    this.wasPressed = false;
    this.prevMousePos = UHTMath.Vector3.zero
}
ScrollableListThumb.prototype.OnHover = function(isHover) {
    if (this.wasPressed && !isHover) this.OnPress(false)
};
ScrollableListThumb.prototype.OnPress = function(isPressed) {
    this.wasPressed = isPressed;
    if (isPressed) this.prevMousePos = this.scrollableList.scrollbar.transform.inverseTransformPoint(this.scrollableList.CachedCamera().ScreenToWorldPoint(Input.mousePosition))
};
ScrollableListThumb.prototype.Update = function() {
    if (this.wasPressed) {
        var pos = this.scrollableList.scrollbar.transform.inverseTransformPoint(this.scrollableList.CachedCamera().ScreenToWorldPoint(Input.mousePosition));
        var posDelta = UHTMath.Vector3.sub(pos, this.prevMousePos);
        this.prevMousePos = pos;
        if (posDelta.y != 0) this.scrollableList.ThumbDragged(posDelta.y)
    }
};
goog.provide("UHT.ScrollConfirmation");
goog.require("UHT.Engine");
ScrollConfirmation.prototype = Object.create(Component.prototype);
ScrollConfirmation.prototype.constructor = ScrollConfirmation;

function ScrollConfirmation() {
    Component.call(this);
    this.numberError = .001
}
ScrollConfirmation.prototype.CanScroll = function() {
    return true
};
ScrollConfirmation.prototype.CanScrollPrevious = function() {
    return this.CanScroll()
};
ScrollConfirmation.prototype.CanScrollNext = function() {
    return this.CanScroll()
};
ScrollConfirmation.prototype.VectorsEqual = function(a, b) {
    return Math.abs(a.x - b.x) < this.numberError && Math.abs(a.y - b.y) < this.numberError && Math.abs(a.z - b.z) < this.numberError
};
goog.require("UHT.ScrollConfirmation");
LobbyScrollbarsController.prototype = Object.create(ScrollConfirmation.prototype);
LobbyScrollbarsController.prototype.constructor = LobbyScrollbarsController;

function LobbyScrollbarsController() {
    ScrollConfirmation.call(this);
    this.pageScrollbar = null;
    this.pageDrag = null;
    this.gamesScrollbar = null;
    this.games2PageProxy = null;
    this.featuredScrollbar = null;
    this.gameButtonsHolder = null;
    this.canScrollGamesNext = false;
    this.canScrollPagePrevious = false;
    this.gameButtons = null;
    this.gameButtonsCamera = null;
    this.gameButtonsLayerMask = null;
    this.featuredPressed = false;
    this.featuredPressedFrame = -1;
    this.featuredReleasedFrame = -1;
    this.featuredMouse = null;
    this.featuredDeltas = [];
    this.featuredDeltasCount =
        10;
    this.canScrollFeatured = true
}
LobbyScrollbarsController.prototype.scriptUpdatePriority = 4;
LobbyScrollbarsController.prototype.CanScroll = function() {
    return this.canScrollFeatured
};
LobbyScrollbarsController.prototype.CanScrollNext = function() {
    return this.canScrollGamesNext
};
LobbyScrollbarsController.prototype.Update = function() {
    var canScroll = this.VectorsEqual(this.pageDrag.target.localPosition(), this.pageDrag.localPositionLimitMax);
    if (this.canScrollGamesNext != canScroll) {
        this.canScrollGamesNext = canScroll;
        if (canScroll && this.pageScrollbar.isInertia) {
            this.gamesScrollbar.isInertia = true;
            this.gamesScrollbar.inertiaTime = this.pageScrollbar.inertiaTime;
            this.gamesScrollbar.scrollDelta = UHTMath.Vector3.scale(UHTMath.Vector3.sub(this.pageScrollbar.simpleLocalPositionLimitMax, this.pageScrollbar.simpleLocalPositionLimitMin),
                this.pageScrollbar.scrollDelta).y
        }
    }
    if (this.canScrollGamesNext) {
        canScroll = this.gamesScrollbar.reachedMin;
        if (this.canScrollPagePrevious != canScroll) {
            this.canScrollPagePrevious = canScroll;
            this.pageDrag.gameObject.SetActive(canScroll);
            if (canScroll) {
                this.games2PageProxy.NotifyIfHovered();
                this.games2PageProxy.NotifyIfPressed();
                if (this.gamesScrollbar.isInertia) {
                    this.pageScrollbar.isInertia = true;
                    this.pageScrollbar.inertiaTime = this.gamesScrollbar.inertiaTime;
                    this.pageScrollbar.scrollDelta = this.gamesScrollbar.scrollDelta /
                        (this.pageScrollbar.simpleLocalPositionLimitMax.y - this.pageScrollbar.simpleLocalPositionLimitMin.y)
                }
            }
        }
    }
    if (this.featuredPressed) {
        var delta = UHTMath.Vector3.sub(Input.mousePosition, this.featuredMouse);
        this.featuredMouse = Input.mousePosition;
        this.featuredDeltas.push(new UHTMath.Vector3(Math.abs(delta.x), Math.abs(delta.y), 0));
        if (this.featuredDeltas.length > this.featuredDeltasCount) this.featuredDeltas.splice(0, 1);
        var totalDelta = new UHTMath.Vector3(0, 0, 0);
        for (var i = 0; i < this.featuredDeltas.length; ++i) totalDelta.add(this.featuredDeltas[i]);
        if (totalDelta.x != totalDelta.y) this.canScrollFeatured = totalDelta.x > totalDelta.y;
        this.pageDrag.movement = new UHTMath.Vector3(0, this.canScrollFeatured ? 0 : 1, 0)
    }
    var resetFeatured = false;
    if (!this.featuredPressed && this.featuredPressedFrame > this.featuredReleasedFrame) {
        this.featuredPressed = true;
        this.featuredMouse = Input.mousePosition;
        resetFeatured = true
    }
    if (this.featuredPressed && this.featuredPressedFrame < this.featuredReleasedFrame) {
        this.featuredPressed = false;
        this.featuredDeltas.splice(0);
        resetFeatured = true
    }
    if (resetFeatured) {
        this.canScrollFeatured =
            true;
        this.pageDrag.movement = new UHTMath.Vector3(0, 1, 0)
    }
};
LobbyScrollbarsController.prototype.FeaturedColliderPressed = function() {
    if (this.featuredScrollbar.isEnabled) this.featuredPressedFrame = Time.frameCount
};
LobbyScrollbarsController.prototype.FeaturedColliderReleased = function() {
    if (this.featuredScrollbar.isEnabled) this.featuredReleasedFrame = Time.frameCount
};
LobbyScrollbarsController.prototype.UpdateGameButtonHover = function() {
    if (this.gameButtons == null) {
        this.gameButtons = this.gameButtonsHolder.GetComponentsInChildren(LobbyGameButton, true);
        this.gameButtonsCamera = Globals.GetCameraForObject(this.gameButtons[0].gameObject);
        this.gameButtonsLayerMask = new LayerMask;
        this.gameButtonsLayerMask.mask = 1 << this.gameButtons[0].gameObject.layer
    }
    var hoveredCollider = globalColliderInputManager.getHoveredCollider(this.gameButtonsCamera.ScreenToWorldPoint(Input.mousePosition),
        this.gameButtonsLayerMask);
    for (var i = 0; i < this.gameButtons.length; ++i)
        if (hoveredCollider != this.gameButtons[i].gameObject.collider) this.gameButtons[i].OnHover(false)
};
goog.require("UHT.PromotionWarning");
SelectedPromotionWarning.prototype = Object.create(PromotionWarning.prototype);
SelectedPromotionWarning.prototype.constructor = SelectedPromotionWarning;

function SelectedPromotionWarning() {
    PromotionWarning.call(this);
    this.offset = null;
    this.staticContents = null;
    this.dynamicContents = null;
    this.warningContents = null;
    this.scrollables = null;
    this.needUpdate = false;
    this.staticPos = null;
    this.dynamicPos = null
}
SelectedPromotionWarning.prototype.XTRegisterCallbacks = function() {
    PromotionWarning.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackString(TournamentVars.SelectedTournamentID, this.UpdatePromotion, this)
};
SelectedPromotionWarning.prototype.UpdateVisual = function(visible) {
    this.needUpdate = true
};
SelectedPromotionWarning.prototype.LateUpdate = function() {
    if (!this.needUpdate) return;
    this.needUpdate = false;
    if (this.staticPos == null) {
        this.staticPos = [];
        this.dynamicPos = [];
        for (var i = 0; i < this.dynamicContents.length; ++i) this.dynamicPos[i] = this.dynamicContents[i].localPosition()
    }
    for (var i = 0; i < this.staticContents.length; ++i) this.staticPos[i] = this.staticContents[i].position();
    var offsetW = this.transform.parent.transformVector(this.offset);
    for (var i = 0; i < this.dynamicContents.length; ++i) {
        var offsetL = this.isVisible ?
            this.dynamicContents[i].parent.inverseTransformVector(offsetW) : UHTMath.Vector3.zero;
        this.dynamicContents[i].localPosition(UHTMath.Vector3.add(this.dynamicPos[i], offsetL))
    }
    for (var i = 0; i < this.staticContents.length; ++i) this.staticContents[i].position(this.staticPos[i]);
    for (var i = 0; i < this.warningContents.length; ++i) this.warningContents[i].SetActive(this.isVisible);
    for (var i = 0; i < this.scrollables.length; ++i) this.scrollables[i].Shrink(this.isVisible, offsetW)
};
goog.provide("UHT.Tournament");
goog.require("UHT.ScrollableListItem");
Tournament.prototype = Object.create(ScrollableListItem.prototype);
Tournament.prototype.constructor = Tournament;

function Tournament() {
    ScrollableListItem.call(this);
    this.selectedContent = null;
    this.unselectedContent = null;
    this.nameLabel = null;
    this.nameLabels = null;
    this.statusLabel = null;
    this.statusLabels = null;
    this.localizedStartsInLabel_0 = null;
    this.localizedStartsInLabel_1 = null;
    this.localizedOpenLabel_0 = null;
    this.localizedOpenLabel_1 = null;
    this.localizedCloseLabel = null;
    this.localizedDayLabel_0 = null;
    this.localizedDayLabel_1 = null;
    this.localizedDaysLabel_0 = null;
    this.localizedDaysLabel_1 = null;
    this.localizedHourLabel_0 =
        null;
    this.localizedHourLabel_1 = null;
    this.localizedHoursLabel_0 = null;
    this.localizedHoursLabel_1 = null;
    this.localizedMinuteLabel_0 = null;
    this.localizedMinuteLabel_1 = null;
    this.localizedMinutesLabel_0 = null;
    this.localizedMinutesLabel_1 = null;
    this.localizedSecondLabel_0 = null;
    this.localizedSecondLabel_1 = null;
    this.localizedSecondsLabel_0 = null;
    this.localizedSecondsLabel_1 = null;
    this.localizedLineBreakLabel_0 = null;
    this.localizedLineBreakLabel_1 = null;
    this.localizedRaceOpenLabel_0 = null;
    this.localizedRaceOpenLabel_1 =
        null;
    this.shortFormat = false;
    this.contentSwitcher = null;
    this.maxDaysDisplayedInShortFormat = 99999;
    this.localizedWholeWordDaysLabel_0;
    this.localizedWholeWordDaysLabel_1;
    this.showRank = false;
    this.rankLabels = null;
    this.rankedContent = null;
    this.notRankedContent = null;
    this.showTimeInStatus = true;
    this.capitalizeStatus = false;
    this.formatStatus = false;
    this.statusFormatStartsSoon = "";
    this.statusFormatOpen = "";
    this.statusFormatClosed = "";
    this.clockDisplayer = null;
    this.warning = null;
    this.IDNSM = null;
    this.IDNCSM = null;
    this.IDNEX =
        null;
    this.IDNVIP = null;
    this.dropsAndWins = null;
    this.dropsAndWinsIcon = null;
    this.tournamentData = null;
    this.dnwIconUpdated = false
}
Tournament.DHMS = function(seconds) {
    this.d = Math.floor(seconds / 86400);
    seconds %= 86400;
    this.h = Math.floor(seconds / 3600);
    seconds %= 3600;
    this.m = Math.floor(seconds / 60);
    this.s = seconds % 60
};
Tournament.prototype.UpdateValue = function(value) {
    this.gameObject.SetActive(value != null);
    this.tournamentData = value;
    if (this.tournamentData == null) return;
    this.nameLabel.text = this.tournamentData.name;
    if (this.nameLabels != null)
        for (var i = 0; i < this.nameLabels.length; ++i) this.nameLabels[i].text = this.tournamentData.name;
    this.UpdateTournamentStatus();
    this.UpdateSelectedTournamentID(XT.GetString(TournamentVars.SelectedTournamentID));
    if (this.warning != null) this.warning.UpdatePromotion(this.tournamentData.uid);
    if (this.dropsAndWins !=
        null) {
        this.dropsAndWins.SetActive(this.tournamentData.displayStyle == TournamentProtocol.DisplayStyle.DropsAndWins);
        if (!this.dnwIconUpdated) {
            this.dnwIconUpdated = true;
            this.dropsAndWinsIcon.SetSpriteName(Tournament.GetDropsAndWinsSpriteName())
        }
    }
    if (this.IDNSM != null) this.IDNSM.SetActive(this.tournamentData.displayStyle == TournamentProtocol.DisplayStyle.IDNSM);
    if (this.IDNCSM != null) this.IDNCSM.SetActive(this.tournamentData.displayStyle == TournamentProtocol.DisplayStyle.IDNCSM);
    if (this.IDNEX != null) this.IDNEX.SetActive(this.tournamentData.displayStyle ==
        TournamentProtocol.DisplayStyle.IDNEX);
    if (this.IDNVIP != null) this.IDNVIP.SetActive(this.tournamentData.displayStyle == TournamentProtocol.DisplayStyle.IDNVIP)
};
Tournament.prototype.SetVisible = function(isVisible) {
    if (this.tournamentData == null) return;
    this.gameObject.SetActive(isVisible)
};
Tournament.prototype.UpdateSelectedTournamentID = function(newID) {
    if (this.tournamentData == null) return;
    this.selectedContent.SetActive(newID == this.tournamentData.uid);
    if (this.unselectedContent != null) this.unselectedContent.SetActive(newID != this.tournamentData.uid)
};
Tournament.prototype.UpdateTournamentStatus = function() {
    if (this.tournamentData == null) return;
    var status = this.tournamentData.status;
    var deltaTime = 0;
    if (status == TournamentProtocol.StatusCode.StartsSoon) {
        deltaTime = this.tournamentData.startDate - XT.GetInt(TournamentVars.ServerTime);
        if (deltaTime <= 0) status = TournamentProtocol.StatusCode.Open
    } else if (this.tournamentData.status == TournamentProtocol.StatusCode.Open) {
        deltaTime = this.tournamentData.endDate - XT.GetInt(TournamentVars.ServerTime);
        if (deltaTime <= 0) {
            status =
                TournamentProtocol.StatusCode.Closed;
            XT.SetString(TournamentVars.ClosedByTimePromotionUID, this.tournamentData.uid);
            XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionClosedByTime)
        }
    }
    var rankText = "";
    var dhms = new Tournament.DHMS(deltaTime);
    if (status == TournamentProtocol.StatusCode.StartsSoon) this.statusLabel.text = this.ProcessText(this.localizedStartsInLabel_0.text + this.SecondsToString(dhms) + this.localizedStartsInLabel_1.text);
    else if (status == TournamentProtocol.StatusCode.Open) {
        var details = PromotionsHelper.FindDetails(this.tournamentData.uid);
        var hasPrizes = details != null && details.prizePool != null;
        if (this.tournamentData.type == TournamentProtocol.PromoType.Race && hasPrizes && !this.shortFormat) this.statusLabel.text = this.ProcessText(this.localizedRaceOpenLabel_0.text + this.SecondsToString(dhms) + this.localizedRaceOpenLabel_1.text).replace("{0}", String(details.prizePool.totalCount));
        else this.statusLabel.text = this.ProcessText(this.localizedOpenLabel_0.text + this.SecondsToString(dhms) + this.localizedOpenLabel_1.text);
        if (this.showRank && this.tournamentData.type ==
            TournamentProtocol.PromoType.Race && hasPrizes && details.prizePool.totalCount > 0) rankText = String(details.prizePool.totalCount)
    } else if (status == TournamentProtocol.StatusCode.Closed) this.statusLabel.text = this.localizedCloseLabel.text;
    this.statusLabel.text = this.ProcessStatusText(status, this.statusLabel.text);
    if (this.statusLabels != null)
        for (var i = 0; i < this.statusLabels.length; ++i) this.statusLabels[i].text = this.statusLabel.text;
    if (this.showRank) {
        if (this.tournamentData.type == TournamentProtocol.PromoType.Tournament) {
            var leaderboard =
                PromotionsHelper.FindLeaderboard(this.tournamentData.uid);
            if (leaderboard != null && leaderboard.playerIndex > -1) rankText = String(leaderboard.playerPosition)
        }
        for (var i = 0; i < this.rankLabels.length; ++i) this.rankLabels[i].text = rankText;
        var isRanked = !_string.IsNullOrEmpty(rankText);
        this.rankedContent.SetActive(isRanked);
        this.notRankedContent.SetActive(!isRanked)
    }
    this.contentSwitcher.SwitchByStatus(status);
    this.contentSwitcher.SwitchByType(this.tournamentData.type);
    this.contentSwitcher.SwitchByStyle(this.tournamentData.clientStyle);
    if (this.clockDisplayer != null) this.clockDisplayer.UpdateValue(status != TournamentProtocol.StatusCode.Closed, dhms);
    this.tournamentData.status = status
};
Tournament.prototype.Update = function() {
    this.UpdateTournamentStatus()
};
Tournament.prototype.SecondsToString = function(dhms) {
    var ret = "";
    if (!this.showTimeInStatus) return ret;
    var d = dhms.d;
    var h = dhms.h;
    var m = dhms.m;
    var s = dhms.s;
    if (d == 1) ret += this.localizedDayLabel_0.text + String(d) + this.localizedDayLabel_1.text;
    else if (d > 1) ret += this.localizedDaysLabel_0.text + String(d) + this.localizedDaysLabel_1.text;
    if (d > this.maxDaysDisplayedInShortFormat) {
        ret = this.localizedWholeWordDaysLabel_0.text + String(d) + this.localizedWholeWordDaysLabel_1.text;
        return this.localizedLineBreakLabel_0.text +
            ret + this.localizedLineBreakLabel_1.text
    }
    if (h == 1) ret += this.localizedHourLabel_0.text + String(h) + this.localizedHourLabel_1.text;
    else if (d > 0 || h > 1) ret += this.localizedHoursLabel_0.text + String(h) + this.localizedHoursLabel_1.text;
    var b = !this.shortFormat || d == 0;
    if (b)
        if (m == 1) ret += this.localizedMinuteLabel_0.text + String(m) + this.localizedMinuteLabel_1.text;
        else if (d > 0 || h > 0 || m > 1) ret += this.localizedMinutesLabel_0.text + String(m) + this.localizedMinutesLabel_1.text;
    b = !this.shortFormat || d == 0 && h == 0;
    if (b)
        if (d == 0)
            if (s ==
                1) ret += this.localizedSecondLabel_0.text + String(s) + this.localizedSecondLabel_1.text;
            else if (d > 0 || h > 0 || m > 0 || s > 1) ret += this.localizedSecondsLabel_0.text + String(s) + this.localizedSecondsLabel_1.text;
    return this.localizedLineBreakLabel_0.text + ret + this.localizedLineBreakLabel_1.text
};
Tournament.prototype.ProcessText = function(text) {
    var split = text.split("\n");
    for (var i = 0; i < split.length; ++i) {
        split[i] = split[i].replace(/\s\s/g, " ");
        split[i] = _string.Trim(split[i])
    }
    return split.join("\n")
};
Tournament.prototype.ProcessStatusText = function(status, text) {
    if (this.capitalizeStatus) text = text.toUpperCase();
    if (this.formatStatus) text = this.GetStatusFormat(status).replace("{0}", text);
    return text
};
Tournament.prototype.GetStatusFormat = function(status) {
    if (status == TournamentProtocol.StatusCode.StartsSoon) return this.statusFormatStartsSoon;
    if (status == TournamentProtocol.StatusCode.Open) return this.statusFormatOpen;
    return this.statusFormatClosed
};
Tournament.dnwSpriteName = "";
Tournament.GetDNWinsSpriteName = function() {
    var ret = "drop_win_promo";
    var key = "region";
    if (UHT_GAME_CONFIG_SRC["region"] == undefined || UHT_GAME_CONFIG_SRC["region"] != "Asia") return ret;
    ret += "_as";
    var language = ServerOptions.language;
    if (language == "zh" || language == "zt") ret += "_zh_zt";
    return ret
};
Tournament.GetDropsAndWinsSpriteName = function() {
    if (_string.IsNullOrEmpty(Tournament.dnwSpriteName)) Tournament.dnwSpriteName = Tournament.GetDNWinsSpriteName();
    return Tournament.dnwSpriteName
};
goog.require("UHT.AnnouncementDisplayer");
TournamentAnnouncementDisplayer.prototype = Object.create(AnnouncementDisplayer.prototype);
TournamentAnnouncementDisplayer.prototype.constructor = TournamentAnnouncementDisplayer;

function TournamentAnnouncementDisplayer() {
    AnnouncementDisplayer.call(this);
    this.normal;
    this.IDNSM;
    this.IDNCSM;
    this.dropsAndWins;
    this.IDNEX;
    this.IDNVIP
}
TournamentAnnouncementDisplayer.prototype.OnShowAnnouncement = function() {
    var announcement = XT.GetObject(AnnouncementVars.Announcement);
    if (this.type != announcement.type) return;
    XT.TriggerEvent(AnnouncementVars.Evt_Internal_AnnouncementHandled);
    if (this.normal != null) this.normal.Start();
    var processedMessage = announcement.message;
    var tag = "#DDW#";
    if (processedMessage.indexOf(tag) > -1) {
        processedMessage = processedMessage.replace(tag, "");
        if (this.dropsAndWins != null) this.dropsAndWins.Start()
    }
    tag = "#IDNSM#";
    if (processedMessage.indexOf(tag) >
        -1) {
        processedMessage = processedMessage.replace(tag, "");
        if (this.IDNSM != null) this.IDNSM.Start()
    }
    tag = "#IDNCSM#";
    if (processedMessage.indexOf(tag) > -1) {
        processedMessage = processedMessage.replace(tag, "");
        if (this.IDNCSM != null) this.IDNCSM.Start()
    }
    tag = "#IDNEX#";
    if (processedMessage.indexOf(tag) > -1) {
        processedMessage = processedMessage.replace(tag, "");
        if (this.IDNEX != null) this.IDNEX.Start()
    }
    tag = "#IDNVIP#";
    if (processedMessage.indexOf(tag) > -1) {
        processedMessage = processedMessage.replace(tag, "");
        if (this.IDNVIP != null) this.IDNVIP.Start()
    }
    for (var i =
            0; i < this.message.length; i++) this.message[i].text = processedMessage;
    this.show.Start()
};
goog.require("UHT.Tournament");
TournamentButton.prototype = Object.create(Tournament.prototype);
TournamentButton.prototype.constructor = TournamentButton;

function TournamentButton() {
    Tournament.call(this);
    this.manager = null;
    this.buttonEnabler = null;
    this.root = null;
    this.threshold = 20;
    this.cachedCamera = null;
    this.pressPos = null
}
TournamentButton.prototype.OnPress = function(isPressed) {
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    var pos = this.root.inverseTransformPoint(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition));
    if (isPressed) {
        this.pressPos = pos;
        return
    }
    var posDelta = UHTMath.Vector3.sub(pos, this.pressPos);
    if (Math.abs(posDelta.y) > this.threshold) return;
    var idx = this.manager.scrollableList.items.indexOf(this);
    this.manager.OnScrollableListItemClicked(String(idx))
};
TournamentButton.prototype.UpdateSelectedTournamentID = function(uid) {
    Tournament.prototype.UpdateSelectedTournamentID.call(this, uid);
    if (this.tournamentData == null) return;
    if (uid != this.tournamentData.uid) this.buttonEnabler.EnableButton();
    else this.buttonEnabler.DisableButton()
};
goog.require("UHT.Engine");
TournamentClock.prototype = Object.create(Component.prototype);
TournamentClock.prototype.constructor = TournamentClock;

function TournamentClock() {
    Component.call(this);
    this.content = null;
    this.days = null;
    this.hours = null;
    this.minutes = null;
    this.seconds = null
}
TournamentClock.prototype.UpdateValue = function(enabled, dhms) {
    this.content.SetActive(enabled);
    if (!enabled) return;
    this.days.text = this.FormatValue(dhms.d);
    this.hours.text = this.FormatValue(dhms.h);
    this.minutes.text = this.FormatValue(dhms.m);
    this.seconds.text = this.FormatValue(dhms.s)
};
TournamentClock.prototype.FormatValue = function(value) {
    var ret = String(value);
    if (ret.length < 2) ret = "0" + ret;
    return ret
};
goog.provide("UHT.TournamentDetails");
goog.require("UHT.XTLink");
TournamentDetails.prototype = Object.create(XTLink.prototype);
TournamentDetails.prototype.constructor = TournamentDetails;

function TournamentDetails() {
    XTLink.call(this);
    this.scrollableList = null;
    this.details = null;
    this.mustUpdateDetails = false
}
TournamentDetails.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(TournamentVars.TournamentDetails, this.OnTournamentDetailsUpdatedInternal, this);
    XT.RegisterCallbackString(TournamentVars.SelectedTournamentID, this.OnSelectedTournamentIDChangedInternal, this)
};
TournamentDetails.prototype.OnTournamentDetailsUpdatedInternal = function(param) {
    this.details = param;
    this.OnTournamentDetailsUpdated();
    if (this.mustUpdateDetails) {
        this.mustUpdateDetails = false;
        this.OnSelectedTournamentIDChanged(XT.GetString(TournamentVars.SelectedTournamentID))
    }
};
TournamentDetails.prototype.OnSelectedTournamentIDChangedInternal = function(selectedTournamentID) {
    var details = PromotionsHelper.FindDetails(selectedTournamentID);
    this.mustUpdateDetails = details == null;
    this.OnSelectedTournamentIDChanged(selectedTournamentID)
};
TournamentDetails.prototype.OnTournamentDetailsUpdated = function() {};
TournamentDetails.prototype.OnSelectedTournamentIDChanged = function(selectedTournamentID) {};
goog.require("UHT.TournamentDetails");

function PromotionPrizePoolTypeLabels() {
    this.prizesTypes = null;
    this.labels = null
}

function PromotionPrizePoolTypeMLAnchorLabels() {
    this.anchor = null;
    this.labels = null
}

function PromoTypePrizePoolTypeContents() {
    this.promoTypes = null;
    this.prizesTypes = null;
    this.contents = null
}
PromotionPrizePoolTypeSwitcher.prototype = Object.create(TournamentDetails.prototype);
PromotionPrizePoolTypeSwitcher.prototype.constructor = PromotionPrizePoolTypeSwitcher;

function PromotionPrizePoolTypeSwitcher() {
    TournamentDetails.call(this);
    this.anchorLabelsByPrizesType = null;
    this.contentsByPromotionPrizesType = null
}
PromotionPrizePoolTypeSwitcher.prototype.OnTournamentDetailsUpdated = function() {
    this.OnSelectedTournamentIDChanged(XT.GetString(TournamentVars.SelectedTournamentID))
};
PromotionPrizePoolTypeSwitcher.prototype.OnSelectedTournamentIDChanged = function(uid) {
    var promo = PromotionsHelper.FindPromotion(uid);
    if (promo == null) return;
    for (var i = 0; i < this.anchorLabelsByPrizesType.length; ++i) {
        var anchor = this.anchorLabelsByPrizesType[i].anchor;
        var labels = this.anchorLabelsByPrizesType[i].labels;
        for (var j = 0; j < labels.length; ++j)
            if (labels[j].prizesTypes.indexOf(promo.prizesType) > -1) {
                anchor.labels = labels[j].labels;
                anchor.DiscardCache()
            }
    }
    for (var i = 0; i < this.contentsByPromotionPrizesType.length; ++i) {
        var promoTypes =
            this.contentsByPromotionPrizesType[i].promoTypes;
        var prizesTypes = this.contentsByPromotionPrizesType[i].prizesTypes;
        var contents = this.contentsByPromotionPrizesType[i].contents;
        var isActive = promoTypes.indexOf(promo.type) > -1 && prizesTypes.indexOf(promo.prizesType) > -1;
        for (var j = 0; j < contents.length; ++j) contents[j].SetActive(isActive)
    }
};
goog.provide("UHT.TournamentDisplayer");
goog.require("UHT.Tournament");
TournamentDisplayer.prototype = Object.create(Tournament.prototype);
TournamentDisplayer.prototype.constructor = TournamentDisplayer;

function TournamentDisplayer() {
    Tournament.call(this)
}
TournamentDisplayer.prototype.UpdateTournament = function(id) {
    var tournament = PromotionsHelper.FindPromotion(id);
    if (tournament != null) XT.SetInt(TournamentVars.CurrentPromotionDisplayStyle, tournament.displayStyle);
    this.UpdateValue(tournament)
};
goog.require("UHT.TournamentDisplayer");
DisplayStyleAwareContent.prototype = Object.create(XTLink.prototype);
DisplayStyleAwareContent.prototype.constructor = DisplayStyleAwareContent;

function DisplayStyleAwareContent() {
    XTLink.call(this);
    this.displayStyles;
    this.CATLinks
}
DisplayStyleAwareContent.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackInt(TournamentVars.CurrentPromotionDisplayStyle, this.OnDisplayStyleChanged, this)
};
DisplayStyleAwareContent.prototype.OnDisplayStyleChanged = function(value) {
    var idx = this.displayStyles.indexOf(value);
    if (idx > -1) this.CATLinks[idx].Start()
};
goog.require("UHT.TournamentDisplayer");
DropsAndWinsRegionAwareContent.prototype = Object.create(XTLink.prototype);
DropsAndWinsRegionAwareContent.prototype.constructor = DropsAndWinsRegionAwareContent;

function DropsAndWinsRegionAwareContent() {
    XTLink.call(this);
    this.toEnable;
    this.toDisable
}
DropsAndWinsRegionAwareContent.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
};
DropsAndWinsRegionAwareContent.prototype.OnGameInit = function() {
    var key = "region";
    if (UHT_GAME_CONFIG_SRC[key] && UHT_GAME_CONFIG_SRC[key] == "Asia") {
        for (var i = 0; i < this.toEnable.length; i++) this.toEnable[i].SetActive(true);
        for (var i = 0; i < this.toDisable.length; i++) this.toDisable[i].SetActive(false)
    }
};
goog.require("UHT.TournamentDisplayer");
SelectedTournament.prototype = Object.create(TournamentDisplayer.prototype);
SelectedTournament.prototype.constructor = SelectedTournament;

function SelectedTournament() {
    TournamentDisplayer.call(this)
}
SelectedTournament.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(TournamentVars.Tournaments, this.OnTournamentsUpdated, this);
    XT.RegisterCallbackString(TournamentVars.SelectedTournamentID, this.UpdateTournament, this)
};
SelectedTournament.prototype.OnTournamentsUpdated = function(param) {
    this.UpdateTournament(XT.GetString(TournamentVars.SelectedTournamentID))
};
goog.require("UHT.XTLink");
TournamentLeaderboard.prototype = Object.create(XTLink.prototype);
TournamentLeaderboard.prototype.constructor = TournamentLeaderboard;

function TournamentLeaderboard() {
    XTLink.call(this);
    this.scrollableList = null;
    this.isExpanded = false;
    this.canScrollToPlayer = false;
    this.uid = "";
    this.firstUID = [];
    this.firstIndex = []
}
TournamentLeaderboard.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_LeaderboardsReloaded, this.OnLeaderboardsReloaded, this);
    XT.RegisterCallbackObject(TournamentVars.TournamentLeaderboards, this.OnTournamentLeaderboardsUpdated, this);
    XT.RegisterCallbackString(TournamentVars.SelectedTournamentID, this.OnSelectedTournamentIDChanged, this)
};
TournamentLeaderboard.prototype.OnLeaderboardsReloaded = function() {
    this.OnSelectedTournamentIDChanged(XT.GetString(TournamentVars.SelectedTournamentID))
};
TournamentLeaderboard.prototype.OnTournamentLeaderboardsUpdated = function(param) {
    this.OnSelectedTournamentIDChanged(XT.GetString(TournamentVars.SelectedTournamentID))
};
TournamentLeaderboard.prototype.OnSelectedTournamentIDChanged = function(newID) {
    var lb = PromotionsHelper.FindLeaderboard(newID, this.isExpanded);
    if (!PromotionsHelper.CanUseLeaderboard(newID)) {
        lb = null;
        XT.TriggerEvent(TournamentVars.Evt_CodeToData_ShowWheelOfPatience)
    } else XT.TriggerEvent(TournamentVars.Evt_CodeToData_HideWheelOfPatience);
    if (lb != null)
        if (lb.items != null) {
            this.scrollableList.SetValues(lb.items.slice(), false);
            var idx = this.firstUID.indexOf(this.uid);
            if (idx > -1) this.firstIndex[idx] = this.scrollableList.items[0].valueIdx;
            this.uid = newID;
            idx = this.firstUID.indexOf(this.uid);
            if (idx < 0) {
                this.firstUID.push(this.uid);
                this.firstIndex.push(0);
                idx = this.firstUID.length - 1
            }
            var firstValueIdx = this.firstIndex[idx];
            if (this.canScrollToPlayer && this.scrollableList.isScrollable()) {
                firstValueIdx = 0;
                for (var i = 0; i < lb.items.length; ++i)
                    if (lb.items[i].isPlayer) {
                        firstValueIdx = i;
                        break
                    }
                var lastIdx = firstValueIdx + (this.scrollableList.items.length - 1);
                var lastValueIdx = this.scrollableList.itemValues.length - 1;
                firstValueIdx -= lastIdx > lastValueIdx ? lastIdx -
                    lastValueIdx : 0;
                if (this.scrollableList.scrollRemain != 0) this.scrollableList.ScrollItems(-this.scrollableList.scrollRemain, true)
            }
            this.scrollableList.UpdateValuesAndIndex(null, firstValueIdx, true);
            return
        }
    this.scrollableList.SetValues(null)
};
TournamentLeaderboard.prototype.ScrollToPlayer = function() {
    this.canScrollToPlayer = true;
    this.OnTournamentLeaderboardsUpdated(XT.GetObject(TournamentVars.TournamentLeaderboards));
    this.canScrollToPlayer = false
};
goog.provide("UHT.TournamentLeaderboardItem");
goog.require("UHT.ScrollableListItem");
TournamentLeaderboardItem.prototype = Object.create(ScrollableListItem.prototype);
TournamentLeaderboardItem.prototype.constructor = TournamentLeaderboardItem;

function TournamentLeaderboardItem() {
    ScrollableListItem.call(this);
    this.placeLabel = null;
    this.playerLabel = null;
    this.scoreLabel = null;
    this.colorYou = null;
    this.colorNotYou = null;
    this.useColor = false;
    this.localizedYouLabel = null;
    this.oddContents = null;
    this.capitalizeYou = false;
    this.youContent = null;
    this.formatYou = false;
    this.youFormat = "";
    this.replaceAsterisksInPlayerID = true;
    this.playerIDAsteriskReplacement = "";
    this.alternativeText = "";
    this.countryFlag = null;
    this.countryFlagPlayerOffset = 0;
    this.countryFlagPlayerLabel =
        null;
    this.countryFlagPlayerScoreSpacing = 0;
    this.scoreWidth = -1;
    this.playerWidth = -1;
    this.playerLocalPos = null
}
TournamentLeaderboardItem.multiplierFormat = "x {0}";
TournamentLeaderboardItem.defaultCountryID = "zz";
TournamentLeaderboardItem.prototype.UpdateValue = function(lbi) {
    this.gameObject.SetActive(lbi != null);
    if (lbi == null) return;
    var isYou = lbi.isPlayer;
    var color = isYou ? this.colorYou : this.colorNotYou;
    this.placeLabel.text = String(lbi.position);
    this.scoreLabel.text = PromotionsHelper.FormatScore(lbi.score, lbi.leaderboard);
    this.playerLabel.text = isYou ? this.localizedYouLabel.text : String(lbi.playerID);
    if (this.useColor) {
        this.placeLabel.SetColor(color);
        this.scoreLabel.SetColor(color);
        this.playerLabel.SetColor(color)
    }
    if (this.oddContents !=
        null) this.oddContents.SetActive(this.valueIdx % 2 == 1);
    if (this.youContent != null) this.youContent.SetActive(isYou);
    if (isYou) {
        if (this.capitalizeYou) this.playerLabel.text = this.playerLabel.text.toUpperCase();
        if (this.formatYou) this.playerLabel.text = this.youFormat.replace("{0}", this.playerLabel.text)
    } else if (this.replaceAsterisksInPlayerID) this.playerLabel.text = this.playerLabel.text.replace(/\*/g, this.playerIDAsteriskReplacement);
    if (this.countryFlag != null) {
        if (this.playerWidth < 0) {
            this.scoreWidth = this.scoreLabel.width;
            this.playerWidth = this.playerLabel.width;
            this.playerLocalPos = this.playerLabel.transform.localPosition()
        }
        var hasFlag = !_string.IsNullOrEmpty(lbi.countryID);
        var playerOffset = new UHTMath.Vector3(hasFlag ? this.countryFlagPlayerOffset : 0, 0, 0);
        this.playerLabel.width = this.playerWidth - playerOffset.x;
        this.playerLabel.transform.localPosition(UHTMath.Vector3.add(this.playerLocalPos, playerOffset));
        this.countryFlag.gameObject.SetActive(hasFlag);
        if (hasFlag) {
            var countryID = lbi.countryID;
            var data = this.countryFlag.atlas.getTextureInfoForSprite(this.countryFlag,
                countryID);
            if (data == null) countryID = TournamentLeaderboardItem.defaultCountryID;
            this.countryFlag.SetSpriteNameForAnimation(countryID)
        }
        if (this.countryFlagPlayerLabel != null) {
            this.CountryFlagAdjustPlayerScoreWidths(hasFlag);
            this.countryFlagPlayerLabel.text = this.playerLabel.text;
            this.countryFlagPlayerLabel.SetColor(this.playerLabel.GetColor());
            this.playerLabel.gameObject.SetActive(!hasFlag);
            this.countryFlagPlayerLabel.gameObject.SetActive(hasFlag)
        }
    }
};
TournamentLeaderboardItem.prototype.FormatMultiplier = function(multiplier) {
    return TournamentLeaderboardItem.multiplierFormat.replace("{0}", String(multiplier))
};
TournamentLeaderboardItem.prototype.CountryFlagAdjustPlayerScoreWidths = function(hasFlag) {
    if (hasFlag) {
        var pos1 = this.countryFlagPlayerLabel.transform.localPosition();
        var pos2 = this.scoreLabel.transform.localPosition();
        this.scoreLabel.width = Math.round(pos2.x - pos1.x - this.countryFlagPlayerLabel.GetWidth() - this.countryFlagPlayerScoreSpacing)
    } else this.scoreLabel.width = this.scoreWidth
};
goog.require("UHT.XTLink");
TournamentLeaderboardItemPlayer.prototype = Object.create(XTLink.prototype);
TournamentLeaderboardItemPlayer.prototype.constructor = TournamentLeaderboardItemPlayer;

function TournamentLeaderboardItemPlayer() {
    XTLink.call(this);
    this.placeLabel = null;
    this.scoreLabel = null;
    this.alternativeText = ""
}
TournamentLeaderboardItemPlayer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_LeaderboardsReloaded, this.OnLeaderboardsReloaded, this);
    XT.RegisterCallbackObject(TournamentVars.TournamentLeaderboards, this.OnTournamentLeaderboards, this);
    XT.RegisterCallbackString(TournamentVars.SelectedTournamentID, this.OnSelectedTournamentID, this)
};
TournamentLeaderboardItemPlayer.prototype.OnLeaderboardsReloaded = function() {
    this.OnSelectedTournamentID(XT.GetString(TournamentVars.SelectedTournamentID))
};
TournamentLeaderboardItemPlayer.prototype.OnTournamentLeaderboards = function(param) {
    this.OnSelectedTournamentID(XT.GetString(TournamentVars.SelectedTournamentID))
};
TournamentLeaderboardItemPlayer.prototype.OnSelectedTournamentID = function(uid) {
    var lbi = PromotionsHelper.FindPlayerInLeaderboard(uid);
    if (lbi != null) {
        this.placeLabel.text = PromotionsHelper.FormatRank(uid, lbi.position);
        this.scoreLabel.text = PromotionsHelper.FormatScore(lbi.score, lbi.leaderboard)
    } else this.placeLabel.text = this.scoreLabel.text = this.alternativeText
};
goog.provide("UHT.TournamentNoPrizeItemAGBM");
goog.require("UHT.TournamentLeaderboardItem");
TournamentNoPrizeItemAGBM.prototype = Object.create(TournamentLeaderboardItem.prototype);
TournamentNoPrizeItemAGBM.prototype.constructor = TournamentNoPrizeItemAGBM;

function TournamentNoPrizeItemAGBM() {
    TournamentLeaderboardItem.call(this);
    this.defaultColor = null;
    this.noPrizeColorNotYou = null;
    this.prizeContent = null;
    this.noPrizeContent = null
}
TournamentNoPrizeItemAGBM.prototype.UpdatePrizeContent = function(hasPrize) {
    if (this.prizeContent != null) this.prizeContent.SetActive(hasPrize);
    if (this.noPrizeContent != null) this.noPrizeContent.SetActive(!hasPrize)
};
goog.require("UHT.TournamentNoPrizeItemAGBM");
TournamentLeaderboardItemAGBM.prototype = Object.create(TournamentNoPrizeItemAGBM.prototype);
TournamentLeaderboardItemAGBM.prototype.constructor = TournamentLeaderboardItemAGBM;

function TournamentLeaderboardItemAGBM() {
    TournamentNoPrizeItemAGBM.call(this);
    this.prizeLabel = null;
    this.localizedFreeRoundsLabel_0;
    this.localizedFreeRoundsLabel_1;
    this.localizedSecondsOfTimedFreeRoundsLabel_0;
    this.localizedSecondsOfTimedFreeRoundsLabel_1
}
TournamentLeaderboardItemAGBM.prototype.UpdateValue = function(lbi) {
    TournamentNoPrizeItemAGBM.prototype.UpdateValue.call(this, lbi);
    if (lbi == null) return;
    if (!lbi.isRanked && !lbi.isPlayer) this.playerLabel.text = this.alternativeText;
    if (!lbi.isRanked) this.placeLabel.text = this.scoreLabel.text = this.alternativeText;
    if (lbi.type == TournamentProtocol.PrizeType.Gift && !_string.IsNullOrEmpty(lbi.gift)) this.prizeLabel.text = lbi.gift;
    else if (lbi.type == TournamentProtocol.PrizeType.Amount && lbi.amount > 0) this.prizeLabel.text =
        LocaleManager.FormatValueWithCustomCurrency(lbi.amount, lbi.currency);
    else if (lbi.type == TournamentProtocol.PrizeType.BetMultiplier) this.prizeLabel.text = this.FormatMultiplier(lbi.betMultiplier);
    else this.prizeLabel.text = this.alternativeText;
    if (lbi.type == TournamentProtocol.PrizeType.FreeRounds)
        if (lbi.freeRoundLimitType == "N") this.prizeLabel.text = this.localizedFreeRoundsLabel_0.text + lbi.freeRoundAmount + this.localizedFreeRoundsLabel_1.text;
        else if (lbi.freeRoundLimitType == "T") this.prizeLabel.text = this.localizedSecondsOfTimedFreeRoundsLabel_0.text +
        lbi.freeRoundAmount + this.localizedSecondsOfTimedFreeRoundsLabel_1.text;
    var hasPrize = lbi.type != TournamentProtocol.PrizeType.Invalid;
    if (!hasPrize && !lbi.isPlayer) {
        this.placeLabel.SetColor(this.noPrizeColorNotYou);
        this.playerLabel.SetColor(this.noPrizeColorNotYou);
        this.scoreLabel.SetColor(this.noPrizeColorNotYou);
        this.prizeLabel.SetColor(this.noPrizeColorNotYou)
    } else {
        var color1 = lbi.isPlayer ? this.colorYou : this.colorNotYou;
        var color2 = this.useColor ? color1 : this.defaultColor;
        this.placeLabel.SetColor(color1);
        this.prizeLabel.SetColor(color1);
        this.playerLabel.SetColor(color2);
        this.scoreLabel.SetColor(color2)
    }
    if (this.countryFlagPlayerLabel != null) {
        this.countryFlagPlayerLabel.text = this.playerLabel.text;
        this.countryFlagPlayerLabel.SetColor(this.playerLabel.GetColor())
    }
    this.UpdatePrizeContent(hasPrize)
};
goog.provide("UHT.TournamentPrize");
goog.require("UHT.ScrollableListItem");
TournamentPrize.prototype = Object.create(ScrollableListItem.prototype);
TournamentPrize.prototype.constructor = TournamentPrize;

function TournamentPrize() {
    ScrollableListItem.call(this);
    this.currency = "";
    this.placeLabel = null;
    this.prizeLabel = null;
    this.localizedToLabel_0 = null;
    this.localizedToLabel_1 = null;
    this.localizedToLabel_2 = null;
    this.localizedFreeRoundsLabel_0;
    this.localizedFreeRoundsLabel_1;
    this.localizedSecondsOfTimedFreeRoundsLabel_0;
    this.localizedSecondsOfTimedFreeRoundsLabel_1;
    this.oddContents = null;
    this.currentContent = null
}
TournamentPrize.prototype.UpdateValue = function(prize) {
    this.gameObject.SetActive(prize != null);
    if (prize == null) return;
    var uid = XT.GetString(TournamentVars.SelectedTournamentID);
    var promo = PromotionsHelper.FindPromotion(uid);
    var type = promo.type;
    var prizeLbl = this.prizeLabel;
    if (type == TournamentProtocol.PromoType.Tournament)
        if (prize.placeFrom == prize.placeTo) this.placeLabel.text = String(prize.placeFrom);
        else this.placeLabel.text = this.localizedToLabel_0.text + prize.placeFrom + this.localizedToLabel_1.text + prize.placeTo +
            this.localizedToLabel_2.text;
    else if (type == TournamentProtocol.PromoType.Race) {
        prizeLbl = this.placeLabel;
        this.prizeLabel.text = String(prize.count)
    }
    if (prize.type == TournamentProtocol.PrizeType.FreeRounds)
        if (prize.freeRoundLimitType == "N") prizeLbl.text = this.localizedFreeRoundsLabel_0.text + prize.freeRoundAmount + this.localizedFreeRoundsLabel_1.text;
        else {
            if (prize.freeRoundLimitType == "T") prizeLbl.text = this.localizedSecondsOfTimedFreeRoundsLabel_0.text + prize.freeRoundAmount + this.localizedSecondsOfTimedFreeRoundsLabel_1.text
        }
    else if (_string.IsNullOrEmpty(prize.gift)) prizeLbl.text =
        LocaleManager.FormatValueWithCustomCurrency(prize.amount, this.currency);
    else prizeLbl.text = prize.gift;
    if (this.oddContents != null) this.oddContents.SetActive(this.valueIdx % 2 == 1);
    var playerPos = PromotionsHelper.FindPlayerLeaderboardPosition(uid);
    var isCurrent = prize.placeFrom <= playerPos && playerPos <= prize.placeTo;
    if (this.currentContent != null) this.currentContent.SetActive(isCurrent)
};
goog.require("UHT.TournamentPrize");
PrizeDropPrizeAGBM.prototype = Object.create(TournamentPrize.prototype);
PrizeDropPrizeAGBM.prototype.constructor = PrizeDropPrizeAGBM;

function PrizeDropPrizeAGBM() {
    TournamentPrize.call(this);
    this.prizesTotalLabel = null
}
PrizeDropPrizeAGBM.multiplierFormat = "x {0}";
PrizeDropPrizeAGBM.prototype.UpdateValue = function(prize) {
    TournamentPrize.prototype.UpdateValue.call(this, prize);
    if (prize == null) return;
    this.prizesTotalLabel.text = String(prize.totalCount);
    if (prize.type == TournamentProtocol.PrizeType.BetMultiplier) this.placeLabel.text = PrizeDropPrizeAGBM.multiplierFormat.replace("{0}", String(prize.betMultiplier))
};
goog.provide("UHT.TournamentPrizeAGBM");
goog.require("UHT.TournamentNoPrizeItemAGBM");
TournamentPrizeAGBM.prototype = Object.create(TournamentNoPrizeItemAGBM.prototype);
TournamentPrizeAGBM.prototype.constructor = TournamentPrizeAGBM;

function TournamentPrizeAGBM() {
    TournamentNoPrizeItemAGBM.call(this);
    this.betLabel = null;
    this.localizedFreeRoundsLabel_0;
    this.localizedFreeRoundsLabel_1;
    this.localizedSecondsOfTimedFreeRoundsLabel_0;
    this.localizedSecondsOfTimedFreeRoundsLabel_1;
    this.leaderboardItem = null
}
TournamentPrizeAGBM.prototype.XTRegisterCallbacks = function() {
    TournamentNoPrizeItemAGBM.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_BetChanged, this.OnBetChanged, this)
};
TournamentPrizeAGBM.prototype.OnBetChanged = function() {
    if (this.leaderboardItem == null) return;
    if (this.leaderboardItem.isPlayer && !this.leaderboardItem.isRanked) this.betLabel.text = LocaleManager.FormatValueWithCustomCurrency(XT.GetDouble(Vars.TotalBetDisplayed), ServerOptions.currency)
};
TournamentPrizeAGBM.prototype.UpdateValue = function(lbi) {
    TournamentNoPrizeItemAGBM.prototype.UpdateValue.call(this, lbi);
    this.leaderboardItem = lbi;
    if (lbi == null) return;
    if (lbi.type == TournamentProtocol.PrizeType.BetMultiplier) this.placeLabel.text = this.FormatMultiplier(lbi.betMultiplier);
    else this.placeLabel.text = this.alternativeText;
    if (!lbi.isRanked && !lbi.isPlayer) this.playerLabel.text = this.alternativeText;
    if (lbi.type == TournamentProtocol.PrizeType.Gift && !_string.IsNullOrEmpty(lbi.gift)) this.scoreLabel.text =
        lbi.gift;
    else if (lbi.type == TournamentProtocol.PrizeType.Amount && lbi.amount > 0) this.scoreLabel.text = LocaleManager.FormatValueWithCustomCurrency(lbi.amount, lbi.currency);
    else if (lbi.type == TournamentProtocol.PrizeType.BetMultiplier && lbi.isRanked && lbi.prize > 0) this.scoreLabel.text = LocaleManager.FormatValueWithCustomCurrency(lbi.prize, lbi.memberCurrency);
    else this.scoreLabel.text = this.alternativeText;
    if (lbi.isRanked && lbi.effectiveBetForBetMultiplier > 0) this.betLabel.text = LocaleManager.FormatValueWithCustomCurrency(lbi.effectiveBetForBetMultiplier,
        lbi.memberCurrency);
    else this.betLabel.text = this.alternativeText;
    if (lbi.type == TournamentProtocol.PrizeType.FreeRounds)
        if (lbi.freeRoundLimitType == "N") this.scoreLabel.text = this.localizedFreeRoundsLabel_0.text + lbi.freeRoundAmount + this.localizedFreeRoundsLabel_1.text;
        else if (lbi.freeRoundLimitType == "T") this.scoreLabel.text = this.localizedSecondsOfTimedFreeRoundsLabel_0.text + lbi.freeRoundAmount + this.localizedSecondsOfTimedFreeRoundsLabel_1.text;
    var hasPrize = lbi.type != TournamentProtocol.PrizeType.Invalid;
    if (!hasPrize && !lbi.isPlayer) {
        this.placeLabel.SetColor(this.noPrizeColorNotYou);
        this.playerLabel.SetColor(this.noPrizeColorNotYou);
        this.scoreLabel.SetColor(this.noPrizeColorNotYou);
        this.betLabel.SetColor(this.noPrizeColorNotYou)
    } else {
        var color1 = lbi.isPlayer ? this.colorYou : this.colorNotYou;
        var color2 = this.useColor ? color1 : this.defaultColor;
        this.placeLabel.SetColor(color1);
        this.playerLabel.SetColor(color2);
        this.scoreLabel.SetColor(color2);
        this.betLabel.SetColor(color2)
    }
    this.UpdatePrizeContent(hasPrize);
    this.OnBetChanged()
};
goog.require("UHT.TournamentPrizeAGBM");
PrizeDropWinner.prototype = Object.create(TournamentPrizeAGBM.prototype);
PrizeDropWinner.prototype.constructor = PrizeDropWinner;

function PrizeDropWinner() {
    TournamentPrizeAGBM.call(this);
    this.defaultContent = null;
    this.titleContent = null;
    this.titleLabel = null;
    this.localizedTitleLabel_0 = null;
    this.localizedTitleLabel_1 = null;
    this.betWidth = -1
}
PrizeDropWinner.prototype.UpdateValue = function(lbi) {
    TournamentPrizeAGBM.prototype.UpdateValue.call(this, lbi);
    if (lbi == null) return;
    if (lbi.type != TournamentProtocol.PrizeType.Invalid) this.placeLabel.SetColor(this.colorNotYou);
    if (this.countryFlagPlayerLabel != null) this.countryFlagPlayerLabel.SetColor(this.playerLabel.GetColor());
    if (this.youContent != null) this.youContent.SetActive(false);
    if (this.oddContents != null) this.oddContents.SetActive((this.valueIdx + lbi.valueIndexExtra) % 2 == 1);
    this.defaultContent.SetActive(lbi.winnerContent ==
        TournamentProtocol.WinnerContentType.Default);
    this.titleContent.SetActive(lbi.winnerContent != TournamentProtocol.WinnerContentType.Default);
    if (lbi.winnerContent == TournamentProtocol.WinnerContentType.Title_0) this.titleLabel.text = this.localizedTitleLabel_0.text;
    if (lbi.winnerContent == TournamentProtocol.WinnerContentType.Title_1) this.titleLabel.text = this.localizedTitleLabel_1.text
};
PrizeDropWinner.prototype.CountryFlagAdjustPlayerScoreWidths = function(hasFlag) {
    if (!this.betLabel.gameObject.activeSelf) return;
    if (this.betWidth < 0) this.betWidth = this.betLabel.width;
    if (hasFlag) {
        var pos1 = this.countryFlagPlayerLabel.transform.localPosition();
        var pos2 = this.betLabel.transform.localPosition();
        var width = Math.round((pos2.x - pos1.x - this.countryFlagPlayerScoreSpacing) * .5);
        this.betLabel.width = this.countryFlagPlayerLabel.width = width * this.betLabel.resize
    } else this.betLabel.width = this.betWidth
};
goog.require("UHT.TournamentDetails");
TournamentPrizes.prototype = Object.create(TournamentDetails.prototype);
TournamentPrizes.prototype.constructor = TournamentPrizes;

function TournamentPrizes() {
    TournamentDetails.call(this);
    this.prizes = null;
    this.contents = null;
    this.alternativeContents = null;
    this.hasAlternativeContents = false
}
TournamentPrizes.prototype.OnTournamentDetailsUpdated = function() {
    this.OnSelectedTournamentIDChanged(XT.GetString(TournamentVars.SelectedTournamentID))
};
TournamentPrizes.prototype.OnSelectedTournamentIDChanged = function(newID) {
    var details = PromotionsHelper.FindDetails(newID);
    this.UpdateContents(details);
    if (details != null) {
        for (var i = 0; i < this.prizes.length; ++i) this.prizes[i].currency = details.prizePool.currency;
        if (details.prizePool.prizesList != null) {
            this.scrollableList.SetValues(details.prizePool.prizesList.slice());
            return
        }
    }
    this.scrollableList.SetValues(null)
};
TournamentPrizes.prototype.UpdateContents = function(details) {
    if (!this.hasAlternativeContents) return;
    var hasContents = details != null && details.prizePool != null && details.prizePool.prizesList != null && details.prizePool.prizesList.length > 0;
    for (var i = 0; i < this.contents.length; ++i) this.contents[i].SetActive(hasContents);
    for (var i = 0; i < this.alternativeContents.length; ++i) this.alternativeContents[i].SetActive(!hasContents)
};
goog.require("UHT.TournamentDetails");
goog.require("UHT.PromotionRule");
TournamentRules.prototype = Object.create(TournamentDetails.prototype);
TournamentRules.prototype.constructor = TournamentRules;

function TournamentRules() {
    TournamentDetails.call(this);
    this.maxNumberOfLinesFirstUpdate = 0;
    this.maxNumberOfLinesPerUpdate = 0;
    this.maxLabelWidth = 0;
    this.sampleLabel = null;
    this.isManual = false;
    this.tournamentID = "";
    this.tournamentIDs = [];
    this.tournamentRules = [];
    this.tournamentRulesIndices = [];
    this.needUpdate = false;
    this.isTournamentsVisible = false;
    this.isRulesVisible = true;
    this.isFirstUpdate = false;
    this.isManualUpdate = false;
    this.useHtmlRulesForOptIn = false
}
TournamentRules.prototype.ForceUpdate = function() {
    this.OnTournamentDetailsUpdated()
};
TournamentRules.prototype.OnTournamentDetailsUpdated = function() {
    if (this.details == null) return;
    for (var i = 0; i < this.details.length; ++i) {
        var idx = this.tournamentIDs.indexOf(this.details[i].uid);
        if (idx < 0) {
            this.needUpdate = true;
            var tr = new PromotionRule;
            tr.uid = this.details[i].uid;
            tr.sampleLabel = this.sampleLabel;
            tr.maxLabelWidth = this.maxLabelWidth;
            tr.UpdateRules(this.useHtmlRulesForOptIn ? this.details[i].htmlRulesForOptIn : this.details[i].htmlRules);
            this.tournamentIDs.push(this.details[i].uid);
            this.tournamentRules.push(tr);
            this.tournamentRulesIndices.push(0)
        } else if (this.tournamentRules[idx].rules != (this.useHtmlRulesForOptIn ? this.details[i].htmlRulesForOptIn : this.details[i].htmlRules)) {
            this.needUpdate = true;
            this.tournamentRules[idx].UpdateRules(this.useHtmlRulesForOptIn ? this.details[i].htmlRulesForOptIn : this.details[i].htmlRules)
        }
    }
};
TournamentRules.prototype.OnSelectedTournamentIDChanged = function(newID) {
    if (this.isManual && !this.isManualUpdate) return;
    var idx = this.tournamentIDs.indexOf(this.tournamentID);
    if (idx >= 0) this.tournamentRulesIndices[idx] = this.scrollableList.items[0].valueIdx;
    this.tournamentID = newID;
    this.needUpdate = true;
    idx = this.tournamentIDs.indexOf(this.tournamentID);
    if (idx >= 0)
        if (this.tournamentRules[idx].isSplit) {
            this.scrollableList.UpdateValuesAndIndex(this.tournamentRules[idx].GetSplitLines().slice(), this.tournamentRulesIndices[idx]);
            return
        } else if (this.tournamentRules[idx].splitRules.length < this.maxNumberOfLinesFirstUpdate) {
        this.isFirstUpdate = true;
        return
    }
    this.scrollableList.SetValues(null)
};
TournamentRules.prototype.Update = function() {
    if (!this.isTournamentsVisible || !this.isRulesVisible || !this.needUpdate) return;
    var idx = this.tournamentIDs.indexOf(this.tournamentID);
    if (idx >= 0)
        if (!this.tournamentRules[idx].isSplit) {
            if (this.isFirstUpdate) {
                this.isFirstUpdate = false;
                this.tournamentRules[idx].maxNumberOfLines = this.maxNumberOfLinesFirstUpdate;
                this.scrollableList.UpdateValuesAndIndex(this.tournamentRules[idx].GetSplitLines().slice(), this.tournamentRulesIndices[idx])
            } else {
                this.tournamentRules[idx].maxNumberOfLines =
                    this.maxNumberOfLinesPerUpdate;
                this.scrollableList.UpdateValues(this.tournamentRules[idx].GetSplitLines().slice())
            }
            return
        }
    this.needUpdate = false
};
TournamentRules.prototype.RulesVisible = function(param) {
    this.isRulesVisible = _bool.Parse(param)
};
TournamentRules.prototype.TournamentsVisible = function(param) {
    this.isTournamentsVisible = _bool.Parse(param)
};
TournamentRules.prototype.SetVisible = function(isVisible) {
    this.isRulesVisible = isVisible;
    this.isTournamentsVisible = isVisible
};
TournamentRules.prototype.UpdateRulesManually = function(uid) {
    this.isManualUpdate = true;
    this.OnSelectedTournamentIDChanged(uid);
    this.isManualUpdate = false
};
goog.require("UHT.ScrollableListItem");
TournamentRulesItem.prototype = Object.create(ScrollableListItem.prototype);
TournamentRulesItem.prototype.constructor = TournamentRulesItem;

function TournamentRulesItem() {
    ScrollableListItem.call(this);
    this.label = null
}
TournamentRulesItem.prototype.UpdateValue = function(value) {
    this.gameObject.SetActive(value != null);
    if (value == null) return;
    this.label.text = value
};
goog.require("UHT.XTLink");
TournamentsManager.prototype = Object.create(XTLink.prototype);
TournamentsManager.prototype.constructor = TournamentsManager;

function TournamentsManager() {
    XTLink.call(this);
    this.scrollableList = null;
    this.tournaments = null;
    this.catEnableTournaments = null;
    this.catDisableTournaments = null;
    this.catShowTournaments = null;
    this.catHideTournaments = null;
    this.catShowDetails = null;
    this.catHideDetails = null;
    this.catDisableHiddenMode = null;
    this.catTournamentClicked = null;
    this.showOnlyDetailsIfOneTournament = false;
    this.catShowTournamentDetails = null;
    this.catHideTournamentDetails = null;
    this.serverTime = 0;
    this.isEnabled = true;
    this.isVisible = false;
    this.isHiddenMode =
        true;
    this.enableBtnTimer = 0;
    this.enableBtnClickedTimes = 0;
    this.visibleTournamentsCount = 0;
    this.useDefaultViewCats = false;
    this.catDefaultViewSingle = null;
    this.catDefaultViewMultiple = null;
    this.defaultViewType = null;
    this.catDefaultViewByType = null
}
TournamentsManager.updateDefaultView = true;
TournamentsManager.showTournamentsFrame = -1;
TournamentsManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackInt(TournamentVars.ServerTime, this.OnServerTimeUpdated, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_TournamentsUpdated, this.OnTournamentsUpdated, this);
    XT.RegisterCallbackString(TournamentVars.SelectedTournamentID, this.OnSelectedTournamentIDChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ChangeVSGameState, this.OnVSGameStateChanged, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_CodeToData_InterfaceWindowOpen,
        this.HideTournaments, this)
};
TournamentsManager.prototype.XTInitVariablesAndEvents = function() {
    XT.SetString(TournamentVars.SelectedTournamentID, "");
    XT.SetString(TournamentVars.RankPromotionID, "");
    XT.SetInt(TournamentVars.MenuPromotionType, TournamentProtocol.PromoType.Invalid);
    XT.SetInt(TournamentVars.CurrentPromotionDisplayStyle, TournamentProtocol.DisplayStyle.Default)
};
TournamentsManager.prototype.OnVSGameStateChanged = function() {
    var state = VSGameStateManager.GetState();
    if (state == VSGameState.Spin || state == VSGameState.SpinBonusRounds) this.HideTournaments()
};
TournamentsManager.prototype.OnServerTimeUpdated = function(time) {
    this.serverTime = time
};
TournamentsManager.prototype.OnTournamentsUpdated = function() {
    this.UpdateTournaments(XT.GetObject(TournamentVars.Tournaments))
};
TournamentsManager.prototype.UpdateTournaments = function(tournamentsData) {
    this.visibleTournamentsCount = tournamentsData != null ? tournamentsData.length : 0;
    if (this.visibleTournamentsCount > 0) {
        this.EnableTournaments();
        this.scrollableList.UpdateValues(tournamentsData.slice());
        if (_string.IsNullOrEmpty(XT.GetString(TournamentVars.SelectedTournamentID))) XT.SetString(TournamentVars.SelectedTournamentID, tournamentsData[0].uid);
        if (this.isHiddenMode) this.DisableTournaments();
        return
    }
    this.scrollableList.UpdateValues(null);
    this.DisableTournaments()
};
TournamentsManager.prototype.OnSelectedTournamentIDChanged = function(newId) {
    for (var i = 0; i < this.tournaments.length; ++i) this.tournaments[i].UpdateSelectedTournamentID(newId)
};
TournamentsManager.prototype.OnScrollableListItemClicked = function(itemIndex) {
    var idx = _number.otoi(itemIndex);
    var t = this.scrollableList.items[idx];
    if (t.tournamentData == null) return;
    XT.SetString(TournamentVars.SelectedTournamentID, t.tournamentData.uid);
    if (this.catTournamentClicked != null) {
        if (this.catTournamentClicked.IsRunning()) this.catTournamentClicked.Stop();
        this.catTournamentClicked.Start()
    }
};
TournamentsManager.prototype.Update = function() {
    this.serverTime += Time.deltaTime;
    XT.SetInt(TournamentVars.ServerTime, _number.otoi(this.serverTime));
    this.enableBtnTimer += Time.deltaTime
};
TournamentsManager.prototype.DisableTournaments = function() {
    if (this.isEnabled) {
        this.isEnabled = false;
        this.StopRunningEvents();
        this.catDisableTournaments.Start()
    }
};
TournamentsManager.prototype.EnableTournaments = function() {
    if (!this.isEnabled) {
        this.isEnabled = true;
        this.StopRunningEvents();
        this.catEnableTournaments.Start()
    }
};
TournamentsManager.prototype.ShowTournaments = function() {
    if (!this.isEnabled) return;
    if (!this.isVisible) {
        var rankUID = XT.GetString(TournamentVars.RankPromotionID);
        var rankType = PromotionsHelper.GetPromotionType(rankUID);
        var menuType = XT.GetInt(TournamentVars.MenuPromotionType);
        var canSetUID = (menuType == TournamentProtocol.PromoType.Invalid || menuType == rankType) && TournamentsManager.showTournamentsFrame != Time.frameCount && !_string.IsNullOrEmpty(rankUID);
        TournamentsManager.showTournamentsFrame = Time.frameCount;
        XT.SetInt(TournamentVars.MenuPromotionType, TournamentProtocol.PromoType.Invalid);
        if (canSetUID && XT.GetString(TournamentVars.SelectedTournamentID) != rankUID) XT.SetString(TournamentVars.SelectedTournamentID, rankUID);
        XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionsOpen);
        this.isVisible = true;
        this.StopRunningEvents();
        var cat = this.catShowTournaments;
        if (this.showOnlyDetailsIfOneTournament && this.visibleTournamentsCount == 1) cat = this.catShowTournamentDetails;
        cat.Start();
        if (TournamentsManager.updateDefaultView) {
            TournamentsManager.updateDefaultView =
                false;
            if (this.useDefaultViewCats) {
                cat = this.visibleTournamentsCount == 1 ? this.catDefaultViewSingle : this.catDefaultViewMultiple;
                cat.Start();
                var type = PromotionsHelper.GetPromotionType(XT.GetString(TournamentVars.SelectedTournamentID));
                var idx = this.defaultViewType.indexOf(type);
                if (idx > -1) this.catDefaultViewByType[idx].Start()
            }
        }
    }
};
TournamentsManager.prototype.HideTournaments = function() {
    if (!this.isEnabled) return;
    if (this.isVisible) {
        XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionsClosed);
        this.isVisible = false;
        this.StopRunningEvents();
        var cat = this.catHideTournaments;
        if (this.showOnlyDetailsIfOneTournament && this.visibleTournamentsCount == 1) cat = this.catHideTournamentDetails;
        cat.Start()
    }
};
TournamentsManager.prototype.StopRunningEvents = function() {
    if (this.catEnableTournaments.IsRunning()) this.catEnableTournaments.Stop();
    if (this.catDisableTournaments.IsRunning()) this.catDisableTournaments.Stop();
    if (this.catShowTournaments.IsRunning()) this.catShowTournaments.Stop();
    if (this.catHideTournaments.IsRunning()) this.catHideTournaments.Stop();
    if (this.showOnlyDetailsIfOneTournament) {
        if (this.catShowTournamentDetails.IsRunning()) this.catShowTournamentDetails.Stop();
        if (this.catHideTournamentDetails.IsRunning()) this.catHideTournamentDetails.Stop()
    }
};
TournamentsManager.prototype.StopRunningDetailsEvents = function() {
    if (this.catShowDetails.IsRunning()) this.catShowDetails.Stop();
    if (this.catHideDetails.IsRunning()) this.catHideDetails.Stop()
};
TournamentsManager.prototype.ShowDetails = function() {
    if (this.catShowTournaments.IsRunning()) {
        this.catShowTournaments.RegisterCallback(this.OnShowTournamentsEnded, this);
        return
    }
    this.StopRunningDetailsEvents();
    this.catShowDetails.Start()
};
TournamentsManager.prototype.HideDetails = function() {
    this.StopRunningDetailsEvents();
    this.catHideDetails.Start()
};
TournamentsManager.prototype.OnShowTournamentsEnded = function(type, data) {
    if (type == CAT_Event.CallbackType.EndOfEvent) {
        this.ShowDetails();
        this.catShowTournaments.UnregisterCallback(this.OnShowTournamentsEnded, this)
    }
};
TournamentsManager.prototype.EnableBtnClicked = function() {
    if (this.enableBtnTimer > 1) {
        this.enableBtnTimer = 0;
        this.enableBtnClickedTimes = 0
    }
    this.enableBtnClickedTimes++;
    if (this.enableBtnClickedTimes == 5) this.DisableHiddenMode()
};
TournamentsManager.prototype.DisableHiddenMode = function() {
    this.isHiddenMode = false;
    this.catDisableHiddenMode.Start();
    this.UpdateTournaments(XT.GetObject(TournamentVars.Tournaments))
};
TournamentsManager.prototype.ScrollToSelectedPromotion = function() {
    var uid = XT.GetString(TournamentVars.SelectedTournamentID);
    if (!this.scrollableList.isScrollable()) return;
    var firstValueIdx = 0;
    var itemValues = this.scrollableList.itemValues;
    for (var i = 0; i < itemValues.length; ++i) {
        var promo = itemValues[i];
        if (promo != null && promo.uid == uid) {
            firstValueIdx = i;
            break
        }
    }
    if (this.scrollableList.hasExtraItem) firstValueIdx--;
    var lastIdx = firstValueIdx + (this.scrollableList.items.length - 1);
    var lastValueIdx = this.scrollableList.itemValues.length -
        1;
    firstValueIdx -= lastIdx > lastValueIdx ? lastIdx - lastValueIdx : 0;
    this.scrollableList.scrollRemain = 0;
    this.scrollableList.UpdateValuesAndIndex(null, firstValueIdx, true)
};
goog.require("UHT.XTLink");
TournamentsRank.prototype = Object.create(XTLink.prototype);
TournamentsRank.prototype.constructor = TournamentsRank;

function TournamentsRank() {
    XTLink.call(this);
    this.labels = null;
    this.labelsPrevious = null;
    this.catShowRank = null;
    this.catHideRank = null;
    this.catShowEndDate = null;
    this.tournament = null;
    this.contentSwitcher = null;
    this.rankUp = null;
    this.rankDown = null;
    this.startRotation = null;
    this.stopRotation = null;
    this.promotionTypeChanged = null;
    this.enabledContents = null;
    this.isRankVisible = true;
    this.isEndDateVisible = false;
    this.infoPrev = null;
    this.promoTypes = [TournamentProtocol.PromoType.Race, TournamentProtocol.PromoType.Tournament];
    this.isRotating = false;
    this.isEnabled = false;
    this.shouldAdvance = true
}
TournamentsRank.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_TournamentsUpdated, this.OnTournamentsUpdated, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionClosedByTime, this.OnPromotionClosedByTime, this)
};
TournamentsRank.prototype.OnTournamentsUpdated = function() {
    this.SetEnabled(XT.GetObject(TournamentVars.Tournaments) != null);
    if (!this.isEnabled) return;
    var info = PromotionsHelper.GetRankInfo();
    if (!this.isRotating) {
        this.isRotating = true;
        this.startRotation.Start()
    }
    if (this.contentSwitcher != null) {
        this.contentSwitcher.SwitchByType(info.type);
        this.contentSwitcher.SwitchByStyle(info.style)
    }
    if (!_string.IsNullOrEmpty(info.uid)) {
        XT.SetString(TournamentVars.RankPromotionID, info.realUID);
        if (this.tournament != null) this.tournament.UpdateTournament(info.uid);
        if (info.value < 0) {
            if (!this.isEndDateVisible) {
                this.isEndDateVisible = true;
                this.isRankVisible = false;
                this.catShowEndDate.Start()
            }
        } else {
            var text = info.type == TournamentProtocol.PromoType.Tournament ? PromotionsHelper.FormatRank(info.uid, info.value) : String(info.value);
            var textPrev = this.labels[0].text;
            for (var i = 0; i < this.labels.length; ++i) this.labels[i].text = text;
            for (var i = 0; i < this.labelsPrevious.length; ++i) this.labelsPrevious[i].text = textPrev;
            if (!this.isRankVisible) {
                this.isRankVisible = true;
                this.isEndDateVisible =
                    false;
                this.catShowRank.Start()
            } else if (this.infoPrev != null && info.type == this.infoPrev.type && info.uid == this.infoPrev.uid && text != textPrev) {
                var link = info.value < this.infoPrev.value ? this.rankUp : this.rankDown;
                if (link != null && link.cat != null) link.Start()
            }
        }
    } else {
        if (this.tournament != null) this.tournament.UpdateTournament(info.realUID);
        this.HideRank(info);
        this.isRotating = false
    }
    if (this.infoPrev != null && info.type != this.infoPrev.type) this.promotionTypeChanged.Start();
    this.infoPrev = info
};
TournamentsRank.prototype.NextPromotionType = function() {
    if (this.shouldAdvance) PromotionsHelper.lastPromotionShownIndex++;
    this.OnTournamentsUpdated()
};
TournamentsRank.prototype.SetEnabled = function(enabled) {
    if (this.isEnabled == enabled) return;
    this.isEnabled = enabled;
    if (this.enabledContents != null)
        for (var i = 0; i < this.enabledContents.length; ++i) this.enabledContents[i].SetActive(enabled)
};
TournamentsRank.prototype.HideRank = function(info) {
    if (this.isRankVisible || this.isEndDateVisible || info.type == TournamentProtocol.PromoType.Invalid) {
        this.isRankVisible = false;
        this.isEndDateVisible = false;
        this.catHideRank.Start()
    }
};
TournamentsRank.prototype.OnPromotionClosedByTime = function() {
    if (this.infoPrev == null) return;
    var uid = XT.GetString(TournamentVars.ClosedByTimePromotionUID);
    if (this.infoPrev.uid == uid) this.HideRank(this.infoPrev)
};
goog.require("UHT.Engine");
ActivatorByIndex.prototype = Object.create(Component.prototype);
ActivatorByIndex.prototype.constructor = ActivatorByIndex;

function ActivatorByIndex() {
    Component.call(this);
    this.objects = null
}
ActivatorByIndex.prototype.Activate = function(index, activate) {
    activate = activate == undefined ? true : activate;
    this.objects[index].SetActive(activate)
};
ActivatorByIndex.prototype.Deactivate = function(index) {
    this.Activate(index, false)
};
ActivatorByIndex.prototype.ActivateAll = function() {
    for (var i = 0; i < this.objects.length; ++i) this.Activate(i, true)
};
ActivatorByIndex.prototype.DeactivateAll = function() {
    for (var i = 0; i < this.objects.length; ++i) this.Activate(i, false)
};
goog.require("UHT.Engine");
CameraClippingEnabler.prototype = Object.create(Component.prototype);
CameraClippingEnabler.prototype.constructor = CameraClippingEnabler;

function CameraClippingEnabler() {
    Component.call(this)
}
CameraClippingEnabler.prototype.EnableClipping = function() {
    this.gameObject.GetComponent(ExtraCameraSettings).enabled = true;
    this.gameObject.GetComponent(ExtraCameraSettings).dirtyFlag = true
};
CameraClippingEnabler.prototype.DisableClipping = function() {
    this.gameObject.GetComponent(ExtraCameraSettings).enabled = false
};
goog.require("UHT.Engine");
ColliderProxy.prototype = Object.create(Component.prototype);
ColliderProxy.prototype.constructor = ColliderProxy;

function ColliderProxy() {
    Component.call(this);
    this.boxColliders = [];
    this.sphereColliders = [];
    this.eventPress = null;
    this.eventRelease = null;
    this.eventClick = null;
    this.eventHoverOn = null;
    this.eventHoverOff = null;
    this.notifyPress = true;
    this.notifyRelease = true;
    this.notifyClick = true;
    this.notifyHoverOn = true;
    this.notifyHoverOff = true;
    this.notifyOnDisable = true;
    this.wasHover = false;
    this.wasPressed = false
}
ColliderProxy.prototype.OnDisable = function() {
    if (!this.enabled || !this.notifyOnDisable) return;
    this.OnPress(false)
};
ColliderProxy.prototype.OnClick = function() {
    if (!this.enabled || !this.notifyClick) return;
    var cd = this.gameObject.GetComponent(ClickDelay);
    if (cd == null || cd.CanClick()) {
        for (var i = 0; i < this.boxColliders.length; ++i) this.boxColliders[i].gameObject.SendMessage("OnClick");
        for (var i = 0; i < this.sphereColliders.length; ++i) this.sphereColliders[i].gameObject.SendMessage("OnClick");
        this.SendMessageData(this.eventClick)
    }
};
ColliderProxy.prototype.OnHover = function(isOver) {
    if (!this.enabled) return;
    this.Notify("OnHover", isOver, isOver ? this.eventHoverOn : this.eventHoverOff);
    this.wasHover = isOver
};
ColliderProxy.prototype.OnPress = function(isPressed) {
    if (!this.enabled) return;
    this.Notify("OnPress", isPressed, isPressed ? this.eventPress : this.eventRelease);
    this.wasPressed = isPressed;
    if (this.wasHover) this.OnHover(false)
};
ColliderProxy.prototype.Notify = function(methodName, value, messageData) {
    var notify = methodName == "OnPress" && (this.notifyPress && value || this.notifyRelease && !value) || methodName == "OnHover" && (this.notifyHoverOn && value || this.notifyHoverOff && !value);
    if (!notify) return;
    for (var i = 0; i < this.boxColliders.length; ++i) this.boxColliders[i].gameObject.SendMessage(methodName, value);
    for (var i = 0; i < this.sphereColliders.length; ++i) this.sphereColliders[i].gameObject.SendMessage(methodName, value);
    this.SendMessageData(messageData)
};
ColliderProxy.prototype.SendMessageData = function(messageData) {
    for (var i = 0; i < messageData.length; ++i) MessageSender.SendMessage(messageData[i])
};
ColliderProxy.prototype.SetEnabled = function(enabled) {
    if (!enabled) this.OnDisable();
    this.enabled = enabled
};
ColliderProxy.prototype.NotifyIfHovered = function() {
    if (this.wasHover) this.OnHover(this.wasHover)
};
ColliderProxy.prototype.NotifyIfPressed = function() {
    if (this.wasPressed) this.OnPress(this.wasPressed)
};
goog.require("UHT.Engine");
AnimClipChanger.prototype = Object.create(Component.prototype);
AnimClipChanger.prototype.constructor = AnimClipChanger;

function AnimClipChanger() {
    Component.call(this)
}
AnimClipChanger.prototype.PlayAnim = function(animName) {
    this.gameObject.animation.Play(animName)
};
goog.require("UHT.Engine");
ButtonEnabler.prototype = Object.create(Component.prototype);
ButtonEnabler.prototype.constructor = ButtonEnabler;

function ButtonEnabler() {
    Component.call(this);
    this.target = null;
    this.uibuttons = [];
    this.isInit = false
}
ButtonEnabler.prototype.Init = function() {
    this.uibuttons = this.target.GetComponents(UIButton);
    this.isInit = true
};
ButtonEnabler.prototype.EnableButton = function() {
    if (!this.isInit) this.Init();
    for (var i = 0; i < this.uibuttons.length; i++) this.uibuttons[i].SetEnabled(true)
};
ButtonEnabler.prototype.DisableButton = function() {
    if (!this.isInit) this.Init();
    for (var i = 0; i < this.uibuttons.length; i++) this.uibuttons[i].SetEnabled(false)
};
goog.require("UHT.Engine");
ColliderEnabler.prototype = Object.create(Component.prototype);
ColliderEnabler.prototype.constructor = ColliderEnabler;

function ColliderEnabler() {
    Component.call(this);
    this.includeChildren = false;
    this.enable = null;
    this.disable = null
}
ColliderEnabler.prototype.EnableCollider = function() {
    if (this.includeChildren) {
        var colliders = this.GetComponentsInChildren(Collider, true);
        for (var i = 0; i < colliders.length; ++i) colliders[i].enabled = true
    } else this.gameObject.collider.enabled = true;
    this.StartCATLink(this.enable)
};
ColliderEnabler.prototype.DisableCollider = function() {
    if (this.includeChildren) {
        var colliders = this.GetComponentsInChildren(Collider, true);
        for (var i = 0; i < colliders.length; ++i) colliders[i].enabled = false
    } else this.gameObject.collider.enabled = false;
    this.StartCATLink(this.disable)
};
ColliderEnabler.prototype.StartCATLink = function(link) {
    if (link != null || link.cat != null) link.Start()
};
goog.require("UHT.Engine");
MoveTransformToTarget.prototype = Object.create(Component.prototype);
MoveTransformToTarget.prototype.constructor = MoveTransformToTarget;

function MoveTransformToTarget() {
    Component.call(this);
    this.movingTransform = null;
    this.target = null;
    this.moveDuration = 1;
    this.alsoScaleToTarget = false;
    this.resetAtTheEnd = false;
    this.resetStopsMovement = false;
    this.useTimeChannel = false;
    this.timeChannelID = 0;
    this.speedCurve = null;
    this.moving = false;
    this.myTimeChannel = null;
    this.currentTime = 0;
    this.totalCurveTime = 0;
    this.startPosition = UHTMath.Vector3.zero;
    this.resetPosition = UHTMath.Vector3.zero;
    this.startScale = UHTMath.Vector3.zero;
    this.resetScale = UHTMath.Vector3.zero
}
MoveTransformToTarget.prototype.StartMoving = function() {
    this.moving = true;
    this.currentTime = 0;
    if (this.useTimeChannel) this.myTimeChannel = Globals.RegisterToTimeChannel(this, this.timeChannelID);
    this.totalCurveTime = this.speedCurve.keys[this.speedCurve.keys.length - 1].time - this.speedCurve.keys[0].time;
    this.startPosition = new UHTMath.Vector3(this.movingTransform.position().x, this.movingTransform.position().y, this.movingTransform.position().z);
    this.resetPosition = new UHTMath.Vector3(this.movingTransform.localPosition().x,
        this.movingTransform.localPosition().y, this.movingTransform.localPosition().z);
    this.startScale = new UHTMath.Vector3(this.movingTransform.localScale().x, this.movingTransform.localScale().y, this.movingTransform.localScale().z);
    this.resetScale = new UHTMath.Vector3(this.movingTransform.localScale().x, this.movingTransform.localScale().y, this.movingTransform.localScale().z)
};
MoveTransformToTarget.prototype.ResetPosition = function() {
    if (this.resetStopsMovement) this.moving = false;
    if (this.alsoScaleToTarget) this.movingTransform.localScale(this.resetScale);
    this.movingTransform.localPosition(this.resetPosition)
};
MoveTransformToTarget.prototype.Update = function() {
    if (this.moving) {
        var progress = this.currentTime / this.moveDuration;
        if (this.speedCurve.keys.length >= 2) {
            var curCurveTime = progress * this.totalCurveTime;
            progress = this.speedCurve.Evaluate(curCurveTime + this.speedCurve.keys[0].time);
            progress = UHTMath.clamp(progress, 0, 1)
        }
        if (progress >= 0 && progress <= 1) {
            if (this.alsoScaleToTarget) this.movingTransform.localScale(UHTMath.Vector3.lerp(this.startScale, this.target.localScale(), progress));
            this.movingTransform.position(UHTMath.Vector3.lerp(this.startPosition,
                this.target.position(), progress))
        }
        if (this.useTimeChannel)
            if (this.myTimeChannel.IsChannelMaster(this)) {
                if (this.currentTime < this.moveDuration) this.currentTime += Time.deltaTime;
                this.myTimeChannel.currentTime = this.currentTime
            } else this.currentTime = this.myTimeChannel.currentTime;
        else if (this.currentTime < this.moveDuration) this.currentTime += Time.deltaTime;
        if (this.currentTime >= this.moveDuration) {
            if (this.useTimeChannel) Globals.UnregisterFromTimeChannel(this, this.timeChannelID);
            if (this.alsoScaleToTarget) this.movingTransform.localScale(this.target.localScale());
            this.movingTransform.position(this.target.position());
            this.moving = false;
            if (this.resetAtTheEnd) this.ResetPosition()
        }
    }
};
MoveTransformToTarget.prototype.Stop = function() {
    this.moving = false
};
goog.require("UHT.Engine");
MovieController.prototype = Object.create(Component.prototype);
MovieController.prototype.constructor = MovieController;

function MC_SerializeHelper() {
    this.id = [];
    this.cachedTex = []
}

function MovieController() {
    Component.call(this);
    this.FPS = 10;
    this.startFrame = 0;
    this.loop = true;
    this.playAutomatically = true;
    this.pausedUntilReady = false;
    this.resetOnEnable = false;
    this.deltaMovie = true;
    this.deltaIsOpaque = false;
    this.superTrimPlayInReverse = false;
    this.callback = null;
    this.fallback = null;
    this.isPlaying = false;
    this.canStartCallback = true;
    this.atlases = [];
    this.frames = -1;
    this.numberOfPieces = [];
    this.atlasIdxPerFramePerPiece = [];
    this.color = null;
    this.width = 0;
    this.height = 0;
    this.currentFrame = 0;
    this.time = 0;
    this.frameBuffer = null;
    this.oldFrame = -1;
    this.panel = null;
    this.pixiObject = new PIXI.Container(null);
    this.pixiObjectContent = null;
    this.movieWidth = -1;
    this.movieHeight = -1;
    this.isInit = false;
    this.blendSteps = 1;
    this.currentSubFrame = 0;
    this.oldSubFrame = 0
}
MovieController.prototype.Init = function() {
    if (this.isInit) return;
    var atlasesLoaded = true;
    for (var fl = 0; fl < this.frames; fl++)
        for (var pl = 0; pl < this.numberOfPieces[fl]; pl++) {
            var atlasL = this.atlases[this.atlasIdxPerFramePerPiece[fl].id[pl]];
            if (!atlasL.isLoaded()) {
                atlasL.initAtlas();
                atlasesLoaded = false
            }
        }
    if (!atlasesLoaded) return;
    for (var f = 0; f < this.frames; f++) {
        this.atlasIdxPerFramePerPiece[f].cachedTex = _array.create(this.atlasIdxPerFramePerPiece[f].id.length);
        for (var p = 0; p < this.numberOfPieces[f]; p++) {
            var atlas =
                this.atlases[this.atlasIdxPerFramePerPiece[f].id[p]];
            this.atlasIdxPerFramePerPiece[f].cachedTex[p] = atlas.getTextureForSimpleSprite(null, "Frame_" + f + "_p" + p)
        }
    }
    this.panel = this.gameObject.GetComponent(UIPanel);
    var tex0 = this.atlasIdxPerFramePerPiece[0].cachedTex[0];
    if (this.movieWidth > 0) {
        this.width = this.movieWidth;
        this.height = this.movieHeight
    } else {
        this.width = tex0.trim.width;
        this.height = tex0.trim.height
    }
    if (this.deltaMovie) {
        this.frameBuffer = new PIXI.RenderTexture(globalRenderer.renderer, this.width, this.height);
        this.pixiObjectContent = new PIXI.Sprite(this.frameBuffer);
        this.pixiObjectContent.blendMode = this.atlases[0].blendMode;
        this.pixiObjectContent.anchor.x = .5;
        this.pixiObjectContent.anchor.y = .5
    } else this.pixiObjectContent = new PIXI.Container(null);
    this.pixiObject.addChild(this.pixiObjectContent);
    this.isInit = true;
    if (this.fallback != null && this.fallback.activeSelf) this.fallback.SetActive(false)
};
MovieController.prototype.Start = function() {
    this.Init()
};
MovieController.prototype.OnWillRenderObject = function() {
    if (!this.isInit) {
        this.Init();
        if (!this.isInit) return
    }
    this.pixiObject.dirtyWT = true;
    if (this.deltaMovie) {
        var child = this.pixiObjectContent;
        child.tint = this.color.rgbAsHex;
        if (this.panel != null) child.alpha = this.color.a * this.panel.alpha;
        else child.alpha = this.color.a;
        child.worldAlpha = child.alpha;
        var hc = this.gameObject.transform;
        var parent = this.pixiObject;
        var hp = hc.parent.transform;
        parent.x = hp._dangerous_get_position().x;
        parent.y = -hp._dangerous_get_position().y;
        child.x = hc._dangerous_get_localPosition().x;
        child.y = -hc._dangerous_get_localPosition().y;
        parent.rotation = -hp._dangerous_get_rotation().eulerAnglesRad().z;
        child.rotation = -hc._dangerous_get_localRotation().eulerAnglesRad().z;
        parent.scale.x = hp._dangerous_get_scale().x;
        parent.scale.y = hp._dangerous_get_scale().y;
        child.width = this.width * hc._dangerous_get_localScale().x;
        child.height = this.height * hc._dangerous_get_localScale().y
    } else {
        if (this.oldFrame != this.currentFrame) {
            this.pixiObjectContent.children = [];
            var f =
                this.currentFrame;
            for (var p = 0; p < this.numberOfPieces[f]; p++) {
                var pixiSprite = new PIXI.Sprite(this.atlasIdxPerFramePerPiece[f].cachedTex[p]);
                var resize = this.atlases[this.atlasIdxPerFramePerPiece[f].id[p]].resize / 100;
                pixiSprite.width = this.width / resize;
                pixiSprite.height = this.height / resize;
                pixiSprite.anchor.x = .5;
                pixiSprite.anchor.y = .5;
                pixiSprite.blendMode = this.atlases[0].blendMode;
                this.pixiObjectContent.addChild(pixiSprite)
            }
            this.oldFrame = this.currentFrame
        }
        var child = this.pixiObjectContent;
        for (var i = 0; i <
            child.children.length; i++) {
            var c = child.children[i];
            c.tint = this.color.rgbAsHex;
            if (this.panel != null) c.alpha = this.color.a * this.panel.alpha;
            else c.alpha = this.color.a;
            c.worldAlpha = c.alpha
        }
        var hc = this.gameObject.transform;
        var parent = this.pixiObject;
        var hp = hc.parent.transform;
        parent.x = hp._dangerous_get_position().x;
        parent.y = -hp._dangerous_get_position().y;
        child.x = hc._dangerous_get_localPosition().x;
        child.y = -hc._dangerous_get_localPosition().y;
        parent.rotation = -hp._dangerous_get_rotation().eulerAnglesRad().z;
        child.rotation = -hc._dangerous_get_localRotation().eulerAnglesRad().z;
        parent.scale.x = hp._dangerous_get_scale().x;
        parent.scale.y = hp._dangerous_get_scale().y;
        child.scale.x = hc._dangerous_get_localScale().x;
        child.scale.y = hc._dangerous_get_localScale().y
    }
};
MovieController.prototype.StartPlaying = function() {
    if (this.deltaMovie && !this.deltaIsOpaque) this.ClearFrameBuffer();
    this.time = 0;
    this.currentFrame = this.startFrame;
    this.isPlaying = true
};
MovieController.prototype.Reset = function() {
    this.time = 0;
    this.currentFrame = this.startFrame
};
MovieController.prototype.OnEnable = function() {
    if (this.playAutomatically) this.StartPlaying();
    if (this.resetOnEnable) this.Reset();
    if (!this.isInit && this.fallback != null) this.fallback.SetActive(true)
};
MovieController.prototype.OnDisable = function() {
    if (this.fallback != null && this.fallback.activeSelf) this.fallback.SetActive(false)
};
MovieController.prototype.OnUpdateRenderTexture = function() {
    if (this.deltaMovie) {
        if (!this.isInit) {
            this.Init();
            if (!this.isInit) return
        }
        if (this.oldFrame > this.currentFrame) this.oldFrame = -1;
        var pieces, pixiSprite, resize, f, p;
        if (this.oldFrame != this.currentFrame) {
            pieces = new PIXI.Container(null);
            for (f = this.oldFrame + 1; f <= this.currentFrame; f++)
                for (p = 0; p < this.numberOfPieces[f]; p++) {
                    pixiSprite = new PIXI.Sprite(this.atlasIdxPerFramePerPiece[f].cachedTex[p]);
                    resize = this.atlases[this.atlasIdxPerFramePerPiece[f].id[p]].resize /
                        100;
                    pixiSprite.width = this.width / resize;
                    pixiSprite.height = this.height / resize;
                    pieces.addChild(pixiSprite)
                }
            this.frameBuffer.render(pieces);
            this.oldFrame = this.currentFrame;
            this.oldSubFrame = this.currentSubFrame = 0
        }
        this.currentSubFrame = this.time / (1 / this.FPS / this.blendSteps) | 0;
        if (this.oldSubFrame != this.currentSubFrame) {
            var alpha = 1 / this.blendSteps;
            pieces = new PIXI.Container(null);
            f = this.currentFrame + 1;
            if (this.loop) f = f % this.frames;
            for (p = 0; p < this.numberOfPieces[f]; p++) {
                pixiSprite = new PIXI.Sprite(this.atlasIdxPerFramePerPiece[f].cachedTex[p]);
                resize = this.atlases[this.atlasIdxPerFramePerPiece[f].id[p]].resize / 100;
                pixiSprite.width = this.width / resize;
                pixiSprite.height = this.height / resize;
                pixiSprite.alpha = alpha;
                pieces.addChild(pixiSprite)
            }
            this.frameBuffer.render(pieces);
            this.oldSubFrame = this.currentSubFrame
        }
    }
};
MovieController.prototype.Update = function() {
    if (!this.isInit && this.pausedUntilReady) return;
    if (this.isPlaying) {
        this.time += Time.deltaTime;
        while (this.time > 1 / this.FPS) {
            if (this.superTrimPlayInReverse) this.currentFrame--;
            else this.currentFrame++;
            if (this.currentFrame == this.frames) {
                this.currentFrame--;
                if (!this.loop) this.isPlaying = false;
                else this.currentFrame = 0
            }
            if (this.currentFrame < 0) {
                this.currentFrame = 0;
                if (!this.loop) this.isPlaying = false;
                else this.currentFrame += this.frames
            }
            if (!this.isPlaying && this.callback !=
                null && this.canStartCallback) this.callback.Start();
            this.time = this.time - 1 / this.FPS
        }
    }
};
MovieController.prototype.SetIsPlaying = function(param) {
    this.isPlaying = _bool.Parse(param)
};
MovieController.prototype.SetLoop = function(param) {
    this.loop = _bool.Parse(param)
};
MovieController.prototype.SetCanStartCallback = function(param) {
    this.canStartCallback = _bool.Parse(param)
};
MovieController.prototype.Pause = function() {
    this.isPlaying = false
};
MovieController.prototype.Resume = function() {
    this.isPlaying = true
};
MovieController.prototype.ClearFrameBuffer = function() {
    var fb = this.frameBuffer;
    if (fb != null) fb.clear()
};
MovieController.prototype.GoToFrame = function(frame) {
    if (this.currentFrame == frame) return;
    if (this.deltaMovie) {
        this.oldFrame = -1;
        if (!this.deltaIsOpaque) this.ClearFrameBuffer()
    }
    this.currentFrame = frame
};
goog.require("UHT.Engine");
MultipleParticlesEnabler.prototype = Object.create(Component.prototype);
MultipleParticlesEnabler.prototype.constructor = MultipleParticlesEnabler;

function MultipleParticlesEnabler() {
    Component.call(this);
    this.particlesGenerators = null;
    this.generateParticlesOnStart = false
}
MultipleParticlesEnabler.prototype.Awake = function() {
    if (this.particlesGenerators.length == 0) this.particlesGenerators = this.gameObject.GetComponentsInChildren(ParticleSystem, true);
    for (var i = 0; i < this.particlesGenerators.length; i++) {
        this.particlesGenerators[i].enableEmission = this.generateParticlesOnStart;
        this.particlesGenerators[i].gameObject.SetActive(true)
    }
};
MultipleParticlesEnabler.prototype.EnableEmission = function() {
    this.ChangeEmissionState(true)
};
MultipleParticlesEnabler.prototype.DisableEmission = function() {
    this.ChangeEmissionState(false)
};
MultipleParticlesEnabler.prototype.ChangeEmissionState = function(_enable) {
    if (this.particlesGenerators == null) this.Awake();
    for (var i = 0; i < this.particlesGenerators.length; i++) this.particlesGenerators[i].enableEmission = _enable
};
goog.require("UHT.Engine");
ParticlesControlledActive.prototype = Object.create(Component.prototype);
ParticlesControlledActive.prototype.constructor = ParticlesControlledActive;

function ParticlesControlledActive() {
    Component.call(this);
    this.particles = null;
    this.objects = null;
    this.wasEnabled = false
}
ParticlesControlledActive.prototype.Update = function() {
    var enabled = false;
    var particlesCount = 0;
    for (var i = 0; i < this.particles.length; ++i) particlesCount += this.particles[i].particleCount;
    enabled = particlesCount > 0;
    if (enabled == this.wasEnabled) return;
    this.wasEnabled = enabled;
    for (var i = 0; i < this.objects.length; ++i) this.objects[i].SetActive(enabled)
};
goog.require("UHT.Engine");
ParticlesEnabler.prototype = Object.create(Component.prototype);
ParticlesEnabler.prototype.constructor = ParticlesEnabler;

function ParticlesEnabler() {
    Component.call(this);
    this.particles = null;
    this.pEnabled = false;
    this.disableIfNoEmission = false
}
ParticlesEnabler.prototype.Awake = function() {
    if (this.particles == null) this.particles = this.gameObject.GetComponentsInChildren(ParticleSystem, true)[0];
    this.pEnabled = this.particles.enableEmission;
    if (!this.pEnabled) this.particles.gameObject.SetActive(false)
};
ParticlesEnabler.prototype.OnDisable = function() {
    if (this.particles.gameObject !== this.gameObject) this.particles.gameObject.SetActive(this.pEnabled)
};
ParticlesEnabler.prototype.EnableEmission = function(_enable) {
    if (this.particles == null) this.Awake();
    this.pEnabled = _enable;
    this.particles.enableEmission = _enable;
    if (_enable) this.particles.gameObject.SetActive(true);
    else if (this.gameObject.activeInHierarchy) this.disableIfNoEmission = true
};
ParticlesEnabler.prototype.SetEmissionEnabled = function() {
    this.EnableEmission(true)
};
ParticlesEnabler.prototype.SetEmissionDisabled = function() {
    this.EnableEmission(false)
};
ParticlesEnabler.prototype.Update = function() {
    if (this.disableIfNoEmission)
        if (this.particles.particleCount == 0) {
            this.particles.gameObject.SetActive(false);
            this.disableIfNoEmission = false
        }
};
goog.require("UHT.XTLink");
ResultDisplayerDelayer.prototype = Object.create(XTLink.prototype);
ResultDisplayerDelayer.prototype.constructor = ResultDisplayerDelayer;

function ResultDisplayerDelayer() {
    XTLink.call(this);
    this.symbolsDelays = [];
    this.rq = null;
    this.rm = null;
    this.fastStop = false
}
ResultDisplayerDelayer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_SpinResultReceived, this.OnResultReceived, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelManager_StopSpin, this.OnFastStop, this)
};
ResultDisplayerDelayer.prototype.OnFastStop = function() {
    this.fastStop = true
};
ResultDisplayerDelayer.prototype.OnGameInit = function() {
    this.rq = XT.GetObject(Vars.RQManagerObject);
    this.rm = XT.GetObject(Vars.ReelsManagerObject)
};
ResultDisplayerDelayer.prototype.OnResultReceived = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_InjectRQIOnResultDisplayerLoopStarts, this.OnLoopStarts, this)
};
ResultDisplayerDelayer.prototype.OnLoopStarts = function(param) {
    if (this.fastStop == false) this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.GetDelay()));
    this.fastStop = false;
    XT.UnregisterCallbackEvent(this.OnLoopStarts, this)
};
ResultDisplayerDelayer.prototype.GetDelay = function() {
    var delay = 0;
    for (var i = 0; i < this.symbolsDelays.length; i++)
        for (var j = 0; j < this.symbolsDelays[i].affectedReels.length; j++) {
            var rId = this.symbolsDelays[i].affectedReels[j];
            for (var k = 0; k < this.rm.reels[rId].symbolHolders.length; k++)
                if (this.rm.reels[rId].symbolHolders[k].currentSymbol.symbolId == this.symbolsDelays[i].symbolId) {
                    if (delay < this.symbolsDelays[i].reelDelay[j]) delay = this.symbolsDelays[i].reelDelay[j];
                    break
                }
        }
    return delay
};

function SymbolDelay() {
    this.symbolId = 0;
    this.reelDelay = [];
    this.affectedReels = []
}
goog.require("UHT.Engine");
var SpineControllerMode = {
    Default: 0,
    DefaultThenReset: 1,
    Loop: 2
};
var SpineControllerAction = {
    Reset: 0,
    Play: 1,
    Resume: 2,
    Pause: 3,
    NoAction: 69
};
var SpineControllerCATAction = {
    Reset: 0,
    Play: 1,
    Resume: 2,
    Pause: 3,
    Stop: 4,
    Sample: 5,
    NoAction: 69
};

function UHTSpineAtlases() {
    this.atlases = null
}

function UHTSpine() {
    this.name = "";
    this.spineJSON = "";
    this.spineAtlas = null;
    this.resource = null;
    this.scale = 1
}
SpineController.prototype = Object.create(Component.prototype);
SpineController.prototype.constructor = SpineController;

function SpineController() {
    Component.call(this);
    this.spine = null;
    this.spineData = null;
    this.spineAtlases = null;
    this.animationName = "";
    this.animationTime = -1;
    this.animationMode = SpineControllerMode.Default;
    this.onEnable = SpineControllerAction.Reset;
    this.onComplete = null;
    this.color = null;
    this.timeScaleID = "";
    this.duration = 0;
    this.speed = 0;
    this.trackTime = 0;
    this.sampleTime = 0;
    this.sampleTimeIsNormalized = false;
    this.isPlaying = false;
    this.prevAnimationName = "";
    this.direction = 1;
    this.trackEntry = null;
    this.actions = [];
    this.panel =
        null;
    this.pixiObject = new PIXI.Container(null);
    this.isInit = false;
    this.exportedWithPMA = false;
    this.isUpdated = false;
    this.frameOfLastUpdate = -1;
    this.needUpdateSpine = false;
    this.waitForLocalization = true
}
SpineController.spineAtlasParser = null;
SpineController.prototype.Init = function() {
    if (!(this.spineData.spineJSON instanceof Object)) this.spineData.spineJSON = JSON.parse(atob(String(this.spineData.spineJSON)));
    var atlasesLoaded = true;
    for (var i = 0; i < this.spineAtlases.length; ++i)
        for (var j = 0; j < this.spineAtlases[i].atlases.length; ++j) {
            var atlas = this.spineAtlases[i].atlases[j];
            if (!atlas.isLoaded()) {
                atlas.initAtlas();
                atlasesLoaded = false
            }
        }
    if (!atlasesLoaded) return;
    if (this.spineData.spineAtlas == null) {
        var SpineCore = PIXI.spine.core;
        this.spineData.spineAtlas =
            new SpineCore.TextureAtlas;
        var pages = this.spineData.spineAtlas.pages;
        var regions = this.spineData.spineAtlas.regions;
        for (var i = 0; i < this.spineAtlases.length; ++i)
            for (var j = 0; j < this.spineAtlases[i].atlases.length; ++j) {
                var atlas = this.spineAtlases[i].atlases[j];
                var baseTexture = atlas.pixiTexture.baseTexture;
                baseTexture.premultipliedAlpha = !this.exportedWithPMA;
                var page = new SpineCore.TextureAtlasPage;
                page.name = atlas.gameObject.name;
                page.width = baseTexture.realWidth;
                page.height = baseTexture.realHeight;
                page.baseTexture =
                    baseTexture;
                page.minFilter = page.magFilter = SpineCore.TextureFilter.Linear;
                page.uWrap = SpineCore.TextureWrap.ClampToEdge;
                page.vWrap = SpineCore.TextureWrap.ClampToEdge;
                pages.push(page);
                for (var spriteName in atlas.cachedSprites) {
                    var sprite = atlas.cachedSprites[spriteName];
                    var width = sprite.rotate ? sprite.height : sprite.width;
                    var height = sprite.rotate ? sprite.width : sprite.height;
                    var rotate = sprite.rotate ? 6 : 0;
                    var rectFrame = new PIXI.Rectangle(sprite.x, sprite.y, width, height);
                    var rectCrop = new PIXI.Rectangle(sprite.x,
                        sprite.y, width, height);
                    var rectTrim;
                    if (sprite.rotate) rectTrim = new PIXI.Rectangle(sprite.paddingBottom, sprite.paddingLeft, width + sprite.paddingBottom + sprite.paddingTop, height + sprite.paddingLeft + sprite.paddingRight);
                    else rectTrim = new PIXI.Rectangle(sprite.paddingLeft, sprite.paddingTop, width + sprite.paddingLeft + sprite.paddingRight, height + sprite.paddingTop + sprite.paddingBottom);
                    var texture = new PIXI.Texture(atlas.pixiTexture, rectFrame, rectCrop, rectTrim, rotate);
                    var region = new SpineCore.TextureAtlasRegion;
                    region.name = spriteName;
                    region.page = page;
                    region.texture = texture;
                    region.index = sprite.index;
                    region.texture._updateUvs();
                    regions.push(region);
                    atlas.cachedSimpleSpriteInfo[atlas.cachedSpriteNames[spriteName]] = texture
                }
            }
        this.spineData.resource = {
            data: this.spineData.spineJSON,
            metadata: {
                spineAtlas: this.spineData.spineAtlas
            }
        };
        if (SpineController.spineAtlasParser == null) SpineController.spineAtlasParser = PIXI.spine.atlasParser();
        SpineController.spineAtlasParser(this.spineData.resource, SpineController.OnAtlasParsed)
    }
    this.spine =
        new PIXI.spine.Spine(this.spineData.resource.spineData);
    this.spine.autoUpdate = false;
    this.panel = this.gameObject.GetComponent(UIPanel);
    this.isInit = true
};
SpineController.OnAtlasParsed = function() {};
SpineController.prototype.OnEnable = function() {
    this.actions.push(this.onEnable);
    this.Update()
};
SpineController.prototype.OnDisable = function() {
    if (this.spine != null) this.spine.state.clearTracks()
};
SpineController.prototype.Update = function() {
    if (this.waitForLocalization && !ModificationsManager.Applied) return;
    if (this.frameOfLastUpdate == Time.frameCount) return;
    if (!this.isInit) {
        this.Init();
        if (!this.isInit) return;
        this.pixiObject.addChild(this.spine)
    }
    this.frameOfLastUpdate = Time.frameCount;
    this.SetupAnimation();
    for (var i = 0; i < this.actions.length; ++i)
        if (this.actions[i] == SpineControllerCATAction.Reset) this.Reset();
        else if (this.actions[i] == SpineControllerCATAction.Play) this.PlayInternal();
    else if (this.actions[i] ==
        SpineControllerCATAction.Resume) this.Resume();
    else if (this.actions[i] == SpineControllerCATAction.Pause) this.PauseInternal();
    else if (this.actions[i] == SpineControllerCATAction.Stop) this.Stop();
    else if (this.actions[i] == SpineControllerCATAction.Sample) {
        if (this.sampleTimeIsNormalized) this.sampleTime *= this.duration;
        this.SampleTime(this.sampleTime)
    }
    this.actions.splice(0);
    this.UpdateSpine();
    this.isUpdated = true
};
SpineController.prototype.UpdateSpine = function() {
    if (this.trackEntry == null) return;
    if (this.needUpdateSpine || Math.abs(this.trackEntry.timeScale) > UHTMath.numberError) {
        this.needUpdateSpine = false;
        this.spine.update(TimeScaler.GetDeltaTime(this.timeScaleID))
    }
};
SpineController.prototype.LateUpdate = function() {
    if (this.trackEntry != null) this.trackTime = this.trackEntry.animationLast
};
SpineController.prototype.SetupAnimation = function() {
    if (this.prevAnimationName != this.animationName) {
        this.prevAnimationName = this.animationName;
        this.spine.state.clearTracks();
        this.SetToSetupPose()
    }
    this.trackEntry = this.spine.state.getCurrent(0);
    if (this.trackEntry == null) {
        var I = this;
        this.spine.loop = this.animationMode == SpineControllerMode.Loop;
        this.trackEntry = this.spine.state.addAnimation(0, this.animationName, this.spine.loop, 0);
        this.trackEntry.listener = {
            complete: function(trackEntry, count) {
                SpineController.prototype.OnAnimationComplete.call(I,
                    trackEntry)
            }
        };
        this.needUpdateSpine = true
    }
    this.duration = this.trackEntry.animation.duration;
    this.speed = this.animationTime > 0 ? this.duration / this.animationTime : 1
};
SpineController.prototype.OnAnimationComplete = function(trackEntry) {
    if (this.animationMode == SpineControllerMode.DefaultThenReset) this.Reset();
    if (this.animationMode != SpineControllerMode.Loop) {
        this.isPlaying = false;
        this.trackEntry.timeScale = 0;
        if (this.onComplete != null) this.onComplete.Start()
    }
};
SpineController.prototype.Reset = function() {
    if (this.trackEntry == null) {
        this.actions.push(SpineControllerCATAction.Reset);
        return
    }
    this.prevAnimationName = "";
    this.SampleTime(0);
    this.isPlaying = false
};
SpineController.prototype.PlayInternal = function() {
    if (this.trackEntry == null) {
        this.actions.push(SpineControllerCATAction.Play);
        return
    }
    this.SetToSetupPose();
    this.SampleTime(0);
    this.trackEntry.timeScale = this.speed * this.direction
};
SpineController.prototype.Play = function() {
    this.PlayInternal();
    this.isPlaying = true
};
SpineController.prototype.Stop = function() {
    this.Reset()
};
SpineController.prototype.PauseInternal = function() {
    if (this.trackEntry == null) {
        this.actions.push(SpineControllerCATAction.Pause);
        return
    }
    this.SampleTime(this.trackTime);
    this.isPlaying = false
};
SpineController.prototype.Pause = function() {
    if (this.trackEntry != null) this.trackTime = this.trackEntry.animationLast;
    this.PauseInternal()
};
SpineController.prototype.Resume = function() {
    if (this.trackEntry == null) {
        this.actions.push(SpineControllerCATAction.Resume);
        return
    }
    this.SampleTime(this.trackTime);
    this.trackEntry.timeScale = this.speed * this.direction;
    this.isPlaying = true
};
SpineController.prototype.SampleTime = function(time) {
    if (this.trackEntry == null) {
        this.sampleTime = time;
        this.sampleTimeIsNormalized = false;
        this.actions.push(SpineControllerCATAction.Sample);
        return
    }
    this.SetupAnimation();
    this.trackTime = time;
    this.trackEntry.trackTime = time;
    this.trackEntry.timeScale = 0;
    this.needUpdateSpine = true;
    if (this.frameOfLastUpdate == Time.frameCount) this.UpdateSpine()
};
SpineController.prototype.Sample = function(normalizedTime) {
    if (this.trackEntry == null) {
        this.sampleTime = normalizedTime;
        this.sampleTimeIsNormalized = true;
        this.actions.push(SpineControllerCATAction.Sample);
        return
    }
    this.SampleTime(normalizedTime * this.duration)
};
SpineController.prototype.IsPlaying = function() {
    return this.isPlaying
};
SpineController.prototype.OnWillRenderObject = function() {
    if (!this.isUpdated) {
        this.Update();
        if (!this.isUpdated) return
    }
    this.pixiObject.dirtyWT = true;
    var child = this.spine;
    child.tint = this.color.rgbAsHex;
    if (this.panel != null) child.alpha = this.color.a * this.panel.alpha;
    else child.alpha = this.color.a;
    child.worldAlpha = child.alpha;
    var hc = this.gameObject.transform;
    if (!hc.IsDirtyUserFlag(Transform._DirtyFlagSpine)) return;
    hc._internal_get_position();
    hc._internal_get_rotation();
    hc._internal_get_scale();
    hc.ClearDirtyUserFlag(Transform._DirtyFlagSpine);
    var parent = this.pixiObject;
    var hp = hc.parent.transform;
    var v3 = hp._dangerous_get_position();
    parent.x = v3.x;
    parent.y = -v3.y;
    v3 = hc._dangerous_get_localPosition();
    child.x = v3.x;
    child.y = -v3.y;
    parent.rotation = -hp._dangerous_get_rotation().eulerAnglesRad().z;
    child.rotation = -hc._dangerous_get_localRotation().eulerAnglesRad().z;
    v3 = hp._dangerous_get_scale();
    parent.scale.x = v3.x;
    parent.scale.y = v3.y;
    v3 = hc._dangerous_get_localScale();
    child.scale.x = v3.x * this.spineData.scale;
    child.scale.y = v3.y * this.spineData.scale
};
SpineController.prototype.SetToSetupPose = function() {
    if (this.spine != null && this.spine.skeleton != null) this.spine.skeleton.setToSetupPose()
};
SpineController.prototype.SetDirection = function(param) {
    this.direction = param < 0 ? -1 : 1
};
goog.require("UHT.Engine");
SpineCustomAnimator.prototype = Object.create(Component.prototype);
SpineCustomAnimator.prototype.constructor = SpineCustomAnimator;

function SpineCustomAnimator() {
    Component.call(this);
    this.spineController = null;
    this.animationName = "";
    this.animationTime = 1;
    this.playAutomatically = false;
    this.playReverse = false;
    this.useTimeChannel = false;
    this.timeChannelID = 0;
    this.StopOnDisable = true;
    this.noPauseAtPingPongEnd = false;
    this.playMode = SpineCustomAnimator.PlayMode.Default;
    this.animationCurve = null;
    this.loopDelay = 0;
    this.timeScale = 1;
    this.firstCurveKey = null;
    this.lastCurveKey = null;
    this.totalCurveTime = 0;
    this.currentTime = 0;
    this.direction = 1;
    this.playing =
        false;
    this.reset = false;
    this.myTimeChannel = null;
    this.elapsedDelay = 0
}
SpineCustomAnimator.PlayMode = {
    Default: 0,
    Loop: 1,
    PingPong: 2,
    DefaultThenFirstFrame: 3
};
SpineCustomAnimator.prototype.Play = function() {
    this.playing = true
};
SpineCustomAnimator.prototype.Pause = function() {
    this.playing = false
};
SpineCustomAnimator.prototype.Stop = function() {
    this.playing = false;
    this.direction = this.playReverse ? -1 : 1;
    this.currentTime = this.playReverse ? this.animationTime - 1E-5 : 0
};
SpineCustomAnimator.prototype.Reset = function() {
    this.reset = true;
    this.Stop();
    this.Update()
};
SpineCustomAnimator.prototype.OnEnable = function() {
    if (this.playAutomatically) this.playing = true;
    if (this.useTimeChannel) {
        this.myTimeChannel = Globals.RegisterToTimeChannel(this, this.timeChannelID);
        if (!this.myTimeChannel.IsChannelMaster(this)) {
            this.currentTime = this.myTimeChannel.currentTime;
            this.Update()
        }
    }
};
SpineCustomAnimator.prototype.OnDisable = function() {
    if (this.StopOnDisable) this.Reset();
    if (this.useTimeChannel) Globals.UnregisterFromTimeChannel(this, this.timeChannelID)
};
SpineCustomAnimator.prototype.Awake = function() {
    this.direction = this.playReverse ? -1 : 1;
    this.currentTime = this.playReverse ? this.animationTime - 1E-5 : 0;
    this.firstCurveKey = this.animationCurve.keys[0];
    this.lastCurveKey = this.animationCurve.keys[this.animationCurve.keys.length - 1];
    this.totalCurveTime = this.lastCurveKey.time
};
SpineCustomAnimator.prototype.Update = function() {
    if (!_string.IsNullOrEmpty(this.animationName) && (this.playing || this.reset)) {
        if (this.reset) this.reset = false;
        else this.ComputeTime();
        var progress = this.currentTime / this.animationTime;
        if (this.animationCurve.keys.length >= 2) {
            var curCurveTime = progress * this.totalCurveTime;
            progress = this.animationCurve.Evaluate(curCurveTime);
            progress = UHTMath.clamp(progress, 0, 1)
        }
        this.spineController.Sample(progress)
    }
};
SpineCustomAnimator.prototype.Sample = function(normalizedTime) {
    this.spineController.Sample(normalizedTime)
};
SpineCustomAnimator.prototype.ChangeAnimation = function(animationName) {
    this.animationName = animationName;
    this.spineController.animationName = animationName;
    this.Reset();
    this.Play()
};
SpineCustomAnimator.prototype.ComputeTime = function() {
    if (this.direction > 0)
        if (this.currentTime >= this.animationTime) switch (this.playMode) {
            case SpriteFramesAnimator.PlayMode.Loop:
                if (this.elapsedDelay >= this.loopDelay) {
                    this.elapsedDelay = 0;
                    this.currentTime -= this.animationTime
                } else this.elapsedDelay += Time.deltaTime * this.timeScale;
                break;
            case SpriteFramesAnimator.PlayMode.DefaultThenFirstFrame:
                this.Stop();
                break;
            case SpriteFramesAnimator.PlayMode.PingPong:
                this.direction = -1;
                if (this.noPauseAtPingPongEnd) this.currentTime -=
                    this.animationTime + Time.deltaTime;
                break;
            default:
                this.Stop();
                this.currentTime = this.animationTime;
                break
        } else if (this.useTimeChannel)
            if (this.myTimeChannel.IsChannelMaster(this)) {
                this.currentTime += Time.deltaTime * this.timeScale;
                this.myTimeChannel.currentTime = this.currentTime
            } else this.currentTime = this.myTimeChannel.currentTime;
    else this.currentTime += Time.deltaTime * this.timeScale;
    if (this.direction < 0)
        if (this.currentTime <= 0) switch (this.playMode) {
            case SpriteFramesAnimator.PlayMode.Loop:
                if (this.elapsedDelay >=
                    this.loopDelay) {
                    this.elapsedDelay = 0;
                    this.currentTime += this.animationTime
                } else this.elapsedDelay += Time.deltaTime * this.timeScale;
                break;
            case SpriteFramesAnimator.PlayMode.PingPong:
                this.direction = 1;
                break;
            case SpriteFramesAnimator.PlayMode.DefaultThenFirstFrame:
                this.Stop();
                break;
            default:
                this.Stop();
                this.currentTime = 0;
                break
        } else if (this.useTimeChannel)
            if (this.myTimeChannel.IsChannelMaster(this)) {
                this.currentTime -= Time.deltaTime * this.timeScale;
                this.myTimeChannel.currentTime = this.currentTime
            } else this.currentTime =
                this.myTimeChannel.currentTime;
    else this.currentTime -= Time.deltaTime * this.timeScale
};
goog.require("UHT.Engine");
SpriteFramesAnimator.prototype = Object.create(Component.prototype);
SpriteFramesAnimator.prototype.constructor = SpriteFramesAnimator;

function SpriteFramesAnimator() {
    Component.call(this);
    this.animationTime = 1;
    this.spriteNamePrefix = "";
    this.playAutomatically = false;
    this.playReverse = false;
    this.useTimeChannel = false;
    this.timeChannelID = 0;
    this.StopOnDisable = true;
    this.SameFrameSize = false;
    this.noPauseAtPingPongEnd = false;
    this.playMode = SpriteFramesAnimator.PlayMode.Default;
    this.animationCurve = null;
    this.animationAtlases = null;
    this.loopDelay = 0;
    this.timeScale = 1;
    this.mSprite = null;
    this.firstCurveKey = null;
    this.lastCurveKey = null;
    this.totalCurveTime =
        0;
    this.currentTime = 0;
    this.direction = 1;
    this.playing = false;
    this.reset = false;
    this.mSpriteNames = null;
    this.myTimeChannel = null;
    this.elapsedDelay = 0
}

function SpriteNameAtlasPair(spriteName, sourceAtlas) {
    this.name = spriteName;
    this.atlas = sourceAtlas
}
SpriteFramesAnimator.PlayMode = {
    Default: 0,
    Loop: 1,
    PingPong: 2,
    DefaultThenFirstFrame: 3
};
SpriteFramesAnimator.prototype.Play = function() {
    this.playing = true
};
SpriteFramesAnimator.prototype.Pause = function() {
    this.playing = false
};
SpriteFramesAnimator.prototype.Stop = function() {
    this.playing = false;
    this.direction = this.playReverse ? -1 : 1;
    this.currentTime = this.playReverse ? this.animationTime - 1E-5 : 0
};
SpriteFramesAnimator.prototype.SetTimeScale = function(ts) {
    this.timeScale = _number.otod(ts)
};
SpriteFramesAnimator.prototype.Reset = function() {
    this.reset = true;
    this.Stop();
    this.Update()
};
SpriteFramesAnimator.prototype.OnEnable = function() {
    if (this.playAutomatically) this.playing = true;
    if (this.useTimeChannel) {
        this.myTimeChannel = Globals.RegisterToTimeChannel(this, this.timeChannelID);
        if (!this.myTimeChannel.IsChannelMaster(this)) {
            this.currentTime = this.myTimeChannel.currentTime;
            this.Update()
        }
    }
};
SpriteFramesAnimator.prototype.OnDisable = function() {
    if (this.StopOnDisable) this.Reset();
    if (this.useTimeChannel) Globals.UnregisterFromTimeChannel(this, this.timeChannelID)
};
SpriteFramesAnimator.prototype.Awake = function() {
    this.direction = this.playReverse ? -1 : 1;
    this.currentTime = this.playReverse ? this.animationTime - 1E-5 : 0;
    this.firstCurveKey = this.animationCurve.keys[0];
    this.lastCurveKey = this.animationCurve.keys[this.animationCurve.keys.length - 1];
    this.totalCurveTime = this.lastCurveKey.time - this.firstCurveKey.time;
    this.RebuildSpriteList()
};
SpriteFramesAnimator.prototype.Update = function() {
    if (this.AllAtlasesAreDownloaded() && (this.playing || this.reset) && this.mSpriteNames != null && this.mSpriteNames.length > 1) {
        if (this.reset) this.reset = false;
        else this.ComputeTime();
        var progress = this.currentTime / this.animationTime;
        if (this.animationCurve.keys.length >= 2) {
            var curCurveTime = progress * this.totalCurveTime;
            progress = this.animationCurve.Evaluate(curCurveTime);
            progress = UHTMath.clamp(progress, 0, 1)
        }
        this.InternalSample(progress)
    }
};
SpriteFramesAnimator.prototype.InternalSample = function(normalizedTime) {
    var currentSpriteFrame = UHTMath.clamp(Math.floor(normalizedTime * this.mSpriteNames.length), 0, this.mSpriteNames.length - 1);
    this.ChangeAtlas(currentSpriteFrame);
    if (this.SameFrameSize) this.mSprite.SetSpriteNameForAnimation(this.mSpriteNames[currentSpriteFrame].name);
    else this.mSprite.SetSpriteName(this.mSpriteNames[currentSpriteFrame].name)
};
SpriteFramesAnimator.prototype.Sample = function(normalizedTime) {
    if (this.AllAtlasesAreDownloaded() && this.mSpriteNames != null && this.mSpriteNames.length > 1) this.InternalSample(normalizedTime)
};
SpriteFramesAnimator.prototype.AllAtlasesAreDownloaded = function() {
    for (var i = 0; i < this.animationAtlases.length; i++)
        if (!this.animationAtlases[i].isLoaded()) return false;
    return true
};
SpriteFramesAnimator.prototype.ComputeTime = function() {
    if (this.direction > 0)
        if (this.currentTime >= this.animationTime) switch (this.playMode) {
            case SpriteFramesAnimator.PlayMode.Loop:
                if (this.elapsedDelay >= this.loopDelay) {
                    this.elapsedDelay = 0;
                    this.currentTime -= this.animationTime
                } else this.elapsedDelay += Time.deltaTime * this.timeScale;
                break;
            case SpriteFramesAnimator.PlayMode.DefaultThenFirstFrame:
                this.Stop();
                break;
            case SpriteFramesAnimator.PlayMode.PingPong:
                this.direction = -1;
                if (this.noPauseAtPingPongEnd) this.currentTime -=
                    this.animationTime / this.mSpriteNames.length + Time.deltaTime;
                break;
            default:
                this.Stop();
                this.currentTime = this.animationTime;
                break
        } else if (this.useTimeChannel)
            if (this.myTimeChannel.IsChannelMaster(this)) {
                this.currentTime += Time.deltaTime * this.timeScale;
                this.myTimeChannel.currentTime = this.currentTime
            } else this.currentTime = this.myTimeChannel.currentTime;
    else this.currentTime += Time.deltaTime * this.timeScale;
    if (this.direction < 0)
        if (this.currentTime <= 0) switch (this.playMode) {
            case SpriteFramesAnimator.PlayMode.Loop:
                if (this.elapsedDelay >=
                    this.loopDelay) {
                    this.elapsedDelay = 0;
                    this.currentTime += this.animationTime
                } else this.elapsedDelay += Time.deltaTime * this.timeScale;
                break;
            case SpriteFramesAnimator.PlayMode.PingPong:
                this.direction = 1;
                break;
            case SpriteFramesAnimator.PlayMode.DefaultThenFirstFrame:
                this.Stop();
                break;
            default:
                this.Stop();
                this.currentTime = 0;
                break
        } else if (this.useTimeChannel)
            if (this.myTimeChannel.IsChannelMaster(this)) {
                this.currentTime -= Time.deltaTime * this.timeScale;
                this.myTimeChannel.currentTime = this.currentTime
            } else this.currentTime =
                this.myTimeChannel.currentTime;
    else this.currentTime -= Time.deltaTime * this.timeScale
};
SpriteFramesAnimator.prototype.RebuildSpriteList = function() {
    if (this.mSprite == null) this.mSprite = this.gameObject.GetComponent(UISprite);
    this.mSpriteNames = [];
    var tempAtlasList = [];
    if (this.animationAtlases.length == 0) tempAtlasList.push(this.mSprite.atlas);
    else tempAtlasList = this.animationAtlases.slice(0);
    for (var index = 0; index < tempAtlasList.length; index++)
        if (this.mSprite != null && tempAtlasList[index] != null) {
            var sprites = tempAtlasList[index].getSpriteNames();
            var imax = sprites.length;
            for (var i = 0; i < imax; ++i)
                if (_string.IsNullOrEmpty(this.spriteNamePrefix) ||
                    sprites[i].indexOf(this.spriteNamePrefix) == 0) {
                    var snap = new SpriteNameAtlasPair(sprites[i], tempAtlasList[index]);
                    this.mSpriteNames.push(snap)
                }
        }
    this.mSpriteNames.sort(function(a, b) {
        return a.name == b.name ? 0 : a.name > b.name ? 1 : -1
    })
};
SpriteFramesAnimator.prototype.ChangeAtlas = function(currentFrame) {
    if (this.mSprite.atlas != this.mSpriteNames[currentFrame].atlas) this.mSprite.atlas = this.mSpriteNames[currentFrame].atlas
};
goog.require("UHT.Engine");
SpriteSizeAnimator.prototype = Object.create(Component.prototype);
SpriteSizeAnimator.prototype.constructor = SpriteSizeAnimator;

function SpriteSizeAnimator() {
    Component.call(this);
    this.targetSprite = null;
    this.animationTime = 1;
    this.startSize = null;
    this.endSize = null;
    this.playAutomatically = false;
    this.resetOnDisable = false;
    this.playMode = SpriteFramesAnimator.PlayMode.Default;
    this.animationCurve = null;
    this.affectsWidth = true;
    this.affectsHeight = true;
    this.targetCollider = null;
    this.extraSize = false;
    this.playing = false;
    this.mustStop = false;
    this.currentTime = 0;
    this.totalCurveTime = 1;
    this.direction = 1
}
SpriteSizeAnimator.prototype.Play = function() {
    this.playing = true
};
SpriteSizeAnimator.prototype.Pause = function() {
    this.playing = false
};
SpriteSizeAnimator.prototype.Stop = function() {
    this.playing = false;
    this.mustStop = false;
    this.direction = 1;
    this.currentTime = 0
};
SpriteSizeAnimator.prototype.Reset = function() {
    this.Stop();
    this.playing = true;
    this.Update()
};
SpriteSizeAnimator.prototype.Awake = function() {
    this.currentTime = 0;
    var firstCurveKey = this.animationCurve.keys[0];
    var lastCurveKey = this.animationCurve.keys[this.animationCurve.keys.length - 1];
    this.totalCurveTime = lastCurveKey.time - firstCurveKey.time
};
SpriteSizeAnimator.prototype.OnEnable = function() {
    if (this.playAutomatically) this.playing = true
};
SpriteSizeAnimator.prototype.OnDisable = function() {
    if (this.resetOnDisable) this.Reset()
};
SpriteSizeAnimator.prototype.Update = function() {
    if (this.playing) {
        this.ComputeTime();
        var progress = this.currentTime / this.animationTime;
        if (this.animationCurve.keys.length >= 2) {
            var curCurveTime = progress * this.totalCurveTime;
            progress = this.animationCurve.Evaluate(curCurveTime);
            progress = UHTMath.clamp(progress, 0, 1)
        }
        var currentSpriteSize = UHTMath.Vector3.lerp(this.startSize, this.endSize, progress);
        this.targetSprite.width = Math.ceil(currentSpriteSize.x);
        this.targetSprite.height = Math.ceil(currentSpriteSize.y);
        if (this.mustStop) this.Stop()
    }
};
SpriteSizeAnimator.prototype.ComputeTime = function() {
    if (this.direction > 0)
        if (this.currentTime >= this.animationTime) switch (this.playMode) {
            case SpriteFramesAnimator.PlayMode.Default:
                this.currentTime = this.animationTime;
                this.mustStop = true;
                break;
            case SpriteFramesAnimator.PlayMode.DefaultThenFirstFrame:
                this.currentTime = 0;
                this.mustStop = true;
                break;
            case SpriteFramesAnimator.PlayMode.Loop:
                this.currentTime -= this.animationTime;
                break;
            case SpriteFramesAnimator.PlayMode.PingPong:
                this.direction = -1;
                break
        } else this.currentTime +=
            Time.deltaTime;
        else if (this.currentTime <= 0) switch (this.playMode) {
        case SpriteFramesAnimator.PlayMode.Default:
            this.currentTime = 0;
            this.mustStop = true;
            break;
        case SpriteFramesAnimator.PlayMode.DefaultThenFirstFrame:
            this.currentTime = 0;
            this.mustStop = true;
            break;
        case SpriteFramesAnimator.PlayMode.Loop:
            this.currentTime += this.animationTime;
            break;
        case SpriteFramesAnimator.PlayMode.PingPong:
            this.direction = 1;
            break
    } else this.currentTime -= Time.deltaTime
};
SpriteSizeAnimator.prototype.Sample = function(normalizedTime) {
    normalizedTime = Number(normalizedTime);
    var curCurveTime = normalizedTime * this.totalCurveTime;
    normalizedTime = this.animationCurve.Evaluate(curCurveTime);
    normalizedTime = UHTMath.clamp(normalizedTime, 0, 1);
    var currentSpriteSize = UHTMath.Vector3.lerp(this.startSize, this.endSize, normalizedTime);
    if (this.affectsWidth) {
        if (this.targetSprite != null) this.targetSprite.width = Math.ceil(currentSpriteSize.x + (this.extraSize ? this.targetSprite.width : 0));
        if (this.targetCollider !=
            null) this.targetCollider.size = new UHTMath.Vector3(currentSpriteSize.x + (this.extraSize ? this.targetCollider.size.x : 0), this.targetCollider.size.y, this.targetCollider.size.z)
    }
    if (this.affectsHeight) {
        if (this.targetSprite != null) this.targetSprite.height = Math.ceil(currentSpriteSize.y + (this.extraSize ? this.targetSprite.height : 0));
        if (this.targetCollider != null) this.targetCollider.size = new UHTMath.Vector3(this.targetCollider.size.x, currentSpriteSize.y + (this.extraSize ? this.targetCollider.size.y : 0), this.targetCollider.size.z)
    }
};
goog.provide("UHT.FloatAnimatedMonoBehaviour");
goog.require("UHT.Engine");
CurveValueAnimator.prototype = Object.create(Component.prototype);
CurveValueAnimator.prototype.constructor = CurveValueAnimator;
FloatAnimatedMonoBehaviour.prototype = Object.create(Component.prototype);
FloatAnimatedMonoBehaviour.prototype.constructor = FloatAnimatedMonoBehaviour;

function CurveValueAnimator() {
    Component.call(this);
    this.descriptiom = "";
    this.animatedMemberTargets = [];
    this.curve = null;
    this.Loop = true;
    this.isStarted = false;
    this.startTime = 0;
    this.lastKeyTime = 0
}

function FloatAnimatedMonoBehaviour() {
    Component.call(this);
    this.AnimatedF = 0
}
FloatAnimatedMonoBehaviour.prototype.ResetF = function() {};
CurveValueAnimator.prototype.Awake = function() {
    this.lastKeyTime = this.curve.keys[this.curve.keys.length - 1].time
};
CurveValueAnimator.prototype.StartCurveAnimation = function() {
    this.isStarted = true;
    this.startTime = Time.time
};
CurveValueAnimator.prototype.StopCurveAnimation = function() {
    this.isStarted = false;
    for (var i = 0; i < this.animatedMemberTargets.length; i++) this.animatedMemberTargets[i].ResetF()
};
CurveValueAnimator.prototype.Update = function() {
    var current_time = Time.time;
    if (!this.isStarted) return;
    for (var i = 0; i < this.animatedMemberTargets.length; i++) this.animatedMemberTargets[i].AnimatedF = this.curve.Evaluate(this.Loop ? (current_time - this.startTime) % this.lastKeyTime : UHTMath.clamp(current_time - this.startTime, 0, this.lastKeyTime));
    if (!this.Loop)
        if (current_time - this.startTime > this.lastKeyTime) this.isStarted = false
};
goog.require("UHT.Engine");
goog.require("UHT.FloatAnimatedMonoBehaviour");
AlphaAnimatedSprite.prototype = Object.create(FloatAnimatedMonoBehaviour.prototype);
AlphaAnimatedSprite.prototype.constructor = AlphaAnimatedSprite;

function AlphaAnimatedSprite() {
    FloatAnimatedMonoBehaviour.call(this);
    this.resetValue = .75;
    this.oldAlpha = -1;
    this.mySprite = null
}
AlphaAnimatedSprite.prototype.ResetF = function() {
    this.AnimatedF = this.resetValue;
    this.oldAlpha = this.resetValue;
    this.mySprite.color.a = UHTMath.clamp(this.resetValue, 0, 1)
};
AlphaAnimatedSprite.prototype.Awake = function() {
    this.mySprite = this.gameObject.GetComponent(UISprite)
};
AlphaAnimatedSprite.prototype.Update = function() {
    if (this.AnimatedF != this.oldAlpha) {
        this.mySprite.color.a = UHTMath.clamp(this.AnimatedF, 0, 1);
        this.oldAlpha = this.AnimatedF
    }
};
AlphaAnimatedSprite.prototype.CAT_GoToCustomValue = function(val) {
    this.AnimatedF = _number.otod(val);
    this.oldAlpha = this.AnimatedF;
    this.mySprite.color.a = UHTMath.clamp(this.AnimatedF, 0, 1)
};
goog.require("UHT.Globals");
goog.require("UHT.MessageSender");
CustomDragObject.prototype = Object.create(Component.prototype);
CustomDragObject.prototype.constructor = CustomDragObject;

function CustomDragObject() {
    Component.call(this);
    this.target = null;
    this.movement = null;
    this.messageDragStarts = null;
    this.messageDragEnds = null;
    this.swipeOverridesDrag = false;
    this.swipeMaxTime = .3;
    this.swipeMinDistance = .05;
    this.messageSwipeUp = null;
    this.messageSwipeDown = null;
    this.messageSwipeLeft = null;
    this.messageSwipeRight = null;
    this.swipeStartTime = 0;
    this.cachedCamera = null;
    this.lastMousePosition = null;
    this.mouseTotalDelta = null;
    this.isPressed = false;
    this.isStarted = false;
    this.isHover = false;
    this.limitPosition =
        false;
    this.localPositionLimitMin = null;
    this.localPositionLimitMax = null;
    this.useScrollWheel = false;
    this.scrollWheelMovement = null;
    this.wheelDirection = 0;
    this.useOnlyScrollWheel = false
}
CustomDragObject.prototype.scriptUpdatePriority = 7;

function registerCustomDragObjectAsListener(a, b, c) {
    window.addEventListener(a, b, c)
}
CustomDragObject.prototype.Awake = function() {
    var self = this;
    var mwl = function(e) {
        return self.OnMouseWheel(e)
    };
    registerCustomDragObjectAsListener("mousewheel", mwl, {
        passive: false
    });
    registerCustomDragObjectAsListener("DOMMouseScroll", mwl, {
        passive: false
    })
};
CustomDragObject.prototype.OnMouseWheel = function(e) {
    e.preventDefault();
    if (!this.gameObject.activeInHierarchy || !this.isHover || Globals.InputBlocked && !(this.cachedCamera != null && this.cachedCamera.ignoreInputBlocked)) return;
    this.wheelDirection = e.wheelDelta ? -e.wheelDelta : e.detail;
    this.wheelDirection = UHTMath.clamp(this.wheelDirection, -1, 1)
};
CustomDragObject.prototype.OnEnable = function() {
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.target.gameObject);
    this.isPressed = false;
    this.isStarted = false
};
CustomDragObject.prototype.OnPress = function(pressed) {
    this.isPressed = pressed;
    if (pressed) {
        this.lastMousePosition = Input.mousePosition;
        this.mouseTotalDelta = new UHTMath.Vector3(0, 0, 0);
        this.isStarted = false
    } else if (this.isStarted) {
        this.isStarted = false;
        var isSwipe = false;
        if (Time.time - this.swipeStartTime <= this.swipeMaxTime) {
            if (this.mouseTotalDelta.x > this.swipeMinDistance * UHTScreen.height) {
                MessageSender.SendMessage(this.messageSwipeRight);
                isSwipe = true
            } else if (this.mouseTotalDelta.x < -this.swipeMinDistance * UHTScreen.height) {
                MessageSender.SendMessage(this.messageSwipeLeft);
                isSwipe = true
            }
            if (this.mouseTotalDelta.y > this.swipeMinDistance * UHTScreen.height) {
                MessageSender.SendMessage(this.messageSwipeDown);
                isSwipe = true
            } else if (this.mouseTotalDelta.y < -this.swipeMinDistance * UHTScreen.height) {
                MessageSender.SendMessage(this.messageSwipeUp);
                isSwipe = true
            }
        }
        if (!this.swipeOverridesDrag || !isSwipe) MessageSender.SendMessage(this.messageDragEnds)
    }
};
CustomDragObject.prototype.Update = function() {
    if (!this.isPressed) {
        if (this.isHover)
            if (this.wheelDirection != 0) {
                this.ScrollWheel(this.wheelDirection);
                this.wheelDirection = 0
            }
        return
    }
    if (this.useOnlyScrollWheel) return;
    var mouseDeltaPos = UHTMath.Vector3.sub(Input.mousePosition, this.lastMousePosition);
    this.mouseTotalDelta.add(mouseDeltaPos);
    this.lastMousePosition = Input.mousePosition;
    if (!this.isStarted)
        if (this.mouseTotalDelta.sqrMagnitude() > 20) {
            this.isStarted = true;
            this.swipeStartTime = Time.time;
            MessageSender.SendMessage(this.messageDragStarts)
        }
    if (this.isStarted) {
        if (this.cachedCamera ==
            null) this.cachedCamera = Globals.GetCameraForObject(this.target.gameObject);
        var targetDeltaPos = UHTMath.Vector3.sub(this.cachedCamera.ScreenToWorldPoint(this.lastMousePosition), this.cachedCamera.ScreenToWorldPoint(UHTMath.Vector3.add(this.lastMousePosition, mouseDeltaPos)));
        targetDeltaPos.x *= this.movement.x;
        targetDeltaPos.y *= this.movement.y;
        targetDeltaPos.z *= this.movement.z;
        this.target.position(this.GetPosition(UHTMath.Vector3.sub(this.target.position(), targetDeltaPos)))
    }
};
CustomDragObject.prototype.OnHover = function(hover) {
    this.isHover = hover
};
CustomDragObject.prototype.ScrollWheel = function(direction) {
    if (this.useScrollWheel) this.target.position(this.GetPosition(UHTMath.Vector3.add(this.target.position(), UHTMath.Vector3.scale(this.scrollWheelMovement, direction))))
};
CustomDragObject.prototype.GetPosition = function(pos) {
    if (this.limitPosition) {
        var posMin = this.target.parent.transformPoint(this.localPositionLimitMin);
        var posMax = this.target.parent.transformPoint(this.localPositionLimitMax);
        var x = UHTMath.clamp(pos.x, posMin.x, posMax.x);
        var y = UHTMath.clamp(pos.y, posMin.y, posMax.y);
        var z = UHTMath.clamp(pos.z, posMin.z, posMax.z);
        return new UHTMath.Vector3(x, y, z)
    }
    return pos
};
goog.require("UHT.Engine");
goog.require("UHT.TwoFloatsAnimatedMonoBehaviour");
ElementsFader.prototype = Object.create(TwoFloatsAnimatedMonoBehaviour.prototype);
ElementsFader.prototype.constructor = ElementsFader;

function ElementsFader() {
    TwoFloatsAnimatedMonoBehaviour.call(this);
    this.labelsToFade = [];
    this.spritesToFade = [];
    this.resetValue_1 = 1;
    this.resetValue_2 = 1;
    this.alphaValue = -1;
    this.oldAlpha = -1
}
ElementsFader.prototype.SetAnimatedF_1 = function(val) {
    this.alphaValue = val;
    this.Update()
};
ElementsFader.prototype.SetAnimatedF_2 = function(val) {
    this.alphaValue = val;
    this.Update()
};
ElementsFader.prototype.ResetF_1 = function() {
    this.alphaValue = this.resetValue_1;
    this.Update()
};
ElementsFader.prototype.ResetF_2 = function() {
    this.alphaValue = this.resetValue_2;
    this.Update()
};
ElementsFader.prototype.Update = function() {
    if (this.oldAlpha != this.alphaValue) {
        this.alphaValue = UHTMath.clamp(this.alphaValue, 0, 1);
        for (var i = 0; i < this.labelsToFade.length; i++) {
            if (this.alphaValue < .05) {
                this.labelsToFade[i].enabled = false;
                continue
            }
            if (!this.labelsToFade[i].enabled) this.labelsToFade[i].enabled = true;
            var col = this.labelsToFade[i].GetColor();
            col.a = this.alphaValue;
            this.labelsToFade[i].SetColor(col)
        }
        for (var j = 0; j < this.spritesToFade.length; j++) {
            if (this.alphaValue < .05) {
                this.spritesToFade[j].enabled =
                    false;
                continue
            }
            if (!this.spritesToFade[j].enabled) this.spritesToFade[j].enabled = true;
            this.spritesToFade[j].color.a = this.alphaValue
        }
        this.oldAlpha = this.alphaValue
    }
};
goog.require("UHT.XTLink");
GameWindow.prototype = Object.create(XTLink.prototype);
GameWindow.prototype.constructor = GameWindow;

function GameWindow() {
    XTLink.call(this);
    this.isEnabled = true;
    this.showOnEvents = [];
    this.hideOnEvents = [];
    this.triggerAfterShow = [];
    this.triggerAfterHide = [];
    this.cat = null;
    this.showEventId = null;
    this.hideEventId = null;
    this.waitForBigWin = false;
    this.waitForWinCount = false;
    this.showAfterWinCount = false;
    this.showAfterBigWinClear = false
}
GameWindow.prototype.XTRegisterCallbacks = function() {
    if (!this.isEnabled) return;
    for (var i = 0; i < this.showOnEvents.length; i++) XT.RegisterCallbackEvent(this.showOnEvents[i].name, this.OnShowWindow, this);
    for (var j = 0; j < this.hideOnEvents.length; j++) XT.RegisterCallbackEvent(this.hideOnEvents[j].name, this.OnHideWindow, this);
    XT.RegisterCallbackBool(Vars.LastWinIsCounting, this.OnLastWinIsCountingChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_BigWinHasFinished, this.OnBigWinHasFinished, this)
};
GameWindow.prototype.OnDestroy = function() {
    if (!this.isEnabled) return;
    XT.UnregisterCallbackEvent(this.OnShowWindow, this);
    XT.UnregisterCallbackEvent(this.OnHideWindow, this);
    XT.UnregisterCallbackBool(this.OnLastWinIsCountingChanged, this)
};
GameWindow.prototype.OnCloseButtonPressed = function() {
    if (!this.isEnabled) return;
    this.OnHideWindow()
};
GameWindow.prototype.OnShowWindow = function() {
    if (!this.isEnabled) return;
    if (this.waitForBigWin && XT.GetBool(Vars.WaitInResultForBigWin)) this.showAfterBigWinClear = true;
    else if (this.waitForWinCount && XT.GetBool(Vars.LastWinIsCounting)) this.showAfterWinCount = true;
    else this.ShowWindow()
};
GameWindow.prototype.OnHideWindow = function() {
    if (this.cat != null && this.hideEventId.cat != null) {
        if (this.showEventId != null && this.showEventId.IsRunning()) this.showEventId.Stop();
        this.cat.RegisterCallback(this.hideEventId.id, this.HideEventFinished, this);
        this.cat.StartEvent(this.hideEventId.id)
    } else {
        this.gameObject.SetActive(false);
        for (var i = 0; i < this.triggerAfterHide.length; i++) XT.TriggerEvent(this.triggerAfterHide[i].name)
    }
};
GameWindow.prototype.ShowEventFinished = function(type, data) {
    if (type == CAT_Event.CallbackType.EndOfEvent) {
        for (var i = 0; i < this.triggerAfterShow.length; i++) XT.TriggerEvent(this.triggerAfterShow[i].name);
        if (this.cat != null) this.cat.UnregisterCallback(this.showEventId.id, this.ShowEventFinished, this)
    }
};
GameWindow.prototype.HideEventFinished = function(type, data) {
    if (type == CAT_Event.CallbackType.EndOfEvent) {
        this.gameObject.SetActive(false);
        for (var i = 0; i < this.triggerAfterHide.length; i++) XT.TriggerEvent(this.triggerAfterHide[i].name);
        if (this.cat != null) this.cat.UnregisterCallback(this.hideEventId.id, this.HideEventFinished, this)
    }
};
GameWindow.prototype.OnLastWinIsCountingChanged = function(value) {
    if (!this.isEnabled) return;
    if (this.showAfterWinCount && !value) {
        this.ShowWindow();
        this.showAfterWinCount = false
    }
};
GameWindow.prototype.OnBigWinHasFinished = function() {
    if (!this.isEnabled) return;
    if (this.showAfterBigWinClear) {
        this.ShowWindow();
        this.showAfterBigWinClear = false
    }
};
GameWindow.prototype.ShowWindow = function() {
    if (!this.isEnabled) return;
    this.gameObject.SetActive(true);
    if (this.cat != null && this.showEventId.cat != null) {
        this.cat.RegisterCallback(this.showEventId.id, this.ShowEventFinished, this);
        this.cat.StartEvent(this.showEventId.id)
    }
};
goog.require("UHT.Engine");
var FSWindow_WinAmount = {
    FSWindow_TotalWinDisplayed: "FSWindow_TotalWinDisplayed"
};
GameWindow_FSWindow.prototype = Object.create(GameWindow.prototype);
GameWindow_FSWindow.prototype.constructor = GameWindow_FSWindow;

function GameWindow_FSWindow() {
    GameWindow.call(this);
    this.variable = null
}
GameWindow_FSWindow.prototype.OnShowWindow = function() {
    var tempValue = XT.GetDouble(this.variable.name);
    XT.SetDouble(FSWindow_WinAmount.FSWindow_TotalWinDisplayed, 0);
    XT.SetDouble(FSWindow_WinAmount.FSWindow_TotalWinDisplayed, tempValue);
    GameWindow.prototype.OnShowWindow.call(this)
};
goog.require("UHT.XTLink");
JurisdictionCustomization.prototype = Object.create(XTLink.prototype);
JurisdictionCustomization.prototype.constructor = JurisdictionCustomization;

function JurisdictionCustomization() {
    XTLink.call(this);
    this.jurisdiction = "";
    this.jurisdictionRequirement = null;
    this.jurisdictionCustomization = null;
    this.jurisdictionCustomizationF = null
}
JurisdictionCustomization.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this)
};
JurisdictionCustomization.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGUIInit, this)
};
JurisdictionCustomization.prototype.OnGUIInit = function() {
    var varValue = false;
    var varName = this.jurisdictionRequirement.name;
    if (varName != null && varName != "" && varName != "*None*") varValue = XT.GetBool(varName);
    if (ServerOptions.jurisdiction == this.jurisdiction || varValue) this.jurisdictionCustomization.Start();
    else this.jurisdictionCustomizationF.Start()
};
goog.require("UHT.Engine");
MoveSource.prototype = Object.create(XTLink.prototype);
MoveSource.prototype.constructor = MoveSource;

function MoveSource() {
    XTLink.call(this);
    this.targetID = MoveTargetID.Invalid
}
MoveSource.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(InterfaceVars.Interface_UpdateMoveSourceComponents, this.UpdatePosition, this)
};
MoveSource.prototype.Awake = function() {
    XTLink.prototype.Awake.call(this);
    this.UpdatePosition()
};
MoveSource.prototype.UpdatePosition = function() {
    var roots = globalRuntime.sceneRoots;
    for (var i = 0; i < roots.length; ++i) {
        var targets = roots[i].GetComponentsInChildren(MoveTarget, true);
        for (var j = 0; j < targets.length; ++j)
            if (targets[j].targetID == this.targetID) {
                if (targets[j].useLocalPosition) this.gameObject.transform.localPosition(targets[j].transform.localPosition());
                else this.gameObject.transform.position(targets[j].transform.position());
                break
            }
    }
};
goog.require("UHT.Engine");
var MoveTargetID = {
    Invalid: 0,
    SpinButton: 1,
    AutoplayButton: 2,
    BetButton: 3
};
MoveTarget.prototype = Object.create(Component.prototype);
MoveTarget.prototype.constructor = MoveTarget;

function MoveTarget() {
    Component.call(this);
    this.targetID = MoveTargetID.Invalid;
    this.useLocalPosition = false
}
goog.require("UHT.XTLink");
ObjectsDisablerByPath.prototype = Object.create(XTLink.prototype);
ObjectsDisablerByPath.prototype.constructor = ObjectsDisablerByPath;

function ObjectsDisablerByPath() {
    XTLink.call(this);
    this.paths = null;
    this.useOnGameInit = true
}
ObjectsDisablerByPath.prototype.XTRegisterCallbacks = function() {
    if (this.useOnGameInit) XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
};
ObjectsDisablerByPath.prototype.OnGameInit = function() {
    var roots = globalRuntime.sceneRoots;
    var localizationRoot = roots[1].transform.GetComponentsInChildren(LocalizationRoot, true)[0].transform;
    for (var r = 0; r < roots.length; ++r)
        for (var i = 0; i < this.paths.length; ++i) {
            var t = roots[r].transform.Find(this.paths[i]);
            if (t != null) t.gameObject.SetActive(false);
            else {
                var temp = this.paths[i].split("/");
                var newPath = "";
                for (var j = 3; j < temp.length; j++) newPath += temp[j] + (j < temp.length - 1 ? "/" : "");
                t = localizationRoot.Find(newPath);
                if (t != null) t.gameObject.SetActive(false);
                else console.log("Couldn't find object at path: " + this.paths[i])
            }
        }
};
goog.require("UHT.XTLink");
PageFlipper.prototype = Object.create(XTLink.prototype);
PageFlipper.prototype.constructor = PageFlipper;
var MobilePageContentType = {
    Normal: 0,
    Jackpot: 1
};

function PageFlipper() {
    XTLink.call(this);
    this.topPages = [];
    this.bottomPages = [];
    this.pageContentType = [];
    this.gambleTopPageIndex = -1;
    this.gambleBottomPageIndex = -1;
    this.dragObject = null;
    this.dragMovementOffset = 300;
    this.flippingPanelDepth = 1;
    this.staticPanelDepth = 0;
    this.pageSpringStrength = 5;
    this.animationTime = 0;
    this.followDragObject = false;
    this.topPageIsFlipping = false;
    this.bottomPageIsFlipping = false;
    this.flippingPage = null;
    this.currentSpring = null;
    this.cachedCamera = null;
    this.dragReleaseTime = 0;
    this.lastDragObjHeight =
        0;
    this.isDragged = false;
    this.fakeIsNotDraggedUp = false;
    this.fakeIsNotDraggedDown = false;
    this.isFlippingEnabled = true;
    this.jpData = null
}
PageFlipper.visibleTopPage = 0;
PageFlipper.visibleBottomPage = 0;
PageFlipper.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableMobileUpdatePages, this.OnMustUpdatePages, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this);
    EventManager.AddHandler(JackpotEvents.evtJackpotStateChanged, this.OnJackpotStateChanged, this)
};
PageFlipper.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnMustUpdatePages, this);
    XT.UnregisterCallbackEvent(this.OnGUIInit, this)
};
PageFlipper.prototype.OnJackpotStateChanged = function(param) {
    this.jpData = param
};
PageFlipper.prototype.OnGUIInit = function() {
    if (XT.GetBool(Vars.CanGamble_Spin) == false && this.gambleTopPageIndex >= 0 && this.gambleBottomPageIndex >= 0) {
        this.topPages.splice(this.gambleTopPageIndex, 1);
        this.bottomPages.splice(this.gambleBottomPageIndex, 1)
    }
    this.ProcessJackpotPages();
    this.ProcessRequirementChecker()
};
PageFlipper.prototype.ProcessJackpotPages = function() {
    if (this.jpData != null && !this.jpData.IsActive && this.pageContentType.indexOf(PageContentType.Jackpot) != -1) {
        var removalCount = 0;
        for (var i = 0; i < this.pageContentType.length; i++) {
            this.topPages[i - removalCount].gameObject.SetActive(false);
            this.bottomPages[i - removalCount].gameObject.SetActive(false);
            if (this.pageContentType[i] == PageContentType.Jackpot) {
                this.topPages.splice(i - removalCount, 1);
                this.bottomPages.splice(i - removalCount, 1);
                removalCount++
            }
        }
        for (var j =
                0; j < this.topPages.length; j++) {
            this.topPages[j].gameObject.SetActive(j == 0);
            this.bottomPages[j].gameObject.SetActive(j == 0)
        }
    }
};
PageFlipper.prototype.OnMustUpdatePages = function() {
    for (var i = 0; i < this.topPages.length; i++) this.topPages[i].gameObject.SetActive(PageFlipper.visibleTopPage == i);
    for (var j = 0; j < this.bottomPages.length; j++) this.bottomPages[j].gameObject.SetActive(PageFlipper.visibleBottomPage == j)
};
PageFlipper.prototype.OnDisable = function() {
    if (!this.isFlippingEnabled) return;
    if (this.flippingPage != null) {
        this.dragObject.localPosition(new UHTMath.Vector3(0, 0, 0));
        this.SpringPositionFinised()
    }
    this.isDragged = false;
    this.topPageIsFlipping = false;
    this.bottomPageIsFlipping = false;
    for (var i = 0; i < this.topPages.length; i++)
        if (this.topPages[i].gameObject.activeSelf) PageFlipper.visibleTopPage = i;
    for (var j = 0; j < this.bottomPages.length; j++)
        if (this.bottomPages[j].gameObject.activeSelf) PageFlipper.visibleBottomPage =
            j;
    XT.TriggerEvent(Vars.Evt_Internal_PaytableMobileUpdatePages)
};
PageFlipper.prototype.Update = function() {
    if (!this.isFlippingEnabled) return;
    if (this.followDragObject) {
        this.animationTime = this.dragObject.localPosition().y / this.dragMovementOffset;
        if (this.animationTime > 0) {
            if (this.topPageIsFlipping)
                if (this.isDragged && !this.fakeIsNotDraggedUp) {
                    if (this.lastDragObjHeight > this.dragObject.localPosition().y) this.dragObject.localPosition(new UHTMath.Vector3(0, 0, 0));
                    this.animationTime = 0
                } else {
                    this.fakeIsNotDraggedUp = false;
                    this.StopFlippingTopPage()
                }
            else if (this.animationTime >
                1) {
                if (this.flippingPage == null) {
                    this.dragObject.localPosition(this.dragObject.localPosition().x, 0, this.dragObject.localPosition().z);
                    return
                }
                this.fakeIsNotDraggedDown = false;
                this.fakeIsNotDraggedUp = false;
                this.SwitchFromBotToTopPageFlipping();
                var dragObjPos1 = new UHTMath.Vector3(this.dragObject.localPosition().x, -(this.dragMovementOffset - 1), this.dragObject.localPosition().z);
                this.dragObject.localPosition(dragObjPos1.x, dragObjPos1.y, dragObjPos1.z);
                this.animationTime = this.dragObject.localPosition().y / this.dragMovementOffset;
                if (this.animationTime < 0) this.animationTime *= -1;
                this.SampleAnimation(this.flippingPage.gameObject.animation, this.animationTime);
                return
            }
            if (this.flippingPage == null) this.BottomPageStartsFlipping()
        }
        if (this.animationTime < 0) {
            this.animationTime *= -1;
            if (this.bottomPageIsFlipping)
                if (this.isDragged && !this.fakeIsNotDraggedDown) {
                    if (this.lastDragObjHeight < this.dragObject.localPosition().y) this.dragObject.localPosition(new UHTMath.Vector3(0, 0, 0));
                    this.animationTime = 0
                } else {
                    this.fakeIsNotDraggedDown = false;
                    this.StopFlippingBottomPage()
                }
            else if (this.animationTime >
                1) {
                if (this.flippingPage == null) {
                    this.dragObject.localPosition(this.dragObject.localPosition().x, 0, this.dragObject.localPosition().z);
                    return
                }
                this.fakeIsNotDraggedDown = false;
                this.fakeIsNotDraggedUp = false;
                this.SwitchFromTopToBottomPageFlipping();
                var dragObjPos2 = new UHTMath.Vector3(this.dragObject.localPosition().x, this.dragMovementOffset - 1, this.dragObject.localPosition().z);
                this.dragObject.localPosition(dragObjPos2.x, dragObjPos2.y, dragObjPos2.z);
                this.animationTime = this.dragObject.localPosition().y / this.dragMovementOffset;
                if (this.animationTime < 0) this.animationTime *= -1;
                this.SampleAnimation(this.flippingPage.gameObject.animation, this.animationTime);
                return
            }
            if (this.flippingPage == null) this.TopPageStartsFlipping()
        }
        this.lastDragObjHeight = this.dragObject.localPosition().y;
        if (this.flippingPage != null) this.SampleAnimation(this.flippingPage.gameObject.animation, this.animationTime)
    }
};
PageFlipper.prototype.OnClick = function() {
    if (!this.isFlippingEnabled) return;
    if (Time.time - this.dragReleaseTime < .2) return;
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    var worldClickPos = this.cachedCamera.ScreenToWorldPoint(Input.mousePosition);
    var colliderYCenter = this.gameObject.collider.center;
    colliderYCenter = this.gameObject.transform.transformPoint(colliderYCenter);
    if (worldClickPos.y <= colliderYCenter.y) {
        this.currentSpring = SpringPosition.Begin(this.dragObject.gameObject,
            new UHTMath.Vector3(0, this.dragMovementOffset * 1.7, 0), this.pageSpringStrength);
        this.currentSpring.callWhenFinished = "SpringPositionFinised";
        this.currentSpring.eventReceiver = this;
        this.followDragObject = true
    } else {
        this.currentSpring = SpringPosition.Begin(this.dragObject.gameObject, new UHTMath.Vector3(0, -this.dragMovementOffset * 1.7, 0), this.pageSpringStrength);
        this.currentSpring.callWhenFinished = "SpringPositionFinised";
        this.currentSpring.eventReceiver = this;
        this.followDragObject = true
    }
};
PageFlipper.prototype.OnDragStarts = function() {
    this.isDragged = true;
    this.followDragObject = true;
    if (this.currentSpring != null && this.currentSpring.enabled) {
        if (this.animationTime < .2) {
            if (this.topPageIsFlipping) this.fakeIsNotDraggedUp = true;
            else if (this.bottomPageIsFlipping) this.fakeIsNotDraggedDown = true;
            this.dragObject.localPosition(new UHTMath.Vector3(0, 0, 0))
        }
        this.currentSpring.enabled = false
    }
};
PageFlipper.prototype.OnDragEnds = function() {
    this.isDragged = false;
    this.dragReleaseTime = Time.time;
    if (this.animationTime < .05) {
        this.dragObject.localPosition(new UHTMath.Vector3(0, 0, 0));
        this.SpringPositionFinised()
    } else {
        this.currentSpring = SpringPosition.Begin(this.dragObject.gameObject, new UHTMath.Vector3(0, 0, 0), this.pageSpringStrength);
        this.currentSpring.callWhenFinished = "SpringPositionFinised";
        this.currentSpring.eventReceiver = this
    }
};
PageFlipper.prototype.OnSwipe = function(direction) {
    this.isDragged = false;
    this.dragReleaseTime = Time.time;
    var _sign = 1;
    if (direction == "DOWN") _sign = -1;
    if (this.animationTime < .05) {
        this.dragObject.localPosition(new UHTMath.Vector3(0, 0, 0));
        this.SpringPositionFinised()
    }
    if (_sign > 0 && this.topPageIsFlipping || _sign < 0 && this.bottomPageIsFlipping) this.currentSpring = SpringPosition.Begin(this.dragObject.gameObject, new UHTMath.Vector3(0, 0, 0), this.pageSpringStrength);
    else this.currentSpring = SpringPosition.Begin(this.dragObject.gameObject,
        new UHTMath.Vector3(0, _sign * this.dragMovementOffset * 1.7, 0), this.pageSpringStrength);
    this.currentSpring.callWhenFinished = "SpringPositionFinised";
    this.currentSpring.eventReceiver = this
};
PageFlipper.prototype.SpringPositionFinised = function() {
    this.followDragObject = false;
    if (this.topPageIsFlipping) this.StopFlippingTopPage();
    else if (this.bottomPageIsFlipping) this.StopFlippingBottomPage()
};
PageFlipper.prototype.StopFlippingTopPage = function() {
    this.topPageIsFlipping = false;
    this.SampleAnimation(this.flippingPage.gameObject.animation, 0);
    for (var i = 0; i < this.topPages.length; i++)
        if (this.flippingPage == this.topPages[i]) {
            if (i == 0) this.topPages[this.topPages.length - 1].gameObject.SetActive(false);
            else this.topPages[i - 1].gameObject.SetActive(false);
            this.flippingPage.GetComponent(UIPanel).depth = this.staticPanelDepth;
            this.flippingPage = null;
            break
        }
};
PageFlipper.prototype.StopFlippingBottomPage = function() {
    this.bottomPageIsFlipping = false;
    this.SampleAnimation(this.flippingPage.gameObject.animation, 0);
    for (var i = 0; i < this.bottomPages.length; i++)
        if (this.flippingPage == this.bottomPages[i]) {
            if (i == this.bottomPages.length - 1) this.bottomPages[0].gameObject.SetActive(false);
            else this.bottomPages[i + 1].gameObject.SetActive(false);
            this.flippingPage.GetComponent(UIPanel).depth = this.staticPanelDepth;
            this.flippingPage = null;
            break
        }
};
PageFlipper.prototype.SwitchFromBotToTopPageFlipping = function() {
    this.bottomPageIsFlipping = false;
    this.topPageIsFlipping = true;
    this.flippingPage.gameObject.SetActive(false);
    this.flippingPage.GetComponent(UIPanel).depth = this.staticPanelDepth;
    this.SampleAnimation(this.flippingPage.gameObject.animation, 0);
    for (var i = 0; i < this.topPages.length; i++)
        if (this.topPages[i].gameObject.activeSelf) {
            if (i == this.topPages.length - 1) this.flippingPage = this.topPages[0];
            else this.flippingPage = this.topPages[i + 1];
            var p = this.flippingPage.GetComponent(UIPanel);
            p.depth = this.flippingPanelDepth;
            this.flippingPage.gameObject.SetActive(true);
            break
        }
    if (this.currentSpring != null && this.currentSpring.enabled) {
        this.currentSpring = SpringPosition.Begin(this.dragObject.gameObject, new UHTMath.Vector3(0, 0, 0), this.pageSpringStrength);
        this.currentSpring.callWhenFinished = "SpringPositionFinised";
        this.currentSpring.eventReceiver = this
    }
};
PageFlipper.prototype.SwitchFromTopToBottomPageFlipping = function() {
    this.topPageIsFlipping = false;
    this.bottomPageIsFlipping = true;
    this.flippingPage.gameObject.SetActive(false);
    this.flippingPage.GetComponent(UIPanel).depth = this.staticPanelDepth;
    this.SampleAnimation(this.flippingPage.gameObject.animation, 0);
    for (var i = 0; i < this.bottomPages.length; i++)
        if (this.bottomPages[i].gameObject.activeSelf) {
            if (i == 0) this.flippingPage = this.bottomPages[this.bottomPages.length - 1];
            else this.flippingPage = this.bottomPages[i -
                1];
            var p = this.flippingPage.GetComponent(UIPanel);
            p.depth = this.flippingPanelDepth;
            this.flippingPage.gameObject.SetActive(true);
            break
        }
    if (this.currentSpring != null && this.currentSpring.enabled) {
        this.currentSpring = SpringPosition.Begin(this.dragObject.gameObject, new UHTMath.Vector3(0, 0, 0), this.pageSpringStrength);
        this.currentSpring.callWhenFinished = "SpringPositionFinised";
        this.currentSpring.eventReceiver = this
    }
};
PageFlipper.prototype.BottomPageStartsFlipping = function() {
    this.bottomPageIsFlipping = true;
    this.topPageIsFlipping = false;
    for (var i = 0; i < this.bottomPages.length; i++)
        if (this.bottomPages[i].gameObject.activeSelf) {
            this.flippingPage = this.bottomPages[i];
            this.flippingPage.GetComponent(UIPanel).depth = this.flippingPanelDepth;
            if (i == this.bottomPages.length - 1) this.bottomPages[0].gameObject.SetActive(true);
            else this.bottomPages[i + 1].gameObject.SetActive(true);
            break
        }
};
PageFlipper.prototype.TopPageStartsFlipping = function() {
    this.topPageIsFlipping = true;
    this.bottomPageIsFlipping = false;
    for (var i = 0; i < this.topPages.length; i++)
        if (this.topPages[i].gameObject.activeSelf) {
            this.flippingPage = this.topPages[i];
            this.flippingPage.GetComponent(UIPanel).depth = this.flippingPanelDepth;
            if (i == 0) this.topPages[this.topPages.length - 1].gameObject.SetActive(true);
            else this.topPages[i - 1].gameObject.SetActive(true);
            break
        }
};
PageFlipper.prototype.SampleAnimation = function(anim, animationTime) {
    var animationState = anim.GetAnimationState(anim.clip.name);
    animationState.enabled = true;
    animationState.weight = 1;
    animationState.time = animationTime;
    anim.Sample();
    animationState.enabled = false
};
PageFlipper.prototype.ProcessRequirementChecker = function() {
    var removalCount = 0;
    var numberOfPages = this.topPages.length;
    for (var i = 0; i < numberOfPages; i++) {
        this.topPages[i - removalCount].gameObject.SetActive(false);
        this.bottomPages[i - removalCount].gameObject.SetActive(false);
        var rac = this.topPages[i - removalCount].GetComponent(window["RequirementChecker"]);
        if (rac != null && !rac.isActive) {
            this.topPages.splice(i - removalCount, 1);
            this.bottomPages.splice(i - removalCount, 1);
            removalCount++
        }
    }
    for (var j = 0; j < this.topPages.length; j++) {
        this.topPages[j].gameObject.SetActive(j ==
            0);
        this.bottomPages[j].gameObject.SetActive(j == 0)
    }
};
goog.require("UHT.Engine");
PanelAlphaProxy.prototype = Object.create(Component.prototype);
PanelAlphaProxy.prototype.constructor = PanelAlphaProxy;

function PanelAlphaProxy() {
    Component.call(this);
    this.alpha = -1;
    this.includeChildren = true;
    this.oldAlpha = -1;
    this.panels = null;
    this.mustGetPanels = true
}
PanelAlphaProxy.prototype.Start = function() {
    this.FindPanels()
};
PanelAlphaProxy.prototype.FindPanels = function() {
    if (this.includeChildren) this.panels = this.gameObject.GetComponentsInChildren(UIPanel, true);
    else this.panels = this.gameObject.GetComponents(UIPanel)
};
PanelAlphaProxy.prototype.Update = function() {
    if (Math.abs(this.alpha - this.oldAlpha) > .001) {
        if (this.mustGetPanels) {
            this.FindPanels();
            this.mustGetPanels = false
        }
        this.oldAlpha = this.alpha;
        for (var i = 0; i < this.panels.length; i++) this.panels[i].alpha = this.alpha
    } else this.mustGetPanels = true
};
PanelAlphaProxy.prototype.SetAlpha = function(value) {
    this.alpha = value
};
goog.require("UHT.Engine");
goog.require("UHT.TwoFloatsAnimatedMonoBehaviour");
PanelFader.prototype = Object.create(TwoFloatsAnimatedMonoBehaviour.prototype);
PanelFader.prototype.constructor = PanelFader;

function PanelFader() {
    TwoFloatsAnimatedMonoBehaviour.call(this);
    this.panelToFade = null;
    this.resetValue_1 = 1;
    this.resetValue_2 = 1;
    this.alphaValue = -1;
    this.oldAlpha = -1
}
PanelFader.prototype.SetAnimatedF_1 = function(val) {
    this.alphaValue = UHTMath.clamp(val, 0, 1)
};
PanelFader.prototype.SetAnimatedF_2 = function(val) {
    this.alphaValue = UHTMath.clamp(val, 0, 1)
};
PanelFader.prototype.ResetF_1 = function() {
    this.alphaValue = UHTMath.clamp(this.resetValue_1, 0, 1)
};
PanelFader.prototype.ResetF_2 = function() {
    this.alphaValue = UHTMath.clamp(this.resetValue_2, 0, 1)
};
PanelFader.prototype.Update = function() {
    if (this.oldAlpha != this.alphaValue) {
        if (this.alphaValue < .05) {
            this.panelToFade.enabled = false;
            return
        }
        if (!this.panelToFade.enabled) this.panelToFade.enabled = true;
        this.panelToFade.alpha = this.alphaValue;
        this.oldAlpha = this.alphaValue
    }
};
goog.require("UHT.Engine");
ParticleScaleFromLabel.prototype = Object.create(Component.prototype);
ParticleScaleFromLabel.prototype.constructor = ParticleScaleFromLabel;

function ParticleScaleFromLabel() {
    Component.call(this);
    this.targetLabel = null;
    this.extraScaleX = 1;
    this.extraScaleY = 1;
    this.extraSizeX = 0;
    this.extraSizeY = 0
}
ParticleScaleFromLabel.prototype.OnEnable = function() {
    var newScale = new UHTMath.Vector3(this.targetLabel.GetWidth() * this.extraScaleX + this.extraSizeX, this.targetLabel.GetHeight() * this.extraScaleY + this.extraSizeY, 1);
    this.gameObject.transform.localScale(newScale)
};
goog.require("UHT.Engine");
RandomGameObjectActivator.prototype = Object.create(Component.prototype);
RandomGameObjectActivator.prototype.constructor = RandomGameObjectActivator;

function RandomGameObjectActivator() {
    Component.call(this);
    this.targetGameObject = null;
    this.minActiveDuration = 1;
    this.maxActiveDuration = 1;
    this.minInactiveDuration = 1;
    this.maxInactiveDuration = 5;
    this.useRandomScaleOnEnable = false;
    this.minScaleMultiplier = 1;
    this.maxScaleMultiplier = 2;
    this.timer = 0;
    this.duration = 0;
    this.isInactive = true;
    this.initialScale = new UHTMath.Vector3(1, 1, 1)
}
RandomGameObjectActivator.prototype.Start = function() {
    this.isInactive = Random.Range(0, 2) > 0;
    this.initialScale = new UHTMath.Vector3(this.targetGameObject.transform.localScale().x, this.targetGameObject.transform.localScale().y, this.targetGameObject.transform.localScale().z);
    this.UpdateState()
};
RandomGameObjectActivator.prototype.Update = function() {
    if (this.timer >= this.duration) this.UpdateState();
    else this.timer += Time.deltaTime
};
RandomGameObjectActivator.prototype.UpdateState = function() {
    if (this.isInactive) {
        this.duration = Random.Range(this.minActiveDuration, this.maxActiveDuration);
        if (this.useRandomScaleOnEnable) {
            var scaleMultiplier = Random.Range(this.minScaleMultiplier, this.maxScaleMultiplier);
            this.targetGameObject.transform.localScale(this.initialScale.x * scaleMultiplier, this.initialScale.y * scaleMultiplier, this.initialScale.z * scaleMultiplier)
        }
    } else this.duration = Random.Range(this.minInactiveDuration, this.maxInactiveDuration);
    this.targetGameObject.SetActive(this.isInactive);
    this.isInactive = !this.isInactive;
    this.timer = 0
};
goog.require("UHT.Engine");
RandomIntervalCATLink.prototype = Object.create(Component.prototype);
RandomIntervalCATLink.prototype.constructor = RandomIntervalCATLink;

function RandomIntervalCATLink() {
    Component.call(this);
    this.catLink = null;
    this.minInterval = 0;
    this.maxInterval = 0;
    this.timer = 0;
    this.targetTimer = 0
}
RandomIntervalCATLink.prototype.StartCATLink = function() {
    this.catLink.Start();
    this.timer = 0;
    this.targetTimer = Random.Range(this.minInterval, this.maxInterval)
};
RandomIntervalCATLink.prototype.Start = function() {
    this.targetTimer = Random.Range(this.minInterval, this.maxInterval)
};
RandomIntervalCATLink.prototype.Update = function() {
    if (this.timer >= this.targetTimer) this.StartCATLink();
    this.timer += Time.deltaTime
};
goog.require("UHT.XTLink");
RequirementChecker.prototype = Object.create(XTLink.prototype);
RequirementChecker.prototype.constructor = RequirementChecker;

function RequirementChecker() {
    XTLink.call(this);
    this.jurisdictionRequirement = null;
    this.isActiveWhenRequirementIsTrue = true;
    this.isActive = false
}
RequirementChecker.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this, -1)
};
RequirementChecker.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGUIInit, this)
};
RequirementChecker.prototype.OnGUIInit = function() {
    var varValue = false;
    var varName = this.jurisdictionRequirement.name;
    if (varName != null && varName != "" && varName != "*None*") varValue = XT.GetBool(varName);
    if (this.isActiveWhenRequirementIsTrue) this.isActive = varValue;
    else this.isActive = !varValue
};

function RoutineQueueHelper() {}
RoutineQueueHelper.scheduledRQItems = [];
RoutineQueueHelper.ClearScheduledRQItems = function() {
    RoutineQueueHelper.scheduledRQItems = []
};
RoutineQueueHelper.AddScheduledRQItem = function(item, time) {
    var rqItem = new ScheduledRQItem;
    rqItem.rqItem = item;
    rqItem.time = time;
    RoutineQueueHelper.scheduledRQItems.push(rqItem)
};
RoutineQueueHelper.PutScheduledItemsToRQ = function(rq) {
    RoutineQueueHelper.scheduledRQItems.sort(function(a, b) {
        return a.time - b.time
    });
    if (RoutineQueueHelper.scheduledRQItems[0].time != 0) rq.AddRoutineQueueItem(new RQIWaitForSeconds(RoutineQueueHelper.scheduledRQItems[0].time));
    rq.AddRoutineQueueItem(RoutineQueueHelper.scheduledRQItems[0].rqItem);
    for (var i = 1; i < RoutineQueueHelper.scheduledRQItems.length; i++) {
        var waitForSeconds = RoutineQueueHelper.scheduledRQItems[i].time - RoutineQueueHelper.scheduledRQItems[i -
            1].time;
        if (waitForSeconds != 0) rq.AddRoutineQueueItem(new RQIWaitForSeconds(waitForSeconds));
        rq.AddRoutineQueueItem(RoutineQueueHelper.scheduledRQItems[i].rqItem)
    }
};

function ScheduledRQItem() {
    this.rqItem;
    this.time = 0
}
goog.require("UHT.Engine");
SpriteFillProxy.prototype = Object.create(Component.prototype);
SpriteFillProxy.prototype.constructor = SpriteFillProxy;

function SpriteFillProxy() {
    Component.call(this);
    this.targetSprite = null;
    this.fillAmount = 0;
    this.topFillAmount = 0;
    this.bottomFillAmount = 0;
    this.leftFillAmount = 0;
    this.rightFillAmount = 0;
    this.previousFillAmount = 0;
    this.previousTopFillAmount = 0;
    this.previousBottomFillAmount = 0;
    this.previousLeftFillAmount = 0;
    this.previousRightFillAmount = 0;
    this.fillChanged = false
}
SpriteFillProxy.prototype.LateUpdate = function() {
    this.fillChanged = false;
    if (Math.abs(this.previousFillAmount - this.fillAmount) > .001) {
        this.previousFillAmount = this.fillAmount;
        this.targetSprite.fillAmount = this.fillAmount;
        this.fillChanged = true
    }
    if (Math.abs(this.previousTopFillAmount - this.topFillAmount) > .001) {
        this.previousTopFillAmount = this.topFillAmount;
        this.targetSprite.fillAmountTop = this.topFillAmount;
        this.fillChanged = true
    }
    if (Math.abs(this.previousBottomFillAmount - this.bottomFillAmount) > .001) {
        this.previousBottomFillAmount =
            this.bottomFillAmount;
        this.targetSprite.fillAmountBottom = this.bottomFillAmount;
        this.fillChanged = true
    }
    if (Math.abs(this.previousLeftFillAmount - this.leftFillAmount) > .001) {
        this.previousLeftFillAmount = this.leftFillAmount;
        this.targetSprite.fillAmountLeft = this.leftFillAmount;
        this.fillChanged = true
    }
    if (Math.abs(this.previousRightFillAmount - this.rightFillAmount) > .001) {
        this.previousRightFillAmount = this.rightFillAmount;
        this.targetSprite.fillAmountRight = this.rightFillAmount;
        this.fillChanged = true
    }
    if (this.fillChanged) this.targetSprite.SetSpriteName(this.targetSprite.spriteName)
};
goog.require("UHT.Engine");
var AnimationControllerUpdateMethod = {
    Update: 0,
    LateUpdate: 1
};
AnimationController.prototype = Object.create(Component.prototype);
AnimationController.prototype.constructor = AnimationController;

function AnimationController() {
    Component.call(this);
    this.target = null;
    this.clip = null;
    this.animationTime = 0;
    this.animationTimeIsFixed = false;
    this.useWrapMode = false;
    this.wrapMode = WrapMode.Default;
    this.playOnEnable = false;
    this.callWhenFinished = null;
    this.normalizedTimeCurve = null;
    this.useNormalizedTimeCurve = false;
    this.randomClips = null;
    this.updateOn = AnimationControllerUpdateMethod.Update;
    this.isPlaying = false;
    this.startNormalizedTime = 0;
    this.targetNormalizedTime = 0;
    this.deltaAnimationTime = 0;
    this.curNormalizedTime =
        0;
    this.curAnimationTime = 0;
    this.randomIndex = -1;
    this.randomIndices = []
}
AnimationController.prototype.ChooseRandomClip = function() {
    if (this.randomIndices.length <= 0)
        for (var i = 0; i < this.randomClips.length; ++i)
            if (this.randomIndex != i) this.randomIndices.push(i);
    var idx = Random.Range(0, this.randomIndices.length);
    this.randomIndex = this.randomIndices[idx];
    this.randomIndices.splice(idx, 1);
    this.clip = this.randomClips[this.randomIndex]
};
AnimationController.prototype.Sample = function(normalizedTime) {
    this.curNormalizedTime = Number(normalizedTime);
    var animationState = this.target.GetAnimationState(this.clip.name);
    animationState.enabled = true;
    animationState.weight = 1;
    animationState.time = this.curNormalizedTime * animationState.length;
    this.target.Sample();
    animationState.enabled = false
};
AnimationController.prototype.Play = function() {
    if (this.animationTime <= 0) this.Sample(1);
    else {
        var animationState = this.target.GetAnimationState(this.clip.name);
        if (this.useWrapMode) animationState.wrapMode = this.wrapMode;
        animationState.speed = this.clip.length / this.animationTime;
        animationState.time = 0;
        this.target.Play(this.clip.name)
    }
};
AnimationController.prototype.Stop = function() {
    this.target.Stop()
};
AnimationController.prototype.Pause = function() {
    this.target.GetAnimationState(this.clip.name).speed = 0
};
AnimationController.prototype.Resume = function() {
    this.target.GetAnimationState(this.clip.name).speed = this.clip.length / this.animationTime
};
AnimationController.prototype.IsPlaying = function() {
    return this.isPlaying || this.target.IsPlaying(this.clip.name)
};
AnimationController.prototype.PlayTo = function(normalizedTime) {
    this.startNormalizedTime = this.curNormalizedTime;
    this.targetNormalizedTime = Number(normalizedTime);
    this.deltaAnimationTime = this.animationTimeIsFixed ? this.animationTime : Math.abs(this.targetNormalizedTime - this.startNormalizedTime) * this.animationTime;
    this.isPlaying = true;
    this.curAnimationTime = 0
};
AnimationController.prototype.InternalUpdate = function() {
    if (this.isPlaying)
        if (this.curAnimationTime >= this.deltaAnimationTime) {
            this.Sample(this.targetNormalizedTime);
            this.isPlaying = false;
            if (this.callWhenFinished != null) this.callWhenFinished.Start()
        } else {
            if (this.deltaAnimationTime == 0) {
                console.error("AnimationController.Update - Gonna divide by 0 ... aborting");
                return
            }
            var time = this.curAnimationTime / this.deltaAnimationTime;
            if (this.useNormalizedTimeCurve) time = this.normalizedTimeCurve.Evaluate(time);
            this.Sample(UHTMath.lerp(this.startNormalizedTime,
                this.targetNormalizedTime, time));
            this.curAnimationTime += Time.deltaTime
        }
};
AnimationController.prototype.OnEnable = function() {
    if (this.playOnEnable) this.Play()
};
AnimationController.prototype.GetNormalizedTime = function() {
    return this.curNormalizedTime
};
AnimationController.prototype.Update = function() {
    if (this.updateOn == AnimationControllerUpdateMethod.Update) this.InternalUpdate()
};
AnimationController.prototype.LateUpdate = function() {
    if (this.updateOn == AnimationControllerUpdateMethod.LateUpdate) this.InternalUpdate()
};
AnimationController.prototype.StopPlaying = function() {
    this.isPlaying = false
};
AnimationController.prototype.SetAnimationTime = function(time) {
    this.animationTime = time
};
AnimationController.prototype.SetIsPlaying = function(play) {
    this.isPlaying = play
};
goog.require("UHT.Random");
goog.require("UHT.Engine");
goog.provide("UHT.ExtraParticleModule");
ExtraParticleModule.prototype = Object.create(Component.prototype);
ExtraParticleModule.prototype.constructor = ExtraParticleModule;

function ExtraParticleModule() {
    Component.call(this)
}
ExtraParticleModule.prototype.SupportsFastParticleContainer = function() {
    return true
};
ExtraParticleModule.prototype.OnNewParticle = function(particle) {};
ExtraParticleModule.prototype.OnUpdateParticle = function(particle) {};
goog.require("UHT.Random");
goog.require("UHT.Engine");
goog.require("UHT.ExtraParticleModule");
AnimatedParticleFrames.prototype = Object.create(ExtraParticleModule.prototype);
AnimatedParticleFrames.prototype.constructor = AnimatedParticleFrames;

function AnimatedParticleFrames() {
    ExtraParticleModule.call(this);
    this.atlas = null;
    this.FPS = 15;
    this.frameInfo = []
}
AnimatedParticleFrames.prototype.Awake = function() {
    this.BuildSprites()
};
AnimatedParticleFrames.prototype.BuildSprites = function() {
    this.atlas.initAtlas();
    var mSpriteNames = this.atlas.getSpriteNames();
    mSpriteNames.sort(function(a, b) {
        return a == b ? 0 : a > b ? 1 : -1
    });
    for (var i = 0; i < mSpriteNames.length; i++) this.frameInfo.push(this.atlas.getTextureForSimpleSprite(null, mSpriteNames[i]))
};
AnimatedParticleFrames.prototype.SupportsFastParticleContainer = function() {
    return false
};
AnimatedParticleFrames.prototype.OnNewParticle = function(particle) {
    particle._epm_apf_frame = Random.Range(0, this.frameInfo.length - 1);
    particle._epm_apf_frameTime = Random.Range(.01, 1 / this.FPS);
    particle.sprite = new PIXI.Sprite(this.frameInfo[particle._epm_apf_frame])
};
AnimatedParticleFrames.prototype.OnUpdateParticle = function(particle) {
    particle._epm_apf_frameTime += Time.deltaTime;
    var newFrame = particle._epm_apf_frame;
    while (particle._epm_apf_frameTime > 1 / this.FPS) {
        particle._epm_apf_frameTime -= 1 / this.FPS;
        newFrame++
    }
    newFrame %= this.frameInfo.length;
    if (newFrame != particle._epm_apf_frame) {
        var index = -1;
        var pppc = particle.parent.pixiZOrderedContainer.children;
        for (var i = 0; i < pppc.length; i++)
            if (pppc[i] == particle.sprite) index = i;
        particle._epm_apf_frame = newFrame;
        particle.sprite =
            new PIXI.Sprite(this.frameInfo[particle._epm_apf_frame]);
        particle.sprite.blendMode = particle.parent.blendMode;
        particle.sprite.anchor.x = .5;
        particle.sprite.anchor.y = .5;
        if (index != -1) {
            particle.sprite.parent = particle.parent.pixiZOrderedContainer;
            pppc[index] = particle.sprite
        } else particle.parent.pixiZOrderedContainer.addChild(particle.sprite)
    }
};
goog.require("UHT.GenericPoolObject");
LabelTiledEffect.prototype = Object.create(GenericPoolObject.prototype);
LabelTiledEffect.prototype.constructor = LabelTiledEffect;

function LabelTiledEffect() {
    GenericPoolObject.call(this);
    this.label = null
}
goog.require("UHT.XTLink");
LabelTiledEffects.prototype = Object.create(XTLink.prototype);
LabelTiledEffects.prototype.constructor = LabelTiledEffects;

function LabelTiledEffects() {
    XTLink.call(this);
    this.label = null;
    this.labelsAnchor = null;
    this.effectsPooler = null;
    this.effectPoolID = 0;
    this.effectWidth = 0;
    this.prevWidth = -1;
    this.isGameInit = false;
    this.effects = []
}
LabelTiledEffects.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
};
LabelTiledEffects.prototype.OnGameInit = function() {
    this.isGameInit = true
};
LabelTiledEffects.prototype.LateUpdate = function() {
    if (!this.isGameInit || this.effectsPooler.initializing) return;
    var width = this.label.GetWidth();
    if (width == this.prevWidth) return;
    this.prevWidth = width;
    var count = Math.ceil(width / this.effectWidth);
    var prevCount = this.effects.length;
    var deleteCount = this.effects.length - count;
    var fxWidth = Math.round(width / count);
    for (var i = 0; i < deleteCount; ++i) {
        this.effectsPooler.RecycleObject(this.effects[0]);
        this.effects.splice(0, 1);
        this.labelsAnchor.labels.splice(0, 1)
    }
    for (var i =
            0; i < count; ++i) {
        if (i == this.effects.length) {
            this.effects.push(this.effectsPooler.GetObject(this.effectPoolID, this.labelsAnchor.gameObject));
            this.labelsAnchor.labels.push(this.effects[i].label)
        }
        this.effects[i].label.SetWidth(fxWidth)
    }
    if (prevCount != count) this.labelsAnchor.DiscardCache();
    this.labelsAnchor.ForceNextUpdate();
    this.labelsAnchor.Update()
};
goog.require("UHT.Engine");
PanelAlphaAnimator.prototype = Object.create(Component.prototype);
PanelAlphaAnimator.prototype.constructor = PanelAlphaAnimator;

function PanelAlphaAnimator() {
    Component.call(this);
    this.targetPanels = [];
    this.startAlpha = null;
    this.endAlpha = null;
    this.autoIncludeChildPanels = false;
    this.animationTime = 1;
    this.playAutomatically = false;
    this.playReverse = false;
    this.useAnimationCurve = true;
    this.useTimeChannel = false;
    this.timeChannelID = 0;
    this.playMode = WidgetColorAnimator.PlayMode.Default;
    this.animationCurve = null;
    this.firstCurveKey = null;
    this.lastCurveKey = null;
    this.totalCurveTime = 0;
    this.currentTime = 0;
    this.direction = 1;
    this.playing = false;
    this.reset =
        false;
    this.myTimeChannel = null
}
PanelAlphaAnimator.PlayMode = {
    Default: 0,
    Loop: 1,
    PingPong: 2
};
PanelAlphaAnimator.prototype.FindChildPanels = function() {
    this.targetPanels = this.gameObject.GetComponentsInChildren(UIPanel, true)
};
PanelAlphaAnimator.prototype.Play = function() {
    if (this.autoIncludeChildPanels) this.FindChildPanels();
    this.playing = true;
    this.direction = this.playReverse ? -1 : 1;
    this.Update()
};
PanelAlphaAnimator.prototype.PlayReversed = function() {
    if (this.autoIncludeChildPanels) this.FindChildPanels();
    this.direction = -1;
    this.currentTime = this.animationTime - 1E-5;
    this.playing = true;
    this.Update()
};
PanelAlphaAnimator.prototype.PlayReversedFromCurrentTime = function() {
    if (this.autoIncludeChildPanels) this.FindChildPanels();
    if (!this.playing) this.currentTime = this.animationTime - 1E-5;
    this.playing = true;
    this.direction = -1;
    if (!this.useAnimationCurve) this.Update()
};
PanelAlphaAnimator.prototype.Pause = function() {
    this.playing = false
};
PanelAlphaAnimator.prototype.Stop = function() {
    if (!this.playing) return;
    var undefined;
    if (this.useAnimationCurve)
        if (this.direction == 1)
            for (var panelIndex = 0; panelIndex < this.targetPanels.length; panelIndex++) this.targetPanels[panelIndex].alpha = UHTMath.lerp(this.startAlpha, this.endAlpha, this.animationCurve.keys[this.animationCurve.keys.length - 1].value);
        else
            for (var panelIndex2 = 0; panelIndex2 < this.targetPanels.length; panelIndex2++) this.targetPanels[panelIndex2].alpha = UHTMath.lerp(this.startAlpha, this.endAlpha,
                this.animationCurve.keys[0].value);
    this.playing = false;
    this.direction = this.playReverse ? -1 : 1;
    this.currentTime = this.playReverse ? this.animationTime - 1E-5 : 0
};
PanelAlphaAnimator.prototype.Reset = function() {
    this.reset = true;
    this.Stop()
};
PanelAlphaAnimator.prototype.OnEnable = function() {
    if (this.useTimeChannel) this.myTimeChannel = Globals.RegisterToTimeChannel(this, this.timeChannelID);
    if (this.playAutomatically) this.Play()
};
PanelAlphaAnimator.prototype.OnDisable = function() {
    this.Stop();
    if (this.useTimeChannel) Globals.UnregisterFromTimeChannel(this, this.timeChannelID)
};
PanelAlphaAnimator.prototype.Start = function() {
    this.direction = this.playReverse ? -1 : 1;
    this.firstCurveKey = this.animationCurve.keys[0];
    this.lastCurveKey = this.animationCurve.keys[this.animationCurve.keys.length - 1];
    this.totalCurveTime = this.lastCurveKey.time - this.firstCurveKey.time
};
PanelAlphaAnimator.prototype.Update = function() {
    if ((this.playing || this.reset) && this.targetPanels.length > 0) {
        if (this.reset) this.reset = false;
        if (!this.useAnimationCurve)
            if (this.direction > 0) this.currentTime = this.animationTime;
            else this.currentTime = 0;
        var progress = this.currentTime / this.animationTime;
        if (this.animationCurve.keys.length >= 2) {
            var curCurveTime = progress * this.totalCurveTime;
            progress = this.animationCurve.Evaluate(curCurveTime);
            progress = UHTMath.clamp(progress, 0, 1)
        }
        if (progress >= 0 && progress <= 1)
            for (var i =
                    0; i < this.targetPanels.length; i++) this.targetPanels[i].alpha = UHTMath.lerp(this.startAlpha, this.endAlpha, progress);
        if (this.direction > 0) {
            if (this.useTimeChannel)
                if (this.myTimeChannel.IsChannelMaster(this)) {
                    if (this.currentTime < this.animationTime) this.currentTime += Time.deltaTime;
                    this.myTimeChannel.currentTime = this.currentTime
                } else this.currentTime = this.myTimeChannel.currentTime;
            else if (this.currentTime < this.animationTime) this.currentTime += Time.deltaTime;
            if (this.currentTime >= this.animationTime) switch (this.playMode) {
                case WidgetColorAnimator.PlayMode.Loop:
                    this.currentTime -=
                        this.animationTime;
                    break;
                case WidgetColorAnimator.PlayMode.PingPong:
                    this.direction = -1;
                    break;
                default:
                    this.Stop();
                    break
            }
        }
        if (this.direction < 0) {
            if (this.useTimeChannel)
                if (this.myTimeChannel.IsChannelMaster(this)) {
                    if (this.currentTime > 0) this.currentTime -= Time.deltaTime;
                    this.myTimeChannel.currentTime = this.currentTime
                } else this.currentTime = this.myTimeChannel.currentTime;
            else if (this.currentTime > 0) this.currentTime -= Time.deltaTime;
            if (this.currentTime <= 0) switch (this.playMode) {
                case WidgetColorAnimator.PlayMode.Loop:
                    this.currentTime +=
                        this.animationTime;
                    break;
                case WidgetColorAnimator.PlayMode.PingPong:
                    this.direction = 1;
                    break;
                default:
                    this.Stop();
                    break
            }
        }
    }
};
PanelAlphaAnimator.prototype.Sample = function(normalizedTime) {
    for (var i = 0; i < this.targetPanels.length; i++) this.targetPanels[i].alpha = UHTMath.lerp(this.startAlpha, this.endAlpha, normalizedTime)
};
goog.require("UHT.Random");
goog.require("UHT.Engine");
RandomAnimationPlayer.prototype = Object.create(Component.prototype);
RandomAnimationPlayer.prototype.constructor = RandomAnimationPlayer;

function RandomAnimationPlayer() {
    Component.call(this);
    this.anim = null;
    this.animationClips = [];
    this.resetClip = null;
    this.startOnEnable = false;
    this.useDelayOnStart = false;
    this.waitForPreviousClipToFinish = false;
    this.playResetAnimOnStop = true;
    this.minRandomTime = 1;
    this.maxRandomTime = 5;
    this.minRandomSpeed = 1;
    this.maxRandomSpeed = 5;
    this.noRepetition = false;
    this.isRunning = false;
    this.currentTime = 0;
    this.randomIndex = -1;
    this.randomIndices = []
}
RandomAnimationPlayer.prototype.GetRandomIndex = function() {
    if (this.randomIndices.length <= 0)
        for (var i = 0; i < this.animationClips.length; ++i)
            if (this.randomIndex != i) this.randomIndices.push(i);
    var idx = Random.Range(0, this.randomIndices.length);
    this.randomIndex = this.randomIndices[idx];
    this.randomIndices.splice(idx, 1);
    return this.randomIndex
};
RandomAnimationPlayer.prototype.OnEnable = function() {
    if (this.startOnEnable) this.StartAnimating()
};
RandomAnimationPlayer.prototype.PlayRandomClip = function() {
    var randomIndex = this.noRepetition ? this.GetRandomIndex() : Random.Range(0, this.animationClips.length);
    var randomSpeed = Random.Range(this.minRandomSpeed, this.maxRandomSpeed);
    if (!this.anim.IsPlaying(this.animationClips[randomIndex].name)) {
        this.anim.GetAnimationState(this.animationClips[randomIndex].name).speed = randomSpeed;
        this.anim.Play(this.animationClips[randomIndex].name)
    }
};
RandomAnimationPlayer.prototype.StartAnimating = function() {
    this.isRunning = true;
    if (this.useDelayOnStart) this.currentTime = Random.Range(this.minRandomTime, this.maxRandomTime);
    else this.currentTime = 0
};
RandomAnimationPlayer.prototype.StopAnimating = function() {
    this.isRunning = false;
    if (this.playResetAnimOnStop) this.anim.Play(this.resetClip.name)
};
RandomAnimationPlayer.prototype.Update = function() {
    if (this.isRunning && !(this.waitForPreviousClipToFinish && this.anim.isPlaying))
        if (this.currentTime <= 0) {
            this.currentTime = Random.Range(this.minRandomTime, this.maxRandomTime);
            this.PlayRandomClip()
        } else this.currentTime -= Time.deltaTime
};
goog.require("UHT.XTLink");
SplitLabelV3FX.prototype = Object.create(XTLink.prototype);
SplitLabelV3FX.prototype.constructor = SplitLabelV3FX;

function SplitLabelV3FX() {
    XTLink.call(this);
    this.source = null;
    this.labelsAnchor = null;
    this.charSources = null;
    this.charsPooler = null;
    this.charPoolID = 0;
    this.colorAnimators = null;
    this.useExtraSpaces = false;
    this.extraSpaces = null;
    this.keepCharsInMemory = false;
    this.prevText = "";
    this.prevWidth = -1;
    this.prevScale = null;
    this.chars = [];
    this.removedChars = [];
    this.widgets = [];
    this.isGameInit = false;
    this.extraSpaceWidths = []
}
SplitLabelV3FX.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
};
SplitLabelV3FX.prototype.OnGameInit = function() {
    this.isGameInit = true;
    this.PrepareCharSources();
    if (this.useExtraSpaces)
        for (var i = 0; i < this.extraSpaces.length; ++i) this.extraSpaceWidths.push(this.extraSpaces[i].GetWidth())
};
SplitLabelV3FX.prototype.LateUpdate = function() {
    if (!this.isGameInit || this.charsPooler.initializing) return;
    var width = this.source.GetWidth();
    var scale = this.source.transform.localScale();
    var textChanged = this.prevText != this.source.text;
    if (textChanged) this.UpdateText();
    if (textChanged || width != this.prevWidth || !scale.equals(this.prevScale)) {
        this.UpdateWidth(width, scale);
        this.labelsAnchor.ForceNextUpdate();
        this.labelsAnchor.Update();
        this.UpdateExtraSpaces(width)
    }
};
SplitLabelV3FX.prototype.UpdateText = function() {
    this.removedChars.splice(0);
    var text = this.source.text;
    var deleteCount = this.chars.length - text.length;
    for (var i = 0; i < deleteCount; ++i) {
        this.removedChars.push(this.chars[0]);
        this.chars[0].label.keepInMemory = false;
        this.charsPooler.RecycleObject(this.chars[0]);
        this.chars.splice(0, 1);
        this.labelsAnchor.labels.splice(0, 1)
    }
    for (var i = 0; i < text.length; ++i) {
        if (i == this.chars.length) {
            this.chars.push(this.charsPooler.GetObject(this.charPoolID, this.labelsAnchor.gameObject));
            this.labelsAnchor.labels.push(this.chars[i].label);
            this.chars[i].label.keepInMemory = this.keepCharsInMemory
        }
        this.chars[i].UpdateValue(this.GetCharSource(text[i]), text, i)
    }
    if (this.prevText.length != text.length) this.labelsAnchor.DiscardCache();
    for (var i = 0; i < this.colorAnimators.length; ++i) this.UpdateColorAnimator(this.colorAnimators[i]);
    this.prevText = text
};
SplitLabelV3FX.prototype.UpdateColorAnimator = function(animator) {
    this.widgets.splice(0);
    this.widgets = this.widgets.concat(animator.targetWidgets);
    for (var i = 0; i < this.removedChars.length; ++i) {
        var idx = this.widgets.indexOf(this.removedChars[i].label);
        if (idx > -1) this.widgets.splice(idx, 1)
    }
    for (var i = 0; i < this.chars.length; ++i) {
        var idx = this.widgets.indexOf(this.chars[i].label);
        if (idx < 0) this.widgets.push(this.chars[i].label)
    }
    animator.targetWidgets = this.widgets.slice()
};
SplitLabelV3FX.prototype.PrepareCharSources = function() {
    this.source.Prepare();
    for (var i = 0; i < this.charSources.length; ++i) this.charSources[i].Prepare()
};
SplitLabelV3FX.prototype.GetCharSource = function(chr) {
    for (var i = 0; i < this.charSources.length; ++i)
        if (chr == this.charSources[i].text) return this.charSources[i];
    return this.source
};
SplitLabelV3FX.prototype.UpdateWidth = function(width, scale) {
    if (this.source.overflow == UILabel.Overflow.ShrinkContent) this.labelsAnchor.maxWidth = width;
    for (var i = 0; i < this.chars.length; ++i) this.chars[i].transformToScale.localScale(scale);
    this.prevWidth = width;
    this.prevScale = scale
};
SplitLabelV3FX.prototype.UpdateExtraSpaces = function(width) {
    if (!this.useExtraSpaces) return;
    var extraWidth = this.labelsAnchor.width - width;
    var extraSpace = Math.round(extraWidth / this.extraSpaces.length);
    for (var i = 0; i < this.extraSpaces.length; ++i) this.extraSpaces[i].width = Math.round((this.extraSpaceWidths[i] + extraSpace) * this.extraSpaces[i].resize)
};
goog.require("UHT.GenericPoolObject");
SplitLabelV3FXChar.prototype = Object.create(GenericPoolObject.prototype);
SplitLabelV3FXChar.prototype.constructor = SplitLabelV3FXChar;

function SplitLabelV3FXChar() {
    GenericPoolObject.call(this);
    this.label = null;
    this.panel = null;
    this.samplers = null;
    this.transformToScale = null;
    this.isInit = false;
    this.initialDepth = 0
}
SplitLabelV3FXChar.prototype.UpdateValue = function(source, text, idx) {
    this.label.text = text[idx];
    if (!this.isInit) this.Init(source);
    this.panel.depth = this.initialDepth + idx;
    var time = UHTMath.inverseLerp(0, text.length - 1, idx);
    for (var i = 0; i < this.samplers.length; ++i) this.samplers[i].Sample(time)
};
SplitLabelV3FXChar.prototype.Init = function(source) {
    this.isInit = true;
    this.initialDepth = this.panel.depth;
    this.label.fontSize = source.fontSize;
    this.label.fontName = source.fontName;
    this.label.IOSresized = true;
    this.label.resize = source.resize;
    this.label.Prepare();
    if (this.transformToScale == null) this.transformToScale = this.transform
};
goog.require("UHT.XTLink");
UILabelForceFallbackFont.prototype = Object.create(XTLink.prototype);
UILabelForceFallbackFont.prototype.constructor = UILabelForceFallbackFont;

function UILabelForceFallbackFont() {
    XTLink.call(this);
    this.fontFamily = "Verdana";
    this.labels = null;
    this.forceFontAfterLocalization = false;
    this.forceFontOnAwake = false
}
UILabelForceFallbackFont.prototype.XTRegisterCallbacks = function() {
    if (this.forceFontAfterLocalization) XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.ForceFallbackFont, this, 1)
};
UILabelForceFallbackFont.prototype.Awake = function() {
    FontLoader.LoadFont(this.fontFamily, null);
    if (!this.forceFontAfterLocalization || this.forceFontOnAwake) this.ForceFallbackFont()
};
UILabelForceFallbackFont.prototype.ForceFallbackFont = function() {
    for (var i = 0; i < this.labels.length; ++i) {
        this.labels[i].fontName = this.fontFamily;
        this.labels[i].Prepare()
    }
};
goog.require("UHT.Engine");
UILabelPropertyCopy.prototype = Object.create(Component.prototype);
UILabelPropertyCopy.prototype.constructor = UILabelPropertyCopy;

function UILabelPropertyCopy() {
    Component.call(this);
    this.FromLabel = null;
    this.ToLabel = null;
    this.CopyText = false;
    this.CopyColor = false
}
UILabelPropertyCopy.prototype.CopyProperties = function() {
    if (this.FromLabel == null || this.ToLabel == null) return;
    if (this.CopyText == true) this.ToLabel.text = this.FromLabel.text;
    if (this.CopyColor == true) this.ToLabel.SetColor(this.FromLabel.GetColor())
};
goog.require("UHT.Engine");
WidgetColorAnimator.prototype = Object.create(Component.prototype);
WidgetColorAnimator.prototype.constructor = WidgetColorAnimator;

function WidgetColorAnimator() {
    Component.call(this);
    this.targetWidgets = [];
    this.colorA = null;
    this.colorB = null;
    this.animationTime = 1;
    this.playAutomatically = false;
    this.playReverse = false;
    this.useAnimationCurve = true;
    this.useAnimationCurveSample = false;
    this.useTimeChannel = false;
    this.timeChannelID = 0;
    this.playMode = WidgetColorAnimator.PlayMode.Default;
    this.animationCurve = null;
    this.animators = null;
    this.timeScaleID = "";
    this.firstCurveKey = null;
    this.lastCurveKey = null;
    this.totalCurveTime = 0;
    this.currentTime = 0;
    this.direction =
        1;
    this.playing = false;
    this.reset = false;
    this.myTimeChannel = null
}
WidgetColorAnimator.PlayMode = {
    Default: 0,
    Loop: 1,
    PingPong: 2
};
WidgetColorAnimator.prototype.Play = function() {
    this.playing = true;
    this.direction = this.playReverse ? -1 : 1;
    if (!this.useAnimationCurve) this.Update()
};
WidgetColorAnimator.prototype.PlayReversed = function() {
    this.direction = -1;
    this.currentTime = this.animationTime - 1E-5;
    this.playing = true;
    if (!this.useAnimationCurve) this.Update()
};
WidgetColorAnimator.prototype.PlayReversedFromCurrentTime = function() {
    if (!this.playing) this.currentTime = this.animationTime - 1E-5;
    this.playing = true;
    this.direction = -1;
    if (!this.useAnimationCurve) this.Update()
};
WidgetColorAnimator.prototype.Pause = function() {
    this.playing = false
};
WidgetColorAnimator.prototype.Resume = function() {
    this.playing = true
};
WidgetColorAnimator.prototype.Stop = function() {
    if (!this.playing) return;
    var undefined;
    if (this.useAnimationCurve)
        if (this.direction == 1)
            for (var widgetIndex = 0; widgetIndex < this.targetWidgets.length; widgetIndex++) Color.qLerp(this.targetWidgets[widgetIndex].color, this.colorA, this.colorB, this.animationCurve.keys[this.animationCurve.keys.length - 1].value);
        else
            for (var widgetIndex2 = 0; widgetIndex2 < this.targetWidgets.length; widgetIndex2++) Color.qLerp(this.targetWidgets[widgetIndex2].color, this.colorA, this.colorB,
                this.animationCurve.keys[0].value);
    this.playing = false;
    this.direction = this.playReverse ? -1 : 1;
    this.currentTime = this.playReverse ? this.animationTime - 1E-5 : 0
};
WidgetColorAnimator.prototype.Reset = function() {
    this.reset = true;
    this.Stop()
};
WidgetColorAnimator.prototype.OnEnable = function() {
    if (this.useTimeChannel) this.myTimeChannel = Globals.RegisterToTimeChannel(this, this.timeChannelID);
    if (this.playAutomatically) {
        this.playing = true;
        this.Update()
    }
};
WidgetColorAnimator.prototype.OnDisable = function() {
    this.Stop();
    if (this.useTimeChannel) Globals.UnregisterFromTimeChannel(this, this.timeChannelID)
};
WidgetColorAnimator.prototype.Start = function() {
    this.direction = this.playReverse ? -1 : 1;
    this.firstCurveKey = this.animationCurve.keys[0];
    this.lastCurveKey = this.animationCurve.keys[this.animationCurve.keys.length - 1];
    this.totalCurveTime = this.lastCurveKey.time - this.firstCurveKey.time
};
WidgetColorAnimator.prototype.Update = function() {
    if ((this.playing || this.reset) && this.targetWidgets.length > 0) {
        if (this.reset) this.reset = false;
        if (!this.useAnimationCurve)
            if (this.direction > 0) this.currentTime = this.animationTime;
            else this.currentTime = 0;
        var progress = this.currentTime / this.animationTime;
        if (this.animationCurve.keys.length >= 2) {
            var curCurveTime = progress * this.totalCurveTime;
            progress = this.animationCurve.Evaluate(curCurveTime);
            progress = UHTMath.clamp(progress, 0, 1)
        }
        if (progress >= 0 && progress <= 1)
            for (var i =
                    0; i < this.targetWidgets.length; i++) Color.qLerp(this.targetWidgets[i].color, this.colorA, this.colorB, progress);
        if (this.direction > 0) {
            if (this.useTimeChannel)
                if (this.myTimeChannel.IsChannelMaster(this)) {
                    if (this.currentTime < this.animationTime) this.currentTime += TimeScaler.GetDeltaTime(this.timeScaleID);
                    this.myTimeChannel.currentTime = this.currentTime
                } else this.currentTime = this.myTimeChannel.currentTime;
            else if (this.currentTime < this.animationTime) this.currentTime += TimeScaler.GetDeltaTime(this.timeScaleID);
            if (this.currentTime >= this.animationTime) switch (this.playMode) {
                case WidgetColorAnimator.PlayMode.Loop:
                    this.currentTime -= this.animationTime;
                    break;
                case WidgetColorAnimator.PlayMode.PingPong:
                    this.direction = -1;
                    break;
                default:
                    this.Stop();
                    break
            }
        }
        if (this.direction < 0) {
            if (this.useTimeChannel)
                if (this.myTimeChannel.IsChannelMaster(this)) {
                    if (this.currentTime > 0) this.currentTime -= TimeScaler.GetDeltaTime(this.timeScaleID);
                    this.myTimeChannel.currentTime = this.currentTime
                } else this.currentTime = this.myTimeChannel.currentTime;
            else if (this.currentTime > 0) this.currentTime -= TimeScaler.GetDeltaTime(this.timeScaleID);
            if (this.currentTime <= 0) switch (this.playMode) {
                case WidgetColorAnimator.PlayMode.Loop:
                    this.currentTime += this.animationTime;
                    break;
                case WidgetColorAnimator.PlayMode.PingPong:
                    this.direction = 1;
                    break;
                default:
                    this.Stop();
                    break
            }
        }
    }
};
WidgetColorAnimator.prototype.FindLabels = function() {
    var labels = this.gameObject.GetComponentsInChildren(UILabel, true);
    for (var i = 0; i < labels.length; ++i)
        if (this.targetWidgets.indexOf(labels[i]) < 0) this.targetWidgets.push(labels[i])
};
WidgetColorAnimator.prototype.Sample = function(normalizedTime) {
    normalizedTime = _number.otod(normalizedTime);
    if (this.useAnimationCurveSample) normalizedTime = this.animationCurve.Evaluate(normalizedTime * this.totalCurveTime);
    for (var i = 0; i < this.targetWidgets.length; i++) Color.qLerp(this.targetWidgets[i].color, this.colorA, this.colorB, normalizedTime)
};
WidgetColorAnimator.prototype.SampleAndSetCurrentTime = function(normalizedTime) {
    normalizedTime = Number(normalizedTime);
    this.Sample(normalizedTime);
    this.currentTime = normalizedTime * this.animationTime
};
WidgetColorAnimator.prototype.SyncCurrentTimeWithAnimator = function(index) {
    this.currentTime = this.animators[index].currentTime
};
goog.provide("UHT.GraphicsShape");
goog.require("UHT.Engine");
GraphicsShape.prototype = Object.create(Component.prototype);
GraphicsShape.prototype.constructor = GraphicsShape;

function GraphicsShape() {
    Component.call(this);
    this.points = null;
    this.positions = [];
    this.pixiPoints = []
}
GraphicsShape.prototype.Init = function() {
    for (var i = 0; i < this.points.length; ++i) {
        this.positions.push(new UHTMath.Vector3(-69, -69, -69));
        this.pixiPoints.push(new PIXI.Point(-69, -69))
    }
};
GraphicsShape.prototype.NeedUpdate = function() {
    var needUpdate = false;
    for (var i = 0; i < this.points.length; ++i) {
        var pos = this.points[i].position();
        if (this.positions[i].equals(pos)) continue;
        needUpdate = true;
        this.positions[i] = pos
    }
    return needUpdate
};
GraphicsShape.prototype.UpdatePoints = function(camera) {
    for (var i = 0; i < this.points.length; ++i) this.UpdatePoint(this.pixiPoints[i], this.points[i].position(), camera)
};
GraphicsShape.prototype.UpdatePoint = function(point, position, camera) {
    var p = camera.WorldToScreenPoint(position);
    point.set(p.x, p.y)
};
GraphicsShape.prototype.Draw = function(camera, graphics) {};
goog.require("UHT.GraphicsShape");
GraphicsShapeCircle.prototype = Object.create(GraphicsShape.prototype);
GraphicsShapeCircle.prototype.constructor = GraphicsShapeCircle;

function GraphicsShapeCircle() {
    GraphicsShape.call(this);
    this.arc_start = 0;
    this.arc_end = 0
}
GraphicsShapeCircle.prototype.Draw = function(camera, graphics) {
    this.UpdatePoints(camera);
    var x0 = this.pixiPoints[0].x;
    var y0 = this.pixiPoints[0].y;
    var x1 = this.pixiPoints[1].x;
    var y1 = this.pixiPoints[1].y;
    var x = UHTMath.lerp(x0, x1, .5);
    var y = UHTMath.lerp(y0, y1, .5);
    var r = (new UHTMath.Vector3(x0 - x1, y0 - y1, 0)).magnitude() * .5;
    graphics.beginFill(16777215);
    if (this.arc_start == this.arc_end) graphics.drawCircle(x, y, r);
    else {
        graphics.moveTo(x, y);
        graphics.arc(x, y, r, this.arc_start, this.arc_end)
    }
    graphics.endFill()
};
goog.require("UHT.GraphicsShape");
GraphicsShapePolygon.prototype = Object.create(GraphicsShape.prototype);
GraphicsShapePolygon.prototype.constructor = GraphicsShapePolygon;

function GraphicsShapePolygon() {
    GraphicsShape.call(this)
}
GraphicsShapePolygon.prototype.Draw = function(camera, graphics) {
    this.UpdatePoints(camera);
    graphics.beginFill(16777215);
    graphics.drawPolygon(this.pixiPoints);
    graphics.endFill()
};
goog.require("UHT.GraphicsShape");
GraphicsShapeRect.prototype = Object.create(GraphicsShape.prototype);
GraphicsShapeRect.prototype.constructor = GraphicsShapeRect;

function GraphicsShapeRect() {
    GraphicsShape.call(this)
}
GraphicsShapeRect.prototype.Draw = function(camera, graphics) {
    this.UpdatePoints(camera);
    var x = this.pixiPoints[0].x;
    var y = this.pixiPoints[0].y;
    var w = this.pixiPoints[1].x - x;
    var h = this.pixiPoints[1].y - y;
    graphics.beginFill(16777215);
    graphics.drawRect(x, y, w, h);
    graphics.endFill()
};
goog.require("UHT.Component");
WidgetMask.prototype = Object.create(Component.prototype);
WidgetMask.prototype.constructor = WidgetMask;

function WidgetMask() {
    Component.call(this)
}
goog.require("UHT.XTLink");
WidgetsMaskGraphics.prototype = Object.create(XTLink.prototype);
WidgetsMaskGraphics.prototype.constructor = WidgetsMaskGraphics;

function WidgetsMaskGraphics() {
    XTLink.call(this);
    this.widgets = null;
    this.shapes = null;
    this.updateOnEnable = false;
    this.clearOnDisable = false;
    this.mask = new PIXI.Graphics;
    this.cachedCamera = null;
    this.needUpdate = false;
    this.screenWidth = -1;
    this.screenHeight = -1;
    this.cameraPos = null
}
WidgetsMaskGraphics.pixiTypes = [UIPanel, UISprite];
WidgetsMaskGraphics.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(InterfaceVars.Evt_Internal_BlackBandsUpdated, this.OnGameSizeChanged, this)
};
WidgetsMaskGraphics.prototype.OnGameSizeChanged = function() {
    this.needUpdate = true;
    if (this.gameObject.activeInHierarchy) this.LateUpdate()
};
WidgetsMaskGraphics.prototype.Start = function() {
    for (var i = 0; i < this.shapes.length; ++i) this.shapes[i].Init()
};
WidgetsMaskGraphics.prototype.LateUpdate = function() {
    var camera = this.GetCamera();
    if (camera == null) return;
    if (!this.NeedUpdate()) return;
    this.needUpdate = false;
    this.mask.clear();
    for (var i = 0; i < this.shapes.length; ++i) this.shapes[i].Draw(camera, this.mask);
    for (var i = 0; i < this.widgets.length; ++i) {
        var pixi = this.FindPixi(this.widgets[i]);
        if (pixi != null) pixi.mask = this.mask
    }
};
WidgetsMaskGraphics.prototype.OnEnable = function() {
    if (this.updateOnEnable) this.needUpdate = true
};
WidgetsMaskGraphics.prototype.OnDisable = function() {
    if (this.clearOnDisable) {
        this.mask.clear();
        this.needUpdate = true
    }
};
WidgetsMaskGraphics.prototype.IsScreenSizeChanged = function() {
    var changed = this.screenWidth != UHTScreen.width || this.screenHeight != UHTScreen.height;
    if (changed) {
        this.screenWidth = UHTScreen.width;
        this.screenHeight = UHTScreen.height
    }
    return changed
};
WidgetsMaskGraphics.prototype.IsCameraPositionChanged = function() {
    var camera = this.GetCamera();
    if (camera == null) return false;
    var pos = camera.transform.position();
    var changed = this.cameraPos == null || !this.cameraPos.equals(pos);
    if (changed) this.cameraPos = pos;
    return changed
};
WidgetsMaskGraphics.prototype.NeedUpdate = function() {
    if (this.IsScreenSizeChanged() || this.IsCameraPositionChanged()) return true;
    for (var i = 0; i < this.shapes.length; ++i)
        if (this.shapes[i].NeedUpdate()) return true;
    return this.needUpdate
};
WidgetsMaskGraphics.prototype.GetCamera = function() {
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    return this.cachedCamera
};
WidgetsMaskGraphics.prototype.FindPixi = function(obj) {
    var pixiTypes = WidgetsMaskGraphics.pixiTypes;
    for (var i = 0; i < pixiTypes.length; ++i) {
        var c = obj.GetComponent(pixiTypes[i]);
        if (c == null) continue;
        if (c instanceof Camera || c instanceof UIPanel) return c;
        return c.pixiObject
    }
    return null
};
WidgetsMaskGraphics.prototype.ForceNextUpdate = function() {
    this.needUpdate = true
};
goog.require("UHT.Engine");
WidgetsEnabler.prototype = Object.create(Component.prototype);
WidgetsEnabler.prototype.constructor = WidgetsEnabler;

function WidgetsEnabler() {
    Component.call(this);
    this.root = null;
    this.sprites = null;
    this.spritesActive = null;
    this.labels = null;
    this.labelsActive = null;
    this.isInit = false
}
WidgetsEnabler.prototype.EnableWidgets = function() {
    if (!this.isInit) this.FindWidgets();
    for (var i = 0; i < this.sprites.length; ++i) this.sprites[i].gameObject.SetActive(this.spritesActive[i]);
    for (var i = 0; i < this.labels.length; ++i) this.labels[i].gameObject.SetActive(this.labelsActive[i])
};
WidgetsEnabler.prototype.DisableWidgets = function() {
    if (!this.isInit) this.FindWidgets();
    for (var i = 0; i < this.sprites.length; ++i) this.sprites[i].gameObject.SetActive(false);
    for (var i = 0; i < this.labels.length; ++i) this.labels[i].gameObject.SetActive(false)
};
WidgetsEnabler.prototype.FindWidgets = function() {
    this.sprites = this.root.GetComponentsInChildren(UISprite, true);
    this.spritesActive = _array.create(this.sprites.length);
    for (var i = 0; i < this.sprites.length; ++i) this.spritesActive[i] = this.sprites[i].gameObject.activeSelf;
    this.labels = this.root.GetComponentsInChildren(UILabel, true);
    this.labelsActive = _array.create(this.labels.length);
    for (var i = 0; i < this.labels.length; ++i) this.labelsActive[i] = this.labels[i].gameObject.activeSelf;
    this.isInit = true
};
goog.require("UHT.Engine");
WidgetsUtils.prototype = Object.create(Component.prototype);
WidgetsUtils.prototype.constructor = WidgetsUtils;

function WidgetsUtils() {
    Component.call(this);
    this.sprites = null;
    this.labels = null;
    this.labelAnchors = null
}
WidgetsUtils.prototype.SetWidth = function(width) {
    for (var i = 0; i < this.sprites.length; ++i) this.sprites[i].width = width;
    for (var i = 0; i < this.labels.length; ++i) this.labels[i].width = width
};
WidgetsUtils.prototype.SetHeight = function(height) {
    for (var i = 0; i < this.sprites.length; ++i) this.sprites[i].height = height;
    for (var i = 0; i < this.labels.length; ++i) this.labels[i].height = height
};
WidgetsUtils.prototype.SetFontSize = function(fontSize) {
    for (var i = 0; i < this.labels.length; ++i) this.labels[i].fontSize = fontSize
};
WidgetsUtils.prototype.SetMaxWidth = function(maxWidth) {
    for (var i = 0; i < this.labelAnchors.length; ++i) {
        var anchor = this.labelAnchors[i];
        if (anchor.maxWidth == maxWidth) continue;
        anchor.maxWidth = maxWidth;
        anchor.ForceNextUpdate();
        if (anchor.gameObject.activeInHierarchy) anchor.Update()
    }
};
goog.provide("UHT.VSGameStateManager");
goog.require("UHT.Engine");
var VSGameState = {
    Spin: 0,
    SpinAutoplay: 1,
    SpinFreeSpins: 2,
    SpinBonusRounds: 3,
    SpinBonusRoundsAutoplay: 4,
    Result: 5,
    ResultAutoplay: 6,
    ResultBonusRounds: 7,
    ResultBonusRoundsAutoplay: 8,
    ResultFreeSpins: 9,
    ResultFreeSpinsPrepare: 10,
    ResultPrepareForBonus: 11,
    Bonus: 12,
    Gamble: 13,
    GambleCustom: 14,
    FSBG: 15,
    Invalid: 16,
    Jackpot: 17
};

function VSGameStateManager() {}
VSGameStateManager.ChangeTo = function(_newState) {
    VSGameStateManager.previousState = VSGameStateManager.internalState;
    VSGameStateManager.internalState = _newState;
    XT.TriggerEvent(Vars.Evt_Internal_ChangeVSGameState)
};
VSGameStateManager.GetState = function() {
    return VSGameStateManager.internalState
};
VSGameStateManager.GetPreviousState = function() {
    return VSGameStateManager.previousState
};
VSGameStateManager.internalState = VSGameState.Invalid;
VSGameStateManager.previousState = VSGameState.Invalid;
goog.provide("UHT.RequestManager");
goog.require("UHT.VSGameStateManager");
var RequestManager = {};
RequestManager.blockRequests = false;
RequestManager.spinTimer = 0;
RequestManager.freeSpinsStates = [VSGameState.SpinFreeSpins, VSGameState.ResultFreeSpins, VSGameState.ResultFreeSpinsPrepare];
RequestManager.requestList = null;
RequestManager.notStartedList = null;
RequestManager.Init = function() {
    RequestManager.requestList = [];
    RequestManager.notStartedList = []
};
RequestManager.Update = function() {
    if (RequestManager.blockRequests) return;
    RequestManager.spinTimer += Time.deltaTime;
    for (var i = 0; i < RequestManager.notStartedList.length; ++i) {
        if (RequestManager.IsSpinRequest(RequestManager.notStartedList[i])) RequestManager.spinTimer = 0;
        RequestManager.notStartedList[i].Start();
        RequestManager.requestList.push(RequestManager.notStartedList[i])
    }
    RequestManager.notStartedList.splice(0);
    var notFinishedList = [];
    for (var i = 0; i < RequestManager.requestList.length; ++i)
        if (RequestManager.requestList[i].IsDone())
            if (RequestManager.IsSpinRequest(RequestManager.requestList[i]))
                if (!RequestManager.MustLimitSpinRequest(RequestManager.requestList[i])) RequestManager.requestList[i].Finish();
                else notFinishedList.push(RequestManager.requestList[i]);
    else RequestManager.requestList[i].Finish();
    else notFinishedList.push(RequestManager.requestList[i]);
    RequestManager.requestList = notFinishedList
};
RequestManager.AddRequest = function(request, external) {
    external = external == undefined ? false : external;
    if (!external)
        if (!_string.IsNullOrEmpty(ServerOptions.mgckey))
            if (request.Method == "POST") request.Fields[GameProtocolDictionary.mgckey] = ServerOptions.mgckey;
            else if (!(new RegExp(GameProtocolDictionary.mgckey)).test(request.Url)) request.Url += (!/\?/.test(request.Url) ? "?" : "&") + GameProtocolDictionary.mgckey + "=" + ServerOptions.mgckey;
    RequestManager.notStartedList.push(request)
};
RequestManager.IsSpinRequest = function(request) {
    return request.Fields[GameProtocolDictionary.Actions.action] != undefined && request.Fields[GameProtocolDictionary.Actions.action] == GameProtocolDictionary.Actions.doSpin && !RequestManager.freeSpinsStates.indexOf(VSGameStateManager.GetState()) > -1
};
RequestManager.MustLimitSpinRequest = function(request) {
    if (XT.GetBool(Vars.IsDifferentSpinType)) return false;
    return XT.GetBool(Vars.Jurisdiction_SpinLimit) && RequestManager.spinTimer < XT.GetFloat(Vars.Jurisdiction_SpinLimit_Value)
};
goog.require("UHT.Engine");
goog.require("UHT.GameConnection");
goog.require("UHT.BalanceManager");
goog.require("UHT.RequestManager");
goog.require("UHT.Adapter");
goog.require("UHT.JackpotsManager");
goog.require("UHT.ServerOptions");
goog.require("UHT.SwedishRegulationManager");
ServerLink.prototype = Object.create(Component.prototype);
ServerLink.prototype.constructor = ServerLink;

function ServerLink() {
    Component.call(this);
    this.connections = null;
    this.balanceManager = null;
    this.adapter = null;
    this.jackpotsManager = null;
    this.freeRoundsBonusConnection = null;
    this.announcementConnection = null;
    this.swedishRegulationManager = null;
    this.requestQueue = null;
    this.isReady = false
}
ServerLink.prototype.scriptUpdatePriority = 6;
ServerLink.prototype.Awake = function() {
    this.requestQueue = [];
    EventManager.Init();
    this.connections = [];
    RequestManager.Init();
    this.balanceManager = new BalanceManager;
    this.balanceManager.Init();
    this.adapter = new Adapter;
    this.adapter.Init();
    this.jackpotsManager = new JackpotsManager;
    this.jackpotsManager.Init();
    this.freeRoundsBonusConnection = new FreeRoundsBonusConnection;
    this.announcementConnection = new AnnouncementConnection;
    this.swedishRegulationManager = new SwedishRegulationManager;
    this.swedishRegulationManager.Init();
    EventManager.AddHandler(ApplicationEvents.evtRequestInitApplication, this.OnInitApplicationRequest, this);
    EventManager.AddHandler(ApplicationEvents.evtAppConfigurationReceived, this.OnApplicationConfigReceived, this);
    EventManager.AddHandler(GameEvents.evtCreateConnectionRequest, this.OnCreateConnectionRequest, this)
};
ServerLink.prototype.Start = function() {
    this.gameObject.AddComponent("ResourceManager")
};
ServerLink.prototype.Update = function() {
    var i;
    if (this.isReady && this.requestQueue.length > 0) {
        for (i = 0; i < this.requestQueue.length; ++i) {
            var connection = new GameConnection;
            connection.Init(this.requestQueue[i]);
            this.connections.push(connection);
            console.log("ServerLink::Update", ServerOptions.gameSymbol);
            EventManager.Trigger(GameEvents.evtConnectionReady, ServerOptions.gameSymbol);
            EventManager.Trigger(ApplicationEvents.evtServerOptionsParsed, null)
        }
        this.requestQueue = []
    }
    RequestManager.Update();
    for (i = 0; i < this.connections.length; ++i) this.connections[i].Update();
    this.balanceManager.Update();
    this.jackpotsManager.Update();
    this.freeRoundsBonusConnection.Update();
    this.announcementConnection.Update();
    this.swedishRegulationManager.Update()
};
ServerLink.prototype.OnInitApplicationRequest = function(param) {
    EventManager.Trigger(ApplicationEvents.evtRequestAppConfiguration, null)
};
ServerLink.prototype.OnApplicationConfigReceived = function(param) {
    var configOptions = param;
    var secure = this.GetConfigValue(FrameworkConfiguration.isSecure, "true", configOptions);
    if (!_string.IsNullOrEmpty(secure)) ServerOptions.isSecure = _bool.Parse(secure);
    ServerOptions.serverUrl = (ServerOptions.isSecure ? "https://" : "http://") + ServerInterface.GetDomain();
    ServerOptions.loginUri = this.GetConfigValue(FrameworkConfiguration.loginUri, ServerOptions.loginUri, configOptions);
    ServerOptions.logoutUri = this.GetConfigValue(FrameworkConfiguration.logoutUri,
        ServerOptions.logoutUri, configOptions);
    ServerOptions.sessionTimeout = this.GetConfigValue(FrameworkConfiguration.sessionTimeout, ServerOptions.sessionTimeout, configOptions);
    ServerOptions.rcSettings = this.GetConfigValue(FrameworkConfiguration.rcSettings, ServerOptions.rcSettings, configOptions);
    ServerOptions.menuUri = this.GetConfigValue(FrameworkConfiguration.menuUri, ServerOptions.menuUri, configOptions);
    ServerOptions.versionUri = this.GetConfigValue(FrameworkConfiguration.versionInfo, ServerOptions.versionUri,
        configOptions);
    ServerOptions.resourceseUri = this.GetConfigValue(FrameworkConfiguration.resourceUri, ServerOptions.resourceseUri, configOptions);
    ServerOptions.settingsUri = this.GetConfigValue(FrameworkConfiguration.settingsUri, ServerOptions.settingsUri, configOptions);
    ServerOptions.reloadBalanceUri = this.GetConfigValue(FrameworkConfiguration.reloadBalanceUri, ServerOptions.reloadBalanceUri, configOptions);
    ServerOptions.reloadJackpotUri = this.GetConfigValue(FrameworkConfiguration.reloadJackpotUri, ServerOptions.reloadJackpotUri,
        configOptions);
    ServerOptions.gameUrl = this.GetConfigValue(FrameworkConfiguration.gameUrl, ServerOptions.gameUrl, configOptions);
    ServerOptions.currency = this.GetConfigValue(FrameworkConfiguration.currency, ServerOptions.currency, configOptions);
    if (UHT_GAME_CONFIG_SRC["currencyOriginal"] != undefined) ServerOptions.realCurrency = UHT_GAME_CONFIG_SRC["currencyOriginal"];
    else ServerOptions.realCurrency = ServerOptions.currency;
    ServerOptions.casinoName = this.GetConfigValue(FrameworkConfiguration.casinoName, ServerOptions.casinoName,
        configOptions);
    ServerOptions.mgckey = this.GetConfigValue(FrameworkConfiguration.mgckey, ServerOptions.mgckey, configOptions);
    ServerOptions.resourcesUrl = (ServerOptions.isSecure ? "https://" : "http://") + this.GetConfigValue(FrameworkConfiguration.bundleDomain, ServerOptions.resourcesUrl, configOptions);
    ServerOptions.gameHistory = this.GetConfigValue(FrameworkConfiguration.gameHistory, ServerOptions.gameHistory, configOptions);
    ServerOptions.jurisdiction = this.GetConfigValue(FrameworkConfiguration.jurisdiction, ServerOptions.jurisdiction,
        configOptions);
    ServerOptions.jurisdictionRequirements = this.GetConfigValue(FrameworkConfiguration.jurisdictionRequirements, ServerOptions.jurisdictionRequirements, configOptions);
    ServerOptions.brandRequirements = this.GetConfigValue(FrameworkConfiguration.brandRequirements, ServerOptions.brandRequirements, UHT_GAME_CONFIG_SRC);
    if (ServerOptions.brandRequirements != null) {
        var unfilteredBR = ServerOptions.brandRequirements.split(",");
        var filteredBR = [];
        for (var ir = 0; ir < unfilteredBR.length; ir++) {
            var req = unfilteredBR[ir];
            var splits = req.split("*");
            if (splits.length > 1) {
                var platform = (Globals.isMini ? "MINI_" : "") + (Globals.isMobile ? "MOBILE" : "DESKTOP");
                if (splits[1] == platform) req = splits[0]
            }
            if (req[0] == "[") {
                if (req.indexOf("[" + ServerOptions.jurisdiction + "]") == 0) filteredBR.push(req.substr(req.indexOf("]") + 1))
            } else filteredBR.push(req)
        }
        ServerOptions.brandRequirements = filteredBR.join(",")
    }
    ServerOptions.promotionurl = this.GetConfigValue(FrameworkConfiguration.promotionurl, ServerOptions.promotionurl, configOptions);
    ServerOptions.amountType =
        this.GetConfigValue(FrameworkConfiguration.amountType, ServerOptions.amountType, configOptions);
    ServerOptions.SwedishRegulation.notificationUrl = this.GetConfigValue("REGULATION_NOTIFICATION_URL", "", configOptions);
    var currentLogLevel = this.GetConfigValue(FrameworkConfiguration.clientLogLevel, "INFO", configOptions);
    if (currentLogLevel == "WARN") ServerOptions.logLevel = LogLevel.Warn;
    else if (currentLogLevel == "DEBUG") ServerOptions.logLevel = LogLevel.Debug;
    else if (currentLogLevel == "ERROR") ServerOptions.logLevel =
        LogLevel.Error;
    else ServerOptions.logLevel = LogLevel.None_Info;
    ServerOptions.isExternal = _bool.Parse(this.GetConfigValue(FrameworkConfiguration.external, "", configOptions));
    ServerOptions.isDemoMode = _bool.Parse(this.GetConfigValue(FrameworkConfiguration.demoMode, "", configOptions));
    ServerOptions.noRating = _bool.Parse(this.GetConfigValue(FrameworkConfiguration.noRating, String(ServerOptions.noRating), configOptions));
    if (!UHT_LOCAL) {
        ServerOptions.styleName = this.GetConfigValue(FrameworkConfiguration.stylename,
            ServerOptions.styleName, configOptions);
        ServerOptions.language = this.GetConfigValue(FrameworkConfiguration.locale, ServerOptions.language, configOptions);
        ServerOptions.gameSymbol = this.GetConfigValue(FrameworkConfiguration.gameSymbol, ServerOptions.gameSymbol, configOptions);
        ServerOptions.gameServiceUri = this.GetConfigValue(FrameworkConfiguration.gameServiceUri, ServerOptions.gameServiceUri, configOptions)
    }
    ServerOptions.gameVerificationUrl = UHT_GAME_CONFIG_SRC["gameVerificationURL"] || null;
    var gvuArgs = new Array(2);
    gvuArgs[0] = "lang=" + ServerOptions.language;
    gvuArgs[1] = GameProtocolDictionary.mgckey + "=" + ServerOptions.mgckey;
    if (ServerOptions.gameVerificationUrl != null) ServerOptions.gameVerificationUrl += "?" + gvuArgs.join("&");
    this.OnCreateConnectionRequest(ServerOptions.gameSymbol);
    this.freeRoundsBonusConnection.Init();
    this.announcementConnection.Init();
    this.isReady = true
};
ServerLink.prototype.GetConfigValue = function(key, value, dictionary) {
    if (dictionary[key] != undefined) return dictionary[key];
    return value
};
ServerLink.prototype.OnCreateConnectionRequest = function(symbol) {
    this.requestQueue.push(symbol)
};
ServerLink.prototype.OnAppConfigurationResponse = function(param, statusCode) {
    EventManager.Trigger(AdapterEvents.evtGetConfiguration, param)
};
ServerLink.prototype.ReloadBalanceCallback = function(response) {
    var nameValues = response.split("&");
    var nameValuesDict = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var balanceData = GameProtocolCommonParser.ParseBalance(nameValuesDict);
    if (balanceData != null) EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData)
};
goog.require("UHT.Engine");
VSGameStateHelper.prototype = Object.create(Component.prototype);
VSGameStateHelper.prototype.constructor = VSGameStateHelper;

function VSGameStateHelper() {
    Component.call(this)
}

function ValueDisplayerVariable() {
    this.variable = null;
    this.suffix = ""
}
ValueDisplayerVariable.prototype.GetAnimatedVarName = function() {
    return this.variable.name + "_" + this.suffix + "_@nimated"
};
goog.require("UHT.UHTEngine");
ValueFX.prototype = Object.create(Component.prototype);
ValueFX.prototype.constructor = ValueFX;

function ValueFX() {
    Component.call(this);
    this.valueLabels = null;
    this.fxCats = null
}
ValueFX.prototype.TryStartFX = function(value, fxIdx) {
    var cat = this.fxCats[UHTMath.clamp(fxIdx, 0, this.fxCats.length - 1)];
    if (cat.IsRunning()) return false;
    for (var i = 0; i < this.valueLabels.length; ++i) this.valueLabels[i].text = value;
    cat.Start();
    return true
};
goog.require("UHT.XTLink");
goog.require("UHT.LocaleManager");
ValueDisplayer.prototype = Object.create(XTLink.prototype);
ValueDisplayer.prototype.constructor = ValueDisplayer;

function ValueDisplayer() {
    XTLink.call(this);
    this.vdVariable = null;
    this.animated = false;
    this.label = null;
    this.multiplier = 1;
    this.isDisplayingCoins = false;
    this.isDisplayingDecimals = false;
    this.formatOptions = null;
    this.forceHasCoins = false;
    this.allowDOG = true;
    this.catEventAnimation = null;
    this.callEventWhenValueChanged = false;
    this.callEventWhenFormatChanged = false;
    this.callEventWhenValueChangedAllowed = true;
    this.actualVarName = "";
    this.manualValue = 0;
    this.isLastOneToChangeTheLabel = false
}
ValueDisplayer.prototype.MarkAsLastModifierForLabel = function() {
    if (this.isLastOneToChangeTheLabel == false) {
        var list = this.label.valueDisplayers;
        if (list == null) list = this.label.valueDisplayers = [];
        var idx = list.indexOf(this);
        if (idx < 0) list.push(this);
        for (var i = 0; i < list.length; i++) list[i].isLastOneToChangeTheLabel = false;
        this.isLastOneToChangeTheLabel = true
    }
};
ValueDisplayer.prototype.XTRegisterCallbacks = function() {
    this.actualVarName = this.animated ? this.vdVariable.GetAnimatedVarName() : this.vdVariable.variable.name;
    if (!this.IsManualValue()) XT.RegisterCallbackDouble(this.actualVarName, this.OnTargetValueChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_LocaleChanged, this.OnLocaleChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinValueChanged, this.OnCoinValueChanged, this);
    XT.RegisterCallbackBool(Vars.HasCoins, this.OnHasCoinsChanged, this)
};
ValueDisplayer.prototype.OnDestroy = function() {
    XT.UnregisterCallbackDouble(this.OnTargetValueChanged, this)
};
ValueDisplayer.prototype.OnTargetValueChanged = function(newVal) {
    if (this.label.DOGchars == null && LocaleManager.isInit) this.label.DOGchars = this.GetDOGchars();
    newVal *= this.multiplier;
    this.MarkAsLastModifierForLabel();
    var oldText = this.label.text;
    if (this.isDisplayingCoins && this.GetHasCoins()) this.label.text = CoinManager.ConvertMoneyToCoins(newVal);
    else if (this.isDisplayingDecimals) {
        var oHasCurrency = this.formatOptions.hasCurrency;
        if (typeof this.label.fontName == "object")
            for (var i = 0; i < LocaleManager.currencyInfo.CurrencySymbol.length; i++)
                if (this.label.fontName.chars.indexOf(LocaleManager.currencyInfo.CurrencySymbol[i]) ==
                    -1) {
                    this.formatOptions.hasCurrency = false;
                    break
                }
        this.label.text = LocaleManager.FormatValue(newVal, this.formatOptions);
        this.formatOptions.hasCurrency = oHasCurrency
    } else this.label.text = (newVal | 0).toString();
    this.StartAnimEventIfNeeded(this.callEventWhenValueChanged && this.callEventWhenValueChangedAllowed, oldText.toString())
};
ValueDisplayer.prototype.OnLocaleChanged = function() {
    this.label.DOGchars = this.GetDOGchars();
    if (this.isDisplayingCoins && this.GetHasCoins()) return;
    if (!this.isLastOneToChangeTheLabel) return;
    LocaleManager.ApplyFontToLabel(this.formatOptions.fontId, this.label);
    this.OnTargetValueChanged(this.GetTargetValue())
};
ValueDisplayer.prototype.OnCoinValueChanged = function() {
    if (!this.isDisplayingCoins || !this.GetHasCoins()) return;
    if (!this.isLastOneToChangeTheLabel) return;
    this.OnTargetValueChanged(this.GetTargetValue())
};
ValueDisplayer.prototype.OnHasCoinsChanged = function(unused) {
    if (!this.isLastOneToChangeTheLabel) return;
    this.OnTargetValueChanged(this.GetTargetValue())
};
ValueDisplayer.prototype.StartAnimEventIfNeeded = function(canStart, oldText) {
    if (canStart && this.label.gameObject.activeInHierarchy && !this.catEventAnimation.IsRunning() && this.label.text != oldText) this.catEventAnimation.Start()
};
ValueDisplayer.prototype.GetHasCoins = function() {
    if (this.forceHasCoins) return true;
    return XT.GetBool(Vars.HasCoins)
};
ValueDisplayer.prototype.IsManualValue = function() {
    return _string.IsNullOrEmpty(this.actualVarName) || this.actualVarName == "*None*"
};
ValueDisplayer.prototype.GetTargetValue = function() {
    return this.IsManualValue() ? this.manualValue : XT.GetDouble(this.actualVarName)
};
ValueDisplayer.prototype.GetInternalValue = function() {
    return this.GetTargetValue()
};
ValueDisplayer.prototype.SetValueManually = function(newVal) {
    this.manualValue = newVal;
    this.OnTargetValueChanged(newVal)
};
ValueDisplayer.prototype.Awake = function() {
    XTLink.prototype.Awake.call(this);
    if (!this.allowDOG) return;
    this.label.isDOG = true;
    this.label.DOGmonospaceDigits = this.animated;
    if (LocaleManager.isInit) this.label.DOGchars = this.GetDOGchars()
};
ValueDisplayer.prototype.GetDOGchars = function() {
    var ret = " ,.0123456789";
    if (this.isDisplayingDecimals)
        if (this.formatOptions.hasJackpotCurrency) ret += LocaleManager.jackpotCurrencyInfo.CurrencySymbol;
        else ret += LocaleManager.currencyInfo.CurrencySymbol;
    return ret
};
goog.require("UHT.UHTEngine");
ValueMultiplierFX.prototype = Object.create(Component.prototype);
ValueMultiplierFX.prototype.constructor = ValueMultiplierFX;

function ValueMultiplierFX() {
    Component.call(this);
    this.fx = null;
    this.fxDurations = null;
    this.affectedMultipliers = null;
    this.startFXTime = [];
    this.curFXIndex = -1;
    this.minX = 2
}
ValueMultiplierFX.prototype.ComputeStartFXTime = function(baseValue, oldValue, newValue, animationTime) {
    this.startFXTime.splice(0);
    var deltaValue = newValue - oldValue;
    var maxX = Math.floor(newValue / baseValue);
    var deltaX = maxX - this.minX;
    var startXTime = (baseValue - oldValue) / deltaValue * animationTime;
    var oneXTime = 0;
    if (deltaX > 0) oneXTime = 1 / deltaX * ((baseValue * maxX - baseValue) / deltaValue * animationTime);
    for (var i = 0; i <= deltaX; ++i)
        if (this.affectedMultipliers.length == 0 || this.affectedMultipliers.indexOf(i + this.minX) > -1) this.startFXTime.push(oneXTime *
            i + startXTime - this.fxDurations[UHTMath.clamp(i, 0, this.fxDurations.length - 1)]);
    this.curFXIndex = this.startFXTime.length > 0 ? 0 : -1
};
ValueMultiplierFX.prototype.StartFX = function() {
    var strX = String(this.affectedMultipliers.length == 0 ? this.curFXIndex + this.minX : this.affectedMultipliers[this.curFXIndex]);
    for (var i = 0; i < this.fx.length; ++i)
        if (this.fx[i].TryStartFX(strX, this.curFXIndex)) break;
    this.curFXIndex++;
    if (this.curFXIndex >= this.startFXTime.length) this.curFXIndex = -1
};
goog.require("UHT.XTLink");
VS_MusicDuckByOneShot.prototype = Object.create(XTLink.prototype);
VS_MusicDuckByOneShot.prototype.constructor = VS_MusicDuckByOneShot;

function VS_MusicDuckByOneShot() {
    XTLink.call(this);
    this.oneShotDuckers = null;
    this.winCounter = null;
    this.soundManager = null;
    this.musicLogic = null
}
VS_MusicDuckByOneShot.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.SoundManagerObject, this.OnSoundManagerObject, this);
    XT.RegisterCallbackObject(Vars.MusicLogicObject, this.OnMusicLogicObject, this);
    XT.RegisterCallbackBool(Vars.LastWinIsCounting, this.OnLastWinCountingChanged, this)
};
VS_MusicDuckByOneShot.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.MusicDuckByOneShotObject, this);
    this.oneShotDuckers.push(this.winCounter)
};
VS_MusicDuckByOneShot.prototype.OnLastWinCountingChanged = function(counting) {
    if (counting) this.OneShotStartsPlaying(null, true);
    else this.OneShotStartsPlaying(null, false)
};
VS_MusicDuckByOneShot.prototype.OnSoundManagerObject = function(sMgr) {
    this.soundManager = sMgr
};
VS_MusicDuckByOneShot.prototype.OnMusicLogicObject = function(mLogic) {
    this.musicLogic = mLogic
};
VS_MusicDuckByOneShot.prototype.OneShotStartsPlaying = function(sound, duck) {
    if (this.soundManager == null) return;
    var isWinCounterDucking = sound == null;
    for (var i = isWinCounterDucking ? this.oneShotDuckers.length - 1 : 0; i < this.oneShotDuckers.length - (isWinCounterDucking ? 0 : 1); i++)
        if (isWinCounterDucking || this.oneShotDuckers[i].oneShotsClips.indexOf(sound) != -1) {
            var j;
            var useFading;
            for (j = 0; j < this.oneShotDuckers[i].musicClipsToDuck.length; j++) {
                var mClip = null;
                if (this.musicLogic != null) mClip = this.musicLogic.GetMusicClipByAudioClip(this.oneShotDuckers[i].musicClipsToDuck[j]);
                if (mClip == null) mClip = this.soundManager.GetMusicClipByAudioClip(this.oneShotDuckers[i].musicClipsToDuck[j]);
                if (mClip == null) {
                    this.oneShotDuckers[i].musicClipsToDuck.splice(j--, 1);
                    continue
                }
                useFading = this.oneShotDuckers[i].duckInDuration > 0 || this.oneShotDuckers[i].duckOutDuration > 0;
                if (useFading) {
                    mClip.duckingSteps[this.oneShotDuckers[i].duckingStep].fadeInDuration = this.oneShotDuckers[i].duckInDuration;
                    mClip.duckingSteps[this.oneShotDuckers[i].duckingStep].fadeOutDuration = this.oneShotDuckers[i].duckOutDuration
                }
                if (duck) {
                    if (isWinCounterDucking ||
                        sound.length > this.oneShotDuckers[i].autoUnduckOffset) this.soundManager.DuckMusicClip(mClip, this.oneShotDuckers[i].duckingStep, isWinCounterDucking ? -1 : sound.length - this.oneShotDuckers[i].autoUnduckOffset, useFading)
                } else this.soundManager.UnduckMusicClip(mClip, this.oneShotDuckers[i].duckingStep, useFading)
            }
            for (j = 0; j < this.oneShotDuckers[i].loopingClipsToDuck.length; j++) {
                var lClip = null;
                if (this.musicLogic != null) lClip = this.musicLogic.GetLoopingClipByAudioClip(this.oneShotDuckers[i].loopingClipsToDuck[j]);
                if (lClip == null) lClip = this.soundManager.GetLoopingClipByAudioClip(this.oneShotDuckers[i].loopingClipsToDuck[j]);
                if (lClip == null) {
                    this.oneShotDuckers[i].loopingClipsToDuck.splice(j--, 1);
                    continue
                }
                useFading = this.oneShotDuckers[i].duckInDuration > 0 || this.oneShotDuckers[i].duckOutDuration > 0;
                if (useFading) {
                    lClip.duckingSteps[this.oneShotDuckers[i].duckingStep].fadeInDuration = this.oneShotDuckers[i].duckInDuration;
                    lClip.duckingSteps[this.oneShotDuckers[i].duckingStep].fadeOutDuration = this.oneShotDuckers[i].duckOutDuration
                }
                if (duck) {
                    if (isWinCounterDucking ||
                        sound.length > this.oneShotDuckers[i].autoUnduckOffset) this.soundManager.DuckLoopingClip(lClip, this.oneShotDuckers[i].duckingStep, isWinCounterDucking ? -1 : sound.length - this.oneShotDuckers[i].autoUnduckOffset, useFading)
                } else this.soundManager.UnduckLoopingClip(lClip, this.oneShotDuckers[i].duckingStep, useFading)
            }
        }
};

function SoundAndMusicList() {
    this.oneShotsClips = null;
    this.musicClipsToDuck = null;
    this.loopingClipsToDuck = null;
    this.duckingStep = 0;
    this.autoUnduckOffset = 0;
    this.duckInDuration = -1;
    this.duckOutDuration = -1
}
goog.require("UHT.XTLink");
VS_OneShotCooldown.prototype = Object.create(XTLink.prototype);
VS_OneShotCooldown.prototype.constructor = VS_OneShotCooldown;

function VS_OneShotCooldown() {
    XTLink.call(this);
    this.clipsWithCooldown = null
}
VS_OneShotCooldown.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.OneShotCooldownObject, this)
};
VS_OneShotCooldown.prototype.IsOnCooldown = function(clip) {
    for (var i = 0; i < this.clipsWithCooldown.length; i++)
        if (this.clipsWithCooldown[i].clip == clip) {
            var onCooldown = this.clipsWithCooldown[i].cooldownTimer > 0;
            if (!onCooldown) this.clipsWithCooldown[i].cooldownTimer = this.clipsWithCooldown[i].cooldown;
            return onCooldown
        }
    return false
};
VS_OneShotCooldown.prototype.ResetClipCooldown = function(clipIndex) {
    this.clipsWithCooldown[clipIndex].cooldownTimer = -1
};
VS_OneShotCooldown.prototype.Update = function() {
    for (var i = 0; i < this.clipsWithCooldown.length; i++) this.clipsWithCooldown[i].UpdateTimer()
};

function CooldownOneShot() {
    this.clip = null;
    this.cooldown = 0;
    this.cooldownTimer = -1
}
CooldownOneShot.prototype.UpdateTimer = function() {
    if (this.cooldownTimer > 0) this.cooldownTimer -= Time.deltaTime
};
goog.provide("UHT.SoundManager");
goog.require("UHT.System.Misc.Utils");
goog.require("UHT.XTLink");
goog.require("UHT.AudioSource");
goog.require("UHT.AudioClip");
SoundManager.prototype = Object.create(XTLink.prototype);
SoundManager.prototype.constructor = SoundManager;
var MusicEmitterState = {
    Free: 0,
    InUse: 1
};

function SoundManager() {
    XTLink.call(this);
    this.playOneShotSource = null;
    this.fadeDuration = .5;
    this.musicSoundSource = [];
    this.loopingSources = [];
    this.AllowDuckingInTurboSpin = false;
    this.musicClips = [];
    this.loopingClips = [];
    this.duckByOneShot = null;
    this.oneShotCooldown = null;
    this.volumeFX = 1;
    this.volumeMusic = 1;
    this.internalVolumeMusic = 1;
    this.internalVolumeFX = 1;
    this.initDone = false;
    this.nextFreeMusicHandler = 0;
    this.nextFreeLoopingHandler = 0
}
SoundManager.InvalidSoundHandle = -1;
SoundManager.forcedMute = false;
SoundManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Init_SoundManager, this.OnSoundManagerInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_SoundBtn, this.OnSoundPressed, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_SoundFXBtn, this.OnSoundFXPressed, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_MusicBtn, this.OnMusicPressed, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SoundStateChanged, this.OnSoundStateChanged, this);
    XT.RegisterCallbackObject(Vars.MusicDuckByOneShotObject, this.OnMusicDuckByOneShotObject, this);
    XT.RegisterCallbackObject(Vars.OneShotCooldownObject, this.OnOneShotCooldownObject, this)
};
SoundManager.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.SoundManagerObject, this)
};
SoundManager.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnSoundManagerInit, this);
    XT.UnregisterCallbackEvent(this.OnSoundStateChanged, this);
    XT.UnregisterCallbackEvent(this.OnSoundPressed, this);
    XT.UnregisterCallbackEvent(this.OnSoundFXPressed, this);
    XT.UnregisterCallbackEvent(this.OnMusicPressed, this);
    XT.UnregisterCallbackObject(this.OnMusicDuckByOneShotObject, this)
};
SoundManager.prototype.OnMusicDuckByOneShotObject = function(OSDucker) {
    this.duckByOneShot = OSDucker
};
SoundManager.prototype.OnOneShotCooldownObject = function(OSCooler) {
    this.oneShotCooldown = OSCooler
};
SoundManager.prototype.OnMusicPressed = function() {
    var sndState = XT.GetObject(Vars.SoundState);
    sndState.oldMusicIsOn = sndState.musicIsOn;
    sndState.musicIsOn = !sndState.musicIsOn;
    sndState.gameSoundIsOn = sndState.musicIsOn || sndState.soundFXIsOn;
    XT.SetBool(Vars.MusicIsOn, sndState.musicIsOn);
    XT.SetObject(Vars.SoundState, sndState);
    XT.TriggerEvent(Vars.Evt_Internal_SoundStateChanged);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
};
SoundManager.prototype.OnSoundFXPressed = function() {
    var sndState = XT.GetObject(Vars.SoundState);
    sndState.oldSoundFXIsOn = sndState.soundFXIsOn;
    sndState.soundFXIsOn = !sndState.soundFXIsOn;
    sndState.gameSoundIsOn = sndState.musicIsOn || sndState.soundFXIsOn;
    XT.SetObject(Vars.SoundState, sndState);
    XT.TriggerEvent(Vars.Evt_Internal_SoundStateChanged);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
};
SoundManager.prototype.OnSoundPressed = function() {
    var sndState = XT.GetObject(Vars.SoundState);
    if (SoundManager.forcedMute)
        if (!sndState.gameSoundIsOn) return;
    sndState.gameSoundIsOn = !sndState.gameSoundIsOn;
    if (sndState.gameSoundIsOn) {
        sndState.musicIsOn = sndState.oldMusicIsOn;
        sndState.soundFXIsOn = sndState.oldSoundFXIsOn
    } else {
        sndState.oldMusicIsOn = sndState.musicIsOn;
        sndState.oldSoundFXIsOn = sndState.soundFXIsOn;
        if (!sndState.musicIsOn && !sndState.soundFXIsOn) sndState.oldMusicIsOn = sndState.oldSoundFXIsOn = true;
        sndState.musicIsOn = false;
        sndState.soundFXIsOn = false
    }
    XT.SetBool(Vars.MusicIsOn, sndState.musicIsOn);
    XT.SetObject(Vars.SoundState, sndState);
    XT.TriggerEvent(Vars.Evt_Internal_SoundStateChanged);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
};
SoundManager.prototype.PlaySimple = function(sound) {
    if (this.oneShotCooldown != null && this.oneShotCooldown.IsOnCooldown(sound)) return;
    this.playOneShotSource.PlayOneShot(sound, UHTAudioListener.volume * this.volumeFX * this.internalVolumeFX);
    if (this.duckByOneShot != null)
        if (sound != null) this.duckByOneShot.OneShotStartsPlaying(sound, true)
};
SoundManager.prototype.PlayMusic = function(music) {
    if (music == null) return -1;
    var mClip = this.GetMusicClipByAudioClip(music);
    this.PlayMusicClip(mClip, true);
    return mClip.handler
};
SoundManager.prototype.GetMusicClipByAudioClip = function(clip) {
    if (clip == null) return null;
    var mClip = null;
    for (var i = 0; i < this.musicClips.length; i++)
        if (this.musicClips[i].clip == clip) {
            mClip = this.musicClips[i];
            break
        }
    if (mClip == null) {
        mClip = new MusicClip;
        mClip.maxVolume = 1;
        mClip.volumeFadeInDuration = this.fadeDuration;
        mClip.volumeFadeOutDuration = this.fadeDuration;
        mClip.clip = clip
    }
    return mClip
};
SoundManager.prototype.RestartMusic = function() {
    for (var handler = 0; handler < this.musicClips.length; handler++)
        if (this.musicClips[handler].isPlaying && this.musicSoundSource[handler].clip != null) this.musicSoundSource[handler].Play()
};
SoundManager.prototype.StopMusic = function(args) {
    for (var i = 0; i < this.musicClips.length; i++)
        if (this.musicClips[i].handler == args.handle) this.StopMusicClip(this.musicClips[i], true);
    args.handle = SoundManager.InvalidSoundHandle
};
SoundManager.prototype.PlayLooping = function(sound) {
    if (sound == null) return -1;
    var lClip = this.GetLoopingClipByAudioClip(sound);
    this.PlayLoopingClip(lClip, false);
    return lClip.handler
};
SoundManager.prototype.GetLoopingClipByAudioClip = function(sound) {
    if (sound == null) return null;
    var lClip = null;
    for (var i = 0; i < this.loopingClips.length; i++)
        if (this.loopingClips[i].clip == sound) {
            lClip = this.loopingClips[i];
            break
        }
    if (lClip == null) {
        lClip = new MusicClip;
        lClip.maxVolume = 1;
        lClip.volumeFadeInDuration = this.fadeDuration;
        lClip.volumeFadeOutDuration = this.fadeDuration;
        lClip.clip = sound
    }
    return lClip
};
SoundManager.prototype.StopLoopingSound = function(args) {
    for (var i = 0; i < this.loopingClips.length; i++)
        if (this.loopingClips[i].handler == args.handle) this.StopLoopingClip(this.loopingClips[i], false);
    args.handle = SoundManager.InvalidSoundHandle
};
SoundManager.prototype.MuteMusic = function() {
    this.internalVolumeMusic = 0;
    XT.TriggerEvent(Vars.Evt_Internal_MuteMusic)
};
SoundManager.prototype.UnmuteMusic = function() {
    this.internalVolumeMusic = 1;
    XT.TriggerEvent(Vars.Evt_Internal_UnmuteMusic)
};
SoundManager.prototype.MuteSoundFX = function() {
    this.internalVolumeFX = 0;
    this.UpdateSoundEmittersVolume()
};
SoundManager.prototype.UnmuteSoundFX = function() {
    this.internalVolumeFX = 1;
    this.UpdateSoundEmittersVolume()
};
SoundManager.prototype.MuteLoopingSound = function(handle) {
    for (var i = 0; i < this.loopingClips.length; i++)
        if (this.loopingClips[i].handler == handle) this.MuteLoopingClip(this.loopingClips[i], false)
};
SoundManager.prototype.UnmuteLoopingSound = function(handle) {
    for (var i = 0; i < this.loopingClips.length; i++)
        if (this.loopingClips[i].handler == handle) this.UnmuteLoopingClip(this.loopingClips[i], false)
};
SoundManager.prototype.OnSoundManagerInit = function() {
    this.initDone = true;
    this.OnSoundStateChanged()
};
SoundManager.prototype.OnSoundStateChanged = function() {
    if (!this.initDone) return;
    var sndState = XT.GetObject(Vars.SoundState);
    this.volumeFX = 1;
    this.volumeMusic = 1;
    if (!sndState.globalSoundIsOn || !sndState.gameSoundIsOn) this.volumeFX = this.volumeMusic = 0;
    if (!sndState.soundFXIsOn) this.volumeFX = 0;
    if (!sndState.musicIsOn) this.volumeMusic = 0;
    this.UpdateSoundEmittersVolume()
};
SoundManager.prototype.UpdateSoundEmittersVolume = function() {
    this.playOneShotSource.volume = this.volumeFX * this.internalVolumeFX
};
SoundManager.prototype.PrepareNewMusicClip = function(mClip) {
    var handler = -1;
    if (this.nextFreeMusicHandler < this.musicSoundSource.length) handler = this.nextFreeMusicHandler;
    else handler = this.GetNewMusicSource();
    this.nextFreeMusicHandler++;
    this.musicSoundSource[handler].clip = mClip.clip;
    this.musicSoundSource[handler].loop = true;
    mClip.handler = handler;
    this.musicClips.push(mClip)
};
SoundManager.prototype.PrepareNewLoopingClip = function(lClip) {
    var handler = -1;
    if (this.nextFreeLoopingHandler < this.loopingSources.length) handler = this.nextFreeLoopingHandler;
    else handler = this.GetNewLoopingSource();
    this.nextFreeLoopingHandler++;
    this.loopingSources[handler].clip = lClip.clip;
    this.loopingSources[handler].loop = true;
    lClip.handler = handler;
    this.loopingClips.push(lClip)
};
SoundManager.prototype.GetNewMusicSource = function() {
    var newMusicSource = instantiate(this.musicSoundSource[0].gameObject);
    newMusicSource.name = "MusicSoundSource" + this.musicSoundSource.length;
    newMusicSource.audio = newMusicSource.GetComponent(AudioSource);
    newMusicSource.audio.playOnAwake = false;
    newMusicSource.transform.SetParent(this.transform, true);
    this.musicSoundSource.push(newMusicSource.audio);
    return this.musicSoundSource.length - 1
};
SoundManager.prototype.GetNewLoopingSource = function() {
    var newLoopingSource = instantiate(this.loopingSources[0].gameObject);
    newLoopingSource.name = "LoopingSource" + this.loopingSources.length;
    newLoopingSource.audio = newLoopingSource.GetComponent(AudioSource);
    newLoopingSource.audio.playOnAwake = false;
    newLoopingSource.transform.SetParent(this.transform, true);
    this.loopingSources.push(newLoopingSource.audio);
    return this.loopingSources.length - 1
};
SoundManager.prototype.PlayMusicClip = function(musicClip, useFading) {
    if (musicClip.handler == SoundManager.InvalidSoundHandle) this.PrepareNewMusicClip(musicClip);
    if (musicClip.isPlaying) return;
    musicClip.isPlaying = true;
    this.musicSoundSource[musicClip.handler].volume = 0;
    if (!musicClip.isMuted)
        if (useFading && musicClip.volumeFadeInDuration > 0) {
            musicClip.volumeLevel = 0;
            musicClip.volumeState = MusicVolumeState.fadingIn;
            musicClip.currentCurveTime = 0
        } else {
            musicClip.volumeLevel = 1;
            musicClip.volumeState = MusicVolumeState.idle;
            if (XT.GetBool(Vars.MusicIsOn)) this.musicSoundSource[musicClip.handler].volume = musicClip.GetVolume() * this.internalVolumeMusic
        }
    if (musicClip.clip != null) this.musicSoundSource[musicClip.handler].Play()
};
SoundManager.prototype.StopMusicClip = function(musicClip, useFading) {
    if (musicClip.handler == SoundManager.InvalidSoundHandle) this.PrepareNewMusicClip(musicClip);
    musicClip.isPlaying = false;
    if (useFading && musicClip.volumeFadeOutDuration > 0) musicClip.volumeState = MusicVolumeState.fadingOut;
    else {
        this.musicSoundSource[musicClip.handler].volume = 0;
        this.musicSoundSource[musicClip.handler].Stop();
        musicClip.volumeLevel = 0;
        musicClip.currentCurveTime = 0;
        musicClip.volumeState = MusicVolumeState.idle
    }
};
SoundManager.prototype.MuteMusicClip = function(musicClip, useFading) {
    if (musicClip.handler == SoundManager.InvalidSoundHandle) this.PrepareNewMusicClip(musicClip);
    musicClip.isMuted = true;
    if (useFading && musicClip.volumeFadeOutDuration > 0) musicClip.volumeState = MusicVolumeState.fadingOut;
    else {
        this.musicSoundSource[musicClip.handler].volume = 0;
        musicClip.volumeState = MusicVolumeState.idle;
        musicClip.volumeLevel = 0;
        musicClip.currentCurveTime = 0
    }
};
SoundManager.prototype.UnmuteMusicClip = function(musicClip, useFading) {
    if (musicClip.handler == SoundManager.InvalidSoundHandle) this.PrepareNewMusicClip(musicClip);
    musicClip.isMuted = false;
    if (useFading && musicClip.volumeFadeInDuration > 0) musicClip.volumeState = MusicVolumeState.fadingIn;
    else {
        musicClip.volumeLevel = 1;
        musicClip.volumeState = MusicVolumeState.idle;
        if (XT.GetBool(Vars.MusicIsOn)) this.musicSoundSource[musicClip.handler].volume = musicClip.GetVolume() * this.internalVolumeMusic
    }
};
SoundManager.prototype.DuckMusicClip = function(musicClip, duckingStepIndex, delayToAutoUnduck, useFading) {
    if (!this.AllowDuckingInTurboSpin)
        if (XT.GetBool(Vars.ContinuousSpin)) return;
    if (musicClip.handler == SoundManager.InvalidSoundHandle) this.PrepareNewMusicClip(musicClip);
    if (delayToAutoUnduck > 0) {
        if (!musicClip.duckingSteps[duckingStepIndex].autoUnduck) {
            musicClip.duckingSteps[duckingStepIndex].autoUnduck = true;
            musicClip.duckingSteps[duckingStepIndex].duckCount++
        }
        if (delayToAutoUnduck > musicClip.duckingSteps[duckingStepIndex].autoUnduckTimer) {
            musicClip.duckingSteps[duckingStepIndex].autoUnduckShouldFade =
                useFading && musicClip.duckingSteps[duckingStepIndex].fadeOutDuration > 0;
            musicClip.duckingSteps[duckingStepIndex].autoUnduckTimer = delayToAutoUnduck
        }
    } else musicClip.duckingSteps[duckingStepIndex].duckCount++;
    musicClip.UpdateDuckingStepPriority();
    if (useFading && musicClip.duckingSteps[duckingStepIndex].fadeInDuration > 0) {
        musicClip.duckingFadeInDuration = musicClip.duckingSteps[duckingStepIndex].fadeInDuration;
        musicClip.duckingState = MusicVolumeState.fadingIn
    } else {
        musicClip.duckingVolume = musicClip.duckingSteps[musicClip.priorityDuckingStepIndex].targetVolume;
        musicClip.duckingState = MusicVolumeState.idle;
        if (XT.GetBool(Vars.MusicIsOn)) this.musicSoundSource[musicClip.handler].volume = musicClip.GetVolume() * this.internalVolumeMusic
    }
};
SoundManager.prototype.UnduckMusicClip = function(musicClip, duckingStepIndex, useFading) {
    if (musicClip.handler == SoundManager.InvalidSoundHandle) this.PrepareNewMusicClip(musicClip);
    if (musicClip.duckingSteps[duckingStepIndex].duckCount > 0) {
        if (musicClip.duckingSteps[duckingStepIndex].duckCount == 1 && musicClip.duckingSteps[duckingStepIndex].autoUnduck) return;
        musicClip.duckingSteps[duckingStepIndex].duckCount--;
        if (musicClip.duckingSteps[duckingStepIndex].duckCount > 0) return
    }
    musicClip.UpdateDuckingStepPriority();
    if (useFading && musicClip.duckingSteps[duckingStepIndex].fadeOutDuration > 0)
        if (musicClip.priorityDuckingStepIndex == -1) {
            musicClip.duckingFadeOutDuration = musicClip.duckingSteps[duckingStepIndex].fadeOutDuration;
            musicClip.duckingState = MusicVolumeState.fadingOut
        } else {
            musicClip.duckingFadeInDuration = musicClip.duckingSteps[duckingStepIndex].fadeInDuration;
            musicClip.duckingFadeOutDuration = musicClip.duckingSteps[duckingStepIndex].fadeOutDuration;
            musicClip.duckingState = MusicVolumeState.fadingIn
        }
    else {
        if (musicClip.priorityDuckingStepIndex ==
            -1) musicClip.duckingVolume = 1;
        else musicClip.duckingVolume = musicClip.duckingSteps[musicClip.priorityDuckingStepIndex].targetVolume;
        musicClip.duckingState = MusicVolumeState.idle;
        if (XT.GetBool(Vars.MusicIsOn)) this.musicSoundSource[musicClip.handler].volume = musicClip.GetVolume() * this.internalVolumeMusic
    }
};
SoundManager.prototype.PlayLoopingClip = function(loopingClip, useFading) {
    if (loopingClip.handler == SoundManager.InvalidSoundHandle) this.PrepareNewLoopingClip(loopingClip);
    if (loopingClip.isPlaying) return;
    loopingClip.isPlaying = true;
    this.loopingSources[loopingClip.handler].volume = 0;
    if (!loopingClip.isMuted)
        if (useFading && loopingClip.volumeFadeInDuration > 0) {
            loopingClip.volumeLevel = 0;
            loopingClip.volumeState = MusicVolumeState.fadingIn
        } else {
            loopingClip.volumeLevel = 1;
            loopingClip.volumeState = MusicVolumeState.idle;
            var sndState = XT.GetObject(Vars.SoundState);
            if (sndState.soundFXIsOn) this.loopingSources[loopingClip.handler].volume = loopingClip.GetVolume() * this.internalVolumeFX
        }
    if (loopingClip.clip != null) this.loopingSources[loopingClip.handler].Play()
};
SoundManager.prototype.StopLoopingClip = function(loopingClip, useFading) {
    if (loopingClip.handler == SoundManager.InvalidSoundHandle) this.PrepareNewLoopingClip(loopingClip);
    loopingClip.isPlaying = false;
    if (useFading && loopingClip.volumeFadeOutDuration > 0) loopingClip.volumeState = MusicVolumeState.fadingOut;
    else {
        this.loopingSources[loopingClip.handler].volume = 0;
        this.loopingSources[loopingClip.handler].Stop();
        loopingClip.volumeLevel = 0;
        loopingClip.volumeState = MusicVolumeState.idle
    }
};
SoundManager.prototype.MuteLoopingClip = function(loopingClip, useFading) {
    if (loopingClip.handler == SoundManager.InvalidSoundHandle) this.PrepareNewLoopingClip(loopingClip);
    loopingClip.isMuted = true;
    if (useFading && loopingClip.volumeFadeOutDuration > 0) loopingClip.volumeState = MusicVolumeState.fadingOut;
    else {
        this.loopingSources[loopingClip.handler].volume = 0;
        loopingClip.volumeState = MusicVolumeState.idle;
        loopingClip.volumeLevel = 0
    }
};
SoundManager.prototype.UnmuteLoopingClip = function(loopingClip, useFading) {
    if (loopingClip.handler == SoundManager.InvalidSoundHandle) this.PrepareNewLoopingClip(loopingClip);
    loopingClip.isMuted = false;
    if (useFading && loopingClip.volumeFadeInDuration > 0) loopingClip.volumeState = MusicVolumeState.fadingIn;
    else {
        loopingClip.volumeLevel = 1;
        loopingClip.volumeState = MusicVolumeState.idle;
        var sndState = XT.GetObject(Vars.SoundState);
        if (sndState.soundFXIsOn) this.loopingSources[loopingClip.handler].volume = loopingClip.GetVolume() *
            this.internalVolumeFX
    }
};
SoundManager.prototype.DuckLoopingClip = function(loopingClip, duckingStepIndex, delayToAutoUnduck, useFading) {
    if (loopingClip.handler == SoundManager.InvalidSoundHandle) this.PrepareNewLoopingClip(loopingClip);
    if (delayToAutoUnduck > 0) {
        if (!loopingClip.duckingSteps[duckingStepIndex].autoUnduck) {
            loopingClip.duckingSteps[duckingStepIndex].autoUnduck = true;
            loopingClip.duckingSteps[duckingStepIndex].duckCount++
        }
        if (delayToAutoUnduck > loopingClip.duckingSteps[duckingStepIndex].autoUnduckTimer) {
            loopingClip.duckingSteps[duckingStepIndex].autoUnduckShouldFade = useFading &&
                loopingClip.duckingSteps[duckingStepIndex].fadeOutDuration > 0;
            loopingClip.duckingSteps[duckingStepIndex].autoUnduckTimer = delayToAutoUnduck
        }
    } else loopingClip.duckingSteps[duckingStepIndex].duckCount++;
    loopingClip.UpdateDuckingStepPriority();
    if (useFading && loopingClip.duckingSteps[duckingStepIndex].fadeInDuration > 0) {
        loopingClip.duckingFadeInDuration = loopingClip.duckingSteps[duckingStepIndex].fadeInDuration;
        loopingClip.duckingState = MusicVolumeState.fadingIn
    } else {
        loopingClip.duckingVolume = loopingClip.duckingSteps[loopingClip.priorityDuckingStepIndex].targetVolume;
        loopingClip.duckingState = MusicVolumeState.idle;
        var sndState = XT.GetObject(Vars.SoundState);
        if (sndState.soundFXIsOn) this.loopingSources[loopingClip.handler].volume = loopingClip.GetVolume() * this.internalVolumeFX
    }
};
SoundManager.prototype.UnduckLoopingClip = function(loopingClip, duckingStepIndex, useFading) {
    if (loopingClip.handler == SoundManager.InvalidSoundHandle) this.PrepareNewLoopingClip(loopingClip);
    if (loopingClip.duckingSteps[duckingStepIndex].duckCount > 0) {
        if (loopingClip.duckingSteps[duckingStepIndex].duckCount == 1 && loopingClip.duckingSteps[duckingStepIndex].autoUnduck) return;
        loopingClip.duckingSteps[duckingStepIndex].duckCount--;
        if (loopingClip.duckingSteps[duckingStepIndex].duckCount > 0) return
    }
    loopingClip.UpdateDuckingStepPriority();
    if (useFading && loopingClip.duckingSteps[duckingStepIndex].fadeOutDuration > 0)
        if (loopingClip.priorityDuckingStepIndex == -1) {
            loopingClip.duckingFadeOutDuration = loopingClip.duckingSteps[duckingStepIndex].fadeOutDuration;
            loopingClip.duckingState = MusicVolumeState.fadingOut
        } else {
            loopingClip.duckingFadeInDuration = loopingClip.duckingSteps[duckingStepIndex].fadeInDuration;
            loopingClip.duckingFadeOutDuration = loopingClip.duckingSteps[duckingStepIndex].fadeOutDuration;
            loopingClip.duckingState = MusicVolumeState.fadingIn
        }
    else {
        if (loopingClip.priorityDuckingStepIndex ==
            -1) loopingClip.duckingVolume = 1;
        else loopingClip.duckingVolume = loopingClip.duckingSteps[loopingClip.priorityDuckingStepIndex].targetVolume;
        loopingClip.duckingState = MusicVolumeState.idle;
        var sndState = XT.GetObject(Vars.SoundState);
        if (sndState.soundFXIsOn) this.loopingSources[loopingClip.handler].volume = loopingClip.GetVolume() * this.internalVolumeFX
    }
};
SoundManager.prototype.UpdateMusicVolume = function() {
    for (var i = 0; i < this.musicClips.length; i++)
        if (this.musicSoundSource[this.musicClips[i].handler].volume != this.musicClips[i].GetVolume() * this.volumeMusic * this.internalVolumeMusic) this.musicSoundSource[this.musicClips[i].handler].volume = this.musicClips[i].GetVolume() * this.volumeMusic * this.internalVolumeMusic
};
SoundManager.prototype.UpdateLoopingClipsVolume = function() {
    for (var i = 0; i < this.loopingClips.length; i++)
        if (this.loopingSources[this.loopingClips[i].handler].volume != this.loopingClips[i].GetVolume() * this.volumeFX * this.internalVolumeFX) this.loopingSources[this.loopingClips[i].handler].volume = this.loopingClips[i].GetVolume() * this.volumeFX * this.internalVolumeFX
};
SoundManager.prototype.ComputeMusicClipsVolume = function() {
    for (var i = 0; i < this.musicClips.length; i++) {
        if (this.musicClips[i].volumeState == MusicVolumeState.fadingIn) {
            if (this.musicClips[i].volumeLevel < 1)
                if (!this.musicClips[i].useFadeCurve) this.musicClips[i].volumeLevel += Time.deltaTime * (1 / this.musicClips[i].volumeFadeInDuration);
                else {
                    this.musicClips[i].currentCurveTime += Time.deltaTime * (1 / this.musicClips[i].volumeFadeInDuration);
                    var fNewVolume = this.musicClips[i].fadeCurve.Evaluate(this.musicClips[i].currentCurveTime);
                    this.musicClips[i].volumeLevel = fNewVolume == 1 ? 69 : fNewVolume
                }
            if (this.musicClips[i].volumeLevel >= 1) {
                this.musicClips[i].volumeLevel = 1;
                this.musicClips[i].volumeState = MusicVolumeState.idle;
                this.musicClips[i].currentCurveTime = 1
            }
        } else if (this.musicClips[i].volumeState == MusicVolumeState.fadingOut) {
            if (this.musicClips[i].volumeLevel > 0)
                if (!this.musicClips[i].useFadeCurve) this.musicClips[i].volumeLevel -= Time.deltaTime * (1 / this.musicClips[i].volumeFadeOutDuration);
                else {
                    this.musicClips[i].currentCurveTime -= Time.deltaTime *
                        (1 / this.musicClips[i].volumeFadeOutDuration);
                    var fNewVolume = this.musicClips[i].fadeCurve.Evaluate(this.musicClips[i].currentCurveTime);
                    this.musicClips[i].volumeLevel = fNewVolume == 0 ? -69 : fNewVolume
                }
            if (this.musicClips[i].volumeLevel <= 0) {
                this.musicClips[i].volumeLevel = 0;
                this.musicClips[i].volumeState = MusicVolumeState.idle;
                this.musicClips[i].currentCurveTime = 0;
                if (!this.musicClips[i].isPlaying) this.StopMusicClip(this.musicClips[i], false)
            }
        }
        for (var j = 0; j < this.musicClips[i].duckingSteps.length; j++)
            if (this.musicClips[i].duckingSteps[j].autoUnduck)
                if (this.musicClips[i].duckingSteps[j].autoUnduckTimer >
                    0) this.musicClips[i].duckingSteps[j].autoUnduckTimer -= Time.deltaTime;
                else {
                    this.musicClips[i].duckingSteps[j].autoUnduck = false;
                    this.UnduckMusicClip(this.musicClips[i], j, this.musicClips[i].duckingSteps[j].autoUnduckShouldFade)
                }
        if (this.musicClips[i].duckingState == MusicVolumeState.fadingIn)
            if (this.musicClips[i].duckingVolume < this.musicClips[i].duckingSteps[this.musicClips[i].priorityDuckingStepIndex].targetVolume) {
                this.musicClips[i].duckingVolume += Time.deltaTime * (1 / this.musicClips[i].duckingFadeOutDuration);
                if (this.musicClips[i].duckingVolume >= this.musicClips[i].duckingSteps[this.musicClips[i].priorityDuckingStepIndex].targetVolume) {
                    this.musicClips[i].duckingVolume = this.musicClips[i].duckingSteps[this.musicClips[i].priorityDuckingStepIndex].targetVolume;
                    this.musicClips[i].duckingState = MusicVolumeState.idle
                }
            } else {
                if (this.musicClips[i].duckingVolume > this.musicClips[i].duckingSteps[this.musicClips[i].priorityDuckingStepIndex].targetVolume) {
                    this.musicClips[i].duckingVolume -= Time.deltaTime * (1 / this.musicClips[i].duckingFadeInDuration);
                    if (this.musicClips[i].duckingVolume <= this.musicClips[i].duckingSteps[this.musicClips[i].priorityDuckingStepIndex].targetVolume) {
                        this.musicClips[i].duckingVolume = this.musicClips[i].duckingSteps[this.musicClips[i].priorityDuckingStepIndex].targetVolume;
                        this.musicClips[i].duckingState = MusicVolumeState.idle
                    }
                }
            }
        else if (this.musicClips[i].duckingState == MusicVolumeState.fadingOut) {
            if (this.musicClips[i].duckingVolume < 1) this.musicClips[i].duckingVolume += Time.deltaTime * (1 / this.musicClips[i].duckingFadeOutDuration);
            if (this.musicClips[i].duckingVolume >= 1) {
                this.musicClips[i].duckingVolume = 1;
                this.musicClips[i].duckingState = MusicVolumeState.idle
            }
        }
    }
};
SoundManager.prototype.ComputeLoopingClipsVolume = function() {
    for (var i = 0; i < this.loopingClips.length; i++) {
        if (this.loopingClips[i].volumeState == MusicVolumeState.fadingIn) {
            if (this.loopingClips[i].volumeLevel < 1) this.loopingClips[i].volumeLevel += Time.deltaTime * (1 / this.loopingClips[i].volumeFadeInDuration);
            if (this.loopingClips[i].volumeLevel >= 1) {
                this.loopingClips[i].volumeLevel = 1;
                this.loopingClips[i].volumeState = MusicVolumeState.idle
            }
        } else if (this.loopingClips[i].volumeState == MusicVolumeState.fadingOut) {
            if (this.loopingClips[i].volumeLevel >
                0) this.loopingClips[i].volumeLevel -= Time.deltaTime * (1 / this.loopingClips[i].volumeFadeOutDuration);
            if (this.loopingClips[i].volumeLevel <= 0) {
                this.loopingClips[i].volumeLevel = 0;
                this.loopingClips[i].volumeState = MusicVolumeState.idle;
                if (!this.loopingClips[i].isPlaying) this.StopLoopingClip(this.loopingClips[i], false)
            }
        }
        for (var j = 0; j < this.loopingClips[i].duckingSteps.length; j++)
            if (this.loopingClips[i].duckingSteps[j].autoUnduck)
                if (this.loopingClips[i].duckingSteps[j].autoUnduckTimer > 0) this.loopingClips[i].duckingSteps[j].autoUnduckTimer -=
                    Time.deltaTime;
                else {
                    this.loopingClips[i].duckingSteps[j].autoUnduck = false;
                    this.UnduckLoopingClip(this.loopingClips[i], j, this.loopingClips[i].duckingSteps[j].autoUnduckShouldFade)
                }
        if (this.loopingClips[i].duckingState == MusicVolumeState.fadingIn)
            if (this.loopingClips[i].duckingVolume < this.loopingClips[i].duckingSteps[this.loopingClips[i].priorityDuckingStepIndex].targetVolume) {
                this.loopingClips[i].duckingVolume += Time.deltaTime * (1 / this.loopingClips[i].duckingFadeOutDuration);
                if (this.loopingClips[i].duckingVolume >=
                    this.loopingClips[i].duckingSteps[this.loopingClips[i].priorityDuckingStepIndex].targetVolume) {
                    this.loopingClips[i].duckingVolume = this.loopingClips[i].duckingSteps[this.loopingClips[i].priorityDuckingStepIndex].targetVolume;
                    this.loopingClips[i].duckingState = MusicVolumeState.idle
                }
            } else {
                if (this.loopingClips[i].duckingVolume > this.loopingClips[i].duckingSteps[this.loopingClips[i].priorityDuckingStepIndex].targetVolume) {
                    this.loopingClips[i].duckingVolume -= Time.deltaTime * (1 / this.loopingClips[i].duckingFadeInDuration);
                    if (this.loopingClips[i].duckingVolume <= this.loopingClips[i].duckingSteps[this.loopingClips[i].priorityDuckingStepIndex].targetVolume) {
                        this.loopingClips[i].duckingVolume = this.loopingClips[i].duckingSteps[this.loopingClips[i].priorityDuckingStepIndex].targetVolume;
                        this.loopingClips[i].duckingState = MusicVolumeState.idle
                    }
                }
            }
        else if (this.loopingClips[i].duckingState == MusicVolumeState.fadingOut) {
            if (this.loopingClips[i].duckingVolume < 1) this.loopingClips[i].duckingVolume += Time.deltaTime * (1 / this.loopingClips[i].duckingFadeOutDuration);
            if (this.loopingClips[i].duckingVolume >= 1) {
                this.loopingClips[i].duckingVolume = 1;
                this.loopingClips[i].duckingState = MusicVolumeState.idle
            }
        }
    }
};
var BT_SoundTimerOn = 0;
var BT_SoundTimerOff = 0;
SoundManager.prototype.Update = function() {
    this.ComputeMusicClipsVolume();
    this.ComputeLoopingClipsVolume();
    this.UpdateMusicVolume();
    this.UpdateLoopingClipsVolume();
    if (SoundLoader.soundsAreLoaded) {
        var sndState = XT.GetObject(Vars.SoundState);
        if (sndState.gameSoundIsOn) BT_SoundTimerOn += Time.deltaTime;
        else BT_SoundTimerOff += Time.deltaTime;
        if (BT_SoundTimerOn + BT_SoundTimerOff > 60) {
            globalTracking.SendEvent("uht_behaviour", "SoundEnabled", BT_SoundTimerOn / (BT_SoundTimerOn + BT_SoundTimerOff), "BehaviourTracker");
            BT_SoundTimerOn =
                0;
            BT_SoundTimerOff = 0
        }
    }
};
goog.provide("UHT.SoundLoader");
goog.require("UHT.AudioClip");
goog.require("UHT.SoundManager");
var SoundHelper = {};
SoundHelper.AudioFormat = {
    none: "none",
    mp3: "mp3",
    ogg: "ogg"
};
SoundHelper.audioFormat = SoundHelper.AudioFormat.none;
SoundHelper.ParsePath = function(value) {
    var ret = {
        name: value,
        src: value,
        extension: SoundHelper.audioFormat
    };
    return ret
};
SoundHelper.wasTouchMove = false;
SoundHelper.OnTouchStart = function() {
    SoundHelper.wasTouchMove = false
};
SoundHelper.OnTouchMove = function() {
    SoundHelper.wasTouchMove = true
};
SoundHelper.OnIOSTouchEnd = function() {
    if (SoundHelper.wasTouchMove) return;
    var audioCtx = createjs.Sound.activePlugin.context;
    if (audioCtx.state == "interrupted" || audioCtx.state == "suspended") {
        console.warn("SoundHelper.OnIOSTouchEnd: state " + audioCtx.state);
        audioCtx.resume().then(function() {
            console.warn("SoundHelper.OnIOSTouchEnd: resumed context");
            XT.GetObject(Vars.SoundManagerObject).RestartMusic()
        })
    }
};
var SoundLoader = {};
SoundLoader.AudioProcessor = function(settings) {
    this.id = settings.id;
    this.url = settings.url;
    this.base64 = settings.base64;
    this.context = settings.context;
    this.handler = settings.handler;
    this.audioSource = null;
    this.state = SoundLoader.AudioState.none;
    this.nextToDecode = null
};
SoundLoader.AudioProcessor.prototype.ProcessWebAudio = function() {
    var instance = this;
    var binary = window.atob(this.base64);
    var base64AsArrayBuffer = new ArrayBuffer(binary.length);
    var bytes = new Uint8Array(base64AsArrayBuffer);
    for (var i = 0; i < base64AsArrayBuffer.byteLength; i++) bytes[i] = binary.charCodeAt(i) & 255;
    this.context.decodeAudioData(base64AsArrayBuffer, function(buffer) {
        instance.audioSource = buffer;
        instance.state = SoundLoader.AudioState.success;
        instance.handler.call(instance)
    }, function() {
        console.error("decode error: ",
            instance.id, instance.url);
        instance.state = SoundLoader.AudioState.error;
        instance.handler.call(instance)
    })
};
var alreadyLoadedBySize = {};
SoundLoader.AudioProcessor.prototype.ProcessHtmlAudio = function() {
    var sufix = "";
    if (SoundHelper.audioFormat == SoundHelper.AudioFormat.mp3) {
        if (alreadyLoadedBySize[this.base64.length] != undefined) sufix = alreadyLoadedBySize[this.base64.length] + "====";
        alreadyLoadedBySize[this.base64.length] = sufix
    }
    this.url = "data:audio/" + SoundHelper.audioFormat + ";base64," + this.base64 + sufix;
    var src = {};
    src[SoundHelper.audioFormat] = this.url;
    createjs.Sound.registerSound(src, this.id, undefined, "")
};
SoundLoader.AudioType = {
    none: "none",
    web: "web",
    html: "html"
};
SoundLoader.AudioState = {
    none: 0,
    success: 1,
    error: 2
};
SoundLoader.audioType = SoundLoader.AudioType.none;
SoundLoader.clips = [];
SoundLoader.processors = {};
SoundLoader.touchStartHandler = null;
SoundLoader.touchMoveHandler = null;
SoundLoader.touchEndHandler = null;
SoundLoader.initialized = false;
SoundLoader.numSounds = 0;
SoundLoader.numClips = 0;
SoundLoader.soundsAreBeingLoaded = false;
SoundLoader.soundsAreLoaded = false;
SoundLoader.checkLoadCompleteTimeout = null;
SoundLoader.numProcessingThreads = 4;
SoundLoader.packageList = [];
SoundLoader.packagesDownloaded = 0;
SoundLoader.sounds = [];
SoundLoader.DelayCheckLoadComplete = function() {
    if (SoundLoader.checkLoadCompleteTimeout != null) clearTimeout(SoundLoader.checkLoadCompleteTimeout);
    SoundLoader.checkLoadCompleteTimeout = setTimeout(SoundLoader.CheckLoadComplete, 200)
};
SoundLoader.LoadSound = function(clip) {
    SoundLoader.clips.push(clip);
    SoundLoader.numClips++
};
SoundLoader.OnSoundDecoded = function(processor) {
    if (processor.nextToDecode != null) processor.nextToDecode.ProcessWebAudio();
    if (processor.state != SoundLoader.AudioState.success) return;
    createjs.Sound._idHash[processor.id] = {
        src: processor.url
    };
    createjs.Sound.activePlugin._soundInstances[processor.url] = [];
    createjs.Sound.activePlugin._audioSources[processor.url] = processor.audioSource
};
var GA_SND_MOBILE_SENT = false;
SoundLoader.LoadSounds = function() {
    if (UHT_DEVICE_TYPE.DESKTOP == false && !GA_SND_MOBILE_SENT) {
        var timer = globalTracking.GetTimerValue("uht_behaviour", "Session_timer", "BehaviourTracker");
        globalTracking.SendEvent("uht_behaviour", "SND_MOBILE_download_started", timer, "BehaviourTracker");
        GA_SND_MOBILE_SENT = true
    }
    if (SoundHelper.audioFormat == SoundHelper.AudioFormat.none) return;
    SoundLoader.soundsAreBeingLoaded = true;
    if (UHT_PACKAGES_INFO_OBJ == null || globalGamePath == undefined) {
        setTimeout(SoundLoader.LoadSounds, 100);
        return
    }
    var info = UHT_PACKAGES_INFO_OBJ["languages"] || [];
    var language = UHT_GAME_CONFIG["LANGUAGE"];
    var filename = "sounds";
    if (language != "en") {
        var soundsLocalized = false;
        for (var i = 0; i < info.length; ++i)
            if (info[i]["language"] == language) {
                if (info[i]["sound"] == 1) {
                    filename += language;
                    soundsLocalized = true
                }
                break
            }
        if (!soundsLocalized) {
            var suffix = UHT_PACKAGES_INFO_OBJ["default_sound_suffix"] || "";
            filename += suffix
        }
    }
    filename += "." + SoundHelper.audioFormat;
    SoundLoader.packageList = [filename, "GUI_sounds." + SoundHelper.audioFormat];
    if (LoaderProgress.Sound_Download_Total == -1) {
        var sizes = {};
        var nameSizes = String(UHT_SOUNDS_SIZES).split(",");
        UHT_SOUNDS_SIZES = null;
        for (var i = 0; i < nameSizes.length; ++i) {
            var nameSize = nameSizes[i].split(":");
            if (nameSize.length > 1) sizes[nameSize[0].split("?")[0]] = nameSize[1];
            for (var pIdx = 0; pIdx < SoundLoader.packageList.length; pIdx++)
                if (nameSize[0].indexOf(SoundLoader.packageList[pIdx]) == 0) SoundLoader.packageList[pIdx] = nameSize[0]
        }
        Modules.LoadSounds(sizes);
        for (var i = 0; i < nameSizes.length; ++i) {
            var nameSize = nameSizes[i].split(":");
            for (var pIdx = 0; pIdx < SoundLoader.packageList.length; pIdx++)
                if (nameSize[0].indexOf(SoundLoader.packageList[pIdx]) == 0) SoundLoader.packageList[pIdx] = nameSize[0]
        }
        LoaderProgress.Sound_Download_Total = Number(sizes[filename])
    }
    for (var i = 0; i < SoundLoader.packageList.length; i++) new ResourceRequest({
        url: (globalGamePath || "") + SoundLoader.packageList[i].replace("?key=", ".json?key="),
        complete: new EventHandler(SoundLoader, SoundLoader.OnSoundsLoaded),
        onprogress: new EventHandler(SoundLoader, SoundLoader.OnSoundsProgress)
    })
};
SoundLoader.OnSoundsProgress = function(progress) {
    LoaderProgress.Sound_Download_Current = progress.loaded
};
SoundLoader.OnSoundsLoaded = function(req) {
    if (!_string.IsNullOrEmpty(req.error)) {
        console.error("SoundLoader - failed to load sounds: " + req.url + " " + req.error);
        setTimeout(SoundLoader.LoadSounds, 250);
        return
    }
    if (!SoundLoader.initialized) {
        setTimeout(function() {
            SoundLoader.OnSoundsLoaded(req)
        }, 200);
        return
    }
    LoaderProgress.Sound_Download_Current = LoaderProgress.Sound_Download_Total;
    var data = JSON.parse(req.Data);
    SoundLoader.sounds = SoundLoader.sounds.concat(data["sounds"]);
    SoundLoader.packagesDownloaded++;
    if (SoundLoader.packagesDownloaded !=
        SoundLoader.packageList.length) return;
    SoundLoader.numSounds += SoundLoader.sounds.length;
    var processAudioMethod = "ProcessWebAudio";
    if (SoundLoader.audioType == SoundLoader.AudioType.html) {
        processAudioMethod = "ProcessHtmlAudio";
        createjs.Sound.addEventListener("fileload", function(ev) {
            var sp = SoundLoader.processors[ev.id];
            if (sp) {
                sp.state = SoundLoader.AudioState.success;
                if (sp.nextToDecode) sp.nextToDecode.ProcessHtmlAudio()
            }
        }, false);
        createjs.Sound.addEventListener("fileerror", function(ev) {
            var sp = SoundLoader.processors[ev.id];
            if (sp) {
                sp.state = SoundLoader.AudioState.error;
                if (sp.nextToDecode) sp.nextToDecode.ProcessHtmlAudio()
            }
        }, false)
    }
    var lastProcessors = [];
    var firstProcessors = [];
    for (var i = 0; i < SoundLoader.sounds.length; ++i) {
        var id = "s" + SoundLoader.sounds[i].id;
        var processor = new SoundLoader.AudioProcessor({
            id: id,
            url: id + "." + SoundHelper.audioFormat,
            base64: SoundLoader.sounds[i].data,
            handler: new EventHandler(SoundLoader, SoundLoader.OnSoundDecoded),
            context: createjs.Sound.activePlugin.context
        });
        var sThread = i % SoundLoader.numProcessingThreads;
        if (i <= SoundLoader.numProcessingThreads - 1) firstProcessors[sThread] = processor;
        else lastProcessors[sThread].nextToDecode = processor;
        SoundLoader.processors[processor.id] = processor;
        lastProcessors[sThread] = processor
    }
    for (var i = 0; i < firstProcessors.length; i++)
        if (firstProcessors[i] != null) firstProcessors[i][processAudioMethod]();
    SoundLoader.DelayCheckLoadComplete()
};
SoundLoader.InitSounds = function() {
    var parser = new UAParser2;
    var browser = parser.getBrowser();
    if (IS_UCBROWSER) createjs.Sound.registerPlugins([createjs.HTMLAudioPlugin]);
    if (!createjs.Sound.initializeDefaultPlugins()) {
        console.error("SoundLoader.InitSounds - html audio & web audio are not supported !");
        return
    }
    var capabilities = createjs.Sound.getCapabilities();
    SoundHelper.audioFormat = capabilities["ogg"] ? SoundHelper.AudioFormat.ogg : SoundHelper.AudioFormat.mp3;
    if (UHT_UA_INFO.browser.name == "Edge") SoundHelper.audioFormat =
        SoundHelper.AudioFormat.mp3;
    if (createjs.Sound.activePlugin instanceof createjs.WebAudioPlugin) SoundLoader.audioType = SoundLoader.AudioType.web;
    else if (createjs.Sound.activePlugin instanceof createjs.HTMLAudioPlugin) {
        createjs.Sound._parsePath = SoundHelper.ParsePath;
        SoundLoader.audioType = SoundLoader.AudioType.html
    }
    SoundLoader.initialized = true;
    console.info("SoundLoader.InitSounds", capabilities, SoundHelper.audioFormat, SoundLoader.audioType)
};
SoundLoader.CheckLoadComplete = function() {
    if (!SoundLoader.IsLoadComplete()) {
        SoundLoader.DelayCheckLoadComplete();
        return
    }
    for (var i = 0; i < SoundLoader.clips.length; i++) {
        var clip = SoundLoader.clips[i];
        var processor = SoundLoader.processors[SoundLoader.clips[i].name];
        if (processor != undefined && processor.state == SoundLoader.AudioState.success) {
            createjs.Sound.setDefaultPlayProps(clip.name, {
                pan: 1E-4
            });
            clip.soundjsObject = createjs.Sound.createInstance(clip.name)
        }
    }
    SoundLoader.soundsAreLoaded = true;
    SoundLoader.processors =
        null;
    SoundLoader.checkLoadCompleteTimeout = null;
    if (!Globals.isMobile) createjs.Sound.setVolume(XT.GetFloat(Vars.SoundVolume))
};
SoundLoader.IsLoadComplete = function() {
    if (SoundLoader.numSounds != SoundLoader.numClips) return false;
    for (var id in SoundLoader.processors)
        if (SoundLoader.processors[id].state == SoundLoader.AudioState.none) return false;
    return true
};
SoundLoader.OnTouchEnd = function() {
    var gameLoaded = LoaderProgress.Download_Current == LoaderProgress.Download_Total && LoaderProgress.Import_Current == LoaderProgress.Import_Total;
    if (gameLoaded && !SoundHelper.wasTouchMove) {
        if (createjs.BrowserDetect.isIOS) globalColliderInputManager.addEventHandler(ColliderEvent.ButtonUp, new EventHandler(SoundHelper, SoundHelper.OnIOSTouchEnd));
        globalColliderInputManager.removeEventHandler(ColliderEvent.ButtonUp, SoundLoader.touchEndHandler);
        window.removeEventListener("keydown",
            SoundLoader.OnTouchEnd, false);
        SoundLoader.InitSounds()
    }
};
SoundLoader.OnLoad = function() {
    if (window["UHT_ForceClickForSounds"] != undefined || createjs.BrowserDetect.isIOS || createjs.BrowserDetect.isAndroid || createjs.BrowserDetect.isBlackberry || createjs.BrowserDetect.isWindowPhone) {
        if (globalColliderInputManager == undefined) {
            setTimeout(SoundLoader.OnLoad, 200);
            return
        }
        if (createjs.BrowserDetect.isIOS) {
            SoundLoader.touchStartHandler = new EventHandler(SoundHelper, SoundHelper.OnTouchStart);
            SoundLoader.touchMoveHandler = new EventHandler(SoundHelper, SoundHelper.OnTouchMove);
            globalColliderInputManager.addEventHandler(ColliderEvent.ButtonDown, SoundLoader.touchStartHandler);
            globalColliderInputManager.addEventHandler(ColliderEvent.MouseMove, SoundLoader.touchMoveHandler)
        }
        SoundLoader.touchEndHandler = new EventHandler(SoundLoader, SoundLoader.OnTouchEnd);
        globalColliderInputManager.addEventHandler(ColliderEvent.ButtonUp, SoundLoader.touchEndHandler);
        window.addEventListener("keydown", SoundLoader.OnTouchEnd, false)
    } else {
        SoundLoader.InitSounds();
        SoundLoader.LoadSounds()
    }
};
SoundLoader.OnLoad();
goog.provide("UHT.Importer");
goog.require("UHT.SoundLoader");
goog.require("UHT.FontLoader");
goog.require("UHT.TextAsset");
goog.require("UHT.AudioClip");

function RawComponentData() {
    this.fileID = 0;
    this.componentType = "";
    this.enabled = false;
    this.serializableData = null
}

function Importer() {
    this.mapInstanceIdToInstanceScene = {};
    this.mapGuidToResource = {};
    this.serializableFields = {};
    this.componentToRawDataMap = [];
    this.allObjects = [];
    this.rootObjects = [];
    this.mapIdToInstance = {};
    this.state = Importer.State.Idle;
    this.timeQuota = 0;
    this.isSync = false;
    this.resourceStartIndex = -1;
    this.jsonStartIndex = -1;
    this.gameObjectStartIndex = -1;
    this.deserializeIndex = -1;
    this.importSteps = 0
}
Importer.State = {
    Idle: 0,
    Inited: 1,
    Instantiating: 2,
    Deserializing: 3,
    Finishing: 4
};
Importer.ImportRetData = function() {
    this.isDone = false;
    this.objects = null
};
Importer.prototype.StartImport = function(timeQuota, jsons) {
    DeserializeCTRDataMapLimit = [];
    this.state = Importer.State.Inited;
    this.timeQuota = timeQuota;
    this.isSync = !(timeQuota > 0);
    this.resourceStartIndex = 0;
    this.jsonStartIndex = 0;
    this.gameObjectStartIndex = 0;
    this.deserializeIndex = 0;
    this.componentToRawDataMap = [];
    this.allObjects = [];
    this.rootObjects = [];
    this.importSteps = 0;
    this.currentProgress = 0;
    this.totalNumberOfSteps = 1;
    LoaderProgress.Import_Textures_Total = 0;
    if (this.isSync) this.AddCount(jsons);
    if (!this.isSync) globalTracking.StartTimer("uht_loading",
        "_X_import_instantiate_duration", "LoadingTracker")
};
Importer.prototype.AddCount = function(jsons) {
    for (var jsonIdx = 0; jsonIdx < jsons.length; jsonIdx++) {
        var jsonData = jsons[jsonIdx];
        for (var resIdx = 0; resIdx < jsonData.resources.length; resIdx++) {
            var curRes = jsonData.resources[resIdx];
            this.totalNumberOfSteps++;
            if (curRes.type == "GameObject")
                for (var goIdx = 0; goIdx < curRes.data.root.length; goIdx++) {
                    var components = curRes.data.root[goIdx].components;
                    this.totalNumberOfSteps += components.length + 1;
                    for (var compIdx = 0; compIdx < components.length; compIdx++)
                        if (components[compIdx].componentType ==
                            "UIAtlas") {
                            var atlasData = components[compIdx].serializableData;
                            var usesLowEndResource = UHT_LOW_END_DEVICE && atlasData.hasLowEndResource;
                            if (!(atlasData.resourcePriority > 0 && !usesLowEndResource)) {
                                LoaderProgress.Import_Textures_Total++;
                                console.log("TEX to be loaded for: " + curRes.data.root[goIdx].name + " " + LoaderProgress.Import_Textures_Total)
                            }
                        }
                }
        }
    }
};
Importer.prototype.Advance = function(jsons, resourcesPath) {
    var ret = new Importer.ImportRetData;
    var time0 = (new Date).getTime();
    this.importSteps++;
    if (this.state == Importer.State.Inited) this.state = Importer.State.Instantiating;
    if (this.state == Importer.State.Instantiating) {
        for (var jsonIdx = this.jsonStartIndex; jsonIdx < jsons.length; jsonIdx++) {
            var jsonData = jsons[jsonIdx];
            for (var resIdx = this.resourceStartIndex; resIdx < jsonData.resources.length; resIdx++) {
                var curRes = jsonData.resources[resIdx];
                switch (curRes.type) {
                    case "Texture":
                        var src =
                            null;
                        if (curRes.isInline) src = curRes.data;
                        else src = resourcesPath + curRes.data;
                        this.mapGuidToResource["g" + curRes.id] = {
                            type: curRes.type,
                            data: src
                        };
                        break;
                    case "Font":
                        var fontName = curRes.data.fontName;
                        this.mapGuidToResource["g" + curRes.id] = {
                            type: curRes.type,
                            data: fontName
                        };
                        FontLoader.LoadFont(fontName, curRes.data.path);
                        break;
                    case "GameObject":
                        if (this.gameObjectStartIndex == 0) this.mapIdToInstance = {};
                        for (var goIdx = this.gameObjectStartIndex; goIdx < curRes.data.root.length; goIdx++) {
                            this.allObjects[this.allObjects.length] =
                                this.createGameObject(curRes.data.root[goIdx], this.mapIdToInstance, this.componentToRawDataMap);
                            if (resIdx == 0 && goIdx == 0) this.rootObjects.push(this.allObjects[this.allObjects.length - 1]);
                            this.gameObjectStartIndex++;
                            this.currentProgress++;
                            if (!(goIdx % 25) && this.IsQuantaFinished(time0)) return ret
                        }
                        var oMapIdToInstance = {};
                        if (this.mapGuidToResource["g" + curRes.id] != undefined) oMapIdToInstance = this.mapGuidToResource["g" + curRes.id].data;
                        this.mapGuidToResource["g" + curRes.id] = {
                            type: curRes.type,
                            data: this.mapIdToInstance
                        };
                        for (var m in oMapIdToInstance) this.mapGuidToResource["g" + curRes.id].data[m] = oMapIdToInstance[m];
                        this.gameObjectStartIndex = 0;
                        break;
                    case "TextAsset":
                        var t = new TextAsset(curRes.data.text);
                        this.mapGuidToResource["g" + curRes.id] = {
                            type: curRes.type,
                            data: t
                        };
                        break;
                    case "AudioClip":
                        var ac = new AudioClip("s" + curRes.id, resourcesPath + curRes.data.path);
                        SoundLoader.LoadSound(ac);
                        this.mapGuidToResource["g" + curRes.id] = {
                            type: curRes.type,
                            data: ac
                        };
                        break;
                    case "AnimationClip":
                        var clip = new AnimationClip;
                        deserializeComponentRec(curRes.data,
                            clip, this, "resolveReference");
                        if (clip.wrapMode == WrapMode.PingPong) console.error("Wrapmode PingPong not supported! (name: " + clip.name + ")");
                        this.mapGuidToResource["g" + curRes.id] = {
                            type: curRes.type,
                            data: clip
                        };
                        break;
                    case "UHTSpine":
                        var spine = new UHTSpine;
                        deserializeComponentRec(curRes.data, spine, this, "resolveReference");
                        this.mapGuidToResource["g" + curRes.id] = {
                            type: curRes.type,
                            data: spine
                        };
                        break;
                    default:
                        console.error("Unknown resource type: " + curRes.type + "!");
                        break
                }
                this.resourceStartIndex++;
                this.currentProgress++;
                if (!(resIdx % 5) && this.IsQuantaFinished(time0)) return ret
            }
            DeserializeCTRDataMapLimit.push(this.componentToRawDataMap.length);
            this.jsonStartIndex++;
            this.resourceStartIndex = 0
        }
        if (!this.isSync) {
            globalTracking.StopTimerAndSend("uht_loading", "_X_import_instantiate_duration", "LoadingTracker");
            globalTracking.StartTimer("uht_loading", "_X_import_deserialize_duration", "LoadingTracker")
        }
        this.state = Importer.State.Deserializing
    }
    if (this.state == Importer.State.Deserializing) {
        var lastDeserializeAllowed = -1;
        for (var i =
                0; i < DeserializeAllowed.length; i++)
            if (DeserializeAllowed[i]) lastDeserializeAllowed = i;
        if (!this.isSync && lastDeserializeAllowed < 0) return ret;
        if (this.isSync) lastDeserializeAllowed = jsonIdx - 1;
        for (var j = this.deserializeIndex; j < DeserializeCTRDataMapLimit[lastDeserializeAllowed]; j++) {
            this.componentToRawDataMap[j].comp.deserialize(this.componentToRawDataMap[j].rawData.serializableData, this, "resolveReference");
            this.deserializeIndex++;
            this.currentProgress++;
            if (!(j % 50) && this.IsQuantaFinished(time0)) return ret
        }
        if (this.isSync ||
            allGameJSONSadded) this.state = Importer.State.Finishing;
        else this.state = Importer.State.Idle
    }
    if (this.state == Importer.State.Finishing) {
        this.currentProgress++;
        ret.isDone = true;
        ret.objects = [];
        for (var k = 0; k < this.allObjects.length; k++)
            for (var compIdx = 0; compIdx < this.allObjects[k].components.length; compIdx++)
                if (this.allObjects[k].components[compIdx]["AfterDeserialize"] != undefined) this.allObjects[k].components[compIdx].AfterDeserialize();
        ret.objects = this.rootObjects;
        console.log("Loaded " + this.allObjects.length +
            " gameobjects in " + this.importSteps + " steps.");
        this.state = Importer.State.Idle;
        if (!this.isSync) globalTracking.StopTimerAndSend("uht_loading", "_X_import_deserialize_duration", "LoadingTracker");
        return ret
    }
    return ret
};
Importer.prototype.IsQuantaFinished = function(curTime) {
    if (this.isSync) return false;
    var t = (new Date).getTime();
    return t - curTime > this.timeQuota
};
Importer.prototype.clear = function() {
    this.mapInstanceIdToInstanceScene = {};
    this.mapGuidToResource = {}
};
Importer.prototype.createGameObject = function(rawGOData, idToInstanceMap, componentToRawDataMap) {
    var newGO = new GameObject;
    newGO.internalCopyFromOther(rawGOData);
    idToInstanceMap["m" + rawGOData.fileID] = newGO;
    for (var i = 0; i < rawGOData.components.length; i++) {
        var compData = rawGOData.components[i];
        this.registerSerializedFields(compData.componentType, compData.serializableData);
        var newComp = createComponent(compData.componentType, compData.enabled);
        if (newComp != null) {
            idToInstanceMap["m" + compData.fileID] = newComp;
            componentToRawDataMap.push({
                comp: newComp,
                rawData: compData
            });
            newComp.gameObject = newGO;
            newGO.components.push(newComp);
            newGO.internalCacheComponent(newComp)
        }
    }
    for (var l = 0; l < newGO.components.length; l++) newGO.components[l].transform = newGO.transform;
    return newGO
};
Importer.prototype.resolveReference = function(rawData) {
    if (rawData == null) return null;
    if (Array.isArray(rawData)) {
        var ret = new Array(rawData.length);
        for (var i = 0; i < rawData.length; i++) ret[i] = this.resolveReference(rawData[i]);
        return ret
    } else if (rawData.hasOwnProperty("fileID")) {
        var id = rawData["fileID"];
        var hasGUID = rawData.hasOwnProperty("guid");
        if (!hasGUID) {
            hasGUID = true;
            if (id >= 69E4) rawData["guid"] = "GUI";
            else rawData["guid"] = "GAME"
        }
        if (!hasGUID) {
            if (id == 0) return null;
            var propName = "m" + id;
            if (this.mapInstanceIdToInstanceScene.hasOwnProperty(propName)) return this.mapInstanceIdToInstanceScene[propName]
        } else {
            var resId =
                "g" + rawData["guid"];
            if (this.mapGuidToResource.hasOwnProperty(resId)) {
                var resDesc = this.mapGuidToResource[resId];
                switch (resDesc.type) {
                    case "Texture":
                        return resDesc.data;
                        break;
                    case "Font":
                        return resDesc.data;
                        break;
                    case "GameObject":
                        var mapIdToInstance = resDesc.data;
                        if (id == 0) return null;
                        var propName = "m" + id;
                        if (mapIdToInstance.hasOwnProperty(propName)) return mapIdToInstance[propName];
                        break;
                    case "TextAsset":
                        return resDesc.data;
                        break;
                    case "AudioClip":
                        return resDesc.data;
                        break;
                    case "AnimationClip":
                        return resDesc.data;
                        break;
                    case "UHTSpine":
                        return resDesc.data;
                        break;
                    default:
                        console.error("Unknown resource type: " + resDesc.type + "!");
                        break
                }
            } else console.error("Trying to reference an unregistered resource! id: " + resId + "!")
        }
    }
    console.error("Could not resolve reference");
    return null
};
Importer.prototype.registerSerializedFields = function(compName, fields) {
    if (this.serializableFields.hasOwnProperty(compName) == false) this.serializableFields[compName] = fields
};
Importer.prototype.getSerializedFields = function(compName) {
    if (this.serializableFields.hasOwnProperty(compName)) return this.serializableFields[compName];
    return null
};
goog.require("UHT.Runtime");
goog.require("UHT.Renderer");
goog.require("UHT.Importer");
goog.require("UHT.ColliderInputManager");
goog.require("UHT.KeyboardManager");
var globalRuntime = new Runtime;
var globalRenderer = new Renderer;
var globalImporter = new Importer;
var globalColliderInputManager = new ColliderInputManager;
var globalClientPath = UHT_CONFIG.GAME_URL + "client/";
var globalGamePath = UHT_CONFIG.GAME_URL + "game/";
var globalResourcesNeededList = [];
var globalResourcesNeededInfo = [];
var globalPauseForResources = false;
var currentDownloadingAtlas = null;
var globalListOfDeferredLoadingAtlases = [];
var filterStrength = 20;
var frameTimeForFPSCounter = 0;
var prevFrameDate = new Date;
var thisFrameDate;
var modulesJsonData = [];
var mainGameJsonData = null;
var GUIJsonData = null;
var mainResources = null;
var otherResources = null;
var GUIResources = null;
var resourcesLeft = -1;
var PageVisible = true;
var IS_UCBROWSER = navigator.userAgent.indexOf("UCBrowser") > -1;

function main() {
    console.log("Main started");
    UHTInterfaceBOSS.PostMessage("gameLoadingStarted");
    globalTracking._internalUseStartTime("uht_loading", "_1_loader_downloaded_and_shown", GA_timer_load_start, "LoadingTracker");
    globalTracking._internalUseStartTime("uht_loading", "_4_loading_total_time", GA_timer_load_start, "LoadingTracker");
    LoadingStep = 1;
    globalTracking.StartTimer("uht_loading", "_CLOSED_at_" + LoadingStep, "LoadingTracker");
    loadJsonWithCallback(globalClientPath + "resources.json" + "?key=" + UHT_REVISION.uncommon,
        onClientResourcesLoaded);
    setInterval(function() {
        globalRenderer.setFPSCount(1 / frameTimeForFPSCounter)
    }, 1E3);
    document.addEventListener("visibilitychange", function() {
        PageVisible = document.visibilityState == "visible";
        if (PageVisible)
            if (XT.GetObject(Vars.SoundManagerObject) != null) XT.GetObject(Vars.SoundManagerObject).RestartMusic();
        var volume = Globals.isMobile ? 1 : XT.GetFloat(Vars.SoundVolume);
        volume = isFinite(volume) && !isNaN(volume) ? volume : 1;
        if (!Globals.WatchingReplay) createjs.Sound.setVolume(PageVisible ? volume :
            1E-5);
        if (!PageVisible) globalTracking.PauseTimers();
        else globalTracking.ResumeTimers()
    })
}
var SENT_GA_EVENT_ALTERNATIVE_DATA_PATH = false;

function loadJsonWithCallback(url, loadedCallback, progressCallback) {
    var xmlhttp = new XMLHttpRequest;
    xmlhttp.onreadystatechange = function() {
        if (xmlhttp.readyState == 4)
            if (xmlhttp.status == 200) loadedCallback(xmlhttp.responseText);
            else {
                if (progressCallback != undefined) progressCallback();
                if (window["currentDatapathRetries"] >= window["retriesBeforeAlternativeDatapath"]) {
                    url = url.replace(UHT_CONFIG.GAME_URL, UHT_CONFIG.GAME_URL_ALTERNATIVE);
                    if (!SENT_GA_EVENT_ALTERNATIVE_DATA_PATH) {
                        SENT_GA_EVENT_ALTERNATIVE_DATA_PATH =
                            true;
                        globalTracking.SendEvent("uht_loading", "_USED_ALTERNATIVE_DATA_PATH", 1, "LoadingTracker")
                    }
                } else window["currentDatapathRetries"]++;
                setTimeout(function() {
                    loadJsonWithCallback(url, loadedCallback, progressCallback)
                }, 250)
            }
    };
    xmlhttp.onprogress = function(progress) {
        if (xmlhttp.readyState != 4)
            if (progressCallback != undefined) progressCallback(progress)
    };
    xmlhttp.open("GET", url, true);
    xmlhttp.send()
}

function onClientResourcesLoaded(resourceData) {
    clientResourceData = JSON.parse(resourceData);
    loadJsonWithCallback(globalClientPath + "game.json" + "?key=" + UHT_REVISION.uncommon, onClientLoaded)
}

function onClientLoaded(text) {
    window["UHTLogotype"]["GameLoadingStarted"]();
    globalTracking.StopTimerAndSend("uht_loading", "_1_loader_downloaded_and_shown", "LoadingTracker");
    var timer = globalTracking.GetTimerValue("uht_loading", "_1_loader_downloaded_and_shown", "LoadingTracker");
    globalTracking.SendEvent("uht_loading", "_1_loader_downloaded_and_shown", timer, "LoadingTracker");
    LoadingStep = 2;
    globalTracking.StartTimer("uht_loading", "_CLOSED_at_" + LoadingStep, "LoadingTracker");
    globalTracking.StartTimer("uht_loading",
        "_2_game_downloading", "LoadingTracker");
    console.log("client loaded!");
    globalRenderer.init();
    var clientParts = [JSON.parse(text)];
    clientParts[0].resources = clientParts[0].resources.concat(clientResourceData.resources);
    clientResourceData = null;
    globalImporter.StartImport(0, clientParts);
    var ret = globalImporter.Advance(clientParts, globalClientPath);
    globalImporter.clear();
    KeyboardManager.Init();
    globalColliderInputManager.initInput();
    globalRuntime.addNewSceneRoot(ret.objects[0]);
    globalDoFrame(0)
}
var UpdateStep = true;

function CheckAndSetPauseForResources() {
    var mustPause = false;
    for (var i = 0; i < globalResourcesNeededList.length; i++)
        if (globalResourcesNeededList[i].isLoaded()) {
            globalResourcesNeededList.splice(i, 1);
            i--
        } else mustPause = true;
    if (globalPauseForResources) {
        var list = globalRuntime.onWillRenderList.components;
        for (var i = 0; i < list.length; i++) {
            var cur = list[i];
            if (cur == null) continue;
            if (cur instanceof UIPanel) cur.container.children = []
        }
    }
    if (mustPause != globalPauseForResources) {
        globalPauseForResources = mustPause;
        var mustShowPauseIndicator =
            globalPauseForResources && !loaderIsVisible;
        if (!mustPause) {
            globalResourcesNeededInfo = [];
            document.getElementById("progressbar").style.display = "none"
        }
        var show = mustShowPauseIndicator ? "block" : "none";
        document.getElementById("PauseRoot").style.display = show;
        document.getElementById("pauseindicator").style.display = show;
        var ccl = document.getElementsByTagName("canvas")[0].classList;
        if (mustShowPauseIndicator) ccl.add("paused");
        else ccl.remove("paused")
    }
    if (!loaderIsVisible) {
        if (mustPause) {
            var percentLoaded = 0;
            for (var j =
                    0; j < globalResourcesNeededInfo.length; j++) {
                var loaded = globalResourcesNeededInfo[j].baseTexture.source.downloadSizeLoaded;
                var total = globalResourcesNeededInfo[j].baseTexture.source.downloadSizeTotal;
                if (total > 0) percentLoaded += loaded / total / globalResourcesNeededInfo.length;
                else if (globalResourcesNeededInfo[j].valid) percentLoaded += 1 / globalResourcesNeededInfo.length
            }
            document.getElementById("progressbar").style.display = "block";
            document.getElementById("progressvalue").style.width = Number(percentLoaded * 100).toFixed(2) +
                "%"
        }
        if (!(UHTEngine.SoundsAreLoaded() || UHTEngine.SoundsAreLoading())) UHTEngine.StartLoadingSounds()
    }
}
var deserializedAtlases = [];
var hasSomethingToDraw = false;
var batterySaverIsOff = true;
var backgroundUpdateTimer;
var useBackgroundTimer;

function globalDoFrame(param) {
    if (useBackgroundTimer == undefined) useBackgroundTimer = checkIsRequired("RUN_BKG");
    clearTimeout(backgroundUpdateTimer);
    if ((!globalPauseForResources || loaderIsVisible) && (!UpdateStep || batterySaverIsOff) && hasSomethingToDraw) {
        globalRenderer.doFrame();
        if (!loaderIsVisible) Time.frameCount++
    }
    if (globalPauseForResources) {
        CheckAndSetPauseForResources();
        prevFrameDate = Date.now();
        requestAnimationFrame(globalDoFrame);
        return
    } else {
        if (!loaderIsVisible) {
            for (var i = 0; i < deserializedAtlases.length; i++) deserializedAtlases[i].initAtlas();
            deserializedAtlases = []
        }
        if (timerToStartPrefetching > 0) timerToStartPrefetching--;
        if (timerToStartPrefetching == 0) internalContinuePrefetchingTextures()
    }
    if (UpdateStep || batterySaverIsOff) {
        globalRenderer.checkWindowSize();
        if (canvasSizeDirty) {
            globalRenderer.resizeUHTScreen();
            EventManager.Trigger("EVT_UHT_RESIZE", null)
        }
        internalContinueImporting();
        var thisFrameTime = ((thisFrameDate = Date.now()) - prevFrameDate) / 1E3;
        if (thisFrameTime < 0) thisFrameTime = 0;
        prevFrameDate = thisFrameDate;
        frameTimeForFPSCounter += (thisFrameTime -
            frameTimeForFPSCounter) / filterStrength;
        Time.deltaTime = thisFrameTime > .1 ? .1 : thisFrameTime;
        Time.time += Time.deltaTime;
        Time.deltaTimeInRealTime = thisFrameTime;
        KeyboardManager.Update();
        globalColliderInputManager.updateInput();
        EventManager.Trigger("EVT_UHT_BEFOREUPDATE", null);
        globalRuntime.doFrame();
        EventManager.Trigger("EVT_UHT_UPDATE", null);
        hasSomethingToDraw = true;
        CheckAndSetPauseForResources()
    }
    UpdateStep = !UpdateStep;
    if (loaderIsVisible) setTimeout(globalDoFrame, 0);
    else {
        if (param != "BACKGROUND_UPDATE") requestAnimationFrame(globalDoFrame);
        if (useBackgroundTimer) backgroundUpdateTimer = setTimeout(globalDoFrame, 100, "BACKGROUND_UPDATE")
    }
}

function checkIsRequired(requirement) {
    var isRequired = false;
    if (window["IsRequired"] != undefined) isRequired = window["IsRequired"](requirement);
    return isRequired
}
var loaderController = null;
var loaderCallbackHide = "";
var loaderIsVisible = true;
var gameRequests = [];
var resourcesRequests = [];
var nonCachedRetried = false;
var clientResourceData = [];

function downloadMainGame(listener, callbackDownloadDone, callbackHide) {
    Modules.OnDownloadMainGame();
    globalImporter.StartImport(UHT_DEVICE_TYPE.DESKTOP == true ? 25 : 40, []);
    loaderController = listener;
    loaderCallbackHide = callbackHide;
    LoaderProgress.Download_Total = UHT_GAME_SIZE;
    gameRequests.push([]);
    var grIndex = 0;
    for (var i = 0; i < UHT_GAME_FILES.length; ++i) {
        if (gameRequests[grIndex].length > 0) {
            var fileName = gameRequests[grIndex][gameRequests[grIndex].length - 1].url;
            fileName = fileName.split("?")[0];
            if (fileName.replace(/[0-9]/g,
                    "").indexOf(UHT_GAME_FILES[i].split("?")[0].replace(/[0-9]/g, "")) == -1) {
                gameRequests.push([]);
                grIndex++
            }
        }
        var req = new ResourceRequest({
            delayed: grIndex > 0,
            url: globalGamePath + UHT_GAME_FILES[i],
            complete: new EventHandler(null, onGamePartComplete),
            onprogress: new EventHandler(null, onGameJSONProgress),
            callbackArg: [i, grIndex, gameRequests[grIndex].length]
        });
        gameRequests[grIndex].push(req)
    }
    resourcesLeft = gameRequests.length
}

function onGamePartComplete(req, arg) {
    if (!_string.IsNullOrEmpty(req.error)) {
        onGameJSONProgress();
        if (window["currentDatapathRetries"] >= window["retriesBeforeAlternativeDatapath"]) {
            req.url = req.url.replace(UHT_CONFIG.GAME_URL, UHT_CONFIG.GAME_URL_ALTERNATIVE);
            if (!SENT_GA_EVENT_ALTERNATIVE_DATA_PATH) {
                SENT_GA_EVENT_ALTERNATIVE_DATA_PATH = true;
                globalTracking.SendEvent("uht_loading", "_USED_ALTERNATIVE_DATA_PATH", 1, "LoadingTracker")
            }
        } else window["currentDatapathRetries"]++;
        setTimeout(function() {
            gameRequests[arg[1]][arg[2]] =
                new ResourceRequest({
                    url: req.url,
                    complete: req.complete,
                    onprogress: req.onprogress,
                    overrideMimeType: "text/plain;charset=UTF-8",
                    callbackArg: req.callbackArg
                })
        }, 250);
        return
    }
    for (var i = 0; i < gameRequests.length; ++i) {
        var sectionComplete = true;
        for (var j = 0; j < gameRequests[i].length; ++j)
            if (!(gameRequests[i][j].Done && _string.IsNullOrEmpty(gameRequests[i][j].error))) {
                sectionComplete = false;
                break
            }
        if (gameRequests[i].length != 0 && sectionComplete) {
            if (i + 1 < gameRequests.length)
                for (var j = 0; j < gameRequests[i + 1].length; ++j) gameRequests[i +
                    1][j].SendRequest();
            if (!parseGameData(gameRequests[i], i)) break
        }
    }
}
var JsonsToImport = [];
var DeserializeAllowed = [];
var DeserializeCTRDataMapLimit = [];
var allGameJSONSadded = false;
var JsonTypes = [];

function PushToImporter(json) {
    JsonsToImport.push(json);
    globalImporter.AddCount([json]);
    LoaderProgress.Import_Total = globalImporter.totalNumberOfSteps;
    LoaderProgress.Import_Current = globalImporter.currentProgress
}

function parseGameData(requests, resourceIndex) {
    var gameData = "";
    for (var i = 0; i < requests.length; ++i) gameData += requests[i].Data;
    try {
        switch (resourceIndex) {
            case 0:
                GUIJsonData = JSON.parse(gameData);
                PushToImporter(GUIJsonData);
                JsonTypes.push(1);
                globalImporter.state = Importer.State.Instantiating;
                break;
            case 1:
                GUIResources = JSON.parse(gameData);
                PushToImporter(GUIResources);
                DeserializeAllowed.push(true);
                DeserializeAllowed.push(true);
                globalImporter.state = Importer.State.Instantiating;
                break;
            case 2:
                mainGameJsonData =
                    JSON.parse(gameData);
                PushToImporter(mainGameJsonData);
                JsonTypes.push(0);
                globalImporter.state = Importer.State.Instantiating;
                break;
            case 3:
                mainResources = JSON.parse(gameData);
                PushToImporter(mainResources);
                globalImporter.state = Importer.State.Instantiating;
                break;
            case 4:
                otherResources = JSON.parse(gameData);
                PushToImporter(otherResources);
                DeserializeAllowed.push(true);
                DeserializeAllowed.push(true);
                DeserializeAllowed.push(true);
                globalImporter.state = Importer.State.Instantiating;
                break;
            default:
                modulesJsonData.push(JSON.parse(gameData));
                PushToImporter(modulesJsonData[0]);
                JsonTypes.push(2);
                DeserializeAllowed.push(true);
                globalImporter.state = Importer.State.Instantiating;
                break
        }
        for (var i = 0; i < gameRequests[resourceIndex].length; i++) globalDone += UHT_GAME_FILES_SIZES[gameRequests[resourceIndex][i].callbackArg[0]];
        gameRequests[resourceIndex] = [];
        resourcesLeft--;
        if (resourcesLeft == 0) {
            onGameJSONLoaded();
            allGameJSONSadded = true;
            UHT_GAME_FILES = null;
            UHT_GAME_FILES_SIZES = null;
            if (nonCachedRetried) globalTracking.SendEvent("uht_loading", "non_cached_retried",
                1, "LoadingTracker")
        }
        return true
    } catch (error) {
        console.error(error);
        if (nonCachedRetried) {
            globalTracking.SendEvent("uht_loading", "non_cached_retried", 0, "LoadingTracker");
            return
        }
        nonCachedRetried = true;
        mainGameJsonData = null;
        GUIJsonData = null;
        mainResources = null;
        otherResources = null;
        GUIResources = null;
        gameRequests = [];
        gameRequests.push([]);
        var grIndex = 0;
        for (var i = 0; i < UHT_GAME_FILES.length; ++i) {
            if (gameRequests[grIndex].length > 0) {
                var fileName = gameRequests[grIndex][gameRequests[grIndex].length - 1].url;
                if (fileName.replace(/[0-9]/g,
                        "").indexOf(UHT_GAME_FILES[i].replace(/[0-9]/g, "")) == -1) {
                    gameRequests.push([]);
                    grIndex++
                }
            }
            var req = new ResourceRequest({
                url: globalGamePath + UHT_GAME_FILES[i],
                complete: new EventHandler(null, onGamePartComplete),
                onprogress: new EventHandler(null, onGameJSONProgress),
                overrideMimeType: "text/plain;charset=UTF-8",
                callbackArg: [i, grIndex, gameRequests[grIndex].length],
                forceNoCache: true
            });
            gameRequests[gameRequests.length - 1].push(req)
        }
        resourcesLeft = gameRequests.length;
        return false
    }
}

function onGameJSONLoaded() {
    globalTracking.StopTimerAndSend("uht_loading", "_2_game_downloading", "LoadingTracker");
    var timer = globalTracking.GetTimerValue("uht_loading", "_2_game_downloading", "LoadingTracker");
    globalTracking.SendEvent("uht_loading", "_2_game_downloading", timer, "LoadingTracker");
    LoadingStep = 3;
    globalTracking.StartTimer("uht_loading", "_CLOSED_at_" + LoadingStep, "LoadingTracker");
    globalTracking.StartTimer("uht_loading", "_3_game_opening_and_connecting", "LoadingTracker");
    LoaderProgress.Download_Current =
        LoaderProgress.Download_Total;
    console.log("maingame loaded!")
}
var timerToStartPrefetching = -1;

function internalContinuePrefetchingTextures() {
    if (currentDownloadingAtlas != null && currentDownloadingAtlas.isLoaded()) {
        currentDownloadingAtlas.internalTextureLoadedCallback();
        currentDownloadingAtlas = null
    }
    if (globalListOfDeferredLoadingAtlases.length > 0 && currentDownloadingAtlas == null) {
        currentDownloadingAtlas = globalListOfDeferredLoadingAtlases[0];
        currentDownloadingAtlas.loadAtlasTexture();
        globalListOfDeferredLoadingAtlases.splice(0, 1)
    }
}

function internalContinueImporting() {
    if (globalImporter.state != Importer.State.Idle) {
        var ret = globalImporter.Advance(JsonsToImport, globalGamePath);
        LoaderProgress.Import_Current = globalImporter.currentProgress;
        if (ret.isDone && allGameJSONSadded) {
            LoaderProgress.Import_Current = globalImporter.totalNumberOfSteps;
            globalImporter.clear();
            var parent = ret.objects[JsonTypes.indexOf(0)].GetComponentsInChildren(LocalizationRoot, true)[0].transform;
            var GUIGo = ret.objects[JsonTypes.indexOf(1)].transform;
            var commonExtraGo =
                GUIGo.children[GUIGo.children.length - 1];
            commonExtraGo.SetParent(parent, false);
            GUIGo.SetParent(parent, false);
            for (var i = 0; i < ret.objects.length; ++i)
                if (JsonTypes[i] > 1) ret.objects[i].transform.SetParent(parent, false);
            globalRuntime.addNewSceneRoot(ret.objects[JsonTypes.indexOf(0)]);
            mainGameJsonData = null;
            GUIJsonData = null;
            mainResources = null;
            otherResources = null;
            GUIResources = null;
            modulesJsonData = null
        }
    }
}
var globalDone = 0;

function onGameJSONProgress() {
    var done = globalDone;
    var loading = 0;
    for (var i = 0; i < gameRequests.length; ++i)
        for (var j = 0; j < gameRequests[i].length; ++j) {
            var req = gameRequests[i][j];
            if (req.Done) {
                if (_string.IsNullOrEmpty(req.error)) done += UHT_GAME_FILES_SIZES[req.callbackArg[0]]
            } else loading += req.progressLoaded
        }
    if (loading + done > LoaderProgress.Download_Current) LoaderProgress.Download_Current = loading + done;
    LoaderProgress.Download_Total = UHT_GAME_SIZE
}
var LoaderProgress = {
    Download_AlreadyDownloaded: -1,
    Download_SoundAlreadyDownloaded: -1,
    Download_Retried_LockedPercent: 0,
    Download_Current: 0,
    Sound_Download_Current: 0,
    Import_Current: 0,
    Import_Textures_Current: 0,
    InitConnection_Current: 0,
    InitConnection_Visual: 0,
    Localize_Current: 0,
    Blocking_Current: 0,
    Blocking_Visual: 0,
    SymbolsManagers_Current: 0,
    Download_Total: -1,
    Sound_Download_Total: -1,
    Import_Total: -1,
    Import_Textures_Total: -1,
    InitConnection_Total: 1,
    Localize_Total: 1,
    Blocking_Total: -1,
    SymbolsManagers_Total: -1,
    Download_Weight: .7,
    Sound_Download_Weight: 0,
    GameAndSound_Download_Weight: .7,
    Import_Weight: .1,
    Import_Textures_Weight: .2,
    InitConnection_Weight: .025,
    Localize_Weight: .025,
    Blocking_Weight: .01,
    SymbolsManagers_Weight: .1
};
var LoadingWheelSentOnce = false;

function signalNeedPauseForTexture(atlas) {
    if (atlas.requested) return;
    if (!LoadingWheelSentOnce && !loaderIsVisible) {
        globalTracking.SendEvent("uht_behaviour", "Loading_wheel_once", 1, "BehaviourTracker");
        LoadingWheelSentOnce = true
    }
    if (!loaderIsVisible) globalTracking.SendEvent("uht_behaviour_loading_wheel", "Initiated_for_" + atlas.gameObject.name, 1, "BehaviourTracker");
    globalResourcesNeededList.push(atlas);
    atlas.requested = true;
    for (var i = 0; i < globalListOfDeferredLoadingAtlases.length; i++) {
        var curAtlas = globalListOfDeferredLoadingAtlases[i];
        if (!curAtlas.requested && curAtlas.isBlockingResource && curAtlas.resourcePriority == atlas.resourcePriority) {
            curAtlas.loadAtlasTexture();
            globalResourcesNeededList.push(curAtlas);
            curAtlas.requested = true;
            if (!loaderIsVisible && !curAtlas.pixiTexture.valid) globalTracking.SendEvent("uht_behaviour_loading_wheel", "Loaded_also_" + curAtlas.gameObject.name, 1, "BehaviourTracker");
            if (loaderIsVisible) {
                if (LoaderProgress.Blocking_Total == -1) LoaderProgress.Blocking_Total = 0;
                LoaderProgress.Blocking_Total++
            }
        }
    }
    globalResourcesNeededInfo = [];
    for (var k = 0; k < globalResourcesNeededList.length; k++) globalResourcesNeededInfo.push(globalResourcesNeededList[k].pixiTexture)
}

function registerAtlasForDeferredLoading(atlas) {
    var index = 0;
    for (var i = 0; i < globalListOfDeferredLoadingAtlases.length; i++)
        if (globalListOfDeferredLoadingAtlases[i].resourcePriority <= atlas.resourcePriority) index++;
    globalListOfDeferredLoadingAtlases.splice(index, 0, atlas)
}
goog.provide("UHT.AudioClassesUtils");
goog.require("UHT.SoundManager");
goog.require("UHT.AudioClip");

function AudioClipDelay() {
    this.currentDelay = 0;
    this.clipToPlay = null
}
AudioClipDelay.prototype.GetClip = function() {
    return this.clipToPlay
};
AudioClipDelay.prototype.Reset = function() {
    this.clipToPlay = null
};
AudioClipDelay.prototype.CountToPlayClip = function(clip, delay) {
    this.currentDelay = delay;
    this.clipToPlay = clip
};
AudioClipDelay.prototype.MustPlay = function() {
    if (this.clipToPlay == null) return false;
    if (this.currentDelay > 0) {
        this.currentDelay -= Time.deltaTime;
        return false
    }
    return true
};

function AudioClipMusicAware() {
    this.clipMusicOn = null;
    this.clipMusicOff = null
}
AudioClipMusicAware.prototype.GetClip = function() {
    if (XT.GetBool(Vars.MusicIsOn)) return this.clipMusicOn;
    return this.clipMusicOff
};

function AudioClipFastPlayAware() {
    this.clipFastPlayOff = null;
    this.clipFastPlayOn = null
}
AudioClipFastPlayAware.prototype.GetClip = function() {
    if (XT.GetBool(Vars.FastPlay)) return this.clipFastPlayOn.GetClip();
    return this.clipFastPlayOff.GetClip()
};

function AudioClipSpinTypeAware() {
    this.clipNormalSpin = null;
    this.clipFreeSpin = null;
    this.useNormalClipAtFreeSpinsStart = false
}
AudioClipSpinTypeAware.prototype.GetClip = function() {
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (XT.GetBool(Vars.Logic_IsFreeSpin))
        if (!(this.useNormalClipAtFreeSpinsStart && fsr.IsFreeSpinsStart)) return this.clipFreeSpin.GetClip();
    return this.clipNormalSpin.GetClip()
};

function AudioClipSpecialSymbolAware() {
    this.specialSymbolId = -1;
    this.hasExcitedClip = false;
    this.clipDefault = null;
    this.clipExcited = null
}
AudioClipSpecialSymbolAware.prototype.GetClip = function() {
    return this.clipDefault.GetClip()
};
AudioClipSpecialSymbolAware.prototype.GetExcitedClip = function() {
    if (this.hasExcitedClip) return this.clipExcited.GetClip();
    else return this.GetClip()
};

function VS_AudioClipLoopable() {
    this.handler = SoundManager.InvalidSoundHandle;
    this.clipDefault = null
}
VS_AudioClipLoopable.prototype.GetClip = function() {
    return this.clipDefault.GetClip()
};
VS_AudioClipLoopable.prototype.IsPlaying = function() {
    return this.handler != SoundManager.InvalidSoundHandle
};

function BG_AudioClipLoopable() {
    this.handler = SoundManager.InvalidSoundHandle;
    this.clipDefault = null
}

function MusicClip() {
    this.friendlyName = "friendly name";
    this.handler = SoundManager.InvalidSoundHandle;
    this.clip = null;
    this.maxVolume = 1;
    this.volumeFadeInDuration = 1;
    this.volumeFadeOutDuration = 1;
    this.duckingFadeInDuration = .5;
    this.duckingFadeOutDuration = .5;
    this.volumeLevel = 0;
    this.duckingVolume = 1;
    this.isPlaying = false;
    this.isMuted = false;
    this.duckingSteps = [];
    this.priorityDuckingStepIndex = -1;
    this.volumeState = MusicVolumeState.idle;
    this.duckingState = MusicVolumeState.idle;
    this.useFadeCurve = false;
    this.currentCurveTime =
        0;
    this.fadeCurve = null;
    for (var i = 0; i < 3; i++) {
        this.duckingSteps.push(new MusicDucking);
        this.duckingSteps[i].targetVolume = .3 + i * .2
    }
}
MusicClip.prototype.GetVolume = function() {
    var currentVolume = this.maxVolume * this.volumeLevel;
    return currentVolume * this.duckingVolume
};
MusicClip.prototype.UpdateDuckingStepPriority = function() {
    this.priorityDuckingStepIndex = -1;
    for (var i = 0; i < this.duckingSteps.length; i++)
        if (this.duckingSteps[i].duckCount > 0)
            if (this.priorityDuckingStepIndex == -1) this.priorityDuckingStepIndex = i;
            else if (this.duckingSteps[i].targetVolume < this.duckingSteps[this.priorityDuckingStepIndex].targetVolume) this.priorityDuckingStepIndex = i
};
var MusicVolumeState = {
    idle: 0,
    fadingIn: 1,
    fadingOut: 2
};

function MusicDucking() {
    this.targetVolume = .3;
    this.autoUnduck = false;
    this.autoUnduckShouldFade = false;
    this.autoUnduckTimer = 0;
    this.fadeInDuration = .5;
    this.fadeOutDuration = .5;
    this.duckCount = 0
}
BG_AudioClipLoopable.prototype.GetClip = function() {
    return this.clipDefault.GetClip()
};
BG_AudioClipLoopable.prototype.IsPlaying = function() {
    return this.handler != SoundManager.InvalidSoundHandle
};

function AudioClipValueAnimator() {
    this.handler = SoundManager.InvalidSoundHandle;
    this.clipSmallWin = null;
    this.clipNormalWin = null;
    this.clipBigWin = null;
    this.clipMegaWin = null;
    this.clipEpicWin = null;
    this.clipFinal = null
}
var ClipStage = {
    smallWin: 0,
    normalWin: 1,
    bigWin: 2,
    megaWin: 3,
    epicWin: 4,
    finalStage: 5
};
AudioClipValueAnimator.prototype.IsPlaying = function() {
    return this.handler != SoundManager.InvalidSoundHandle
};
AudioClipValueAnimator.prototype.GetClip = function(clipIdx) {
    var clip = null;
    switch (clipIdx) {
        case ClipStage.smallWin:
            clip = this.clipSmallWin.GetClip();
            break;
        case ClipStage.normalWin:
            clip = this.clipNormalWin.GetClip();
            break;
        case ClipStage.bigWin:
            clip = this.clipBigWin.GetClip();
            break;
        case ClipStage.megaWin:
            clip = this.clipMegaWin.GetClip();
            break;
        case ClipStage.epicWin:
            clip = this.clipEpicWin.GetClip();
            break;
        case ClipStage.finalStage:
            clip = this.clipFinal.GetClip();
            break
    }
    return clip
};

function AudioClipLoopable() {
    this.handler = SoundManager.InvalidSoundHandle;
    this.clipDefault = null
}
AudioClipLoopable.prototype.GetClip = function() {
    return this.clipDefault
};
AudioClipLoopable.prototype.IsPlaying = function() {
    return this.handler != SoundManager.InvalidSoundHandle
};

function AudioClipLoopableMusicAware() {
    this.handler = SoundManager.InvalidSoundHandle;
    this.clipDefault = null
}
AudioClipLoopableMusicAware.prototype.GetClip = function() {
    return this.clipDefault.GetClip()
};
AudioClipLoopableMusicAware.prototype.IsPlaying = function() {
    return this.handler != SoundManager.InvalidSoundHandle
};

function GambleSounds() {
    this.shufflingCardLoopable = null;
    this.shufflingCardStop = null;
    this.resultWindowWin = null;
    this.resultWindowLose = null;
    this.newProgressItem = null
}

function ReelStopSounds() {
    this.reelStopWithSpecialSymbol = null;
    this.reelStopExcitedWin = null;
    this.reelStopExcitedLose = null;
    this.reelStopDefault = null
}

function ReelStartSounds() {
    this.clipsReelStart = null;
    this.clipsReelStartExcited = null;
    this.clipsReelMusicExcited = null
}
goog.require("UHT.XTLink");
VS_MusicLogic.prototype = Object.create(XTLink.prototype);
VS_MusicLogic.prototype.constructor = VS_MusicLogic;

function VS_MusicLogic() {
    XTLink.call(this);
    this.normalMusic = [];
    this.fsMusic = [];
    this.bgMusic = [];
    this.loopingSoundFX = [];
    this.soundManager = null
}
VS_MusicLogic.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.MusicLogicObject, this)
};
VS_MusicLogic.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.SoundManagerObject, this.OnSoundManagerChanged, this)
};
VS_MusicLogic.prototype.OnDestroy = function() {
    XT.UnregisterCallbackObject(this.OnSoundManagerChanged, this)
};
VS_MusicLogic.prototype.OnSoundManagerChanged = function(sndMgr) {
    this.soundManager = sndMgr
};
VS_MusicLogic.prototype.PlayMusicClip = function(friendlyName, fadeDuration) {
    var mClip = this.FindClipWithFriendlyName(friendlyName);
    if (mClip == null) {
        console.log("There is no music or loopingSoundFX clip with friendly name " + friendlyName + " in VS_MusicLogic!");
        return
    }
    var useFading = false;
    if (fadeDuration > 0) {
        useFading = true;
        mClip.volumeFadeInDuration = fadeDuration
    }
    if (this.loopingSoundFX.indexOf(mClip) != -1) this.soundManager.PlayLoopingClip(mClip, useFading);
    else this.soundManager.PlayMusicClip(mClip, useFading)
};
VS_MusicLogic.prototype.StopMusicClip = function(friendlyName, fadeDuration) {
    var mClip = this.FindClipWithFriendlyName(friendlyName);
    if (mClip == null) {
        console.log("There is no music or loopingSoundFX clip with friendly name " + friendlyName + " in VS_MusicLogic!");
        return
    }
    var useFading = false;
    if (fadeDuration > 0) {
        useFading = true;
        mClip.volumeFadeOutDuration = fadeDuration
    }
    if (this.loopingSoundFX.indexOf(mClip) != -1) this.soundManager.StopLoopingClip(mClip, useFading);
    else this.soundManager.StopMusicClip(mClip, useFading)
};
VS_MusicLogic.prototype.MuteMusicClip = function(friendlyName, fadeDuration) {
    var mClip = this.FindClipWithFriendlyName(friendlyName);
    if (mClip == null) {
        console.log("There is no music or loopingSoundFX clip with friendly name " + friendlyName + " in VS_MusicLogic!");
        return
    }
    var useFading = false;
    if (fadeDuration > 0) {
        useFading = true;
        mClip.volumeFadeOutDuration = fadeDuration
    }
    if (this.loopingSoundFX.indexOf(mClip) != -1) this.soundManager.MuteLoopingClip(mClip, useFading);
    else this.soundManager.MuteMusicClip(mClip, useFading)
};
VS_MusicLogic.prototype.UnmuteMusicClip = function(friendlyName, fadeDuration) {
    var mClip = this.FindClipWithFriendlyName(friendlyName);
    if (mClip == null) {
        console.log("There is no music or loopingSoundFX clip with friendly name " + friendlyName + " in VS_MusicLogic!");
        return
    }
    var useFading = false;
    if (fadeDuration > 0) {
        useFading = true;
        mClip.volumeFadeInDuration = fadeDuration
    }
    if (this.loopingSoundFX.indexOf(mClip) != -1) this.soundManager.UnmuteLoopingClip(mClip, useFading);
    else this.soundManager.UnmuteMusicClip(mClip, useFading)
};
VS_MusicLogic.prototype.DuckMusicClip = function(friendlyName, duckingStepIndex, delayToAutoUnduck, fadeInDuration, fadeOutDuration) {
    var mClip = this.FindClipWithFriendlyName(friendlyName);
    if (mClip == null) {
        console.log("There is no music or loopingSoundFX clip with friendly name " + friendlyName + " in VS_MusicLogic!");
        return
    }
    var useFading = false;
    if (fadeInDuration > 0 || fadeOutDuration > 0) {
        useFading = true;
        mClip.duckingSteps[duckingStepIndex].fadeInDuration = fadeInDuration;
        mClip.duckingSteps[duckingStepIndex].fadeOutDuration =
            fadeOutDuration
    }
    if (this.loopingSoundFX.indexOf(mClip) != -1) this.soundManager.DuckLoopingClip(mClip, duckingStepIndex, delayToAutoUnduck, useFading);
    else this.soundManager.DuckMusicClip(mClip, duckingStepIndex, delayToAutoUnduck, useFading)
};
VS_MusicLogic.prototype.UnduckMusicClip = function(friendlyName, duckingStepIndex, fadeDuration) {
    var mClip = this.FindClipWithFriendlyName(friendlyName);
    if (mClip == null) {
        console.log("There is no music or loopingSoundFX clip with friendly name " + friendlyName + " in VS_MusicLogic!");
        return
    }
    var useFading = false;
    if (fadeDuration > 0) {
        useFading = true;
        mClip.duckingSteps[duckingStepIndex].fadeOutDuration = fadeDuration
    }
    if (this.loopingSoundFX.indexOf(mClip) != -1) this.soundManager.UnduckLoopingClip(mClip, duckingStepIndex,
        useFading);
    else this.soundManager.UnduckMusicClip(mClip, duckingStepIndex, useFading)
};
VS_MusicLogic.prototype.MuteMusic = function(mute) {
    if (mute) this.soundManager.MuteMusic();
    else this.soundManager.UnmuteMusic()
};
VS_MusicLogic.prototype.MuteSoundFX = function(mute) {
    if (mute) this.soundManager.MuteSoundFX();
    else this.soundManager.UnmuteSoundFX()
};
VS_MusicLogic.prototype.FindClipWithFriendlyName = function(friendlyName) {
    var i;
    for (i = 0; i < this.normalMusic.length; i++)
        if (this.normalMusic[i].friendlyName == friendlyName) return this.normalMusic[i];
    for (i = 0; i < this.fsMusic.length; i++)
        if (this.fsMusic[i].friendlyName == friendlyName) return this.fsMusic[i];
    for (i = 0; i < this.bgMusic.length; i++)
        if (this.bgMusic[i].friendlyName == friendlyName) return this.bgMusic[i];
    for (i = 0; i < this.loopingSoundFX.length; i++)
        if (this.loopingSoundFX[i].friendlyName == friendlyName) return this.loopingSoundFX[i];
    return null
};
VS_MusicLogic.prototype.GetMusicClipByAudioClip = function(clip) {
    if (clip == null) return null;
    var i;
    for (i = 0; i < this.normalMusic.length; i++)
        if (this.normalMusic[i].clip == clip) return this.normalMusic[i];
    for (i = 0; i < this.fsMusic.length; i++)
        if (this.fsMusic[i].clip == clip) return this.fsMusic[i];
    for (i = 0; i < this.bgMusic.length; i++)
        if (this.bgMusic[i].clip == clip) return this.bgMusic[i];
    return null
};
VS_MusicLogic.prototype.GetLoopingClipByAudioClip = function(clip) {
    if (clip == null) return null;
    for (var i = 0; i < this.loopingSoundFX.length; i++)
        if (this.loopingSoundFX[i].clip == clip) return this.loopingSoundFX[i];
    return null
};
goog.require("UHT.Engine");

function ClipLevel() {
    this.clips = null;
    this.repeat = 0
}
var CoinCounterType = {
    CoinCounter: 0,
    AlternateMusic: 1,
    IndividualBigWinSounds: 2
};

function CoinCounterSettings() {
    this.coinCounterType = CoinCounterType.CoinCounter;
    this.muteBackgroundMusic = false;
    this.useAlternateMusicForSmallWin = false;
    this.muteBackgroundMusicForBigWin = true
}
CoinCounter.prototype = Object.create(XTLink.prototype);
CoinCounter.prototype.constructor = CoinCounter;

function CoinCounter() {
    XTLink.call(this);
    this.levels = null;
    this.BigWinSteps = [];
    this.useFreeSpinsBigWinSteps = false;
    this.freeSpinsBigWinSteps = null;
    this.originalBigWinSteps = null;
    this.finalSound = null;
    this.delay = 0;
    this.secondsToCountOneTotalBet = 1;
    this.forcedSmallWinCountDuration = -1;
    this.secondsToCountOneTotalBetOldValue = 1;
    this.normalSettings = null;
    this.freeSpinsSettings = null;
    this.useBonusGameSettings = false;
    this.bonusGameSettings = null;
    this.currentSettings = null;
    this.normalAlternateMusic = null;
    this.freeSpinsAlternateMusic =
        null;
    this.bonusGameAlternateMusic = null;
    this.finalAlternateSound = null;
    this.finalAlternateSoundFS = null;
    this.currentAlternateMusic = null;
    this.individualBigWinClips = null;
    this.finalIndividualBigWinClips = null;
    this.IndividualBigWinSoundsDuration = [];
    this.finalIndividualBigWinSound = null;
    this.targetBigWinLevel = 0;
    this.timesTotalBet = 0;
    this.timesTotalBetFloat = 0;
    this.target = 0;
    this.counting = false;
    this.counter = 0;
    this.level = 0;
    this.idxInLevel = 0;
    this.inLevelRepeatCounter = 0;
    this.sndManager = null;
    this.timer = 0;
    this.totalWinReceivedSoFarInFS =
        0
}
CoinCounter.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.SoundManagerObject, this.OnSoundManagerChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinCounterStart, this.StartCount, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinCounterStop, this.StopCount, this);
    XT.RegisterCallbackInt(Vars.CurrentCoinCountTarget, this.OnCountTarget, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StartVSLogicSounds, this.ResetAlternateMusic, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_MusicBtn, this.ResetAlternateMusic,
        this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_SoundBtn, this.ResetAlternateMusic, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_SpinResultReceived, this.SpinResultIsBigWin, this);
    if (this.useBonusGameSettings) XT.RegisterCallbackEvent(Vars.Evt_Internal_ChangeVSGameState, this.OnVSGameStateChanged, this);
    else {
        XT.RegisterCallbackEvent(Vars.Evt_Internal_FreeSpinsStarted, this.OnFreeSpins, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_FreeSpinsEnded,
            this.OnFreeSpins, this)
    }
};
CoinCounter.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.CoinCounterObject, this)
};
CoinCounter.prototype.OnDestroy = function() {
    XT.UnregisterCallbackObject(this.OnSoundManagerChanged, this);
    XT.UnregisterCallbackEvent(this.StartCount, this);
    XT.UnregisterCallbackEvent(this.StopCount, this);
    XT.UnregisterCallbackEvent(this.ResetAlternateMusic, this);
    XT.UnregisterCallbackEvent(this.OnGameInit, this);
    XT.UnregisterCallbackEvent(this.OnFreeSpins, this);
    XT.UnregisterCallbackEvent(this.SpinResultIsBigWin, this)
};
CoinCounter.prototype.GetTargetBigWinLevel = function() {
    return this.targetBigWinLevel
};
CoinCounter.prototype.GetCurentCoinCounterSettings = function() {
    return this.currentSettings
};
CoinCounter.prototype.OnCountTarget = function(tgt) {
    this.target = tgt
};
CoinCounter.prototype.OnSoundManagerChanged = function(mgr) {
    this.sndManager = mgr
};
CoinCounter.prototype.StartCount = function() {
    if (XT.GetBool(Vars.Jurisdiction_NoSmallWinCount) && this.timesTotalBetFloat <= 1) return;
    this.counting = true;
    var sndState = XT.GetObject(Vars.SoundState);
    if (this.currentSettings.coinCounterType == CoinCounterType.CoinCounter || this.currentSettings.coinCounterType == CoinCounterType.IndividualBigWinSounds && this.timesTotalBet < this.BigWinSteps[0] && !this.currentSettings.useAlternateMusicForSmallWin) {
        this.timer = 0;
        this.counter = 0;
        this.level = 0;
        this.idxInLevel = 0;
        this.inLevelRepeatCounter =
            0
    } else if (this.currentSettings.coinCounterType == CoinCounterType.AlternateMusic || this.currentSettings.coinCounterType == CoinCounterType.IndividualBigWinSounds && this.timesTotalBet < this.BigWinSteps[0] && this.currentSettings.useAlternateMusicForSmallWin) {
        if (this.currentAlternateMusic.IsPlaying())
            if (sndState.soundFXIsOn) this.sndManager.UnmuteLoopingSound(this.currentAlternateMusic.handler);
            else this.sndManager.MuteLoopingSound(this.currentAlternateMusic.handler)
    } else this.PlayIndividualBigWinSounds();
    if (sndState.soundFXIsOn)
        if (this.timesTotalBet <
            this.BigWinSteps[0]) {
            if (this.currentSettings.muteBackgroundMusic) this.sndManager.MuteMusic()
        } else if (this.currentSettings.muteBackgroundMusicForBigWin) this.sndManager.MuteMusic()
};
CoinCounter.prototype.StopCount = function() {
    if (XT.GetBool(Vars.Jurisdiction_NoSmallWinCount) && this.timesTotalBetFloat <= 1) return;
    this.counting = false;
    if (this.currentSettings.coinCounterType == CoinCounterType.CoinCounter || this.currentSettings.coinCounterType == CoinCounterType.IndividualBigWinSounds && this.timesTotalBet < this.BigWinSteps[0] && !this.currentSettings.useAlternateMusicForSmallWin) this.PlayClip(this.finalSound);
    else if (this.currentSettings.coinCounterType == CoinCounterType.AlternateMusic || this.currentSettings.coinCounterType ==
        CoinCounterType.IndividualBigWinSounds && this.timesTotalBet < this.BigWinSteps[0] && this.currentSettings.useAlternateMusicForSmallWin) {
        this.sndManager.MuteLoopingSound(this.currentAlternateMusic.handler);
        if (this.currentSettings == this.freeSpinsSettings && this.finalAlternateSoundFS != null) this.PlayClip(this.finalAlternateSoundFS);
        else this.PlayClip(this.finalAlternateSound)
    } else this.StopIndividualBigWinSounds();
    if (XT.GetBool(Vars.WaitInResultForBigWin) && this.currentSettings.muteBackgroundMusicForBigWin ||
        this.currentSettings.muteBackgroundMusic) this.sndManager.UnmuteMusic();
    this.targetBigWinLevel = 0;
    this.secondsToCountOneTotalBet = this.secondsToCountOneTotalBetOldValue
};
CoinCounter.prototype.PlayClip = function(clip) {
    this.sndManager.PlaySimple(clip)
};
CoinCounter.prototype.ComputeLevelRepeatCounters = function() {
    this.levels[0].repeat = Math.round(this.BigWinSteps[0] * this.secondsToCountOneTotalBet / (this.levels[0].clips.length * this.delay));
    for (var i = 1; i < this.levels.length - 1; i++) this.levels[i].repeat = Math.round((this.BigWinSteps[i] - this.BigWinSteps[i - 1]) * this.secondsToCountOneTotalBet / (this.levels[i].clips.length * this.delay));
    this.levels[this.levels.length - 1].repeat = 0
};
CoinCounter.prototype.Start = function() {
    this.currentAlternateMusic = this.normalAlternateMusic;
    this.currentSettings = this.normalSettings;
    this.secondsToCountOneTotalBetOldValue = this.secondsToCountOneTotalBet;
    this.ComputeLevelRepeatCounters()
};
CoinCounter.prototype.OnGameInit = function() {
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr.IsFreeSpin) {
        this.currentAlternateMusic = this.freeSpinsAlternateMusic;
        this.currentSettings = this.freeSpinsSettings;
        this.totalWinReceivedSoFarInFS = fsr.CurrentWin
    }
};
CoinCounter.prototype.OnVSGameStateChanged = function() {
    var newState = VSGameStateManager.GetState();
    var newAltMusic;
    var newSettings;
    if (newState == VSGameState.Bonus) {
        newAltMusic = this.bonusGameAlternateMusic;
        newSettings = this.bonusGameSettings
    } else if (newState == VSGameState.SpinFreeSpins || newState == VSGameState.ResultFreeSpins || newState == VSGameState.ResultFreeSpinsPrepare) {
        newAltMusic = this.freeSpinsAlternateMusic;
        newSettings = this.freeSpinsSettings
    } else {
        newAltMusic = this.normalAlternateMusic;
        newSettings = this.normalSettings
    }
    if (this.currentSettings !=
        newSettings) {
        if (this.currentAlternateMusic.IsPlaying()) {
            var args = {
                handle: this.currentAlternateMusic.handler
            };
            this.sndManager.StopLoopingSound(args);
            this.currentAlternateMusic.handler = args.handle
        }
        this.currentSettings = newSettings;
        this.currentAlternateMusic = newAltMusic;
        this.secondsToCountOneTotalBet = this.secondsToCountOneTotalBetOldValue;
        this.ResetAlternateMusic()
    }
};
CoinCounter.prototype.OnFreeSpins = function() {
    if (this.currentAlternateMusic.IsPlaying()) {
        var args = {
            handle: this.currentAlternateMusic.handler
        };
        this.sndManager.StopLoopingSound(args);
        this.currentAlternateMusic.handler = args.handle
    }
    this.currentAlternateMusic = this.currentSettings == this.normalSettings ? this.freeSpinsAlternateMusic : this.normalAlternateMusic;
    this.currentSettings = this.currentSettings == this.normalSettings ? this.freeSpinsSettings : this.normalSettings;
    this.secondsToCountOneTotalBet = this.secondsToCountOneTotalBetOldValue;
    this.ResetAlternateMusic()
};
CoinCounter.prototype.ResetAlternateMusic = function() {
    if (this.currentSettings.coinCounterType == CoinCounterType.AlternateMusic || this.currentSettings.coinCounterType == CoinCounterType.IndividualBigWinSounds && this.currentSettings.useAlternateMusicForSmallWin) {
        if (this.currentAlternateMusic.IsPlaying()) {
            var args = {
                handle: this.currentAlternateMusic.handler
            };
            this.sndManager.StopLoopingSound(args);
            this.currentAlternateMusic.handler = args.handle
        }
        this.currentAlternateMusic.handler = IS_UCBROWSER ? -1 : this.sndManager.PlayLooping(this.currentAlternateMusic.GetClip());
        this.sndManager.MuteLoopingSound(this.currentAlternateMusic.handler)
    }
};
CoinCounter.prototype.PlayIndividualBigWinSounds = function() {
    if (this.individualBigWinClips.length >= this.targetBigWinLevel) this.individualBigWinClips[this.targetBigWinLevel - 1].handler = this.sndManager.PlayLooping(this.individualBigWinClips[this.targetBigWinLevel - 1].GetClip())
};
CoinCounter.prototype.StopIndividualBigWinSounds = function() {
    if (this.individualBigWinClips.length >= this.targetBigWinLevel)
        if (this.individualBigWinClips[this.targetBigWinLevel - 1].IsPlaying()) {
            var args = {
                handle: this.individualBigWinClips[this.targetBigWinLevel - 1].handler
            };
            this.sndManager.StopLoopingSound(args);
            this.individualBigWinClips[this.targetBigWinLevel - 1].handler = args.handle
        }
    if (this.timesTotalBet >= this.BigWinSteps[0])
        if (this.finalIndividualBigWinClips.length > 0) this.PlayClip(this.finalIndividualBigWinClips[this.targetBigWinLevel -
            1]);
        else this.PlayClip(this.finalIndividualBigWinSound)
};
CoinCounter.prototype.ComputeTargetBigWinLevel = function(totalWin, totalBet) {
    if (this.currentSettings.coinCounterType == CoinCounterType.IndividualBigWinSounds && totalWin > 0) {
        this.timesTotalBet = Math.floor(totalWin / totalBet * 100) / 100;
        this.timesTotalBetFloat = totalWin / totalBet;
        this.targetBigWinLevel = 0;
        for (var i = 0; i < this.BigWinSteps.length; i++)
            if (this.timesTotalBet >= this.BigWinSteps[i]) this.targetBigWinLevel++;
        this.secondsToCountOneTotalBet = this.targetBigWinLevel > 0 ? this.IndividualBigWinSoundsDuration[this.targetBigWinLevel -
            1] / this.timesTotalBet : this.secondsToCountOneTotalBetOldValue
    }
};
CoinCounter.prototype.Update = function() {
    if (this.currentSettings.coinCounterType == CoinCounterType.CoinCounter || this.currentSettings.coinCounterType == CoinCounterType.IndividualBigWinSounds && this.timesTotalBet < this.BigWinSteps[0] && !this.currentSettings.useAlternateMusicForSmallWin)
        if (this.counting) {
            this.timer += Time.deltaTime;
            if (this.timer > this.delay) {
                this.timer -= this.delay;
                this.counter++;
                if (this.counter >= this.target) this.StopCount();
                else {
                    this.PlayClip(this.levels[this.level].clips[this.idxInLevel]);
                    this.idxInLevel++;
                    if (this.idxInLevel >= this.levels[this.level].clips.length) {
                        this.idxInLevel = 0;
                        this.inLevelRepeatCounter++;
                        if (this.inLevelRepeatCounter >= this.levels[this.level].repeat) {
                            this.inLevelRepeatCounter = 0;
                            this.level++;
                            if (this.level >= this.levels.length) this.level--
                        }
                    }
                }
            }
        }
    if (this.currentAlternateMusic.IsPlaying() && !this.counting) this.sndManager.MuteLoopingSound(this.currentAlternateMusic.handler)
};
CoinCounter.prototype.SpinResultIsBigWin = function() {
    if (this.originalBigWinSteps == null) this.originalBigWinSteps = this.BigWinSteps;
    if (this.useFreeSpinsBigWinSteps) this.BigWinSteps = XT.GetBool(Vars.Logic_IsFreeSpin) ? this.freeSpinsBigWinSteps : this.originalBigWinSteps;
    var isBigWin = false;
    var totalWin = 0;
    var totalBet = CoinManager.GetLastTotalBet();
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (XT.GetBool(Vars.RespinInProgress))
        if (fsr.IsFreeSpin) {
            totalWin = XT.GetDouble(Vars.WinReceived) * fsr.TotalMultiplier;
            this.totalWinReceivedSoFarInFS = fsr.CurrentWin
        } else totalWin = XT.GetDouble(Vars.WinReceived);
    else if (fsr.IsFreeSpin)
        if (fsr.IsLastFreeSpin && XT.GetObject(Vars.TumblingData) == null) {
            totalWin = (fsr.CurrentWin - this.totalWinReceivedSoFarInFS) * fsr.TotalMultiplier;
            this.totalWinReceivedSoFarInFS = 0
        } else {
            totalWin = XT.GetDouble(Vars.WinReceived) * fsr.TotalMultiplier;
            this.totalWinReceivedSoFarInFS = fsr.CurrentWin
        }
    else if (!XT.GetBool(Vars.MustOpenBonus) || XT.GetBool(Vars.CanTriggerBigWinBeforeBonus)) totalWin = XT.GetDouble(Vars.WinReceived);
    this.timesTotalBet = Math.floor(totalWin / totalBet * 100) / 100;
    isBigWin = this.timesTotalBet >= this.BigWinSteps[0];
    XT.SetInt(Vars.SpinResultWinLevel, this.timesTotalBet);
    XT.SetInt(Vars.SpinResultBigWinLevel, 0);
    for (var i = 0; i < this.BigWinSteps.length; i++)
        if (this.timesTotalBet >= this.BigWinSteps[i]) XT.SetInt(Vars.SpinResultBigWinLevel, i);
    XT.SetBool(Vars.SpinResultIsBigWin, isBigWin)
};
CoinCounter.prototype.ForceChangeToState = function(state) {
    var newAlternateMusic = null;
    var newSettings = null;
    if (state == "normal") {
        newAlternateMusic = this.normalAlternateMusic;
        newSettings = this.normalSettings
    } else if (state == "freespins") {
        newAlternateMusic = this.freeSpinsAlternateMusic;
        newSettings = this.freeSpinsSettings
    } else if (state == "bonus") {
        newAlternateMusic = this.bonusGameAlternateMusic;
        newSettings = this.bonusGameSettings
    }
    if (this.currentSettings != newSettings) this.secondsToCountOneTotalBet = this.secondsToCountOneTotalBetOldValue;
    this.currentAlternateMusic = newAlternateMusic;
    this.currentSettings = newSettings;
    this.ResetAlternateMusic()
};
CoinCounter.prototype.ForceResetToExpectedState = function() {
    this.OnVSGameStateChanged()
};
goog.require("UHT.XTLink");
goog.require("UHT.AudioClassesUtils");
var WinAnimState = {
    idle: 0,
    level0: 1,
    level1: 2,
    level2: 3,
    level3: 4,
    level4: 5,
    level5: 6,
    jackpot: 7,
    hidingBigWin: 8
};
ValueAnimatorWithBigWin.prototype = Object.create(XTLink.prototype);
ValueAnimatorWithBigWin.prototype.constructor = ValueAnimatorWithBigWin;
ValueAnimatorWithBigWin.prototype.scriptUpdatePriority = 6;

function ValueAnimatorWithBigWin() {
    XTLink.call(this);
    this.vdVariable = null;
    this.reallyTriggersBigWin = true;
    this.setSkipTheNextBigWin = true;
    this.canBeSkippedByPreviousBigWin = true;
    this.animateWhenIncreasing = true;
    this.playSoundsWhenAnimating = false;
    this.isJackPot = false;
    this.makeTrueWhenAnimating = null;
    this.minimumBigWinDuration = 2;
    this.multiplierFX = null;
    this.oldValue = 0;
    this.newValue = 0;
    this.delta = 0;
    this.currentValue = 0;
    this.isAnimating = false;
    this.curTime = -1;
    this.animationTime = 1;
    this.normalWinTime = .5;
    this.totalBet =
        0;
    this.coinCounter = null;
    this.currentState = WinAnimState.idle;
    this.skipClicks = 0;
    this.lastFinalizeReceived = -1
}
ValueAnimatorWithBigWin.counterVars = [];
ValueAnimatorWithBigWin.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_LastBetsChanged, this.ComputeTotalBet, this);
    XT.RegisterCallbackDouble(this.vdVariable.variable.name, this.OnTargetValueChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_BigWinHasFinished, this.OnBigWinFinished, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_FinalizeDisplayedWin, this.OnFinalizeValue, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnInit, this)
};
ValueAnimatorWithBigWin.prototype.XTInitVariablesAndEvents = function() {
    XT.SetDouble(this.vdVariable.GetAnimatedVarName(), 0);
    XT.SetBool(Vars.SkipNextBigWin, false);
    if (this.makeTrueWhenAnimating.name != "") XT.SetBool(this.makeTrueWhenAnimating.name, false)
};
ValueAnimatorWithBigWin.prototype.ComputeTotalBet = function() {
    this.totalBet = CoinManager.GetLastTotalBet()
};
ValueAnimatorWithBigWin.prototype.OnDestroy = function() {
    XT.UnregisterCallbackDouble(this.OnTargetValueChanged, this);
    XT.UnregisterCallbackEvent(this.OnBigWinFinished, this);
    XT.UnregisterCallbackEvent(this.OnFinalizeValue, this);
    XT.UnregisterCallbackEvent(this.ComputeTotalBet, this)
};
ValueAnimatorWithBigWin.prototype.OnInit = function() {
    this.coinCounter = XT.GetObject(Vars.CoinCounterObject)
};
ValueAnimatorWithBigWin.prototype.OnTargetValueChanged = function(newVal) {
    this.newValue = newVal;
    this.skipClicks = 0;
    var justSetTheValue = true;
    var epsilon = 1E-4;
    if (this.isAnimating) this.oldValue = this.currentValue;
    this.delta = this.newValue - this.oldValue;
    if (XT.GetBool(Vars.CanAnimateValues) && this.newValue > this.oldValue + epsilon && this.animateWhenIncreasing && this.totalBet > 0 && CoinManager.IsInit()) {
        if (this.reallyTriggersBigWin) this.coinCounter.ComputeTargetBigWinLevel(this.delta, this.totalBet);
        var skip = this.CalculateAnimationTime(this.delta);
        if (!skip) {
            this.isAnimating = true;
            this.curTime = 0;
            if (this.multiplierFX != null) {
                this.multiplierFX.ComputeStartFXTime(this.oldValue, this.oldValue, this.newValue, this.animationTime);
                if (this.multiplierFX.curFXIndex > -1) this.curTime = this.multiplierFX.startFXTime[this.multiplierFX.curFXIndex]
            }
            if (this.makeTrueWhenAnimating.name != "") XT.SetBool(this.makeTrueWhenAnimating.name, true);
            var allowShowVisual = true;
            if (this.vdVariable.variable.name != Vars.BalanceDisplayed) {
                if (XT.GetInt(Vars.VAWBWCounters) == 0) XT.SetBool(Vars.LastWinIsCounting,
                    true);
                this.IncreaseVAWBWCounter(this.vdVariable.variable.name)
            } else XT.SetBool(Vars.BalanceIsCounting, true);
            if (!(newVal >= this.totalBet * this.coinCounter.BigWinSteps[0] || this.isJackPot)) allowShowVisual = false;
            if (this.reallyTriggersBigWin && allowShowVisual) {
                XT.SetInt(Vars.BigWinLevel, 7);
                XT.TriggerEvent(Vars.Evt_Internal_ShowBigWin);
                XT.SetBool(Vars.WaitInResultForBigWin, true)
            }
            if (this.setSkipTheNextBigWin) XT.SetBool(Vars.SkipNextBigWin, true);
            if (this.playSoundsWhenAnimating) XT.SetInt(Vars.CurrentCoinCountTarget,
                CoinManager.ConvertMoneyToCoins(this.newValue));
            if (this.playSoundsWhenAnimating && !this.isJackPot) {
                this.coinCounter.ComputeTargetBigWinLevel(this.delta, this.totalBet);
                XT.TriggerEvent(Vars.Evt_Internal_CoinCounterStart)
            }
            justSetTheValue = false
        }
    }
    if (justSetTheValue) {
        this.oldValue = this.newValue;
        this.currentValue = this.newValue;
        XT.SetDouble(this.vdVariable.GetAnimatedVarName(), this.newValue);
        if (this.isJackPot && newVal > 0 && !XT.GetBool(Vars.CanAnimateValues)) XT.TriggerEvent(Vars.Evt_Internal_JackpotCounterEnded)
    }
    this.Update()
};
ValueAnimatorWithBigWin.prototype.OnBigWinFinished = function() {
    this.currentState = WinAnimState.idle;
    XT.SetBool(Vars.WaitInResultForBigWin, false)
};
ValueAnimatorWithBigWin.prototype.SendGASkipEvent = function() {
    var level = XT.GetInt(Vars.BigWinLevel);
    if (level > 0 && level < 6 && this.curTime < this.animationTime && this.reallyTriggersBigWin && GA_BW_SENDONESKIP) {
        globalTracking.SendEvent("uht_behaviour_BigWin", "SkippedTimeLevel_" + level.toString(), this.curTime | 0, "BehaviourTracker");
        GA_BW_SENDONESKIP = false
    }
};
ValueAnimatorWithBigWin.prototype.OnFinalizeValue = function() {
    if (this.gameObject.activeInHierarchy && this.isAnimating) {
        if (this.isJackPot) {
            if (this.curTime > XT.GetFloat(Vars.MinimumJackpotBigWinDuration)) {
                this.curTime = this.animationTime;
                this.SendGASkipEvent();
                this.Update()
            }
            return
        }
        if (XT.GetInt(Vars.BigWinLevel) > 0) {
            this.curTime = this.animationTime;
            this.SendGASkipEvent()
        } else {
            this.curTime = this.animationTime;
            this.SendGASkipEvent()
        }
        this.Update()
    }
};
ValueAnimatorWithBigWin.prototype.UpdateAnimationLevel = function(currAnimTime) {
    if (this.isJackPot) {
        if (this.reallyTriggersBigWin)
            if (this.currentState != WinAnimState.jackpot) {
                this.currentState = WinAnimState.jackpot;
                XT.SetInt(Vars.BigWinLevel, WinAnimState.jackpot - 1);
                XT.TriggerEvent(Vars.Evt_Internal_ShowBigWin)
            }
    } else {
        var progress = currAnimTime / this.animationTime;
        var n = this.oldValue + progress * this.delta;
        if (this.coinCounter.GetCurentCoinCounterSettings().coinCounterType == CoinCounterType.IndividualBigWinSounds &&
            this.coinCounter.GetTargetBigWinLevel() > 0) {
            if (currAnimTime == 0 && this.reallyTriggersBigWin) {
                var lvl = this.coinCounter.GetTargetBigWinLevel();
                XT.SetInt(Vars.BigWinLevel, lvl);
                var wantedState = WinAnimState.level0 + lvl;
                this.currentState = wantedState;
                XT.TriggerEvent(Vars.Evt_Internal_ShowBigWin)
            }
        } else {
            var lvl = 0;
            for (lvl = 0; lvl < this.coinCounter.BigWinSteps.length; lvl++)
                if (this.totalBet * this.coinCounter.BigWinSteps[lvl] > n) break;
            var wantedState = WinAnimState.level0 + lvl;
            if (this.currentState != wantedState) {
                this.currentState =
                    wantedState;
                if (lvl > 0)
                    if (this.reallyTriggersBigWin && this.animationTime != this.normalWinTime) {
                        XT.SetInt(Vars.BigWinLevel, this.currentState - WinAnimState.level0);
                        XT.TriggerEvent(Vars.Evt_Internal_ShowBigWin)
                    }
            }
        }
    }
    if (currAnimTime == this.animationTime) {
        if (!this.reallyTriggersBigWin) this.currentState = WinAnimState.idle;
        else if (this.currentState == WinAnimState.level0) {
            this.currentState = WinAnimState.idle;
            if (this.playSoundsWhenAnimating && !this.isJackPot) XT.TriggerEvent(Vars.Evt_Internal_CoinCounterStop)
        } else {
            this.currentState =
                WinAnimState.hidingBigWin;
            XT.TriggerEvent(Vars.Evt_Internal_ClearBigWin);
            if (this.playSoundsWhenAnimating && !this.isJackPot) XT.TriggerEvent(Vars.Evt_Internal_CoinCounterStop);
            if (this.isJackPot) XT.TriggerEvent(Vars.Evt_Internal_JackpotCounterEnded)
        }
        if (this.vdVariable.variable.name != Vars.BalanceDisplayed) {
            this.DecreaseVAWBWCounter(this.vdVariable.variable.name);
            if (XT.GetInt(Vars.VAWBWCounters) == 0) {
                XT.SetBool(Vars.LastWinIsCounting, false);
                UHTInterfaceBOSS.PostMessage("resultShown")
            }
        } else XT.SetBool(Vars.BalanceIsCounting,
            false)
    }
};
ValueAnimatorWithBigWin.prototype.CalculateAnimationTime = function(deltaValue) {
    if (this.coinCounter == null) return true;
    if (this.isJackPot) {
        this.animationTime = 18;
        return false
    } else this.animationTime = CoinManager.ConvertMoneyToCoins(deltaValue);
    this.normalWinTime = this.coinCounter.BigWinSteps[0] - 1;
    var speedUp = CoinManager.ConvertMoneyToCoins(this.totalBet) / this.coinCounter.secondsToCountOneTotalBet;
    if (this.coinCounter.GetTargetBigWinLevel() < 1 && this.coinCounter.forcedSmallWinCountDuration > 0) this.animationTime = this.coinCounter.forcedSmallWinCountDuration;
    else this.animationTime /= speedUp;
    this.normalWinTime /= speedUp;
    if (this.canBeSkippedByPreviousBigWin && XT.GetBool(Vars.SkipNextBigWin)) {
        this.animationTime = this.normalWinTime;
        return true
    }
    return false
};
ValueAnimatorWithBigWin.prototype.Update = function() {
    if (this.totalBet > 0 && CoinManager.IsInit())
        if (this.isAnimating) {
            if (this.multiplierFX != null && this.multiplierFX.curFXIndex > -1) {
                var fxTime = this.multiplierFX.startFXTime[this.multiplierFX.curFXIndex];
                if (this.curTime <= fxTime && this.curTime + Time.deltaTime > fxTime) this.multiplierFX.StartFX()
            }
            if (this.curTime > -.001) {
                var progress = this.curTime / this.animationTime;
                this.currentValue = this.oldValue + progress * this.delta;
                if (this.curTime < this.animationTime) {
                    XT.SetDouble(this.vdVariable.GetAnimatedVarName(),
                        this.currentValue);
                    this.UpdateAnimationLevel(this.curTime);
                    this.curTime += Time.deltaTime
                } else {
                    this.isAnimating = false;
                    this.curTime = -1;
                    XT.SetDouble(this.vdVariable.GetAnimatedVarName(), this.newValue);
                    this.UpdateAnimationLevel(this.animationTime);
                    this.oldValue = this.newValue;
                    if (this.makeTrueWhenAnimating.name != "") XT.SetBool(this.makeTrueWhenAnimating.name, false)
                }
            } else this.curTime += Time.deltaTime
        }
};
ValueAnimatorWithBigWin.prototype.IncreaseVAWBWCounter = function(name) {
    var idx = ValueAnimatorWithBigWin.counterVars.indexOf(name);
    if (idx < 0) {
        XT.SetInt(Vars.VAWBWCounters, XT.GetInt(Vars.VAWBWCounters) + 1);
        ValueAnimatorWithBigWin.counterVars.push(name)
    }
};
ValueAnimatorWithBigWin.prototype.DecreaseVAWBWCounter = function(name) {
    var idx = ValueAnimatorWithBigWin.counterVars.indexOf(name);
    if (idx > -1) {
        XT.SetInt(Vars.VAWBWCounters, XT.GetInt(Vars.VAWBWCounters) - 1);
        ValueAnimatorWithBigWin.counterVars.splice(idx, 1)
    }
};
goog.require("UHT.XTLink");
goog.require("UHT.AnimationCurve");
ValueAnimator.prototype = Object.create(XTLink.prototype);
ValueAnimator.prototype.constructor = ValueAnimator;

function ValueAnimator() {
    XTLink.call(this);
    this.vdVariable = null;
    this.animationTime = 2;
    this.animateWhenIncreasing = true;
    this.animCurveIncreasing = null;
    this.animateWhenDecreasing = true;
    this.animCurveDecreasing = null;
    this.curAnimCurve = null;
    this.oldValue = 0;
    this.newValue = 0;
    this.delta = 0;
    this.currentValue = 0;
    this.curTime = -1
}
ValueAnimator.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackDouble(this.vdVariable.variable.name, this.OnTargetValueChanged, this)
};
ValueAnimator.prototype.XTInitVariablesAndEvents = function() {
    XT.SetDouble(this.vdVariable.GetAnimatedVarName(), 0)
};
ValueAnimator.prototype.OnDestroy = function() {
    XT.UnregisterCallbackDouble(this.OnTargetValueChanged, this)
};
ValueAnimator.prototype.OnTargetValueChanged = function(newVal) {
    this.newValue = newVal;
    var justSetTheValue = true;
    var epsilon = 1E-4;
    if (this.curTime > -.001)
        if (this.curTime < this.animationTime) this.oldValue = this.currentValue;
    if (this.newValue > this.oldValue + epsilon && this.animateWhenIncreasing) {
        this.curTime = 0;
        this.delta = this.newValue - this.oldValue;
        this.curAnimCurve = this.animCurveIncreasing;
        justSetTheValue = false
    } else if (this.newValue < this.oldValue - epsilon && this.animateWhenDecreasing) {
        this.curTime = 0;
        this.delta = this.newValue -
            this.oldValue;
        this.curAnimCurve = this.animCurveDecreasing;
        justSetTheValue = false
    }
    if (justSetTheValue) {
        this.oldValue = this.newValue;
        this.currentValue = this.newValue;
        XT.SetDouble(this.vdVariable.GetAnimatedVarName(), this.newValue)
    }
};
ValueAnimator.prototype.Update = function() {
    if (this.curTime > -.001) {
        var progress = this.curTime / this.animationTime;
        if (this.curAnimCurve.keys.length >= 2) {
            var startKey = this.curAnimCurve.keys[0];
            var endKey = this.curAnimCurve.keys[this.curAnimCurve.keys.length - 1];
            var totalCurveTime = endKey.time - startKey.time;
            var curCurveTime = progress * totalCurveTime;
            progress = this.curAnimCurve.Evaluate(curCurveTime)
        }
        this.currentValue = this.oldValue + progress * this.delta;
        if (this.curTime < this.animationTime) {
            this.curTime += Time.deltaTime;
            XT.SetDouble(this.vdVariable.GetAnimatedVarName(), this.currentValue)
        } else {
            this.curTime = -1;
            this.curAnimCurve = null;
            this.oldValue = this.newValue;
            XT.SetDouble(this.vdVariable.GetAnimatedVarName(), this.newValue)
        }
    }
};
ValueAnimator.prototype.Stop = function() {
    this.curTime = -1;
    this.curAnimCurve = null;
    this.oldValue = this.newValue;
    XT.SetDouble(this.vdVariable.GetAnimatedVarName(), this.newValue)
};
goog.require("UHT.Engine");
JackpotButtonController.prototype = Object.create(XTLink.prototype);
JackpotButtonController.prototype.constructor = JackpotButtonController;

function JackpotButtonController() {
    XTLink.call(this);
    this.jackpots = []
}
JackpotButtonController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_UpdateJackpotUI, this.OnJackpotUIUpdate, this)
};
JackpotButtonController.prototype.XTInitVariablesAndEvents = function() {
    XT.SetInt(Vars.CurrentlyDisplayedJackpot, -1)
};
JackpotButtonController.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnJackpotUIUpdate, this)
};
JackpotButtonController.prototype.OnJackpotUIUpdate = function() {
    for (var i = 0; i < this.jackpots.length; i++)
        if (i == XT.GetInt(Vars.CurrentlyDisplayedJackpot)) this.jackpots[i].SetActive(true);
        else this.jackpots[i].SetActive(false)
};
goog.require("UHT.Engine");
SmallWinSkipper.prototype = Object.create(XTLink.prototype);
SmallWinSkipper.prototype.constructor = SmallWinSkipper;

function SmallWinSkipper() {
    XTLink.call(this)
}
SmallWinSkipper.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.LastWinIsCounting, this.OnWinCount, this)
};
SmallWinSkipper.prototype.OnDestroy = function() {
    XT.UnregisterCallbackBool(this.OnWinCount, this)
};
SmallWinSkipper.prototype.OnWinCount = function(b) {
    var shouldBeActive = b && !XT.GetBool(Vars.WaitInResultForBigWin);
    this.gameObject.SetActive(shouldBeActive)
};
SmallWinSkipper.prototype.SkipSmallWinCount = function() {
    XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    this.gameObject.SetActive(false)
};
goog.require("UHT.Engine");
HotKeyClicker.prototype = Object.create(Component.prototype);
HotKeyClicker.prototype.constructor = HotKeyClicker;

function HotKeyClicker() {
    Component.call(this);
    this.inactiveDuringBigWin = false
}
HotKeyClicker.prototype.Update = function() {
    if (!Globals.InputBlocked && (Input.GetKeyDown(KeyCode.Space, true) || Input.GetKeyDown(KeyCode.Return, true))) {
        if (this.inactiveDuringBigWin && XT.GetBool(Vars.WaitInResultForBigWin)) return;
        var cd = this.gameObject.GetComponent(ClickDelay);
        if (cd == null || cd.CanClick()) this.gameObject.SendMessage("OnClick")
    }
};
goog.require("UHT.Engine");
ScreenAnchor.prototype = Object.create(Component.prototype);
ScreenAnchor.prototype.constructor = ScreenAnchor;

function ScreenAnchor() {
    Component.call(this);
    this.targetTransform = null;
    this.alsoScaleTheSprite = false;
    this.anchorTop = false;
    this.topOffset = 0;
    this.anchorBottom = false;
    this.bottomOffset = 0;
    this.anchorLeft = false;
    this.leftOffset = 0;
    this.anchorRight = false;
    this.rightOffset = 0;
    this.scaleHorizontaly = false;
    this.widthOffset = 0;
    this.scaleVerticaly = false;
    this.heightOffset = 0;
    this.callWhenChanged = null;
    this.limitByGameAnchors = false;
    this.lastScreenWidth = 0;
    this.lastScreenHeight = 0;
    this.updateIsNeeded = false;
    this.cachedLayer = -1;
    this.cachedCamera = null;
    this.cameraPos = null
}
ScreenAnchor.prototype.Update = function() {
    var myCamera = this.GetMyCamera();
    if (this.lastScreenWidth != UHTScreen.width || this.lastScreenHeight != UHTScreen.height || this.IsCameraPositionChanged(myCamera)) {
        this.lastScreenWidth = UHTScreen.width;
        this.lastScreenHeight = UHTScreen.height;
        this.updateIsNeeded = true;
        return
    }
    if (!this.updateIsNeeded || myCamera == null) return;
    this.updateIsNeeded = false;
    var posOnScreen = new UHTMath.Vector3(0, 0, 0);
    if (this.anchorBottom) posOnScreen.y = this.lastScreenHeight;
    if (this.anchorRight) posOnScreen.x =
        this.lastScreenWidth;
    var posOnWorld = myCamera.ScreenToWorldPoint(posOnScreen);
    var pos = this.targetTransform.position();
    if (this.limitByGameAnchors) {
        var ga = XT.GetObject(InterfaceVars.GameAnchors);
        var UL = ga.upLeft.position();
        var DR = ga.downRight.position();
        var x = this.anchorLeft || this.anchorRight ? posOnWorld.x : pos.x;
        var y = this.anchorTop || this.anchorBottom ? posOnWorld.y : pos.y;
        if (this.anchorLeft && x < UL.x) x = UL.x;
        if (this.anchorRight && x > DR.x) x = DR.x;
        if (this.anchorTop && y > UL.y) y = UL.y;
        if (this.anchorBottom && y < DR.y) y =
            DR.y;
        posOnWorld = new UHTMath.Vector3(x, y, 0)
    }
    this.targetTransform.position(this.anchorLeft || this.anchorRight ? posOnWorld.x : pos.x, this.anchorTop || this.anchorBottom ? posOnWorld.y : pos.y, pos.z);
    var offset = new UHTMath.Vector3(0, 0, 0);
    if (this.anchorTop) offset.y = -this.topOffset;
    else if (this.anchorBottom) offset.y = this.bottomOffset;
    if (this.anchorLeft) offset.x = this.leftOffset;
    else if (this.anchorRight) offset.x = -this.rightOffset;
    this.targetTransform.localPosition(this.targetTransform.localPosition().x + offset.x, this.targetTransform.localPosition().y +
        offset.y, this.targetTransform.localPosition().z);
    if (this.alsoScaleTheSprite) {
        var uiRoot = Component.FindObjectOfType(ArrangeableUIRoot).gameObject.GetComponent(UIRoot);
        var targetRatio = uiRoot.manualWidth / uiRoot.manualHeight;
        var currentRatio = this.lastScreenWidth / this.lastScreenHeight;
        var sceneScale = 1;
        if (currentRatio < targetRatio) sceneScale = this.lastScreenWidth / uiRoot.manualWidth;
        else sceneScale = this.lastScreenHeight / uiRoot.manualHeight;
        var sprite = this.targetTransform.GetComponent(UISprite);
        if (this.scaleHorizontaly) {
            var w =
                this.lastScreenWidth / sceneScale;
            w *= uiRoot.gameObject.transform._internal_get_scale().x / sprite.gameObject.transform._internal_get_scale().x;
            sprite.width = _number.otoi(w + this.widthOffset)
        }
        if (this.scaleVerticaly) {
            var h = this.lastScreenHeight / sceneScale;
            h *= uiRoot.gameObject.transform._internal_get_scale().y / sprite.gameObject.transform._internal_get_scale().y;
            sprite.height = _number.otoi(h + this.heightOffset)
        }
    }
    if (this.callWhenChanged != null) this.callWhenChanged.Start()
};
ScreenAnchor.prototype.GetMyCamera = function() {
    var go = this.targetTransform.gameObject;
    if (this.cachedLayer != go.layer || this.cachedCamera == null) {
        this.cachedLayer = go.layer;
        this.cachedCamera = Globals.GetCameraForObject(go)
    }
    return this.cachedCamera
};
ScreenAnchor.prototype.IsCameraPositionChanged = function(camera) {
    if (camera == null) return false;
    var pos = camera.transform.position();
    var changed = this.cameraPos == null || !this.cameraPos.equals(pos);
    if (changed) this.cameraPos = pos;
    return changed
};
goog.require("UHT.XTLink");
CoinsAndCashHint.prototype = Object.create(XTLink.prototype);
CoinsAndCashHint.prototype.constructor = CoinsAndCashHint;
var CoinsAndCashHintVars = {
    Evt_DataToCode_HideCoinsAndCashHint: "Evt_DataToCode_HideCoinsAndCashHint"
};

function CoinsAndCashHint() {
    XTLink.call(this);
    this.catShowHint = null;
    this.catHideHint = null;
    this.canHideHint = false
}
CoinsAndCashHint.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this);
    XT.RegisterCallbackEvent(CoinsAndCashHintVars.Evt_DataToCode_HideCoinsAndCashHint, this.HideHintIfVisible, this)
};
CoinsAndCashHint.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(InterfaceVars.ShowCoinsAndCashHint, !ServerOptions.isReplay)
};
CoinsAndCashHint.prototype.UnregisterCallbacks = function() {
    XT.UnregisterCallbackBool(this.OnHasCoinsChanged, this)
};
CoinsAndCashHint.prototype.OnGUIInit = function() {
    if (XT.GetBool(InterfaceVars.ShowCoinsAndCashHint) && XT.GetBool(Vars.FromServer_AllowCoins)) XT.RegisterCallbackEvent(Vars.Evt_CodeToData_IntroClosedOrSkipped, this.ShowHint, this)
};
CoinsAndCashHint.prototype.OnHasCoinsChanged = function(unused) {
    if (this.canHideHint) this.HideHint()
};
CoinsAndCashHint.prototype.ShowHint = function() {
    XT.RegisterCallbackBool(Vars.HasCoins, this.OnHasCoinsChanged, this);
    this.canHideHint = true;
    this.StopRunningEvents();
    this.catShowHint.Start();
    XT.SetBool(InterfaceVars.ShowCoinsAndCashHint, false);
    XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
};
CoinsAndCashHint.prototype.HideHint = function() {
    this.canHideHint = false;
    this.StopRunningEvents();
    this.catHideHint.Start()
};
CoinsAndCashHint.prototype.HideHintForever = function() {
    this.OnHasCoinsChanged(true)
};
CoinsAndCashHint.prototype.StopRunningEvents = function() {
    if (this.catShowHint.IsRunning()) this.catShowHint.Stop();
    if (this.catHideHint.IsRunning()) this.catHideHint.Stop()
};
CoinsAndCashHint.prototype.HideHintIfVisible = function() {
    if (this.canHideHint) this.HideHint()
};
goog.require("UHT.Engine");
AnchorToUILabel.prototype = Object.create(Component.prototype);
AnchorToUILabel.prototype.constructor = AnchorToUILabel;

function AnchorToUILabel() {
    Component.call(this);
    this.targetLabel = null;
    this.updateSpriteSize = false;
    this.extraSize = 0;
    this.keepAspectRatio = false;
    this.snapToLabelsPosition = false;
    this.labelPositionOffset = UHTMath.Vector3.zero;
    this.transformToChangeIfSnap = null;
    this.labelScale = null;
    this.curWidth = -1;
    this.updatePosition = false
}
AnchorToUILabel.prototype.scriptUpdatePriority = 9;
AnchorToUILabel.prototype.OnEnable = function() {
    this.updatePosition = this.snapToLabelsPosition
};
AnchorToUILabel.prototype.Update = function() {
    var w = this.targetLabel.GetWidth();
    if (this.labelScale != null) w = Math.round(w * this.labelScale.localScale().x);
    if (w != this.curWidth && this.updateSpriteSize) {
        this.curWidth = w;
        var sprite = this.GetComponent(UISprite);
        var oldWidth = sprite.width;
        sprite.width = w + this.extraSize;
        if (this.keepAspectRatio) sprite.height = sprite.height * (sprite.width / oldWidth) | 0;
        sprite.SetSpriteName(sprite.spriteName)
    }
    if (this.snapToLabelsPosition && (this.updatePosition || this.transformToChangeIfSnap.position().equals(this.targetLabel.transform.position()) ==
            false)) {
        this.updatePosition = false;
        var pos = this.targetLabel.transform.transformPoint(new UHTMath.Vector3(this.targetLabel.GetWidth() * this.labelPositionOffset.x, this.targetLabel.GetHeight() * this.labelPositionOffset.y, 0));
        this.transformToChangeIfSnap.position(new UHTMath.Vector3(pos.x, pos.y, this.transformToChangeIfSnap.position().z))
    }
};
goog.require("UHT.Engine");
ClickDelay.prototype = Object.create(Component.prototype);
ClickDelay.prototype.constructor = ClickDelay;

function ClickDelay() {
    Component.call(this);
    this.delay = 2;
    this.timer = 0
}
ClickDelay.prototype.OnEnable = function() {
    this.timer = 0
};
ClickDelay.prototype.Update = function() {
    this.timer += Time.deltaTime
};
ClickDelay.prototype.CanClick = function() {
    return this.timer > this.delay
};
goog.provide("UHT.InterfaceUtils");

function ButtonOpenClose() {
    this.opened = null;
    this.closed = null
}
goog.require("UHT.XTLink");
goog.require("UHT.InterfaceUtils");
InterfaceControllerMobile_2.prototype = Object.create(XTLink.prototype);
InterfaceControllerMobile_2.prototype.constructor = InterfaceControllerMobile_2;

function InterfaceControllerMobile_2() {
    XTLink.call(this);
    this.otherInterface = null;
    this.contentInterface = null;
    this.menuButton = null;
    this.betsButton = null;
    this.menuButtonsParent = null;
    this.paytableCloseButton = null;
    this.autoplayCloseButton = null;
    this.totalBetButton = null;
    this.spinBtn = null;
    this.stopBtn = null;
    this.stopBtnVisual = null;
    this.gambleButton = null;
    this.betsControllers = null;
    this.autoplayControllers = null;
    this.menuWindow = null;
    this.gambleWindow = null;
    this.buttons_resultFSWithGamble = null;
    this.buttons_resultFSWithoutGamble =
        null;
    this.autoplayAdvancedWindow = null;
    this.dynamicContentNormal = null;
    this.dynamicContentAutoplay = null;
    this.dynamicContentFreeSpins = null;
    this.dynamicContentFreeSpinsMysteryScatter = null;
    this.dynamicContentBonusRounds = null;
    this.dynamicContentBonusRoundsAutoplay = null;
    this.toggledInBonusGame = null;
    this.toggledInGamble = [];
    this.toggledOnHideWin = null;
    this.winDisplayedContainers = null;
    this.fsMultiplierToggles = null;
    this.messageController = null;
    this.middleBar = null;
    this.rq = null;
    this.balanceParent = null;
    this.bonusBalanceParent =
        null;
    this.visibleIfGameHasLines = null;
    this.visibleIfGameHasWays = null;
    this.internalState = VSGameState.Invalid;
    this.enableMenuButtons = true;
    this.currentOpenedWindow = InterfaceControllerMobile_2.WindowTypes.None;
    this.uiIsActive = false;
    this.coinValueChanged = false;
    this.stopButtonEnabler = null;
    this.stopButtonColliderEnabler = null
}
InterfaceControllerMobile_2.AutoplayState = {
    Normal: 0,
    Pressed: 1,
    Stop: 2
};
InterfaceControllerMobile_2.WindowTypes = {
    None: 0,
    Autoplay_Simple: 1,
    Autoplay_Advanced: 2,
    Bets: 3,
    Paytable: 4,
    Menu: 5
};
InterfaceControllerMobile_2.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(InterfaceVars.IsMobileGUI, true)
};
InterfaceControllerMobile_2.prototype.XTRegisterCallbacks = function() {
    this.stopButtonEnabler = this.stopBtn.transform.gameObject.GetComponentsInChildren(ButtonEnabler, true)[0];
    this.stopButtonColliderEnabler = this.stopBtn.transform.gameObject.GetComponentsInChildren(ColliderEnabler, true)[0];
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_PaytableClosed, this.OnRequestToClosePaytable, this);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayout,
        this.DisableUI, this);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWide, this.DisableUI, this);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWideFull, this.DisableUI, this);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayout, this.EnableUI, this);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPad, this.EnableUI, this);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPhone, this.EnableUI, this);
    XT.RegisterCallbackBool(Vars.CanSpin,
        this.OnCanSpinChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinValueChanged, this.OnCoinValueChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_UpdateDisplayedWinInUI, this.OnRequestToUpdateDisplayedWinInUI, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_DataToCode_CloseAllInterfaceWindows, this.CloseCurrentOpenedWindow, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ChangeVSGameState, this.OnVSGameStateChanged,
        this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_DataToCode_HidePortraitMiddleBar, this.OnHidePortraitMiddleBar, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_DataToCode_ShowPortraitMiddleBar, this.OnShowPortraitMiddleBar, this);
    XT.RegisterCallbackBool(Vars.LastWinIsCounting, this.OnLastWinIsCountingChanged, this);
    XT.RegisterCallbackDouble(Vars.BonusBalance, this.UpdateBalanceContent, this);
    XT.RegisterCallbackBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins, this.OnResultMinimumTimeBetweenSpins, this);
    XT.RegisterCallbackBool(Vars.DisableStopButton, this.OnDisableStopButton, this)
};
InterfaceControllerMobile_2.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGUIInit, this);
    XT.UnregisterCallbackEvent(this.OnRequestToClosePaytable, this);
    XT.UnregisterCallbackEvent(this.EnableUI, this);
    XT.UnregisterCallbackEvent(this.DisableUI, this);
    XT.UnregisterCallbackEvent(this.OnCoinValueChanged, this);
    XT.UnregisterCallbackEvent(this.OnSpinStarted, this);
    XT.UnregisterCallbackEvent(this.OnRequestToUpdateDisplayedWinInUI, this);
    XT.UnregisterCallbackEvent(this.OnVSGameStateChanged, this);
    XT.UnregisterCallbackDouble(this.UpdateBalanceContent, this)
};
InterfaceControllerMobile_2.prototype.OnVSGameStateChanged = function() {
    this.ChangeState(VSGameStateManager.GetState());
    this.UpdateStopBtn()
};
InterfaceControllerMobile_2.prototype.GetCurrentWindow = function() {
    return this.currentOpenedWindow
};
InterfaceControllerMobile_2.prototype.EnableUI = function() {
    if (this.uiIsActive) return;
    this.uiIsActive = true;
    this.contentInterface.SetActive(true);
    this.ChangeState(this.internalState);
    this.CloseCurrentOpenedWindow();
    var w = this.otherInterface.GetCurrentWindow();
    if (this.currentOpenedWindow != w) this.UpdateWindows(w, true)
};
InterfaceControllerMobile_2.prototype.DisableUI = function() {
    this.uiIsActive = false;
    this.contentInterface.SetActive(false)
};
InterfaceControllerMobile_2.prototype.Pressed_Menu_Open = function() {
    this.UpdateWindows(InterfaceControllerMobile_2.WindowTypes.Menu, true)
};
InterfaceControllerMobile_2.prototype.Pressed_Menu_Close = function() {
    this.UpdateWindows(InterfaceControllerMobile_2.WindowTypes.Menu, false)
};
InterfaceControllerMobile_2.prototype.Pressed_BetsWindow_Open = function() {
    this.UpdateWindows(InterfaceControllerMobile_2.WindowTypes.Bets, true)
};
InterfaceControllerMobile_2.prototype.Pressed_BetsWindow_Close = function() {
    this.UpdateWindows(InterfaceControllerMobile_2.WindowTypes.Bets, false)
};
InterfaceControllerMobile_2.prototype.Pressed_AutoplayWindow_Open = function() {
    this.UpdateWindows(InterfaceControllerMobile_2.WindowTypes.Autoplay_Simple, true)
};
InterfaceControllerMobile_2.prototype.Pressed_AutoplayWindow_Close = function() {
    this.UpdateWindows(InterfaceControllerMobile_2.WindowTypes.Autoplay_Simple, false)
};
InterfaceControllerMobile_2.prototype.Pressed_AutoplayStart = function() {
    this.CloseCurrentOpenedWindow()
};
InterfaceControllerMobile_2.prototype.Pressed_OpenAdvancedAutoplay = function() {
    this.UpdateWindows(InterfaceControllerMobile_2.WindowTypes.Autoplay_Advanced, true)
};
InterfaceControllerMobile_2.prototype.Pressed_Paytable_Open = function() {
    this.UpdateWindows(InterfaceControllerMobile_2.WindowTypes.Paytable, true)
};
InterfaceControllerMobile_2.prototype.Pressed_Paytable_Close = function() {
    this.UpdateWindows(InterfaceControllerMobile_2.WindowTypes.Paytable, false)
};
InterfaceControllerMobile_2.prototype.OnRequestToClosePaytable = function() {
    this.UpdateWindows(InterfaceControllerMobile_2.WindowTypes.Paytable, false)
};
InterfaceControllerMobile_2.prototype.Pressed_Balance = function() {
    XT.TriggerEvent(Vars.Evt_ToServer_OpenCashier)
};
InterfaceControllerMobile_2.prototype.Pressed_Home = function() {
    XT.TriggerEvent(Vars.Evt_ToServer_CloseGame)
};
InterfaceControllerMobile_2.prototype.Pressed_SkipScreens = function() {
    XT.SetBool(Vars.Autoplay_SkipScreens, !XT.GetBool(Vars.Autoplay_SkipScreens))
};
InterfaceControllerMobile_2.prototype.UpdateInterfaceBetButton = function(enabled) {
    var be = this.totalBetButton.closed.GetComponentInChildren(ButtonEnabler);
    if (enabled) be.EnableButton();
    else be.DisableButton()
};
InterfaceControllerMobile_2.prototype.OnGUIInit = function() {
    var b = XT.GetBool(Vars.CanGamble_Spin);
    this.gambleButton.SetActive(b);
    var b_fs = XT.GetBool(Vars.CanGamble_FreeSpin);
    this.buttons_resultFSWithGamble.SetActive(b_fs);
    this.buttons_resultFSWithoutGamble.SetActive(!b_fs);
    var hasWays = XT.GetBool(Vars.GameHasWaysInsteadOfLines);
    this.InternalSetActive(this.visibleIfGameHasLines, !hasWays);
    this.InternalSetActive(this.visibleIfGameHasWays, hasWays);
    this.ChangeState(VSGameState.Invalid)
};
InterfaceControllerMobile_2.prototype.ChangeState = function(newState) {
    this.internalState = newState;
    if (!this.uiIsActive) return;
    var isMisteryScatter = false;
    var isDuringFS = false;
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr != null) {
        isMisteryScatter = fsr.MysteryScatter.length > 0;
        isDuringFS = fsr.IsFreeSpin
    }
    this.rq.StopRoutines();
    if (this.internalState == VSGameState.Spin || this.internalState == VSGameState.SpinAutoplay || this.internalState == VSGameState.SpinFreeSpins || this.internalState == VSGameState.SpinBonusRounds ||
        this.internalState == VSGameState.SpinBonusRoundsAutoplay) {
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(XT.GetDouble(InterfaceVars.GUIDynamicMessageDelay)));
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.HideWin, null, this));
        this.rq.StartRoutines()
    }
    switch (newState) {
        case VSGameState.Spin:
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds,
                false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentNormal, true);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(true);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(true);
                else this.stopBtnVisual.SetActive(false);
            this.CloseCurrentOpenedWindow();
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons =
                false;
            this.messageController.ChangeToState(VSGameState.Spin);
            break;
        case VSGameState.SpinAutoplay:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentAutoplay, true);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(true);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(true);
                else this.stopBtnVisual.SetActive(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.SpinAutoplay);
            break;
        case VSGameState.SpinFreeSpins:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay,
                false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(true);
            if (isMisteryScatter) {
                this.InternalSetActive(this.dynamicContentFreeSpins, false);
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, true)
            } else {
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
                this.InternalSetActive(this.dynamicContentFreeSpins, true)
            }
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(true);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(true);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.SpinFreeSpins);
            break;
        case VSGameState.SpinBonusRounds:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter,
                false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, true);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(true);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(true);
            this.CloseCurrentOpenedWindow();
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.SpinBonusRounds);
            break;
        case VSGameState.SpinBonusRoundsAutoplay:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, true);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(true);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(true);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.SpinBonusRoundsAutoplay);
            break;
        case VSGameState.Result:
            this.gambleButton.SetActive(XT.GetBool(Vars.CanGamble_Spin));
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter,
                false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentNormal, true);
            if (XT.GetInt(Vars.AutoplaySpinsLeft) >= 0) this.InternalSetActive(this.dynamicContentAutoplay, true);
            else this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.ToggleFSMultiplier(false);
            this.toggledInBonusGame.Toggle(true);
            this.InternalSetActive(this.toggledInGamble, true);
            var canSpin = this.InternalCanSpin();
            this.spinBtn.SetActive(canSpin);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins) || XT.GetBool(Vars.Jurisdiction_ResultMinimumTime)) this.stopBtnVisual.SetActive(!canSpin);
            this.UpdateWinDisplayedState();
            this.CloseCurrentOpenedWindow();
            this.UpdateBetButtons(canSpin);
            this.SetAllowAutoplay(canSpin);
            this.enableMenuButtons = true;
            this.firstFS = true;
            this.messageController.ChangeToState(VSGameState.Result);
            break;
        case VSGameState.ResultPrepareForBonus:
            this.InternalSetActive(this.dynamicContentAutoplay,
                false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentNormal, true);
            this.ToggleFSMultiplier(false);
            this.toggledInBonusGame.Toggle(true);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.UpdateWinDisplayedState();
            this.CloseCurrentOpenedWindow();
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.ResultPrepareForBonus);
            break;
        case VSGameState.ResultAutoplay:
            this.gambleButton.SetActive(XT.GetBool(Vars.CanGamble_Spin));
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter,
                false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentAutoplay, true);
            this.ToggleFSMultiplier(false);
            this.toggledInBonusGame.Toggle(true);
            this.InternalSetActive(this.toggledInGamble, true);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins) || XT.GetBool(Vars.Jurisdiction_ResultMinimumTime)) this.stopBtnVisual.SetActive(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.UpdateWinDisplayedState();
            this.messageController.ChangeToState(VSGameState.ResultAutoplay);
            break;
        case VSGameState.ResultBonusRounds:
            this.gambleButton.SetActive(false);
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, true);
            this.ToggleFSMultiplier(false);
            this.toggledInBonusGame.Toggle(true);
            this.InternalSetActive(this.toggledInGamble, true);
            var canSpin = this.InternalCanSpin();
            this.spinBtn.SetActive(canSpin);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(!canSpin);
            this.UpdateWinDisplayedState();
            this.CloseCurrentOpenedWindow();
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(canSpin);
            this.enableMenuButtons = true;
            this.messageController.ChangeToState(VSGameState.ResultBonusRounds);
            break;
        case VSGameState.ResultBonusRoundsAutoplay:
            this.gambleButton.SetActive(false);
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter,
                false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, true);
            this.ToggleFSMultiplier(false);
            this.toggledInBonusGame.Toggle(true);
            this.InternalSetActive(this.toggledInGamble, true);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons =
                false;
            this.UpdateWinDisplayedState();
            this.messageController.ChangeToState(VSGameState.ResultBonusRoundsAutoplay);
            break;
        case VSGameState.ResultFreeSpinsPrepare:
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentNormal,
                true);
            this.ToggleFSMultiplier(false);
            this.toggledInBonusGame.Toggle(true);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.UpdateWinDisplayedState();
            this.CloseCurrentOpenedWindow();
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.ResultFreeSpinsPrepare);
            break;
        case VSGameState.ResultFreeSpins:
            this.InternalSetActive(this.dynamicContentNormal,
                false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(true);
            if (isMisteryScatter) {
                this.InternalSetActive(this.dynamicContentFreeSpins, false);
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, true)
            } else {
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
                this.InternalSetActive(this.dynamicContentFreeSpins,
                    true)
            }
            this.toggledInBonusGame.Toggle(true);
            this.InternalSetActive(this.toggledInGamble, true);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins) || XT.GetBool(Vars.Jurisdiction_ResultMinimumTime)) this.stopBtnVisual.SetActive(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.UpdateWinDisplayedState();
            this.messageController.ChangeToState(VSGameState.ResultFreeSpins);
            break;
        case VSGameState.Bonus:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(isDuringFS);
            if (isMisteryScatter) {
                this.InternalSetActive(this.dynamicContentFreeSpins, false);
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, isDuringFS)
            } else {
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter,
                    false);
                this.InternalSetActive(this.dynamicContentFreeSpins, isDuringFS)
            }
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.CloseCurrentOpenedWindow();
            this.toggledInBonusGame.Toggle(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.UpdateWinDisplayedState();
            this.messageController.ChangeToState(VSGameState.Bonus);
            break;
        case VSGameState.Gamble:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual !=
                null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.CloseCurrentOpenedWindow();
            this.InternalSetActive(this.toggledInGamble, false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.Gamble);
            break;
        case VSGameState.GambleCustom:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins,
                false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.CloseCurrentOpenedWindow();
            this.toggledInBonusGame.Toggle(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.messageController.ChangeToState(VSGameState.GambleCustom);
            break;
        case VSGameState.Jackpot:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.CloseCurrentOpenedWindow();
            this.toggledInBonusGame.Toggle(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.messageController.ChangeToState(VSGameState.Jackpot);
            break;
        case VSGameState.FSBG:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay,
                false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(isDuringFS);
            if (isMisteryScatter) {
                this.InternalSetActive(this.dynamicContentFreeSpins, false);
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, isDuringFS)
            } else {
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
                this.InternalSetActive(this.dynamicContentFreeSpins, isDuringFS)
            }
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.CloseCurrentOpenedWindow();
            this.toggledInBonusGame.Toggle(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.UpdateWinDisplayedState();
            this.messageController.ChangeToState(VSGameState.FSBG);
            break;
        default:
        case VSGameState.Invalid:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay,
                false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.CloseCurrentOpenedWindow();
            this.toggledInBonusGame.Toggle(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.Invalid);
            break
    }
};
InterfaceControllerMobile_2.prototype.InternalSetActive = function(arr, active) {
    for (var i = 0; i < arr.length; i++) arr[i].SetActive(active)
};
InterfaceControllerMobile_2.prototype.CloseCurrentOpenedWindow = function() {
    if (this.currentOpenedWindow != InterfaceControllerMobile_2.WindowTypes.None) {
        this.ShowHideWindow(this.currentOpenedWindow, false);
        this.currentOpenedWindow = InterfaceControllerMobile_2.WindowTypes.None
    }
};
InterfaceControllerMobile_2.prototype.UpdateWindows = function(type, open) {
    if (this.currentOpenedWindow != InterfaceControllerMobile_2.WindowTypes.None) {
        this.ShowHideWindow(this.currentOpenedWindow, false);
        this.currentOpenedWindow = InterfaceControllerMobile_2.WindowTypes.None
    }
    if (type != InterfaceControllerMobile_2.WindowTypes.None && open) {
        this.ShowHideWindow(type, true);
        this.currentOpenedWindow = type;
        XT.TriggerEvent(InterfaceVars.Evt_CodeToData_InterfaceWindowOpen)
    }
};
InterfaceControllerMobile_2.prototype.ShowHideWindow = function(type, open) {
    switch (type) {
        case InterfaceControllerMobile_2.WindowTypes.Paytable:
            if (open) XT.TriggerEvent(Vars.Evt_Internal_PaytableOpen);
            else XT.TriggerEvent(Vars.Evt_Internal_PaytableClose);
            this.menuButtonsParent.SetActive(!open);
            this.paytableCloseButton.SetActive(open);
            break;
        case InterfaceControllerMobile_2.WindowTypes.Menu:
            if (open) {
                this.menuWindow.ShowMenuWindow(this.enableMenuButtons);
                this.UpdateAutoplayControllers()
            } else this.menuWindow.HideMenuWindow();
            this.menuButton.opened.SetActive(open);
            this.menuButton.closed.SetActive(!open);
            break;
        case InterfaceControllerMobile_2.WindowTypes.Bets:
            this.betsButton.opened.SetActive(open);
            this.betsButton.closed.SetActive(!open);
            this.OpenBetsWindows(open);
            break;
        case InterfaceControllerMobile_2.WindowTypes.Autoplay_Simple:
            var instantAutoplay = XT.GetBool(Vars.InstantAutoplay);
            if (open) {
                if (instantAutoplay) {
                    this.autoplayAdvancedWindow.GetComponentsInChildren(AutoplayControllerAdvanced, true)[0].StartAutoplayPressed();
                    this.Pressed_AutoplayStart()
                }
                this.UpdateAutoplayControllers()
            } else this.spinBtn.SetActive(this.InternalCanSpin());
            if (!instantAutoplay) this.OpenAutoplayWindows(open);
            break;
        case InterfaceControllerMobile_2.WindowTypes.Autoplay_Advanced:
            var instantAutoplay = XT.GetBool(Vars.InstantAutoplay);
            if (open) {
                if (instantAutoplay) {
                    this.autoplayAdvancedWindow.GetComponentsInChildren(AutoplayControllerAdvanced, true)[0].StartAutoplayPressed();
                    this.Pressed_AutoplayStart()
                }
                this.UpdateAutoplayControllers()
            } else this.spinBtn.SetActive(this.InternalCanSpin());
            if (!instantAutoplay) {
                this.autoplayAdvancedWindow.SetActive(open);
                this.menuButtonsParent.SetActive(!open);
                this.autoplayCloseButton.SetActive(open)
            }
            break;
        default:
            console.error("Interface: Trying to start / close an invalid window");
            break
    }
};
InterfaceControllerMobile_2.prototype.UpdateWinDisplayedState = function() {
    var win = 0;
    if (this.internalState == VSGameState.ResultFreeSpins) win = XT.GetDouble(Vars.FreeSpinsLastWinDisplayed);
    else win = XT.GetDouble(Vars.SpinCycleWinDisplayed);
    this.UpdateDisplayForWinContainers(win > 1E-4, win > 1E-4 && !this.coinValueChanged)
};
InterfaceControllerMobile_2.prototype.UpdateDisplayForWinContainers = function(showCash, showCoins) {
    for (var i = 0; i < this.winDisplayedContainers.length; i++) this.winDisplayedContainers[i].UpdateDisplay(showCash, showCoins)
};
InterfaceControllerMobile_2.prototype.OnCanSpinChanged = function() {
    if (this.internalState == VSGameState.Result || this.internalState == VSGameState.ResultBonusRounds) {
        var canSpin = this.InternalCanSpin();
        this.spinBtn.SetActive(canSpin);
        if (this.stopBtnVisual != null)
            if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(!canSpin);
        this.UpdateBetButtons(canSpin && this.internalState == VSGameState.Result);
        this.SetAllowAutoplay(canSpin)
    }
};
InterfaceControllerMobile_2.prototype.HideWin = function(param) {
    if (this.internalState == VSGameState.Spin || this.internalState == VSGameState.SpinAutoplay || this.internalState == VSGameState.SpinFreeSpins || this.internalState == VSGameState.SpinBonusRounds || this.internalState == VSGameState.SpinBonusRoundsAutoplay) {
        this.UpdateDisplayForWinContainers(false, false);
        for (var i = 0; i < this.toggledOnHideWin.length; i++) this.toggledOnHideWin[i].WinIsHidden();
        if (this.uiIsActive) this.otherInterface.HideWin(null)
    }
};
InterfaceControllerMobile_2.prototype.OnSpinStarted = function() {
    this.coinValueChanged = false
};
InterfaceControllerMobile_2.prototype.OnCoinValueChanged = function() {
    if (this.internalState == VSGameState.Result || this.internalState == VSGameState.ResultBonusRounds) {
        this.coinValueChanged = true;
        var win = XT.GetDouble(Vars.SpinCycleWinDisplayed);
        this.UpdateDisplayForWinContainers(win > 1E-4, false)
    }
};
InterfaceControllerMobile_2.prototype.OnRequestToUpdateDisplayedWinInUI = function() {
    this.UpdateWinDisplayedState()
};
InterfaceControllerMobile_2.prototype.InternalCanSpin = function() {
    var respinData = XT.GetObject(Vars.RespinData);
    var canSpin = XT.GetBool(Vars.CanSpin) && (respinData == null || respinData.IsDone || XT.GetBool(Vars.ManualRespin));
    return canSpin
};
InterfaceControllerMobile_2.prototype.ToggleFSMultiplier = function(isFreeSpin) {
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    var multiplier = isFreeSpin ? fsr.TotalMultiplier : 1;
    for (var i = 0; i < this.fsMultiplierToggles.length; i++) this.fsMultiplierToggles[i].FSMultiplierChanged(multiplier)
};
InterfaceControllerMobile_2.prototype.SetAllowAutoplay = function(allow) {
    for (var i = 0; i < this.autoplayControllers.length; i++) this.autoplayControllers[i].AllowAutoplay(allow)
};
InterfaceControllerMobile_2.prototype.UpdateAutoplayControllers = function() {
    for (var i = 0; i < this.autoplayControllers.length; i++) this.autoplayControllers[i].UpdateAutoplayContent()
};
InterfaceControllerMobile_2.prototype.OpenAutoplayWindows = function(show) {
    for (var i = 0; i < this.autoplayControllers.length; i++)
        if (show) this.autoplayControllers[i].ShowAutoplayWindow();
        else this.autoplayControllers[i].HideAutoplayWindow()
};
InterfaceControllerMobile_2.prototype.OpenBetsWindows = function(show) {
    for (var i = 0; i < this.betsControllers.length; i++)
        if (show) this.betsControllers[i].ShowBetsWindow();
        else this.betsControllers[i].HideBetsWindow()
};
InterfaceControllerMobile_2.prototype.UpdateBetButtons = function(enabled) {
    for (var i = 0; i < this.betsControllers.length; i++) this.betsControllers[i].UpdateBetButtons(enabled);
    if (enabled) this.betsButton.closed.GetComponent(ButtonEnabler).EnableButton();
    else this.betsButton.closed.GetComponent(ButtonEnabler).DisableButton()
};
InterfaceControllerMobile_2.prototype.OnShowPortraitMiddleBar = function() {
    this.middleBar.SetActive(true)
};
InterfaceControllerMobile_2.prototype.OnHidePortraitMiddleBar = function() {
    this.middleBar.SetActive(false)
};
InterfaceControllerMobile_2.prototype.OnLastWinIsCountingChanged = function(param) {
    this.UpdateStopBtn()
};
InterfaceControllerMobile_2.prototype.UpdateStopBtn = function() {
    if (!this.stopBtn.activeSelf) this.stopBtn.SetActive(true);
    var mustStop = false;
    switch (VSGameStateManager.GetState()) {
        case VSGameState.Spin:
        case VSGameState.SpinAutoplay:
        case VSGameState.SpinFreeSpins:
        case VSGameState.SpinBonusRounds:
        case VSGameState.SpinBonusRoundsAutoplay:
            mustStop = true;
            break
    }
    if (mustStop) this.stopBtn.GetComponent(XTButton).eventToCode.name = Vars.Evt_DataToCode_Pressed_Stop;
    else if (XT.GetBool(Vars.LastWinIsCounting)) this.stopBtn.GetComponent(XTButton).eventToCode.name =
        Vars.Evt_Internal_FinalizeDisplayedWin;
    else this.stopBtn.SetActive(false)
};
InterfaceControllerMobile_2.prototype.UpdateBalanceContent = function(value) {
    var balance = _number.otod(value);
    if (XT.GetBool(Vars.Jurisdiction_SplitBalance)) {
        this.balanceParent.SetActive(balance <= 0);
        this.bonusBalanceParent.SetActive(balance > 0)
    }
};
InterfaceControllerMobile_2.prototype.OnResultMinimumTimeBetweenSpins = function(param) {
    var isActive = param;
    if (isActive) {
        XT.RegisterCallbackFloat(Vars.SpinDuration, this.OnSpinDuration, this);
        XT.RegisterCallbackBool(Vars.CanSpin, this.OnCanSpin, this)
    }
};
InterfaceControllerMobile_2.prototype.OnSpinDuration = function(param) {
    var spinDuration = param;
    if (spinDuration > XT.GetFloat(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins_Value)) {
        this.stopButtonEnabler.EnableButton();
        this.stopButtonColliderEnabler.EnableCollider()
    }
};
InterfaceControllerMobile_2.prototype.OnCanSpin = function(param) {
    var canSpin = param;
    if (canSpin) {
        this.stopButtonEnabler.EnableButton();
        this.stopButtonColliderEnabler.EnableCollider()
    } else {
        this.stopButtonEnabler.DisableButton();
        this.stopButtonColliderEnabler.DisableCollider()
    }
};
InterfaceControllerMobile_2.prototype.OnDisableStopButton = function(param) {
    var isActive = param;
    if (isActive) XT.RegisterCallbackBool(Vars.CanSpin, this.OnCanSpin, this)
};
goog.require("UHT.XTLink");
BetsControllerMobile.prototype = Object.create(XTLink.prototype);
BetsControllerMobile.prototype.constructor = BetsControllerMobile;

function BetsControllerMobile() {
    XTLink.call(this);
    this.windowShow = null;
    this.windowHide = null;
    this.increaseBetButton = null;
    this.decreaseBetButton = null;
    this.increaseBetButtonCash = null;
    this.decreaseBetButtonCash = null;
    this.increaseCoinValueButton = null;
    this.decreaseCoinValueButton = null;
    this.increaseBetAndCoinValueButtons = null;
    this.decreaseBetAndCoinValueButtons = null;
    this.cashContent = null;
    this.coinsContent = null
}
BetsControllerMobile.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.MinBetReached, this.OnBetStateUpdated, this);
    XT.RegisterCallbackBool(Vars.MaxBetReached, this.OnBetStateUpdated, this);
    XT.RegisterCallbackBool(Vars.MinCoinValueReached, this.OnBetStateUpdated, this);
    XT.RegisterCallbackBool(Vars.MaxCoinValueReached, this.OnBetStateUpdated, this);
    XT.RegisterCallbackBool(Vars.MinBetAndCoinValueReached, this.OnBetStateUpdated, this);
    XT.RegisterCallbackBool(Vars.MaxBetAndCoinValueReached,
        this.OnBetStateUpdated, this);
    XT.RegisterCallbackBool(Vars.FromServer_AllowCoins, this.OnAllowCoinsChanged, this)
};
BetsControllerMobile.prototype.OnDestroy = function() {
    XT.UnregisterCallbackBool(this.OnBetStateUpdated, this);
    XT.UnregisterCallbackBool(this.OnAllowCoinsChanged, this)
};
BetsControllerMobile.prototype.ShowBetsWindow = function() {
    if (this.windowShow != null && this.windowShow.cat != null) this.windowShow.Start()
};
BetsControllerMobile.prototype.HideBetsWindow = function() {
    if (this.windowHide != null && this.windowHide.cat != null) this.windowHide.Start()
};
BetsControllerMobile.prototype.UpdateBetButtons = function(enabled) {
    this.UpdateBetIncDecButtons(enabled)
};
BetsControllerMobile.prototype.OnBetStateUpdated = function(unused) {
    this.UpdateBetIncDecButtons(true)
};
BetsControllerMobile.prototype.UpdateBetIncDecButtons = function(enabled) {
    if (enabled) {
        if (XT.GetBool(Vars.MinBetReached)) {
            this.decreaseBetButton.DisableButton();
            this.decreaseBetButtonCash.DisableButton()
        } else {
            this.decreaseBetButton.EnableButton();
            this.decreaseBetButtonCash.EnableButton()
        }
        if (XT.GetBool(Vars.MaxBetReached)) {
            this.increaseBetButton.DisableButton();
            this.increaseBetButtonCash.DisableButton()
        } else {
            this.increaseBetButton.EnableButton();
            this.increaseBetButtonCash.EnableButton()
        }
        if (XT.GetBool(Vars.MinCoinValueReached)) this.decreaseCoinValueButton.DisableButton();
        else this.decreaseCoinValueButton.EnableButton();
        if (XT.GetBool(Vars.MaxCoinValueReached)) this.increaseCoinValueButton.DisableButton();
        else this.increaseCoinValueButton.EnableButton();
        if (XT.GetBool(Vars.MinBetAndCoinValueReached))
            for (var i = 0; i < this.decreaseBetAndCoinValueButtons.length; ++i) this.decreaseBetAndCoinValueButtons[i].DisableButton();
        else
            for (var i = 0; i < this.decreaseBetAndCoinValueButtons.length; ++i) this.decreaseBetAndCoinValueButtons[i].EnableButton();
        if (XT.GetBool(Vars.MaxBetAndCoinValueReached))
            for (var i =
                    0; i < this.increaseBetAndCoinValueButtons.length; ++i) this.increaseBetAndCoinValueButtons[i].DisableButton();
        else
            for (var i = 0; i < this.increaseBetAndCoinValueButtons.length; ++i) this.increaseBetAndCoinValueButtons[i].EnableButton()
    } else {
        this.decreaseBetButton.DisableButton();
        this.increaseBetButton.DisableButton();
        this.decreaseBetButtonCash.DisableButton();
        this.increaseBetButtonCash.DisableButton();
        this.decreaseCoinValueButton.DisableButton();
        this.increaseCoinValueButton.DisableButton();
        for (var i = 0; i < this.decreaseBetAndCoinValueButtons.length; ++i) this.decreaseBetAndCoinValueButtons[i].DisableButton();
        for (var i = 0; i < this.increaseBetAndCoinValueButtons.length; ++i) this.increaseBetAndCoinValueButtons[i].DisableButton()
    }
};
BetsControllerMobile.prototype.OnAllowCoinsChanged = function(allow) {
    this.coinsContent.SetActive(allow);
    this.cashContent.SetActive(!allow)
};
goog.provide("UHT.AutoplayControllerMobile");
goog.require("UHT.XTLink");
AutoplayControllerMobile.prototype = Object.create(XTLink.prototype);
AutoplayControllerMobile.prototype.constructor = AutoplayControllerMobile;

function AutoplayControllerMobile() {
    XTLink.call(this);
    this.windowShow = null;
    this.windowHide = null;
    this.content = null;
    this.increaseAutoSpinsButton = null;
    this.decreaseAutoSpinsButton = null;
    this.startAutoplayButton = null;
    this.quickStartAutoplayButtons = null;
    this.selectSpinsLabel = null;
    this.autoplayStartAllowed = false;
    this.requestedAutoSpins = [10, 20, 30, 50, 70, 100, 500, 1E3]
}
AutoplayControllerMobile.prototype.XTInitVariablesAndEvents = function() {
    XT.SetInt(InterfaceVars.SelectedAutoSpinsIndex, 0)
};
AutoplayControllerMobile.prototype.ShowAutoplayWindow = function() {
    if (this.windowShow != null && this.windowShow.cat != null) this.windowShow.Start()
};
AutoplayControllerMobile.prototype.HideAutoplayWindow = function() {
    if (this.windowHide != null && this.windowHide.cat != null) this.windowHide.Start()
};
AutoplayControllerMobile.prototype.AllowAutoplay = function(allow) {
    this.autoplayStartAllowed = allow;
    this.UpdateAutoplaySelectionButtons()
};
AutoplayControllerMobile.prototype.UpdateAutospinsLabel = function() {
    this.selectSpinsLabel.text = this.requestedAutoSpins[XT.GetInt(InterfaceVars.SelectedAutoSpinsIndex)]
};
AutoplayControllerMobile.prototype.IncreaseAutoSpins = function() {
    var currIndex = XT.GetInt(InterfaceVars.SelectedAutoSpinsIndex);
    currIndex++;
    XT.SetInt(InterfaceVars.SelectedAutoSpinsIndex, currIndex);
    this.UpdateAutoplaySelectionButtons();
    this.UpdateAutospinsLabel();
    this.SetNumberOfAutoSpins()
};
AutoplayControllerMobile.prototype.DecreaseAutoSpins = function() {
    var currIndex = XT.GetInt(InterfaceVars.SelectedAutoSpinsIndex);
    currIndex--;
    XT.SetInt(InterfaceVars.SelectedAutoSpinsIndex, currIndex);
    this.UpdateAutoplaySelectionButtons();
    this.UpdateAutospinsLabel();
    this.SetNumberOfAutoSpins()
};
AutoplayControllerMobile.prototype.SetNumberOfAutoSpins = function() {
    var xtbStartAutoplay = this.startAutoplayButton.GetComponent(XTButton);
    xtbStartAutoplay.paramValue = this.requestedAutoSpins[XT.GetInt(InterfaceVars.SelectedAutoSpinsIndex)]
};
AutoplayControllerMobile.prototype.UpdateAutoplaySelectionButtons = function() {
    var beUp = this.increaseAutoSpinsButton.GetComponent(ButtonEnabler);
    var beDown = this.decreaseAutoSpinsButton.GetComponent(ButtonEnabler);
    var beStartAutoplay = this.startAutoplayButton.GetComponent(ButtonEnabler);
    var i;
    var beQuickStartAutoplay = [];
    for (i = 0; i < this.quickStartAutoplayButtons.length; i++) beQuickStartAutoplay.push(this.quickStartAutoplayButtons[i].GetComponent(ButtonEnabler));
    if (!this.autoplayStartAllowed) {
        beUp.DisableButton();
        beDown.DisableButton();
        beStartAutoplay.DisableButton();
        for (i = 0; i < beQuickStartAutoplay.length; i++) beQuickStartAutoplay[i].DisableButton();
        return
    }
    beStartAutoplay.EnableButton();
    for (i = 0; i < beQuickStartAutoplay.length; i++) beQuickStartAutoplay[i].EnableButton();
    if (XT.GetInt(InterfaceVars.SelectedAutoSpinsIndex) <= 0) beDown.DisableButton();
    else beDown.EnableButton();
    if (XT.GetInt(InterfaceVars.SelectedAutoSpinsIndex) >= this.requestedAutoSpins.length - 1) beUp.DisableButton();
    else beUp.EnableButton()
};
AutoplayControllerMobile.prototype.UpdateAutoplayContent = function() {
    this.UpdateAutospinsLabel();
    this.UpdateAutoplaySelectionButtons();
    this.SetNumberOfAutoSpins()
};
goog.require("UHT.XTLink");
MenuWindowControllerMobile.prototype = Object.create(XTLink.prototype);
MenuWindowControllerMobile.prototype.constructor = MenuWindowControllerMobile;

function MenuWindowControllerMobile() {
    XTLink.call(this);
    this.content = null;
    this.menuButtons = [];
    this.fastPlayEnabled = null;
    this.fastPlayDisabled = null;
    this.batterySaverEnabled = null;
    this.batterySaverDisabled = null
}
MenuWindowControllerMobile.prototype.ShowMenuWindow = function(enableButtons) {
    this.content.SetActive(true);
    this.ToggleMenuButtons(enableButtons);
    this.UpdateButtons();
    XT.TriggerEvent(Vars.Evt_CodeToData_SettingsWindowOpened)
};
MenuWindowControllerMobile.prototype.HideMenuWindow = function() {
    this.content.SetActive(false);
    XT.TriggerEvent(Vars.Evt_CodeToData_SettingsWindowClosed)
};
MenuWindowControllerMobile.prototype.ToggleMenuButtons = function(enable) {
    for (var i = 0; i < this.menuButtons.length; i++) {
        var be = this.menuButtons[i].GetComponentInChildren(ButtonEnabler);
        if (be != null)
            if (enable) be.EnableButton();
            else be.DisableButton()
    }
};
MenuWindowControllerMobile.prototype.ToggleFastPlay = function() {
    XT.SetBool(Vars.FastPlay, !XT.GetBool(Vars.FastPlay));
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer);
    this.UpdateButtons()
};
MenuWindowControllerMobile.prototype.ToggleBatterySaver = function() {
    XT.SetBool(Vars.BatterySaver, !XT.GetBool(Vars.BatterySaver));
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer);
    this.UpdateButtons()
};
MenuWindowControllerMobile.prototype.UpdateButtons = function() {
    var b = XT.GetBool(Vars.FastPlay);
    this.fastPlayEnabled.SetActive(b);
    this.fastPlayDisabled.SetActive(!b);
    var bb = XT.GetBool(Vars.BatterySaver);
    this.batterySaverEnabled.SetActive(bb);
    this.batterySaverDisabled.SetActive(!bb)
};
goog.require("UHT.Engine");
ToggleOnHideWin.prototype = Object.create(Component.prototype);
ToggleOnHideWin.prototype.constructor = ToggleOnHideWin;

function ToggleOnHideWin() {
    Component.call(this);
    this.visibleOnHideWin = false
}
ToggleOnHideWin.prototype.WinIsHidden = function() {
    this.gameObject.SetActive(this.visibleOnHideWin)
};
goog.require("UHT.Engine");
CoinsAndCashDisplayer.prototype = Object.create(Component.prototype);
CoinsAndCashDisplayer.prototype.constructor = CoinsAndCashDisplayer;

function CoinsAndCashDisplayer() {
    Component.call(this);
    this.cashGameObjects = null;
    this.hiddenWhenCashIsVisible = null;
    this.coinsGameObjects = null;
    this.hiddenWhenCoinsAreVisible = null
}
CoinsAndCashDisplayer.prototype.UpdateDisplay = function(showCash, showCoins) {
    var i = 0;
    for (i = 0; i < this.cashGameObjects.length; i++) this.cashGameObjects[i].SetActive(showCash);
    for (i = 0; i < this.hiddenWhenCashIsVisible.length; i++) this.hiddenWhenCashIsVisible[i].SetActive(!showCash);
    for (i = 0; i < this.coinsGameObjects.length; i++) this.coinsGameObjects[i].SetActive(showCoins);
    for (i = 0; i < this.hiddenWhenCoinsAreVisible.length; i++) this.hiddenWhenCoinsAreVisible[i].SetActive(!showCoins)
};
goog.require("UHT.Engine");
FSMultiplierToggle.prototype = Object.create(Component.prototype);
FSMultiplierToggle.prototype.constructor = FSMultiplierToggle;

function FSMultiplierToggle() {
    Component.call(this);
    this.hideWhenMultiplierIs1 = false;
    this.hideWhenMultiplierIsNot1 = false;
    this.changeLocalPositions = false;
    this.newLocalPosWhenMultiplierIs1 = null;
    this.newLocalPosWhenMultiplierIsNot1 = null
}
FSMultiplierToggle.prototype.FSMultiplierChanged = function(newMultiplier) {
    var visible = !(this.hideWhenMultiplierIs1 && newMultiplier == 1) && !(this.hideWhenMultiplierIsNot1 && newMultiplier != 1);
    this.gameObject.SetActive(visible);
    if (this.changeLocalPositions)
        if (newMultiplier == 1) this.transform.localPosition(this.newLocalPosWhenMultiplierIs1);
        else this.transform.localPosition(this.newLocalPosWhenMultiplierIsNot1)
};
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
var MessageControllerVars = {
    MessageController_ForceGUIMessageResultWin: "MessageController_ForceGUIMessageResultWin"
};
MessageController.prototype = Object.create(XTLink.prototype);
MessageController.prototype.constructor = MessageController;

function MessageController() {
    XTLink.call(this);
    this.rq = null;
    this.hasFeatureWonText = true;
    this.dynamicContentNormal = null;
    this.dynamicContentAutoplay = null;
    this.dynamicContentFreeSpins = null;
    this.dynamicContentFreeSpinsMysteryScatter = null;
    this.dynamicContentBonusRounds = null;
    this.dynamicContentBonusRoundsAutoplay = null;
    this.msg_RandomSpin = null;
    this.showMsgRandomSpinAfterWin = false;
    this.msg_ResultWin = null;
    this.messagesResultWin = null;
    this.useMessagesResultWin = false;
    this.msg_ResultTeaser = null;
    this.msg_ResultBeforeWinIsDisplayed =
        null;
    this.LocalizedSpinMessages = null;
    this.LocalizedResultTeaserMessages = null;
    this.event_Win = null;
    this.event_BigWin = null;
    this.event_Reset = null;
    this.winDisplayedContainers = null;
    this.mysteryScatterSymbolHolder = null;
    this.mysteryScatterScaleFactor = 1;
    this.freeSpinsFeatureCompleted = [];
    this.bonusGameFeatureCompleted = [];
    this.internalState = VSGameState.Invalid;
    this.coinValueChanged = false;
    this.requestToUpdateDisplayedWinInUICame = false
}
MessageController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_MysteryScatterSymbol_Show, this.OnMysteryScatterSymbolShow, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_MysteryScatterSymbol_Hide, this.OnMysteryScatterSymbolHide, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinValueChanged, this.OnCoinValueChanged,
        this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_UpdateDisplayedWinInUI, this.OnRequestToUpdateDisplayedWinInUI, this)
};
MessageController.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(InterfaceVars.HasGUIMessageBeforeWinCount, false);
    XT.SetBool(MessageControllerVars.MessageController_ForceGUIMessageResultWin, false)
};
MessageController.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGUIInit, this);
    XT.UnregisterCallbackEvent(this.OnMysteryScatterSymbolShow, this);
    XT.UnregisterCallbackEvent(this.OnMysteryScatterSymbolHide, this);
    XT.UnregisterCallbackEvent(this.OnCoinValueChanged, this);
    XT.UnregisterCallbackEvent(this.OnSpinStarted, this);
    XT.UnregisterCallbackEvent(this.OnRequestToUpdateDisplayedWinInUI, this)
};
MessageController.prototype.OnGUIInit = function() {
    this.msg_RandomSpin.Init(this.GetListOfMessages(this.LocalizedSpinMessages, InterfaceVars.GUIMessage_RandomSpin));
    if (XT.GetBool(Vars.Jurisdiction_NoSpinToWin) && this.LocalizedResultTeaserMessages.length > 1) this.LocalizedResultTeaserMessages.splice(1, 1);
    this.msg_ResultTeaser.Init(this.GetListOfMessages(this.LocalizedResultTeaserMessages, InterfaceVars.GUIMessage_RandomResultTeaser));
    if (Globals.isMini) {
        this.msg_RandomSpin.label.anchorX = 0;
        this.msg_ResultTeaser.label.anchorX =
            0
    }
};
MessageController.prototype.GetListOfMessages = function(labels, varName) {
    var ret = [];
    for (var i = 0; i < labels.length; i++) ret.push(labels[i].text);
    XT.SetObject(varName, ret);
    return ret
};
MessageController.prototype.ChangeToState = function(newState) {
    var sameState = this.internalState == newState;
    this.internalState = newState;
    if (!sameState) this.HideAllMessages();
    this.event_Reset.Start();
    this.UpdateDynamicContent(true);
    switch (this.internalState) {
        case VSGameState.Spin:
        case VSGameState.SpinAutoplay:
        case VSGameState.SpinFreeSpins:
        case VSGameState.SpinBonusRounds:
        case VSGameState.SpinBonusRoundsAutoplay:
            this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(XT.GetDouble(InterfaceVars.GUIDynamicMessageDelay)));
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.HideWin,
                null, this));
            if (this.showMsgRandomSpinAfterWin && this.IsWinDisplayed()) this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.ShowMessage, this.msg_RandomSpin, this));
            else this.ShowMessage(this.msg_RandomSpin);
            this.rq.StartRoutines();
            this.requestToUpdateDisplayedWinInUICame = false;
            break;
        case VSGameState.Result:
        case VSGameState.ResultAutoplay:
        case VSGameState.ResultBonusRounds:
        case VSGameState.ResultBonusRoundsAutoplay:
        case VSGameState.ResultFreeSpins:
        case VSGameState.ResultFreeSpinsPrepare:
        case VSGameState.ResultPrepareForBonus:
            this.UpdateWinDisplayedState();
            if (this.requestToUpdateDisplayedWinInUICame) this.OnRequestToUpdateDisplayedWinInUI();
            var isBonusRounds = this.internalState == VSGameState.ResultBonusRounds || this.internalState == VSGameState.ResultBonusRoundsAutoplay;
            if (VSGameStateManager.GetPreviousState() == VSGameState.ResultFreeSpins && newState != VSGameStateManager.GetPreviousState()) {
                this.InternalSetActive(this.freeSpinsFeatureCompleted, !isBonusRounds);
                this.InternalSetActive(this.bonusGameFeatureCompleted, false);
                this.HideMessage(this.msg_ResultTeaser)
            }
            if (VSGameStateManager.GetPreviousState() ==
                VSGameState.Bonus) {
                this.InternalSetActive(this.bonusGameFeatureCompleted, !isBonusRounds);
                this.InternalSetActive(this.freeSpinsFeatureCompleted, false);
                this.HideMessage(this.msg_ResultTeaser)
            }
            break;
        case VSGameState.Bonus:
        case VSGameState.Gamble:
        case VSGameState.GambleCustom:
        case VSGameState.Jackpot:
        case VSGameState.FSBG:
        case VSGameState.Invalid:
            this.requestToUpdateDisplayedWinInUICame = false;
            break
    }
};
MessageController.prototype.InternalSetActive = function(arr, active) {
    for (var i = 0; i < arr.length; i++) arr[i].SetActive(active)
};
MessageController.prototype.ShowMessage = function(param) {
    var m = param;
    m.Show()
};
MessageController.prototype.HideMessage = function(param) {
    var m = param;
    m.Hide()
};
MessageController.prototype.UpdateDynamicContent = function(param) {
    var visible = param;
    switch (this.internalState) {
        case VSGameState.Spin:
        case VSGameState.Result:
        case VSGameState.ResultFreeSpinsPrepare:
        case VSGameState.ResultPrepareForBonus:
            this.InternalSetActive(this.dynamicContentNormal, visible);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds,
                false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            break;
        case VSGameState.SpinAutoplay:
        case VSGameState.ResultAutoplay:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, visible);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay,
                false);
            break;
        case VSGameState.SpinFreeSpins:
        case VSGameState.ResultFreeSpins:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            if (XT.GetObject(Vars.ReceivedFreeSpinsResponse).MysteryScatter.length == 0) {
                this.InternalSetActive(this.dynamicContentFreeSpins, visible);
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter,
                    false)
            } else {
                this.InternalSetActive(this.dynamicContentFreeSpins, false);
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, visible)
            }
            break;
        case VSGameState.SpinBonusRounds:
        case VSGameState.ResultBonusRounds:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds,
                visible);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            break;
        case VSGameState.SpinBonusRoundsAutoplay:
        case VSGameState.ResultBonusRoundsAutoplay:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay,
                visible);
            break;
        default:
            break
    }
};
MessageController.prototype.IsWinDisplayed = function() {
    var win = 0;
    if (this.internalState == VSGameState.ResultFreeSpins) win = XT.GetDouble(Vars.FreeSpinsLastWinDisplayed);
    else win = XT.GetDouble(Vars.SpinCycleWinDisplayed);
    return win > 1E-4 || XT.GetBool(MessageControllerVars.MessageController_ForceGUIMessageResultWin)
};
MessageController.prototype.UpdateWinDisplayedState = function() {
    var b = this.IsWinDisplayed();
    this.UpdateDisplayForWinContainers(b, b && !this.coinValueChanged)
};
MessageController.prototype.HideWin = function(param) {
    if (this.internalState == VSGameState.Spin || this.internalState == VSGameState.SpinAutoplay || this.internalState == VSGameState.SpinFreeSpins) this.UpdateDisplayForWinContainers(false, false)
};
MessageController.prototype.OnSpinStarted = function() {
    this.coinValueChanged = false
};
MessageController.prototype.OnCoinValueChanged = function() {
    if (this.internalState == VSGameState.Result || this.internalState == VSGameState.ResultBonusRounds) {
        this.coinValueChanged = true;
        var isWin = this.IsWinDisplayed();
        this.UpdateDisplayForWinContainers(isWin, false);
        if (isWin) this.HideAllMessages()
    }
};
MessageController.prototype.UpdateDisplayForWinContainers = function(showCash, showCoins) {
    for (var i = 0; i < this.winDisplayedContainers.length; i++) this.winDisplayedContainers[i].UpdateDisplay(showCash, showCoins)
};
MessageController.prototype.OnRequestToUpdateDisplayedWinInUI = function() {
    this.requestToUpdateDisplayedWinInUICame = true;
    if (this.gameObject.activeInHierarchy) {
        this.UpdateWinDisplayedState();
        if (this.IsWinDisplayed()) {
            var isFS = this.internalState == VSGameState.ResultFreeSpinsPrepare;
            var isBonus = this.internalState == VSGameState.ResultPrepareForBonus;
            if (this.useMessagesResultWin)
                for (var i = 0; i < this.messagesResultWin.length; ++i) {
                    this.messagesResultWin[i].SetSpecialFlags(isBonus && this.hasFeatureWonText, isFS &&
                        this.hasFeatureWonText);
                    this.ShowMessage(this.messagesResultWin[i])
                } else {
                    this.msg_ResultWin.SetSpecialFlags(isBonus && this.hasFeatureWonText, isFS && this.hasFeatureWonText);
                    this.ShowMessage(this.msg_ResultWin)
                }
            this.HideMessage(this.msg_ResultTeaser);
            if (XT.GetInt(Vars.BigWinLevel) == 0) {
                var i = Random.Range(0, this.event_Win.length);
                this.event_Win[i].Start()
            } else this.event_BigWin.Start()
        } else {
            if (this.useMessagesResultWin)
                for (var i = 0; i < this.messagesResultWin.length; ++i) this.HideMessage(this.messagesResultWin[i]);
            else this.HideMessage(this.msg_ResultWin);
            var respinData = XT.GetObject(Vars.RespinData);
            if (this.internalState != VSGameState.ResultFreeSpins && this.internalState != VSGameState.ResultFreeSpinsPrepare && this.internalState != VSGameState.ResultAutoplay && this.internalState != VSGameState.ResultPrepareForBonus && (respinData == null || respinData.IsDone)) this.ShowMessage(this.msg_ResultTeaser);
            else this.HideMessage(this.msg_ResultTeaser)
        }
    }
};
MessageController.prototype.HideAllMessages = function() {
    this.rq.StopRoutines();
    this.msg_RandomSpin.Hide();
    this.msg_ResultTeaser.Hide();
    this.msg_ResultBeforeWinIsDisplayed.Hide();
    if (this.useMessagesResultWin)
        for (var i = 0; i < this.messagesResultWin.length; ++i) this.messagesResultWin[i].Hide();
    else this.msg_ResultWin.Hide();
    this.InternalSetActive(this.freeSpinsFeatureCompleted, false);
    this.InternalSetActive(this.bonusGameFeatureCompleted, false)
};
MessageController.prototype.OnMysteryScatterSymbolHide = function() {
    if (this.mysteryScatterSymbolHolder != null) {
        var mss = XT.GetObject(Vars.MysteryScatterSymbol_GameObject);
        if (mss == null) {
            this.mysteryScatterSymbolHolder.SetActive(false);
            return
        }
        var mssHolder = XT.GetObject(Vars.MysteryScatterSymbol_ParentGameObject);
        mss.transform.SetParent(mssHolder.transform, false)
    }
};
MessageController.prototype.OnMysteryScatterSymbolShow = function() {
    if (this.mysteryScatterSymbolHolder != null) {
        var mss = XT.GetObject(Vars.MysteryScatterSymbol_GameObject);
        mss.transform.localScale(this.mysteryScatterScaleFactor, this.mysteryScatterScaleFactor, 1);
        mss.transform.SetParent(this.mysteryScatterSymbolHolder.transform, false)
    }
};
goog.require("UHT.XTLink");
goog.require("UHT.InterfaceUtils");

function ToggledObjects() {
    this.active = null;
    this.inactive = null
}
ToggledObjects.prototype.Toggle = function(disable) {
    for (var i = 0; i < this.active.length; ++i) this.active[i].SetActive(!disable);
    for (var i = 0; i < this.inactive.length; ++i) this.inactive[i].SetActive(disable)
};
InterfaceControllerMobile_1.prototype = Object.create(XTLink.prototype);
InterfaceControllerMobile_1.prototype.constructor = InterfaceControllerMobile_1;

function InterfaceControllerMobile_1() {
    XTLink.call(this);
    this.otherInterface = null;
    this.contentInterface = null;
    this.menuButton = null;
    this.betsButton = null;
    this.menuButtonsParent = null;
    this.paytableCloseButton = null;
    this.autoplayCloseButton = null;
    this.totalBetButton = null;
    this.spinBtn = null;
    this.stopBtn = null;
    this.stopBtnVisual = null;
    this.gambleButton = null;
    this.betsControllers = null;
    this.autoplayControllers = null;
    this.menuWindow = null;
    this.gambleWindow = null;
    this.buttons_resultFSWithGamble = null;
    this.buttons_resultFSWithoutGamble =
        null;
    this.autoplayAdvancedWindow = null;
    this.dynamicContentNormal = null;
    this.dynamicContentAutoplay = null;
    this.dynamicContentFreeSpins = null;
    this.dynamicContentFreeSpinsMysteryScatter = null;
    this.dynamicContentBonusRounds = null;
    this.dynamicContentBonusRoundsAutoplay = null;
    this.toggledInBonusGame = null;
    this.toggledInGamble = [];
    this.toggledOnHideWin = null;
    this.winDisplayedContainers = null;
    this.fsMultiplierToggles = null;
    this.messageController = null;
    this.rq = null;
    this.changeState = null;
    this.balanceParent = null;
    this.bonusBalanceParent =
        null;
    this.visibleIfGameHasLines = null;
    this.visibleIfGameHasWays = null;
    this.internalState = VSGameState.Invalid;
    this.enableMenuButtons = true;
    this.currentOpenedWindow = InterfaceControllerMobile_1.WindowTypes.None;
    this.uiIsActive = false;
    this.coinValueChanged = false;
    this.stopButtonEnabler = null;
    this.stopButtonColliderEnabler = null
}
InterfaceControllerMobile_1.AutoplayState = {
    Normal: 0,
    Pressed: 1,
    Stop: 2
};
InterfaceControllerMobile_1.WindowTypes = {
    None: 0,
    Autoplay_Simple: 1,
    Autoplay_Advanced: 2,
    Bets: 3,
    Paytable: 4,
    Menu: 5
};
InterfaceControllerMobile_1.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(InterfaceVars.IsMobileGUI, true)
};
InterfaceControllerMobile_1.prototype.XTRegisterCallbacks = function() {
    this.stopButtonEnabler = this.stopBtn.transform.gameObject.GetComponentsInChildren(ButtonEnabler, true)[0];
    this.stopButtonColliderEnabler = this.stopBtn.transform.gameObject.GetComponentsInChildren(ColliderEnabler, true)[0];
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_PaytableClosed, this.OnRequestToClosePaytable, this);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayout,
        this.EnableUI, this);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWide, this.EnableUI, this);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWideFull, this.EnableUI, this);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayout, this.DisableUI, this);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPhone, this.DisableUI, this);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPad, this.DisableUI, this);
    XT.RegisterCallbackBool(Vars.CanSpin,
        this.OnCanSpinChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinValueChanged, this.OnCoinValueChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_UpdateDisplayedWinInUI, this.OnRequestToUpdateDisplayedWinInUI, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_DataToCode_CloseAllInterfaceWindows, this.CloseCurrentOpenedWindow, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ChangeVSGameState, this.OnVSGameStateChanged,
        this);
    XT.RegisterCallbackBool(Vars.LastWinIsCounting, this.OnLastWinIsCountingChanged, this);
    XT.RegisterCallbackDouble(Vars.BonusBalance, this.UpdateBalanceContent, this);
    XT.RegisterCallbackBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins, this.OnResultMinimumTimeBetweenSpins, this);
    XT.RegisterCallbackBool(Vars.DisableStopButton, this.OnDisableStopButton, this)
};
InterfaceControllerMobile_1.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGUIInit, this);
    XT.UnregisterCallbackEvent(this.OnRequestToClosePaytable, this);
    XT.UnregisterCallbackEvent(this.EnableUI, this);
    XT.UnregisterCallbackEvent(this.DisableUI, this);
    XT.UnregisterCallbackEvent(this.OnCoinValueChanged, this);
    XT.UnregisterCallbackEvent(this.OnSpinStarted, this);
    XT.UnregisterCallbackEvent(this.OnRequestToUpdateDisplayedWinInUI, this);
    XT.UnregisterCallbackEvent(this.OnVSGameStateChanged, this);
    XT.UnregisterCallbackDouble(this.UpdateBalanceContent, this)
};
InterfaceControllerMobile_1.prototype.OnVSGameStateChanged = function() {
    this.ChangeState(VSGameStateManager.GetState());
    this.UpdateStopBtn()
};
InterfaceControllerMobile_1.prototype.GetCurrentWindow = function() {
    return this.currentOpenedWindow
};
InterfaceControllerMobile_1.prototype.EnableUI = function() {
    if (this.uiIsActive) return;
    this.uiIsActive = true;
    this.contentInterface.SetActive(true);
    this.ChangeState(this.internalState);
    this.CloseCurrentOpenedWindow();
    if (this.otherInterface != null) {
        var w = this.otherInterface.GetCurrentWindow();
        if (this.currentOpenedWindow != w) this.UpdateWindows(w, true)
    }
};
InterfaceControllerMobile_1.prototype.DisableUI = function() {
    this.uiIsActive = false;
    this.contentInterface.SetActive(false)
};
InterfaceControllerMobile_1.prototype.Pressed_Menu_Open = function() {
    this.UpdateWindows(InterfaceControllerMobile_1.WindowTypes.Menu, true)
};
InterfaceControllerMobile_1.prototype.Pressed_Menu_Close = function() {
    this.UpdateWindows(InterfaceControllerMobile_1.WindowTypes.Menu, false)
};
InterfaceControllerMobile_1.prototype.Pressed_BetsWindow_Open = function() {
    this.UpdateWindows(InterfaceControllerMobile_1.WindowTypes.Bets, true)
};
InterfaceControllerMobile_1.prototype.Pressed_BetsWindow_Close = function() {
    this.UpdateWindows(InterfaceControllerMobile_1.WindowTypes.Bets, false)
};
InterfaceControllerMobile_1.prototype.Pressed_AutoplayWindow_Open = function() {
    this.UpdateWindows(InterfaceControllerMobile_1.WindowTypes.Autoplay_Simple, true)
};
InterfaceControllerMobile_1.prototype.Pressed_AutoplayWindow_Close = function() {
    this.UpdateWindows(InterfaceControllerMobile_1.WindowTypes.Autoplay_Simple, false)
};
InterfaceControllerMobile_1.prototype.Pressed_AutoplayStart = function() {
    this.CloseCurrentOpenedWindow()
};
InterfaceControllerMobile_1.prototype.Pressed_OpenAdvancedAutoplay = function() {
    this.UpdateWindows(InterfaceControllerMobile_1.WindowTypes.Autoplay_Advanced, true)
};
InterfaceControllerMobile_1.prototype.Pressed_Paytable_Open = function() {
    this.UpdateWindows(InterfaceControllerMobile_1.WindowTypes.Paytable, true)
};
InterfaceControllerMobile_1.prototype.Pressed_Paytable_Close = function() {
    this.UpdateWindows(InterfaceControllerMobile_1.WindowTypes.Paytable, false)
};
InterfaceControllerMobile_1.prototype.OnRequestToClosePaytable = function() {
    this.UpdateWindows(InterfaceControllerMobile_1.WindowTypes.Paytable, false)
};
InterfaceControllerMobile_1.prototype.Pressed_Balance = function() {
    XT.TriggerEvent(Vars.Evt_ToServer_OpenCashier)
};
InterfaceControllerMobile_1.prototype.Pressed_Home = function() {
    XT.TriggerEvent(Vars.Evt_ToServer_CloseGame)
};
InterfaceControllerMobile_1.prototype.Pressed_SkipScreens = function() {
    XT.SetBool(Vars.Autoplay_SkipScreens, !XT.GetBool(Vars.Autoplay_SkipScreens))
};
InterfaceControllerMobile_1.prototype.OnGUIInit = function() {
    var b = XT.GetBool(Vars.CanGamble_Spin);
    this.gambleButton.SetActive(b);
    var b_fs = XT.GetBool(Vars.CanGamble_FreeSpin);
    this.buttons_resultFSWithGamble.SetActive(b_fs);
    this.buttons_resultFSWithoutGamble.SetActive(!b_fs);
    var hasWays = XT.GetBool(Vars.GameHasWaysInsteadOfLines);
    this.InternalSetActive(this.visibleIfGameHasLines, !hasWays);
    this.InternalSetActive(this.visibleIfGameHasWays, hasWays);
    this.ChangeState(VSGameState.Invalid)
};
InterfaceControllerMobile_1.prototype.ChangeState = function(newState) {
    this.internalState = newState;
    if (!this.uiIsActive) return;
    var isMisteryScatter = false;
    var isDuringFS = false;
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr != null) {
        isMisteryScatter = fsr.MysteryScatter.length > 0;
        isDuringFS = fsr.IsFreeSpin
    }
    this.rq.StopRoutines();
    if (this.internalState == VSGameState.Spin || this.internalState == VSGameState.SpinAutoplay || this.internalState == VSGameState.SpinFreeSpins || this.internalState == VSGameState.SpinBonusRounds ||
        this.internalState == VSGameState.SpinBonusRoundsAutoplay) {
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(XT.GetDouble(InterfaceVars.GUIDynamicMessageDelay)));
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.HideWin, null, this));
        this.rq.StartRoutines()
    }
    switch (newState) {
        case VSGameState.Spin:
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds,
                false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentNormal, true);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(true);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(true);
                else this.stopBtnVisual.SetActive(false);
            this.CloseCurrentOpenedWindow();
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons =
                false;
            this.messageController.ChangeToState(VSGameState.Spin);
            break;
        case VSGameState.SpinAutoplay:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentAutoplay, true);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(true);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(true);
                else this.stopBtnVisual.SetActive(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.SpinAutoplay);
            break;
        case VSGameState.SpinFreeSpins:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay,
                false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(true);
            if (isMisteryScatter) {
                this.InternalSetActive(this.dynamicContentFreeSpins, false);
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, true)
            } else {
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
                this.InternalSetActive(this.dynamicContentFreeSpins, true)
            }
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(true);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(true);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.SpinFreeSpins);
            break;
        case VSGameState.SpinBonusRounds:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter,
                false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, true);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(true);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(true);
            this.CloseCurrentOpenedWindow();
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.SpinBonusRounds);
            break;
        case VSGameState.SpinBonusRoundsAutoplay:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, true);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(true);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(true);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.SpinBonusRoundsAutoplay);
            break;
        case VSGameState.Result:
            var canSpin = this.InternalCanSpin();
            this.gambleButton.SetActive(XT.GetBool(Vars.CanGamble_Spin));
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter,
                false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentNormal, true);
            if (XT.GetInt(Vars.AutoplaySpinsLeft) >= 0) this.InternalSetActive(this.dynamicContentAutoplay, true);
            else this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.ToggleFSMultiplier(false);
            this.toggledInBonusGame.Toggle(true);
            this.InternalSetActive(this.toggledInGamble, true);
            this.spinBtn.SetActive(canSpin);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins) || XT.GetBool(Vars.Jurisdiction_ResultMinimumTime)) this.stopBtnVisual.SetActive(!canSpin);
            this.UpdateWinDisplayedState();
            this.CloseCurrentOpenedWindow();
            this.UpdateBetButtons(canSpin);
            this.SetAllowAutoplay(canSpin);
            this.enableMenuButtons = true;
            this.messageController.ChangeToState(VSGameState.Result);
            break;
        case VSGameState.ResultPrepareForBonus:
            this.InternalSetActive(this.dynamicContentAutoplay,
                false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentNormal, true);
            this.ToggleFSMultiplier(false);
            this.toggledInBonusGame.Toggle(true);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.UpdateWinDisplayedState();
            this.CloseCurrentOpenedWindow();
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.ResultPrepareForBonus);
            break;
        case VSGameState.ResultAutoplay:
            this.gambleButton.SetActive(XT.GetBool(Vars.CanGamble_Spin));
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter,
                false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentAutoplay, true);
            this.ToggleFSMultiplier(false);
            this.toggledInBonusGame.Toggle(true);
            this.InternalSetActive(this.toggledInGamble, true);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins) || XT.GetBool(Vars.Jurisdiction_ResultMinimumTime)) this.stopBtnVisual.SetActive(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.ResultAutoplay);
            break;
        case VSGameState.ResultBonusRounds:
            this.gambleButton.SetActive(false);
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay,
                false);
            this.InternalSetActive(this.dynamicContentBonusRounds, true);
            this.ToggleFSMultiplier(false);
            this.toggledInBonusGame.Toggle(true);
            this.InternalSetActive(this.toggledInGamble, true);
            var canSpin = this.InternalCanSpin();
            this.spinBtn.SetActive(canSpin);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(!canSpin);
            this.UpdateWinDisplayedState();
            this.CloseCurrentOpenedWindow();
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(canSpin);
            this.enableMenuButtons = true;
            this.messageController.ChangeToState(VSGameState.ResultBonusRounds);
            break;
        case VSGameState.ResultBonusRoundsAutoplay:
            this.gambleButton.SetActive(false);
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds,
                false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, true);
            this.ToggleFSMultiplier(false);
            this.toggledInBonusGame.Toggle(true);
            this.InternalSetActive(this.toggledInGamble, true);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.UpdateWinDisplayedState();
            this.messageController.ChangeToState(VSGameState.ResultBonusRoundsAutoplay);
            break;
        case VSGameState.ResultFreeSpinsPrepare:
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.InternalSetActive(this.dynamicContentNormal, true);
            this.ToggleFSMultiplier(false);
            this.toggledInBonusGame.Toggle(true);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.UpdateWinDisplayedState();
            this.CloseCurrentOpenedWindow();
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.ResultFreeSpinsPrepare);
            break;
        case VSGameState.ResultFreeSpins:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay,
                false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(true);
            if (isMisteryScatter) {
                this.InternalSetActive(this.dynamicContentFreeSpins, false);
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, true)
            } else {
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
                this.InternalSetActive(this.dynamicContentFreeSpins, true)
            }
            this.toggledInBonusGame.Toggle(true);
            this.InternalSetActive(this.toggledInGamble,
                true);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins) || XT.GetBool(Vars.Jurisdiction_ResultMinimumTime)) this.stopBtnVisual.SetActive(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.UpdateWinDisplayedState();
            this.messageController.ChangeToState(VSGameState.ResultFreeSpins);
            break;
        case VSGameState.Bonus:
            this.InternalSetActive(this.dynamicContentNormal,
                false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(isDuringFS);
            if (isMisteryScatter) {
                this.InternalSetActive(this.dynamicContentFreeSpins, false);
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, isDuringFS)
            } else {
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
                this.InternalSetActive(this.dynamicContentFreeSpins,
                    isDuringFS)
            }
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.CloseCurrentOpenedWindow();
            this.toggledInBonusGame.Toggle(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.UpdateWinDisplayedState();
            this.messageController.ChangeToState(VSGameState.Bonus);
            break;
        case VSGameState.Gamble:
            this.InternalSetActive(this.dynamicContentNormal,
                false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.CloseCurrentOpenedWindow();
            this.InternalSetActive(this.toggledInGamble, false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.Gamble);
            break;
        case VSGameState.GambleCustom:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter,
                false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.CloseCurrentOpenedWindow();
            this.toggledInBonusGame.Toggle(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.messageController.ChangeToState(VSGameState.GambleCustom);
            break;
        case VSGameState.Jackpot:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual !=
                null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.CloseCurrentOpenedWindow();
            this.toggledInBonusGame.Toggle(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.messageController.ChangeToState(VSGameState.Jackpot);
            break;
        case VSGameState.FSBG:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentBonusRounds, false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay,
                false);
            this.ToggleFSMultiplier(isDuringFS);
            if (isMisteryScatter) {
                this.InternalSetActive(this.dynamicContentFreeSpins, false);
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, isDuringFS)
            } else {
                this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
                this.InternalSetActive(this.dynamicContentFreeSpins, isDuringFS)
            }
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.CloseCurrentOpenedWindow();
            this.toggledInBonusGame.Toggle(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.UpdateWinDisplayedState();
            this.messageController.ChangeToState(VSGameState.FSBG);
            break;
        default:
        case VSGameState.Invalid:
            this.InternalSetActive(this.dynamicContentNormal, false);
            this.InternalSetActive(this.dynamicContentAutoplay, false);
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
            this.InternalSetActive(this.dynamicContentBonusRounds,
                false);
            this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
            this.ToggleFSMultiplier(false);
            this.spinBtn.SetActive(false);
            this.stopBtn.SetActive(false);
            if (this.stopBtnVisual != null)
                if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(false);
            this.CloseCurrentOpenedWindow();
            this.toggledInBonusGame.Toggle(false);
            this.UpdateBetButtons(false);
            this.SetAllowAutoplay(false);
            this.enableMenuButtons = false;
            this.messageController.ChangeToState(VSGameState.Invalid);
            break
    }
};
InterfaceControllerMobile_1.prototype.InternalSetActive = function(arr, active) {
    for (var i = 0; i < arr.length; i++) arr[i].SetActive(active);
    var stateIdx = Number(this.internalState);
    if (this.changeState != null && stateIdx < this.changeState.length && this.changeState[stateIdx] != null) this.changeState[stateIdx].Start()
};
InterfaceControllerMobile_1.prototype.CloseCurrentOpenedWindow = function() {
    if (this.currentOpenedWindow != InterfaceControllerMobile_1.WindowTypes.None) {
        this.ShowHideWindow(this.currentOpenedWindow, false);
        this.currentOpenedWindow = InterfaceControllerMobile_1.WindowTypes.None
    }
};
InterfaceControllerMobile_1.prototype.UpdateWindows = function(type, open) {
    if (this.currentOpenedWindow != InterfaceControllerMobile_1.WindowTypes.None) {
        this.ShowHideWindow(this.currentOpenedWindow, false);
        this.currentOpenedWindow = InterfaceControllerMobile_1.WindowTypes.None
    }
    if (type != InterfaceControllerMobile_1.WindowTypes.None && open) {
        this.ShowHideWindow(type, true);
        this.currentOpenedWindow = type;
        XT.TriggerEvent(InterfaceVars.Evt_CodeToData_InterfaceWindowOpen)
    }
};
InterfaceControllerMobile_1.prototype.ShowHideWindow = function(type, open) {
    switch (type) {
        case InterfaceControllerMobile_1.WindowTypes.Paytable:
            if (open) XT.TriggerEvent(Vars.Evt_Internal_PaytableOpen);
            else XT.TriggerEvent(Vars.Evt_Internal_PaytableClose);
            this.menuButtonsParent.SetActive(!open);
            this.paytableCloseButton.SetActive(open);
            break;
        case InterfaceControllerMobile_1.WindowTypes.Menu:
            if (open) {
                this.menuWindow.ShowMenuWindow(this.enableMenuButtons);
                this.UpdateAutoplayControllers()
            } else this.menuWindow.HideMenuWindow();
            this.menuButton.opened.SetActive(open);
            this.menuButton.closed.SetActive(!open);
            break;
        case InterfaceControllerMobile_1.WindowTypes.Bets:
            this.betsButton.opened.SetActive(open);
            this.betsButton.closed.SetActive(!open);
            this.OpenBetsWindows(open);
            break;
        case InterfaceControllerMobile_1.WindowTypes.Autoplay_Simple:
            var instantAutoplay = XT.GetBool(Vars.InstantAutoplay);
            if (open) {
                if (instantAutoplay) {
                    this.autoplayAdvancedWindow.GetComponentsInChildren(AutoplayControllerAdvanced, true)[0].StartAutoplayPressed();
                    this.Pressed_AutoplayStart()
                }
                this.UpdateAutoplayControllers()
            } else this.spinBtn.SetActive(this.InternalCanSpin());
            if (!instantAutoplay) this.OpenAutoplayWindows(open);
            break;
        case InterfaceControllerMobile_1.WindowTypes.Autoplay_Advanced:
            var instantAutoplay = XT.GetBool(Vars.InstantAutoplay);
            if (open) {
                if (instantAutoplay) {
                    this.autoplayAdvancedWindow.GetComponentsInChildren(AutoplayControllerAdvanced, true)[0].StartAutoplayPressed();
                    this.Pressed_AutoplayStart()
                }
                this.UpdateAutoplayControllers()
            } else this.spinBtn.SetActive(this.InternalCanSpin());
            if (!instantAutoplay) {
                this.autoplayAdvancedWindow.SetActive(open);
                this.menuButtonsParent.SetActive(!open);
                this.autoplayCloseButton.SetActive(open)
            }
            break;
        default:
            console.error("Interface: Trying to start / close an invalid window");
            break
    }
};
InterfaceControllerMobile_1.prototype.UpdateWinDisplayedState = function() {
    var win = 0;
    if (this.internalState == VSGameState.ResultFreeSpins) win = XT.GetDouble(Vars.FreeSpinsLastWinDisplayed);
    else win = XT.GetDouble(Vars.SpinCycleWinDisplayed);
    this.UpdateDisplayForWinContainers(win > 1E-4, win > 1E-4 && !this.coinValueChanged)
};
InterfaceControllerMobile_1.prototype.UpdateDisplayForWinContainers = function(showCash, showCoins) {
    for (var i = 0; i < this.winDisplayedContainers.length; i++) this.winDisplayedContainers[i].UpdateDisplay(showCash, showCoins)
};
InterfaceControllerMobile_1.prototype.OnCanSpinChanged = function() {
    if (this.internalState == VSGameState.Result || this.internalState == VSGameState.ResultBonusRounds) {
        var canSpin = this.InternalCanSpin();
        this.spinBtn.SetActive(canSpin);
        if (this.stopBtnVisual != null)
            if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.stopBtnVisual.SetActive(!canSpin);
        this.UpdateBetButtons(canSpin && this.internalState == VSGameState.Result);
        this.SetAllowAutoplay(canSpin)
    }
};
InterfaceControllerMobile_1.prototype.HideWin = function(param) {
    if (this.internalState == VSGameState.Spin || this.internalState == VSGameState.SpinAutoplay || this.internalState == VSGameState.SpinFreeSpins || this.internalState == VSGameState.SpinBonusRounds || this.internalState == VSGameState.SpinBonusRoundsAutoplay) {
        this.UpdateDisplayForWinContainers(false, false);
        for (var i = 0; i < this.toggledOnHideWin.length; i++) this.toggledOnHideWin[i].WinIsHidden();
        if (this.otherInterface != null)
            if (this.uiIsActive) this.otherInterface.HideWin(null)
    }
};
InterfaceControllerMobile_1.prototype.OnSpinStarted = function() {
    this.coinValueChanged = false
};
InterfaceControllerMobile_1.prototype.OnCoinValueChanged = function() {
    if (this.internalState == VSGameState.Result || this.internalState == VSGameState.ResultBonusRounds) {
        this.coinValueChanged = true;
        var win = XT.GetDouble(Vars.SpinCycleWinDisplayed);
        this.UpdateDisplayForWinContainers(win > 1E-4, false)
    }
};
InterfaceControllerMobile_1.prototype.OnRequestToUpdateDisplayedWinInUI = function() {
    this.UpdateWinDisplayedState()
};
InterfaceControllerMobile_1.prototype.InternalCanSpin = function() {
    var respinData = XT.GetObject(Vars.RespinData);
    var canSpin = XT.GetBool(Vars.CanSpin) && (respinData == null || respinData.IsDone || XT.GetBool(Vars.ManualRespin));
    return canSpin
};
InterfaceControllerMobile_1.prototype.ToggleFSMultiplier = function(isFreeSpin) {
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    var multiplier = isFreeSpin ? fsr.TotalMultiplier : 1;
    for (var i = 0; i < this.fsMultiplierToggles.length; i++) this.fsMultiplierToggles[i].FSMultiplierChanged(multiplier)
};
InterfaceControllerMobile_1.prototype.SetAllowAutoplay = function(allow) {
    for (var i = 0; i < this.autoplayControllers.length; i++) this.autoplayControllers[i].AllowAutoplay(allow)
};
InterfaceControllerMobile_1.prototype.UpdateAutoplayControllers = function() {
    for (var i = 0; i < this.autoplayControllers.length; i++) this.autoplayControllers[i].UpdateAutoplayContent()
};
InterfaceControllerMobile_1.prototype.OpenAutoplayWindows = function(show) {
    for (var i = 0; i < this.autoplayControllers.length; i++)
        if (show) this.autoplayControllers[i].ShowAutoplayWindow();
        else this.autoplayControllers[i].HideAutoplayWindow()
};
InterfaceControllerMobile_1.prototype.OpenBetsWindows = function(show) {
    for (var i = 0; i < this.betsControllers.length; i++)
        if (show) this.betsControllers[i].ShowBetsWindow();
        else this.betsControllers[i].HideBetsWindow()
};
InterfaceControllerMobile_1.prototype.UpdateBetButtons = function(enabled) {
    for (var i = 0; i < this.betsControllers.length; i++) this.betsControllers[i].UpdateBetButtons(enabled);
    if (enabled) this.betsButton.closed.GetComponent(ButtonEnabler).EnableButton();
    else this.betsButton.closed.GetComponent(ButtonEnabler).DisableButton()
};
InterfaceControllerMobile_1.prototype.OnLastWinIsCountingChanged = function(param) {
    this.UpdateStopBtn()
};
InterfaceControllerMobile_1.prototype.UpdateStopBtn = function() {
    if (!this.stopBtn.activeSelf) this.stopBtn.SetActive(true);
    var mustStop = false;
    switch (VSGameStateManager.GetState()) {
        case VSGameState.Spin:
        case VSGameState.SpinAutoplay:
        case VSGameState.SpinFreeSpins:
        case VSGameState.SpinBonusRounds:
        case VSGameState.SpinBonusRoundsAutoplay:
            mustStop = true;
            break
    }
    if (mustStop) this.stopBtn.GetComponent(XTButton).eventToCode.name = Vars.Evt_DataToCode_Pressed_Stop;
    else if (XT.GetBool(Vars.LastWinIsCounting)) this.stopBtn.GetComponent(XTButton).eventToCode.name =
        Vars.Evt_Internal_FinalizeDisplayedWin;
    else this.stopBtn.SetActive(false)
};
InterfaceControllerMobile_1.prototype.UpdateBalanceContent = function(value) {
    var balance = _number.otod(value);
    if (XT.GetBool(Vars.Jurisdiction_SplitBalance)) {
        this.balanceParent.SetActive(balance <= 0);
        this.bonusBalanceParent.SetActive(balance > 0)
    }
};
InterfaceControllerMobile_1.prototype.OnResultMinimumTimeBetweenSpins = function(param) {
    var isActive = param;
    if (isActive) {
        XT.RegisterCallbackFloat(Vars.SpinDuration, this.OnSpinDuration, this);
        XT.RegisterCallbackBool(Vars.CanSpin, this.OnCanSpin, this)
    }
};
InterfaceControllerMobile_1.prototype.OnSpinDuration = function(param) {
    var spinDuration = param;
    if (spinDuration > XT.GetFloat(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins_Value)) {
        this.stopButtonEnabler.EnableButton();
        this.stopButtonColliderEnabler.EnableCollider()
    }
};
InterfaceControllerMobile_1.prototype.OnCanSpin = function(param) {
    var canSpin = param;
    if (canSpin) {
        this.stopButtonEnabler.EnableButton();
        this.stopButtonColliderEnabler.EnableCollider()
    } else {
        this.stopButtonEnabler.DisableButton();
        this.stopButtonColliderEnabler.DisableCollider()
    }
};
InterfaceControllerMobile_1.prototype.OnDisableStopButton = function(param) {
    var isActive = param;
    if (isActive) XT.RegisterCallbackBool(Vars.CanSpin, this.OnCanSpin, this)
};
goog.require("UHT.UHTEngine");
var V3AnimationProperty = {
    Position: 0,
    LocalScale: 1,
    LocalPosition: 2,
    LocalRotation: 3
};
var V3AnimationMode = {
    Default: 0,
    Loop: 1,
    Clamp: 2
};
var V3AnimatorAction = {
    NoAction: 0,
    Play: 1,
    PlayReversed: 2
};
var V3AnimatorUpdateMethod = {
    Update: 0,
    LateUpdate: 1
};
V3Animator.prototype = Object.create(Component.prototype);
V3Animator.prototype.constructor = V3Animator;

function V3Animator() {
    Component.call(this);
    this.target = null;
    this.from = null;
    this.to = null;
    this.animationTime = 0;
    this.animationCurve = AnimationCurve.linear(0, 0, 1, 1);
    this.animationProperty = V3AnimationProperty.Position;
    this.animationMode = V3AnimationMode.Default;
    this.staticFromAndTo = false;
    this.staticFrom = false;
    this.staticTo = false;
    this.animationCurveX = null;
    this.animationCurveY = null;
    this.useXAndYCurves = false;
    this.onEnable = V3AnimatorAction.NoAction;
    this.updateOn = V3AnimatorUpdateMethod.Update;
    this.callWhenFinished =
        null;
    this.callWhenNoChange = null;
    this.unclamped = false;
    this.useMultipleTargets = false;
    this.multipleTargets = null;
    this.useManualFrom = false;
    this.manualFrom = null;
    this.useManualTo = false;
    this.manualTo = null;
    this.affectX = true;
    this.affectY = true;
    this.affectZ = true;
    this.timeScaleID = "";
    this.useMoveSpeed = false;
    this.moveSpeed = .001;
    this.v3From = null;
    this.v3To = null;
    this.currentTime = 0;
    this.isPlaying = false;
    this.isReversed = false;
    this.isStuck = false;
    this.stickTime = 0;
    this.prevValue = UHTMath.Vector3.zero;
    this.valueChanged = false;
    this.canStartCallback = true
}
V3Animator.prototype.Play = function() {
    if (this.useMoveSpeed) this.animationTime = UHTMath.Vector3.distance(this.from.transform.position(), this.to.transform.position()) / this.moveSpeed;
    this.currentTime = 0;
    this.isPlaying = true;
    this.isReversed = false;
    this.GetFromAndTo()
};
V3Animator.prototype.PlayReversed = function() {
    this.currentTime = 0;
    this.isPlaying = true;
    this.isReversed = true;
    this.GetFromAndTo()
};
V3Animator.prototype.Stop = function() {
    this.currentTime = 0;
    this.isPlaying = false
};
V3Animator.prototype.Pause = function() {
    this.isPlaying = false
};
V3Animator.prototype.Resume = function() {
    this.isPlaying = true
};
V3Animator.prototype.IsPlaying = function() {
    return this.isPlaying
};
V3Animator.prototype.Sample = function(normalizedTime) {
    this.isPlaying = false;
    this.isReversed = false;
    this.GetFromAndTo();
    this.UpdateValue(Number(normalizedTime))
};
V3Animator.prototype.SampleAndSetCurrentTime = function(normalizedTime) {
    normalizedTime = Number(normalizedTime);
    this.Sample(normalizedTime);
    this.currentTime = normalizedTime * this.animationTime
};
V3Animator.prototype.Stick = function(normalizedTime) {
    this.isStuck = true;
    this.stickTime = Number(normalizedTime)
};
V3Animator.prototype.Unstick = function() {
    this.isStuck = false
};
V3Animator.prototype.InternalUpdate = function() {
    if (this.isPlaying) {
        this.GetFromAndTo(true);
        this.UpdateValue(this.currentTime / this.animationTime);
        if (this.currentTime >= this.animationTime)
            if (this.animationMode == V3AnimationMode.Default) {
                this.isPlaying = false;
                if (this.callWhenFinished != null && this.canStartCallback) this.callWhenFinished.Start()
            } else if (this.animationMode == V3AnimationMode.Loop) {
            this.currentTime -= this.animationTime;
            this.UpdateValue(this.currentTime / this.animationTime)
        }
        if (!this.valueChanged &&
            this.currentTime > 0 && this.callWhenNoChange != null && this.callWhenNoChange.cat != null) this.callWhenNoChange.Start();
        this.currentTime += TimeScaler.GetDeltaTime(this.timeScaleID)
    }
    if (this.isStuck) {
        this.GetFromAndTo(true);
        this.UpdateValue(this.stickTime)
    }
};
V3Animator.prototype.GetFromAndTo = function(onlyNonStatic) {
    var v3F = UHTMath.Vector3.zero;
    var v3T = UHTMath.Vector3.zero;
    switch (this.animationProperty) {
        case V3AnimationProperty.Position:
            if (!this.useManualFrom) v3F = this.from.transform.position();
            if (!this.useManualTo) v3T = this.to.transform.position();
            break;
        case V3AnimationProperty.LocalPosition:
            if (!this.useManualFrom) v3F = this.from.transform.localPosition();
            if (!this.useManualTo) v3T = this.to.transform.localPosition();
            break;
        case V3AnimationProperty.LocalRotation:
            if (!this.useManualFrom) v3F =
                this.from.transform.localEulerAngles();
            if (!this.useManualTo) v3T = this.to.transform.localEulerAngles();
            break;
        case V3AnimationProperty.LocalScale:
            if (!this.useManualFrom) v3F = this.from.transform.localScale();
            if (!this.useManualTo) v3T = this.to.transform.localScale();
            break
    }
    onlyNonStatic = Boolean(onlyNonStatic);
    if (this.useManualFrom) this.v3From = this.manualFrom;
    else if (!onlyNonStatic || !this.staticFrom) this.v3From = v3F;
    if (this.useManualTo) this.v3To = this.manualTo;
    else if (!onlyNonStatic || !this.staticTo) this.v3To =
        v3T
};
V3Animator.prototype.Evaluate = function(normalizedTime) {
    var time = UHTMath.clamp(normalizedTime, 0, 1);
    if (this.isReversed) time = 1 - time;
    time *= this.animationCurve.keys[this.animationCurve.keys.length - 1].time;
    var curveX = this.animationCurve;
    var curveY = this.animationCurve;
    var curveZ = this.animationCurve;
    if (this.useXAndYCurves) {
        curveX = this.animationCurveX;
        curveY = this.animationCurveY
    }
    var x;
    var y;
    var z;
    if (this.unclamped) {
        x = UHTMath.lerpUnclamped(this.v3From.x, this.v3To.x, curveX.Evaluate(time));
        y = UHTMath.lerpUnclamped(this.v3From.y, this.v3To.y,
            curveY.Evaluate(time));
        z = UHTMath.lerpUnclamped(this.v3From.z, this.v3To.z, curveZ.Evaluate(time))
    } else {
        x = UHTMath.lerp(this.v3From.x, this.v3To.x, curveX.Evaluate(time));
        y = UHTMath.lerp(this.v3From.y, this.v3To.y, curveY.Evaluate(time));
        z = UHTMath.lerp(this.v3From.z, this.v3To.z, curveZ.Evaluate(time))
    }
    return new UHTMath.Vector3(x, y, z)
};
V3Animator.prototype.UpdateValue = function(normalizedTime) {
    var value = this.Evaluate(normalizedTime);
    this.valueChanged = !this.prevValue.equals(value);
    this.prevValue = value;
    switch (this.animationProperty) {
        case V3AnimationProperty.Position:
            if (!this.useMultipleTargets) this.target.transform.position(this.GetValue(this.target.transform.position(), value));
            else
                for (var i = 0; i < this.multipleTargets.length; ++i) this.multipleTargets[i].transform.position(this.GetValue(this.multipleTargets[i].transform.position(), value));
            break;
        case V3AnimationProperty.LocalPosition:
            if (!this.useMultipleTargets) this.target.transform.localPosition(this.GetValue(this.target.transform.localPosition(), value));
            else
                for (var i = 0; i < this.multipleTargets.length; ++i) this.multipleTargets[i].transform.localPosition(this.GetValue(this.multipleTargets[i].transform.localPosition(), value));
            break;
        case V3AnimationProperty.LocalRotation:
            if (!this.useMultipleTargets) this.target.transform.localRotation(UHTMath.Quaternion.euler(this.GetValue(this.target.transform.localEulerAngles(),
                value)));
            else
                for (var i = 0; i < this.multipleTargets.length; ++i) this.multipleTargets[i].transform.localRotation(UHTMath.Quaternion.euler(this.GetValue(this.multipleTargets[i].transform.localEulerAngles(), value)));
            break;
        case V3AnimationProperty.LocalScale:
            if (!this.useMultipleTargets) this.target.transform.localScale(this.GetValue(this.target.transform.localScale(), value));
            else
                for (var i = 0; i < this.multipleTargets.length; ++i) this.multipleTargets[i].transform.localScale(this.GetValue(this.multipleTargets[i].transform.localScale(),
                    value));
            break
    }
};
V3Animator.prototype.OnEnable = function() {
    switch (this.onEnable) {
        case V3AnimatorAction.Play:
            this.Play();
            break;
        case V3AnimatorAction.PlayReversed:
            this.PlayReversed();
            break
    }
};
V3Animator.prototype.Update = function() {
    if (this.updateOn == V3AnimatorUpdateMethod.Update) this.InternalUpdate()
};
V3Animator.prototype.LateUpdate = function() {
    if (this.updateOn == V3AnimatorUpdateMethod.LateUpdate) this.InternalUpdate()
};
V3Animator.prototype.Awake = function() {
    if (this.staticFromAndTo) this.staticFrom = this.staticTo = this.staticFromAndTo
};
V3Animator.prototype.GetValue = function(curValue, newValue) {
    var x = this.affectX ? newValue.x : curValue.x;
    var y = this.affectY ? newValue.y : curValue.y;
    var z = this.affectZ ? newValue.z : curValue.z;
    return new UHTMath.Vector3(x, y, z)
};
V3Animator.prototype.SetAnimationTime = function(time) {
    this.animationTime = Number(time)
};
goog.require("UHT.Component");
goog.require("UHT.AudioClip");
var WhenToPlay = {
    OnClick: 0,
    OnHover: 1,
    Custom: 2
};
var PlayMode = {
    OneShot: 0,
    Loop: 1
};
SoundPlayer.prototype = Object.create(Component.prototype);
SoundPlayer.prototype.constructor = SoundPlayer;

function SoundPlayer() {
    Component.call(this);
    this.audioClip = null;
    this.whenToPlay = WhenToPlay.Custom;
    this.playMode = PlayMode.OneShot;
    this.playOnlyIfEnabled = false;
    this.muteBackgroundMusic = false;
    this.handler = -1;
    this.canPlayHoverSound = true
}
SoundPlayer.prototype.OnDisable = function() {
    this.OnHover(false)
};
SoundPlayer.prototype.PlaySound = function() {
    this.InternalPlayClip(this.audioClip)
};
SoundPlayer.prototype.StopPlayingSound = function() {
    if (this.handler >= 0) {
        var mgr = XT.GetObject(Vars.SoundManagerObject);
        var args = {
            handle: this.handler
        };
        mgr.StopLoopingSound(args);
        this.handler = args.handle;
        if (this.muteBackgroundMusic) mgr.UnmuteMusic()
    }
};
SoundPlayer.prototype.OnClick = function() {
    if (this.gameObject.collider == null || !this.gameObject.collider.enabled) return;
    if (this.whenToPlay == WhenToPlay.OnClick) this.InternalPlayClip(this.audioClip)
};
SoundPlayer.prototype.OnHover = function(isOver) {
    if (isOver == false) this.canPlayHoverSound = true;
    if (this.gameObject.collider == null || !this.gameObject.collider.enabled || !isOver) return;
    if (this.whenToPlay == WhenToPlay.OnHover && this.canPlayHoverSound) {
        this.InternalPlayClip(this.audioClip);
        this.canPlayHoverSound = false
    }
};
SoundPlayer.prototype.InternalPlayClip = function(clip) {
    if (this.playOnlyIfEnabled && !this.gameObject.activeInHierarchy) return;
    var mgr = XT.GetObject(Vars.SoundManagerObject);
    if (this.muteBackgroundMusic) mgr.MuteMusic();
    switch (this.playMode) {
        case PlayMode.OneShot:
            mgr.PlaySimple(clip);
            break;
        case PlayMode.Loop:
            this.handler = mgr.PlayLooping(clip);
            break;
        default:
            break
    }
};
goog.require("UHT.XTLink");
var SliderType = {
    Bool: 0,
    Int: 1,
    Double: 2,
    Float: 3
};
Slider.prototype = Object.create(XTLink.prototype);
Slider.prototype.constructor = Slider;

function Slider() {
    XTLink.call(this);
    this.thumb = null;
    this.thumbVisual = null;
    this.localPositionMin = null;
    this.localPositionMax = null;
    this.scrollWheelMovement = null;
    this.scrollWheels = null;
    this.valueDisplayers = null;
    this.bars = null;
    this.slicedBars = null;
    this.slicedBarsMinimumScale = null;
    this.colorAnimators = null;
    this.type = SliderType.Bool;
    this.minValue = 0;
    this.maxValue = 0;
    this.values = null;
    this.value = 0;
    this.valueIndex = 0;
    this.notifyWhenValueChanged = true;
    this.autocomplete = false;
    this.animator = null;
    this.animationTime =
        0;
    this.inverseAnimationTime = 0;
    this.xtVariableName = "";
    this.xtVariableIsIndex = false;
    this.soundPlayer = null;
    this.playClickSoundOnRelease = false;
    this.cachedCamera = null;
    this.prevThumbPos = new UHTMath.Vector3(-1, -1, -1);
    this.isInit = false;
    this.internalValue = 0;
    this.autocompleteFrameCount = 0
}
Slider.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this, -1)
};
Slider.prototype.OnGameInit = function() {
    this.thumb.limitPosition = true;
    this.thumb.useScrollWheel = true;
    this.thumb.localPositionLimitMin = this.localPositionMin;
    this.thumb.localPositionLimitMax = this.localPositionMax;
    this.thumb.scrollWheelMovement = this.scrollWheelMovement;
    for (var i = 0; i < this.scrollWheels.length; ++i) {
        this.scrollWheels[i].limitPosition = true;
        this.scrollWheels[i].useScrollWheel = true;
        this.scrollWheels[i].useOnlyScrollWheel = true;
        this.scrollWheels[i].localPositionLimitMin = this.localPositionMin;
        this.scrollWheels[i].localPositionLimitMax = this.localPositionMax;
        this.scrollWheels[i].scrollWheelMovement = this.scrollWheelMovement
    }
    this.OnEnable();
    this.UpdateValue(this.value);
    this.isInit = true
};
Slider.prototype.OnEnable = function() {
    if (_string.IsNullOrEmpty(this.xtVariableName)) return;
    var val = 0;
    if (this.type == SliderType.Bool) val = XT.GetBool(this.xtVariableName) ? 1 : 0;
    else if (this.type == SliderType.Int) val = XT.GetInt(this.xtVariableName);
    else if (this.type == SliderType.Float) val = XT.GetFloat(this.xtVariableName);
    else if (this.type == SliderType.Double) val = XT.GetDouble(this.xtVariableName);
    this.notifyWhenValueChanged = false;
    if (this.xtVariableIsIndex) this.SetValueIndex(val);
    else this.SetValue(val);
    this.notifyWhenValueChanged =
        true
};
Slider.prototype.LateUpdate = function() {
    if (!this.isInit) return;
    var thumbPos = this.thumb.target.localPosition();
    if (!thumbPos.equals(this.prevThumbPos)) this.UpdateValue((thumbPos.x - this.thumb.localPositionLimitMin.x) / (this.thumb.localPositionLimitMax.x - this.thumb.localPositionLimitMin.x))
};
Slider.prototype.SetValue = function(param) {
    this.UpdateValue(UHTMath.inverseLerp(this.minValue, this.maxValue, param))
};
Slider.prototype.SetValueIndex = function(param) {
    this.UpdateValue(UHTMath.inverseLerp(0, this.values.length - 1, param))
};
Slider.prototype.UpdateValue = function(param) {
    var snapped = param;
    this.internalValue = param;
    if (this.type == SliderType.Bool) this.value = Math.round(param);
    else if (this.values.length > 0) {
        this.valueIndex = Math.round(UHTMath.lerp(0, this.values.length - 1, param));
        snapped = this.valueIndex / (this.values.length - 1);
        this.value = this.values[this.valueIndex]
    } else {
        this.value = UHTMath.lerp(this.minValue, this.maxValue, param);
        if (this.type == SliderType.Int) this.value = Math.round(this.value)
    }
    for (var i = 0; i < this.valueDisplayers.length; ++i) {
        this.valueDisplayers[i].callEventWhenValueChangedAllowed =
            this.notifyWhenValueChanged;
        this.valueDisplayers[i].SetValueManually(this.value)
    }
    for (var i = 0; i < this.bars.length; ++i) this.bars[i].transform.localScale(new UHTMath.Vector3(snapped, 1, 1));
    for (var i = 0; i < this.slicedBars.length; ++i) this.slicedBars[i].Sample(snapped > this.slicedBarsMinimumScale[i] ? snapped : this.slicedBarsMinimumScale[i]);
    for (var i = 0; i < this.colorAnimators.length; ++i) this.colorAnimators[i].Sample(snapped);
    var thumbPos = UHTMath.Vector3.lerp(this.thumb.localPositionLimitMin, this.thumb.localPositionLimitMax,
        param);
    this.thumb.target.localPosition(thumbPos);
    this.prevThumbPos = thumbPos;
    thumbPos = UHTMath.Vector3.lerp(this.thumb.localPositionLimitMin, this.thumb.localPositionLimitMax, snapped);
    this.thumbVisual.localPosition(thumbPos);
    if (!_string.IsNullOrEmpty(this.xtVariableName))
        if (this.type == SliderType.Bool) XT.SetBool(this.xtVariableName, this.value >= .5);
        else if (this.type == SliderType.Int) XT.SetInt(this.xtVariableName, this.value);
    else if (this.type == SliderType.Float) XT.SetFloat(this.xtVariableName, this.value);
    else if (this.type == SliderType.Double) XT.SetDouble(this.xtVariableName, this.value)
};
Slider.prototype.OnPress = function(pressed) {
    if (pressed) {
        if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
        this.thumb.target.position(this.thumb.GetPosition(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition)))
    } else {
        this.Autocomplete();
        if (this.playClickSoundOnRelease) this.soundPlayer.OnClick()
    }
    this.thumb.OnPress(pressed)
};
Slider.prototype.Autocomplete = function() {
    if (this.autocomplete)
        if (this.type == SliderType.Bool) {
            var targetValue = this.internalValue >= .5 ? 1 : 0;
            var value = UHTMath.inverseLerp(this.thumb.localPositionLimitMin.x, this.thumb.localPositionLimitMax.x, this.thumb.target.localPosition().x);
            if (targetValue != value) {
                this.animator.manualTo = this.internalValue >= .5 ? this.thumb.localPositionLimitMax : this.thumb.localPositionLimitMin;
                this.animator.animationTime = this.animationTime * Math.abs(targetValue - value);
                this.animator.Play()
            }
        }
    this.autocompleteFrameCount =
        Time.frameCount
};
Slider.prototype.InverseAutocomplete = function() {
    if (this.autocomplete && this.autocompleteFrameCount != Time.frameCount)
        if (this.type == SliderType.Bool) {
            var targetValue = this.internalValue >= .5 ? 0 : 1;
            var value = UHTMath.inverseLerp(this.thumb.localPositionLimitMin.x, this.thumb.localPositionLimitMax.x, this.thumb.target.localPosition().x);
            if (targetValue != value) {
                this.animator.manualTo = targetValue == 1 ? this.thumb.localPositionLimitMax : this.thumb.localPositionLimitMin;
                this.animator.animationTime = this.inverseAnimationTime * Math.abs(targetValue -
                    value);
                this.animator.Play()
            }
        }
};
goog.require("UHT.AutoplayControllerMobile");
AutoplayControllerMobileV10.prototype = Object.create(AutoplayControllerMobile.prototype);
AutoplayControllerMobileV10.prototype.constructor = AutoplayControllerMobileV10;

function AutoplayControllerMobileV10() {
    AutoplayControllerMobile.call(this);
    this.sliderSpins = null
}
AutoplayControllerMobileV10.prototype.ShowAutoplayWindow = function() {
    AutoplayControllerMobile.prototype.ShowAutoplayWindow.call(this);
    this.sliderSpins.SetValueIndex(5);
    this.SliderValueChanged()
};
AutoplayControllerMobileV10.prototype.UpdateAutoplaySelectionButtons = function() {
    var beStartAutoplay = this.startAutoplayButton.GetComponent(ButtonEnabler);
    var i;
    var beQuickStartAutoplay = [];
    for (i = 0; i < this.quickStartAutoplayButtons.length; i++) beQuickStartAutoplay.push(this.quickStartAutoplayButtons[i].GetComponent(ButtonEnabler));
    if (!this.autoplayStartAllowed) {
        beStartAutoplay.DisableButton();
        for (i = 0; i < beQuickStartAutoplay.length; i++) beQuickStartAutoplay[i].DisableButton();
        return
    }
    beStartAutoplay.EnableButton();
    for (i = 0; i < beQuickStartAutoplay.length; i++) beQuickStartAutoplay[i].EnableButton()
};
AutoplayControllerMobileV10.prototype.UpdateAutoplayContent = function() {
    this.UpdateAutoplaySelectionButtons();
    this.SetNumberOfAutoSpins()
};
AutoplayControllerMobileV10.prototype.SliderValueChanged = function() {
    var currIndex = this.sliderSpins.valueIndex;
    XT.SetInt(InterfaceVars.SelectedAutoSpinsIndex, currIndex);
    this.SetNumberOfAutoSpins()
};
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
AutoplayTypeSwitcher.prototype = Object.create(XTLink.prototype);
AutoplayTypeSwitcher.prototype.constructor = AutoplayTypeSwitcher;

function AutoplayTypeSwitcher() {
    XTLink.call(this);
    this.simpleAutoplay = null;
    this.advancedAutoplay = null;
    this.isAllowed = true;
    this.isAdvanced = false
}
AutoplayTypeSwitcher.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.HasAdvancedAutoplay, this.OnAdvancedAutoplay, this);
    XT.RegisterCallbackBool(Vars.Jurisdiction_DisableAutoplay, this.OnDisableAutoplay, this);
    XT.RegisterCallbackBool(Vars.Jurisdiction_Autoplay_StopOnFeatureWin, this.HideStopOnFeatureWin, this);
    XT.RegisterCallbackBool(Vars.Jurisdiction_Autoplay_NoSkipScreens, this.HideSkipScreens, this)
};
AutoplayTypeSwitcher.prototype.OnAdvancedAutoplay = function(param) {
    this.isAdvanced = param;
    this.DoIt()
};
AutoplayTypeSwitcher.prototype.OnDisableAutoplay = function(param) {
    this.isAllowed = !param;
    this.DoIt()
};
AutoplayTypeSwitcher.prototype.DoIt = function() {
    this.simpleAutoplay.SetActive(!this.isAdvanced && this.isAllowed);
    this.advancedAutoplay.SetActive(this.isAdvanced && this.isAllowed)
};
AutoplayTypeSwitcher.prototype.HideStopOnFeatureWin = function(param) {
    if (param) {
        var paths = ["UI Root/XTRoot/Root/GUI/Interface/Windows/AutoplayAnimator/AutoplayWindow/AdvanceAutoplayWindow/StopAutoplay/Checkboxes/IfFeatureIsWon", "UI Root/XTRoot/Root/GUI_mobile/Interface_Landscape/ContentInterface/Windows/AdvanceAutoplayAnimator/AdvanceAutoplayWindow/StopAutoplay/Checkboxes/IfFeatureIsWon", "UI Root/XTRoot/Root/GUI_mobile/Interface_Portrait/ContentInterface/Windows/AdvanceAutoplayAnimator/AdvanceAutoplayWindow/Clipped/Content/StopAutoplay/Checkboxes/IfFeatureIsWon",
            "UI Root/XTRoot/Root/GUI_mobile/Interface_Portrait/ContentInterface/Windows/AdvanceAutoplayWindow/CheckBoxes/Left/IfFeatureIsWon"
        ];
        this.HideObjects(paths)
    }
};
AutoplayTypeSwitcher.prototype.HideSkipScreens = function(param) {
    if (param) {
        var paths = ["UI Root/XTRoot/Root/GUI/Interface/Windows/AutoplayAnimator/AutoplayWindow/AutoplaySimpleWindow/Content/Checkboxes/SkipScreens", "UI Root/XTRoot/Root/GUI/Interface/Windows/AutoplayAnimator/AutoplayWindow/AdvanceAutoplayWindow/Checkboxes/SkipScreens", "UI Root/XTRoot/Root/GUI_mobile/Interface_Landscape/ContentInterface/Windows/AutoplaySimpleWindow/Content/Checkboxes/SkipScreens", "UI Root/XTRoot/Root/GUI_mobile/Interface_Landscape/ContentInterface/Windows/AdvanceAutoplayAnimator/AdvanceAutoplayWindow/Checkboxes/SkipScreens",
            "UI Root/XTRoot/Root/GUI_mobile/Interface_Portrait/ContentInterface/Windows/AutoplaySimpleWindow/Content/Checkboxes/SkipScreens", "UI Root/XTRoot/Root/GUI_mobile/Interface_Portrait/ContentInterface/Windows/AdvanceAutoplayAnimator/AdvanceAutoplayWindow/Clipped/Content/Checkboxes/SkipScreens", "UI Root/XTRoot/Root/GUI_mobile/Interface_Portrait/ContentInterface/Windows/AutoplaySimpleWindow/Content/SkipScreens", "UI Root/XTRoot/Root/GUI_mobile/Interface_Portrait/ContentInterface/Windows/AdvanceAutoplayWindow/SkipScreens"
        ];
        this.HideObjects(paths)
    }
};
AutoplayTypeSwitcher.prototype.HideObjects = function(paths) {
    var roots = globalRuntime.sceneRoots;
    var localizationRoot = roots[1].transform.GetComponentsInChildren(LocalizationRoot, true)[0].transform;
    for (var r = 0; r < roots.length; ++r)
        for (var i = 0; i < paths.length; ++i) {
            var t = roots[r].transform.Find(paths[i]);
            if (t != null) t.gameObject.SetActive(false);
            else {
                var temp = paths[i].split("/");
                var newPath = "";
                for (var j = 3; j < temp.length; j++) newPath += temp[j] + (j < temp.length - 1 ? "/" : "");
                t = localizationRoot.Find(newPath);
                if (t != null) t.gameObject.SetActive(false);
                else console.log("Couldn't find object at path: " + paths[i])
            }
        }
};
goog.require("UHT.XTLink");
SpinButtonPositionController.prototype = Object.create(XTLink.prototype);
SpinButtonPositionController.prototype.constructor = SpinButtonPositionController;

function SpinButtonPositionController() {
    XTLink.call(this);
    this.dragObject = null;
    this.colliderProxy = null;
    this.buttonVisual = null;
    this.draggables = null;
    this.obstacles = null;
    this.catDragStart = null;
    this.catDragEnd = null;
    this.catCollision = null;
    this.catNoCollision = null;
    this.resetCollider = null;
    this.catCollisionReset = null;
    this.catNoCollisionReset = null;
    this.isLandscape = false;
    this.defaultLocalPosition = null;
    this.numberError = .001;
    this.parent = null;
    this.source = null;
    this.sourceCollider = null;
    this.snapPos = null;
    this.prevLocalPos =
        null;
    this.UL = null;
    this.DR = null;
    this.localUL = null;
    this.localDR = null;
    this.isDragStarted = false;
    this.isDragEnded = false;
    this.isInit = false;
    this.mustReset = false;
    this.isGameInit = false;
    this.testScreenAttemptsLeft = 3
}
SpinButtonPositionController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    if (this.isLandscape) XT.RegisterCallbackEvent(InterfaceVars.Evt_DataToCode_ToggleSpinButtonPositionLocked, this.OnToggleSpinButtonPositionLocked, this)
};
SpinButtonPositionController.prototype.OnToggleSpinButtonPositionLocked = function() {
    XT.SetBool(InterfaceVars.SpinButtonPositionLocked, !XT.GetBool(InterfaceVars.SpinButtonPositionLocked));
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
};
SpinButtonPositionController.prototype.Init = function() {
    this.isInit = true;
    this.dragObject.limitPosition = true;
    this.source = this.dragObject.target;
    this.sourceCollider = this.source.gameObject.GetComponent(Collider);
    this.parent = this.source.parent;
    this.snapPos = this.source.position();
    this.prevLocalPos = this.source.localPosition()
};
SpinButtonPositionController.prototype.OnGameInit = function() {
    this.isGameInit = true;
    var oZ = this.defaultLocalPosition.z;
    this.gameObject.transform.position(this.draggables[0].position());
    var p = this.gameObject.transform.localPosition();
    this.gameObject.transform.localPosition(p.x, p.y, oZ);
    this.defaultLocalPosition = this.gameObject.transform.localPosition()
};
SpinButtonPositionController.prototype.OnGameInitInternal = function() {
    if (!this.isInit) this.Init();
    var setting = XT.GetObject(this.isLandscape ? InterfaceVars.SpinButtonPositionLandscape : InterfaceVars.SpinButtonPositionPortrait);
    if (setting == null) return;
    var settingsPos = setting;
    this.prevLocalPos = this.source.localPosition();
    this.source.position(new UHTMath.Vector3(settingsPos.x, settingsPos.y, this.source.position().z));
    var mustReset = false;
    if (!this.TestScreen()) {
        if (--this.testScreenAttemptsLeft > 0) return;
        mustReset =
            true
    }
    if (this.TestCollision() != null) mustReset = true;
    if (mustReset) {
        this.source.localPosition(this.prevLocalPos);
        return
    }
    this.testScreenAttemptsLeft = 0;
    this.snapPos = this.source.position();
    this.prevLocalPos = this.source.localPosition();
    for (var i = 0; i < this.draggables.length; ++i) this.draggables[i].position(new UHTMath.Vector3(this.snapPos.x, this.snapPos.y, this.draggables[i].position().z))
};
SpinButtonPositionController.prototype.LateUpdate = function() {
    if (!this.isInit) this.Init();
    if (this.isDragEnded) {
        this.isDragEnded = false;
        this.colliderProxy.SetEnabled(true)
    }
    if (!this.VectorsEqual(GUIArranger.I.screenAnchorUpLeft.transform.position(), this.UL) || !this.VectorsEqual(GUIArranger.I.screenAnchorDownRight.transform.position(), this.DR)) {
        this.UL = GUIArranger.I.screenAnchorUpLeft.transform.position();
        this.DR = GUIArranger.I.screenAnchorDownRight.transform.position();
        if (XT.GetBool(InterfaceVars.LimitSpinButtonPositionByGameAnchors)) {
            var gUL =
                GUIArranger.I.gameAnchorUpLeft.transform.position();
            var gDR = GUIArranger.I.gameAnchorDownRight.transform.position();
            this.UL = new UHTMath.Vector3(Math.max(this.UL.x, gUL.x), Math.min(this.UL.y, gUL.y), this.UL.z);
            this.DR = new UHTMath.Vector3(Math.min(this.DR.x, gDR.x), Math.max(this.DR.y, gDR.y), this.DR.z)
        }
        this.localUL = this.parent.inverseTransformPoint(this.UL);
        this.localDR = this.parent.inverseTransformPoint(this.DR);
        var dUL = UHTMath.Vector3.sub(this.localUL, this.sourceCollider.center);
        var dDR = UHTMath.Vector3.sub(this.localDR,
            this.sourceCollider.center);
        var z = this.source.localPosition().z;
        this.dragObject.localPositionLimitMin = new UHTMath.Vector3(dUL.x + this.sourceCollider.size.x, dDR.y + this.sourceCollider.size.y, z);
        this.dragObject.localPositionLimitMax = new UHTMath.Vector3(dDR.x - this.sourceCollider.size.x, dUL.y - this.sourceCollider.size.y, z)
    }
    if (this.isGameInit && this.testScreenAttemptsLeft > 0) this.OnGameInitInternal();
    var isEnabled = false;
    for (var i = 0; i < this.draggables.length; ++i)
        if (this.draggables[i].gameObject.activeInHierarchy) {
            isEnabled =
                true;
            break
        }
    isEnabled = isEnabled && !XT.GetBool(InterfaceVars.SpinButtonPositionLocked);
    this.sourceCollider.enabled = isEnabled;
    if (!isEnabled) return;
    var localPos = this.source.localPosition();
    if (!this.VectorsEqual(localPos, this.prevLocalPos)) {
        var obstacle = this.TestCollision();
        if (obstacle == null) this.snapPos = this.source.position();
        this.mustReset = obstacle == this.resetCollider;
        (this.mustReset ? this.catCollisionReset : this.catNoCollisionReset).Start();
        (obstacle == null ? this.catNoCollision : this.catCollision).Start();
        this.buttonVisual.transform.position(this.snapPos);
        this.prevLocalPos = localPos
    }
};
SpinButtonPositionController.prototype.TestCollision = function() {
    var center = UHTMath.Vector3.add(this.source.localPosition(), this.sourceCollider.center);
    for (var i = 0; i < this.obstacles.length; ++i)
        if (this.obstacles[i].isSphere && this.CollidesCircle(center, this.obstacles[i]) || !this.obstacles[i].isSphere && this.CollidesBox(this.obstacles[i])) return this.obstacles[i];
    return null
};
SpinButtonPositionController.prototype.VectorsEqual = function(a, b) {
    if (a == null || b == null) return a == b;
    return Math.abs(a.x - b.x) < this.numberError && Math.abs(a.y - b.y) < this.numberError && Math.abs(a.z - b.z) < this.numberError
};
SpinButtonPositionController.prototype.CollidesCircle = function(centerA, b) {
    var centerB = UHTMath.Vector3.add(this.parent.inverseTransformPoint(b.gameObject.transform.position()), b.center);
    return UHTMath.Vector3.distance(centerA, centerB) <= this.sourceCollider.size.x + b.size.x
};
SpinButtonPositionController.prototype.CollidesBox = function(b) {
    var centerA = b.transform.inverseTransformPoint(this.parent.transformPoint(UHTMath.Vector3.add(this.source.localPosition(), this.sourceCollider.center)));
    var centerB = UHTMath.Vector3.sub(b.center, UHTMath.Vector3.scale(b.size, .5));
    var deltaX = centerA.x - Math.max(centerB.x, Math.min(centerA.x, centerB.x + b.size.x));
    var deltaY = centerA.y - Math.max(centerB.y, Math.min(centerA.y, centerB.y + b.size.y));
    return deltaX * deltaX + deltaY * deltaY <= this.sourceCollider.size.x *
        this.sourceCollider.size.x
};
SpinButtonPositionController.prototype.TestScreen = function() {
    var center = UHTMath.Vector3.add(this.source.localPosition(), this.sourceCollider.center);
    return !(center.x - this.sourceCollider.size.x < this.localUL.x || center.x + this.sourceCollider.size.x > this.localDR.x || center.y + this.sourceCollider.size.x > this.localUL.y || center.y - this.sourceCollider.size.x < this.localDR.y)
};
SpinButtonPositionController.prototype.DragStarted = function() {
    this.isDragStarted = true;
    this.catDragStart.Start();
    this.colliderProxy.SetEnabled(false)
};
SpinButtonPositionController.prototype.DragEnded = function() {
    if (!this.isDragStarted) return;
    if (this.mustReset) this.snapPos = this.parent.transformPoint(this.defaultLocalPosition);
    this.catDragEnd.Start();
    this.source.position(this.snapPos);
    for (var i = 0; i < this.draggables.length; ++i) {
        this.draggables[i].position(new UHTMath.Vector3(this.snapPos.x, this.snapPos.y, this.draggables[i].position().z));
        var sprites = this.draggables[i].GetComponentsInChildren(UISprite, true);
        for (var j = 0; j < sprites.length; ++j) sprites[j].OnWillRenderObject()
    }
    XT.SetObject(this.isLandscape ?
        InterfaceVars.SpinButtonPositionLandscape : InterfaceVars.SpinButtonPositionPortrait, this.mustReset ? null : this.snapPos);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer);
    this.isDragStarted = false;
    this.isDragEnded = true;
    this.mustReset = false
};
SpinButtonPositionController.prototype.OnDisable = function() {
    this.DragEnded()
};
goog.require("UHT.Engine");
MultipleLabelAnchor.prototype = Object.create(Component.prototype);
MultipleLabelAnchor.prototype.constructor = MultipleLabelAnchor;

function MultipleLabelAnchor() {
    Component.call(this);
    this.labels = null;
    this.spacing = 0;
    this.alignment = MultipleLabelAnchor.Alignment.Right;
    this.maxWidth = 0;
    this.ignoreInactiveLabels = false;
    this.ignoreLabelsScale = false;
    this.anyPivots = false;
    this.scaleY = true;
    this.cachedLabelWidths = [];
    this.cachedActiveState = [];
    this.mustForcedNextUpdate = false;
    this.initialScale = null;
    this.isStarted = false;
    this.width = 0
}
MultipleLabelAnchor.prototype.scriptUpdatePriority = 8;
MultipleLabelAnchor.Alignment = {
    Right: 0,
    Left: 1,
    Center: 2
};
MultipleLabelAnchor.pivotLeft = 0;
MultipleLabelAnchor.pivotCenter = .5;
MultipleLabelAnchor.pivotRight = 1;
MultipleLabelAnchor.prototype.IsPivot = function(pivot, value) {
    return Math.abs(pivot - value) < .1
};
MultipleLabelAnchor.prototype.Start = function() {
    if (this.isStarted) return;
    this.isStarted = true;
    this.initialScale = this.gameObject.transform.localScale();
    for (var i = 0; i < this.labels.length; i++) {
        this.cachedLabelWidths.push(-69);
        this.cachedActiveState.push(false)
    }
};
MultipleLabelAnchor.prototype.Update = function() {
    this.Start();
    var i = 0;
    var needUpdate = false;
    for (i = 0; i < this.labels.length; i++) {
        var w = this.GetLabelWidth(this.labels[i]);
        if (w != this.cachedLabelWidths[i] || this.ignoreInactiveLabels && this.labels[i].gameObject.activeInHierarchy != this.cachedActiveState[i]) {
            this.cachedLabelWidths[i] = w;
            this.cachedActiveState[i] = this.labels[i].gameObject.activeInHierarchy;
            needUpdate = true
        }
    }
    if (needUpdate || this.mustForcedNextUpdate) {
        this.mustForcedNextUpdate = false;
        var offset = 0;
        var p;
        for (i = 0; i < this.labels.length; i++) {
            if (this.ignoreInactiveLabels && this.cachedActiveState[i] == false) continue;
            var x = (this.alignment == MultipleLabelAnchor.Alignment.Left ? -1 : 1) * offset;
            p = this.labels[i].gameObject.transform.localPosition();
            this.labels[i].gameObject.transform.localPosition(x, p.y, p.z);
            offset += this.cachedLabelWidths[i] + this.spacing
        }
        var size = offset - this.spacing;
        if (this.alignment == MultipleLabelAnchor.Alignment.Center) {
            var halfSize = size / 2;
            for (i = 0; i < this.labels.length; i++) {
                if (this.ignoreInactiveLabels &&
                    this.cachedActiveState[i] == false) continue;
                var xOffset = this.labels[i].gameObject.transform.localPosition().x - halfSize;
                p = this.labels[i].gameObject.transform.localPosition();
                this.labels[i].gameObject.transform.localPosition(xOffset, p.y, p.z)
            }
        }
        if (this.anyPivots)
            for (i = 0; i < this.labels.length; i++) {
                if (this.ignoreInactiveLabels && this.cachedActiveState[i] == false) continue;
                if (this.alignment == MultipleLabelAnchor.Alignment.Center || this.alignment == MultipleLabelAnchor.Alignment.Right)
                    if (this.IsPivot(MultipleLabelAnchor.pivotCenter,
                            this.labels[i].anchorX)) {
                        p = this.labels[i].gameObject.transform.localPosition();
                        this.labels[i].gameObject.transform.localPosition(p.x + this.GetLabelWidth(this.labels[i]) * .5, p.y, p.z)
                    } else {
                        if (this.IsPivot(MultipleLabelAnchor.pivotRight, this.labels[i].anchorX)) {
                            p = this.labels[i].gameObject.transform.localPosition();
                            this.labels[i].gameObject.transform.localPosition(p.x + this.GetLabelWidth(this.labels[i]), p.y, p.z)
                        }
                    }
                else if (this.IsPivot(MultipleLabelAnchor.pivotCenter, this.labels[i].anchorX)) {
                    p = this.labels[i].gameObject.transform.localPosition();
                    this.labels[i].gameObject.transform.localPosition(p.x - this.GetLabelWidth(this.labels[i]) * .5, p.y, p.z)
                } else if (this.IsPivot(MultipleLabelAnchor.pivotLeft, this.labels[i].anchorX)) {
                    p = this.labels[i].gameObject.transform.localPosition();
                    this.labels[i].gameObject.transform.localPosition(p.x - this.GetLabelWidth(this.labels[i]), p.y, p.z)
                }
            }
        if (this.maxWidth > 0 && size > this.maxWidth) {
            var scale = this.maxWidth / size;
            this.gameObject.transform.localScale(scale, this.scaleY ? scale : this.initialScale.y, this.initialScale.z)
        } else this.gameObject.transform.localScale(this.initialScale);
        this.width = size
    }
};
MultipleLabelAnchor.prototype.GetLabelWidth = function(label) {
    return this.ignoreLabelsScale ? label.GetWidth() : Math.round(label.GetWidth() * label.transform.localScale().x)
};
MultipleLabelAnchor.prototype.ForceNextUpdate = function() {
    this.mustForcedNextUpdate = true
};
MultipleLabelAnchor.prototype.DiscardCache = function() {
    this.cachedLabelWidths.splice(0);
    this.cachedActiveState.splice(0);
    for (var i = 0; i < this.labels.length; i++) {
        this.cachedLabelWidths.push(-69);
        this.cachedActiveState.push(false)
    }
};
goog.require("UHT.Engine");
LabelGroupScaler.prototype = Object.create(Component.prototype);
LabelGroupScaler.prototype.constructor = LabelGroupScaler;

function LabelGroupScaler() {
    Component.call(this);
    this.target = null;
    this.sources = null
}
LabelGroupScaler.prototype.Update = function() {
    var minScale = this.sources[0].localScale().x;
    for (var i = 1; i < this.sources.length; ++i)
        if (this.sources[i].localScale().x < minScale) minScale = this.sources[i].localScale().x;
    if (minScale != this.target.GetNormalizedTime()) this.target.Sample(UHTMath.clamp(minScale, 0, 1))
};
goog.require("UHT.XTLink");
CoinsSwitcher.prototype = Object.create(XTLink.prototype);
CoinsSwitcher.prototype.constructor = CoinsSwitcher;

function CoinsSwitcher() {
    XTLink.call(this)
}
CoinsSwitcher.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.FromServer_AllowCoins, this.OnAllowCoinsChanged, this)
};
CoinsSwitcher.prototype.OnAllowCoinsChanged = function(allow) {
    this.gameObject.GetComponent(Collider).enabled = allow
};
CoinsSwitcher.prototype.OnPress = function(isPressed) {
    if (isPressed) {
        XT.SetBool(Vars.HasCoins, !XT.GetBool(Vars.HasCoins));
        XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
        XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
    }
};
goog.provide("UHT.GUIMessageBase");
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
GUIMessageBase.prototype = Object.create(XTLink.prototype);
GUIMessageBase.prototype.constructor = GUIMessageBase;

function GUIMessageBase() {
    XTLink.call(this);
    this.label = null;
    this.messages = null
}
GUIMessageBase.prototype.Init = function(texts) {
    this.messages = texts
};
GUIMessageBase.prototype.Show = function() {
    if (this.messages != null && this.messages.length > 0) {
        var i = Random.Range(0, this.messages.length);
        this.label.text = this.messages[i]
    }
    this.gameObject.SetActive(true)
};
GUIMessageBase.prototype.Hide = function() {
    this.gameObject.SetActive(false)
};
goog.require("UHT.Engine");
goog.require("UHT.GUIMessageBase");
GUIMessageSpin.prototype = Object.create(GUIMessageBase.prototype);
GUIMessageSpin.prototype.constructor = GUIMessageSpin;

function GUIMessageSpin() {
    GUIMessageBase.call(this);
    this.localized_TapToStopLabel = null
}
GUIMessageSpin.randomMessagesBetweenTapStopMessage = 0;
GUIMessageSpin.prototype.Show = function() {
    XT.UnregisterCallbackEvent(this.OnPressedStop, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_Stop, this.OnPressedStop, this);
    var jurisdictionConstraint = XT.GetBool(Vars.Jurisdiction_SpinLimit) || XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins);
    var ok = false;
    if (XT.GetInt(Vars.MobileTapToStopMessageShowCount) <= 2 && (GUIMessageSpin.randomMessagesBetweenTapStopMessage | 0) % 3 == 0 && !jurisdictionConstraint) {
        GUIMessageSpin.randomMessagesBetweenTapStopMessage++;
        this.label.text = this.localized_TapToStopLabel.text;
        ok = true
    }
    if (!ok && this.messages != null && this.messages.length > 0) {
        var i = Random.Range(0, this.messages.length);
        this.label.text = this.messages[i];
        GUIMessageSpin.randomMessagesBetweenTapStopMessage++
    }
    this.gameObject.SetActive(true)
};
GUIMessageSpin.prototype.OnPressedStop = function() {
    XT.SetInt(Vars.MobileTapToStopMessageShowCount, XT.GetInt(Vars.MobileTapToStopMessageShowCount) + 1);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
};
GUIMessageSpin.prototype.Hide = function() {
    XT.UnregisterCallbackEvent(this.OnPressedStop, this);
    this.gameObject.SetActive(false)
};
goog.require("UHT.Engine");
goog.require("UHT.GUIMessageBase");
var GUIMessageResultWinVars = {
    GUIMessageResultWin_ForceGamePaysMessage: "GUIMessageResultWin_ForceGamePaysMessage",
    GUIMessageResultWin_ShouldForceGamePaysValue: "GUIMessageResultWin_ShouldForceGamePaysValue",
    GUIMessageResultWin_ForcedGamePaysValue: "GUIMessageResultWin_ForcedGamePaysValue"
};
var CustomMessageShowRule = {
    Always: 0,
    Once: 1
};
GUIMessageResultWin.prototype = Object.create(GUIMessageBase.prototype);
GUIMessageResultWin.prototype.constructor = GUIMessageResultWin;

function GUIMessageResultWin() {
    GUIMessageBase.call(this);
    this.labelCentered = null;
    this.labelCustom = null;
    this.winLineDisplayer = null;
    this.currentTotalWin = null;
    this.localized_GamePays = null;
    this.localized_WinTeasers = null;
    this.localized_Pays = null;
    this.localized_Line = null;
    this.localized_On = null;
    this.localized_Ways = null;
    this.localized_WordsOrder = null;
    this.label_FSWon = null;
    this.label_BonusWon = null;
    this.forceWinLineHasCoins = false;
    this.forceWinLineHasCash = false;
    this.catShowAllLines = null;
    this.catHideAllLines =
        null;
    this.orderedJPText = ["MINI JACKPOT", "MINOR JACKPOT", "MAJOR JACKPOT", "GRAND JACKPOT"];
    this.singleJPText = "JACKPOT";
    this.curWinDesc = [];
    this.settings = null;
    this.receivedWinLines = null;
    this.isBonusWon = false;
    this.isFSWon = false;
    this.isCentered = false;
    this.formatOptions = null;
    this.payingSymbolsDesc = [];
    this.jackpotText = "";
    this.gamePaysText = "";
    this.canShowGamePaysAsWinTeaser = false;
    this.allLinesShownCounter = 0
}
GUIMessageResultWin.prototype.XTRegisterCallbacks = function() {};
GUIMessageResultWin.prototype.XTInitVariablesAndEvents = function() {
    XT.SetInt(InterfaceVars.ExtraWinMultiplier, 1);
    XT.SetBool(GUIMessageResultWinVars.GUIMessageResultWin_ForceGamePaysMessage, false);
    XT.SetBool(GUIMessageResultWinVars.GUIMessageResultWin_ShouldForceGamePaysValue, false);
    XT.SetDouble(GUIMessageResultWinVars.GUIMessageResultWin_ForcedGamePaysValue, 0);
    XT.SetBool(InterfaceVars.ShowInterfaceThumbnailsCount, false);
    XT.SetObject(InterfaceVars.CustomMessage, null);
    XT.SetObject(InterfaceVars.AllLinesMessageCustom,
        null);
    XT.SetInt(InterfaceVars.AllLinesMessageCustomRule, CustomMessageShowRule.Once)
};
GUIMessageResultWin.prototype.OnDestroy = function() {};
GUIMessageResultWin.prototype.OnDisable = function() {
    this.Hide()
};
GUIMessageResultWin.prototype.SetSpecialFlags = function(bonusWon, FSWon) {
    this.isBonusWon = bonusWon;
    this.isFSWon = FSWon;
    this.isCentered = !this.isBonusWon && !this.isFSWon
};
GUIMessageResultWin.prototype.Show = function() {
    this.Hide();
    XT.RegisterCallbackEvent(InterfaceVars.ShowCustomMessage, this.OnShowCustomMessage, this);
    XT.RegisterCallbackEvent(InterfaceVars.HideCustomMessage, this.OnHideCustomMessage, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StartDisplayWinLine, this.OnWinLineShow, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StopDisplayWinLine, this.OnWinLineHide, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowAllLinesWin, this.OnAllLinesShow, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_HideAllLinesWin,
        this.OnAllLinesHide, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowJackpotWin, this.OnJackpotShow, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_HideJackpotWin, this.OnAllLinesHide, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowScattersWin, this.OnScattersWinShow, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_HideScattersWin, this.OnWinLineHide, this);
    XT.RegisterCallbackEvent(PayingSymbolVars.Evt_Internal_ShowPayingSymbol, this.OnPayingSymbolShow, this);
    XT.RegisterCallbackEvent(PayingSymbolVars.Evt_Internal_HidePayingSymbol,
        this.OnWinLineHide, this);
    this.gameObject.SetActive(true);
    this.settings = XT.GetObject(InterfaceVars.GUIMessageZoneSettings);
    this.Prepare();
    if (this.isBonusWon) this.label_BonusWon.gameObject.SetActive(true);
    else if (this.isFSWon) this.label_FSWon.gameObject.SetActive(true)
};
GUIMessageResultWin.prototype.Hide = function() {
    XT.UnregisterCallbackEvent(this.OnShowCustomMessage, this, InterfaceVars.ShowCustomMessage);
    XT.UnregisterCallbackEvent(this.OnHideCustomMessage, this, InterfaceVars.HideCustomMessage);
    XT.UnregisterCallbackEvent(this.OnWinLineShow, this);
    XT.UnregisterCallbackEvent(this.OnWinLineHide, this);
    XT.UnregisterCallbackEvent(this.OnAllLinesShow, this);
    XT.UnregisterCallbackEvent(this.OnAllLinesHide, this);
    XT.UnregisterCallbackEvent(this.OnJackpotShow, this);
    XT.UnregisterCallbackEvent(this.OnScattersWinShow,
        this);
    XT.UnregisterCallbackEvent(this.OnPayingSymbolShow, this);
    this.label_BonusWon.gameObject.SetActive(false);
    this.label_FSWon.gameObject.SetActive(false);
    this.winLineDisplayer.HideWinLine();
    this.label.gameObject.SetActive(false);
    this.labelCentered.gameObject.SetActive(false);
    this.labelCustom.gameObject.SetActive(false);
    this.gameObject.SetActive(false);
    this.allLinesShownCounter = 0
};
GUIMessageResultWin.prototype.Prepare = function() {
    var screenSymbols = XT.GetObject(Vars.ResultScreenSymbols);
    var numberOfReels = screenSymbols.length;
    var numberOfSymbolsPerReel = screenSymbols[0].length;
    this.curWinDesc.splice(0);
    this.receivedWinLines = XT.GetObject(Vars.ReceivedWinLines);
    for (var i = 0; i < this.receivedWinLines.length; i++) {
        var l = this.receivedWinLines[i];
        var desc;
        if (l.isWinWaysGroup) {
            desc = this.ComputeWinGroupDesc(l.symbolId, l.waysLength, l.WinPositions);
            desc.text = this.ComputeWinGroupText(l.WinAmount,
                false, l.Multiplier, l.waysCount)
        } else {
            desc = this.ComputeWinLineDesc(screenSymbols, numberOfReels, numberOfSymbolsPerReel, l.WinPositions);
            desc.text = this.ComputeWinLineText(l.WinAmount, false, l.Multiplier, l.LineNumber)
        }
        this.curWinDesc.push(desc)
    }
    this.payingSymbolsDesc.splice(0);
    var payingSymbols = XT.GetObject(PayingSymbolVars.PayingSymbols);
    for (var i = 0; i < payingSymbols.length; ++i) {
        var s = payingSymbols[i];
        var forcedID = XT.GetBool(InterfaceVars.PayingSymbolsDisplayServerID) ? s.id : -1;
        var desc = this.ComputeWinLineDesc(screenSymbols,
            numberOfReels, numberOfSymbolsPerReel, s.positions, forcedID);
        desc.text = this.ComputeWinLineText(s.amount, true, 1, -1);
        this.payingSymbolsDesc.push(desc)
    }
    this.gamePaysText = "";
    var win = VSGameStateManager.GetState() == VSGameState.ResultFreeSpins ? XT.GetDouble(Vars.FreeSpinsLastWinDisplayed) : XT.GetDouble(Vars.WinDisplayed);
    if (XT.GetBool(GUIMessageResultWinVars.GUIMessageResultWin_ShouldForceGamePaysValue)) win = XT.GetDouble(GUIMessageResultWinVars.GUIMessageResultWin_ForcedGamePaysValue);
    this.canShowGamePaysAsWinTeaser =
        win != XT.GetDouble(Vars.SpinCycleWinDisplayed);
    if (win > 1E-4) this.gamePaysText = this.ComputeText(win, null, this.localized_GamePays.text, false);
    this.jackpotText = "";
    if (ResultDisplayer.isJackpotWin) {
        var jpInfo = XT.GetObject(Vars.FromServer_LastValidJackpotsInformation);
        var text;
        if (jpInfo == null || jpInfo.length == 1 && jpInfo[0].JackpotGroupType == "S") text = this.singleJPText;
        else text = this.orderedJPText[XT.GetInt(Vars.FromServer_JackpotWonOrder)];
        this.jackpotText = this.ComputeText(XT.GetDouble(Vars.FromServer_JackpotAmountWon),
            null, text, true)
    }
    this.winLineDisplayer.targetLabel.fontName = this.localized_Pays.fontName;
    this.winLineDisplayer.targetLabel.fontNameExpectedFromCallback = this.winLineDisplayer.targetLabel.fontName
};
GUIMessageResultWin.prototype.ComputeWinGroupDesc = function(symbolId, waysLength, winPositions) {
    var desc = new WinLineDesc;
    desc.spacing = this.settings.GetSpacing();
    desc.spacingExtraLabel = this.settings.GetSpacingExtraLabel();
    desc.thumbnailSize = this.settings.GetThumbnailSize();
    var thumbnail = this.settings.GetThumbnail(symbolId);
    if (thumbnail != null)
        for (var i = 0; i < waysLength; i++) {
            desc.atlases.push(thumbnail.atlas);
            desc.spriteNames.push(thumbnail.sprite);
            desc.depths.push(thumbnail.depth);
            if (XT.GetBool(InterfaceVars.ShowInterfaceThumbnailsCount) ||
                waysLength > this.winLineDisplayer.symbolSprites.length) {
                desc.prefixText = winPositions.length + "X";
                break
            }
        }
    return desc
};
GUIMessageResultWin.prototype.ComputeWinLineDesc = function(screenSymbols, numberOfReels, numberOfSymbolsPerReel, positions, forcedSymbolID) {
    if (forcedSymbolID == undefined) forcedSymbolID = -1;
    var desc = new WinLineDesc;
    desc.spacing = this.settings.GetSpacing();
    desc.spacingExtraLabel = this.settings.GetSpacingExtraLabel();
    desc.thumbnailSize = this.settings.GetThumbnailSize();
    for (var i = 0; i < positions.length; i++) {
        var symbolPos = positions[i];
        var symbolId = forcedSymbolID >= 0 ? forcedSymbolID : screenSymbols[symbolPos % numberOfReels][numberOfSymbolsPerReel -
            1 - (symbolPos / numberOfReels | 0)
        ];
        var thumbnail = this.settings.GetThumbnail(symbolId);
        if (thumbnail == null) continue;
        var spriteName = thumbnail.sprite + (XT.GetBool(Vars.HasReelAwareSymbolContent) ? "_" + symbolPos % numberOfReels : "");
        if (XT.GetBool(InterfaceVars.ShowInterfaceThumbnailsCount)) {
            if (symbolId != 2 || i + 1 == positions.length) {
                desc.prefixText = positions.length + "X";
                desc.atlases.push(thumbnail.atlas);
                desc.spriteNames.push(spriteName);
                desc.depths.push(thumbnail.depth);
                break
            }
        } else {
            desc.atlases.push(thumbnail.atlas);
            desc.spriteNames.push(spriteName);
            desc.depths.push(thumbnail.depth)
        }
    }
    return desc
};
GUIMessageResultWin.prototype.ComputeWinLineText = function(amount, premultiplied, multiplier, lineNumber) {
    var fsmultiplier = XT.GetDouble(Vars.CurrentWinMultiplier);
    var multipliers = [];
    multipliers.push(multiplier);
    multipliers.push(fsmultiplier);
    multipliers.push(XT.GetInt(InterfaceVars.ExtraWinMultiplier));
    var lineText = null;
    if (lineNumber > -1)
        if (XT.GetBool(Vars.GameHasWaysInsteadOfLines) == false || XT.GetBool(Vars.GameHasLinesWithBetMultiplier)) lineText = this.localized_Line.text + " " + (lineNumber + 1);
    return this.ComputeText(premultiplied ?
        amount : amount * fsmultiplier, multipliers, lineText, true)
};
GUIMessageResultWin.prototype.ComputeWinGroupText = function(amount, premultiplied, multiplier, noOfWays) {
    var fsmultiplier = XT.GetDouble(Vars.CurrentWinMultiplier);
    var multipliers = [];
    multipliers.push(multiplier);
    multipliers.push(fsmultiplier);
    multipliers.push(XT.GetInt(InterfaceVars.ExtraWinMultiplier));
    var computedText = this.localized_WordsOrder.text;
    var computedWinAmount = this.ComputeText(premultiplied ? amount : amount * fsmultiplier, multipliers, null, false);
    computedText = computedText.replace("<PAYS>", this.localized_Pays.text);
    computedText = computedText.replace("<$6>", computedWinAmount);
    if (noOfWays > 1) {
        computedText = computedText.replace("<ON>", this.localized_On.text);
        computedText = computedText.replace("<#9>", noOfWays.toString());
        computedText = computedText.replace("<WAYS>", this.localized_Ways.text)
    }
    return computedText
};
GUIMessageResultWin.prototype.WinLineHasCoins = function() {
    if (this.forceWinLineHasCash) return false;
    if (this.forceWinLineHasCoins) return true;
    return XT.GetBool(Vars.HasCoins)
};
GUIMessageResultWin.prototype.OnWinLineShow = function() {
    var lineIndex = XT.GetInt(Vars.CurrentDisplayedWinLineIndex);
    this.winLineDisplayer.ShowWinLine(this.curWinDesc[lineIndex], this.isCentered);
    this.label.gameObject.SetActive(false);
    this.labelCentered.gameObject.SetActive(false);
    this.labelCustom.gameObject.SetActive(false)
};
GUIMessageResultWin.prototype.OnWinLineHide = function() {
    this.winLineDisplayer.HideWinLine()
};
GUIMessageResultWin.prototype.OnAllLinesHide = function() {
    this.OnWinLineHide();
    this.HideLabel();
    if (this.catHideAllLines != null) this.catHideAllLines.Start()
};
GUIMessageResultWin.prototype.OnShowCustomMessage = function() {
    this.ShowCustomLabel(XT.GetObject(InterfaceVars.CustomMessage))
};
GUIMessageResultWin.prototype.OnHideCustomMessage = function() {
    this.labelCustom.gameObject.SetActive(false)
};
GUIMessageResultWin.prototype.ShowCustomLabel = function(lbl) {
    if (lbl != null) {
        this.labelCustom.SetColor(lbl.color);
        ModificationsManager.CopyFromLabelToLabel(lbl, this.labelCustom, true, true);
        this.labelCustom.gameObject.SetActive(true)
    }
};
GUIMessageResultWin.prototype.OnAllLinesShow = function() {
    var forceGamePays = XT.GetBool(GUIMessageResultWinVars.GUIMessageResultWin_ForceGamePaysMessage);
    var customLabel = XT.GetObject(InterfaceVars.AllLinesMessageCustom);
    var mustShowCustomMsg = false;
    if (customLabel != null) switch (XT.GetInt(InterfaceVars.AllLinesMessageCustomRule)) {
        case CustomMessageShowRule.Always:
            mustShowCustomMsg = true;
            break;
        case CustomMessageShowRule.Once:
            mustShowCustomMsg = this.allLinesShownCounter < 1;
            break
    }
    this.allLinesShownCounter++;
    if (mustShowCustomMsg) {
        this.ShowCustomLabel(customLabel);
        if (this.catShowAllLines != null) this.catShowAllLines.Start()
    } else if (this.receivedWinLines.length == 1 && !ResultDisplayer.isJackpotWin && !XT.GetBool(InterfaceVars.ShowGamePaysAsWinTeaser) && !forceGamePays && !XT.GetBool(InterfaceVars.ShowExplicitResult)) this.ShowWinLine(this.curWinDesc[0]);
    else {
        var text;
        this.winLineDisplayer.HideWinLine();
        if (XT.GetBool(Vars.LastWinIsCounting) && !forceGamePays) {
            var i = XT.GetInt(Vars.BigWinLevel);
            if (XT.GetObject(Vars.CoinCounterObject).BigWinSteps.length == 4 && i >= 3) i++;
            if (i == null ||
                i < 0 || i >= this.localized_WinTeasers.length) i = 0;
            if (XT.GetBool(InterfaceVars.ShowGamePaysAsWinTeaser) && this.canShowGamePaysAsWinTeaser) text = this.gamePaysText;
            else text = this.localized_WinTeasers[i].text
        } else text = this.gamePaysText;
        this.ShowLabel(text);
        if (this.catShowAllLines != null) this.catShowAllLines.Start()
    }
};
GUIMessageResultWin.prototype.OnJackpotShow = function() {
    this.ShowLabel(this.jackpotText)
};
GUIMessageResultWin.prototype.OnPayingSymbolShow = function() {
    this.ShowWinLine(this.payingSymbolsDesc[XT.GetInt(PayingSymbolVars.CurrentDisplayedPayingSymbolIndex)])
};
GUIMessageResultWin.prototype.OnScattersWinShow = function() {
    var idx = XT.GetInt(PayingSymbolVars.PayingSymbolsScatterIndex);
    if (idx > -1) this.ShowWinLine(this.payingSymbolsDesc[idx])
};
GUIMessageResultWin.prototype.ShowWinLine = function(desc) {
    this.winLineDisplayer.ShowWinLine(desc, this.isCentered);
    this.HideLabel()
};
GUIMessageResultWin.prototype.ShowLabel = function(text) {
    this.OnWinLineHide();
    var l = this.isCentered ? this.labelCentered : this.label;
    l.text = text;
    l.gameObject.SetActive(true)
};
GUIMessageResultWin.prototype.HideLabel = function() {
    this.label.gameObject.SetActive(false);
    this.labelCentered.gameObject.SetActive(false);
    this.labelCustom.gameObject.SetActive(false)
};
GUIMessageResultWin.prototype.ComputeText = function(amount, multipliers, subject, usePaysText) {
    var ret = [];
    if (subject != null) ret.push(subject);
    if (usePaysText) ret.push(this.localized_Pays.text);
    if (multipliers != null) {
        var totalMultiplier = 1;
        for (var i = 0; i < multipliers.length; i++) totalMultiplier *= multipliers[i];
        if (totalMultiplier > 1) {
            ret.push(this.FormatValue(amount / totalMultiplier));
            for (var i = 0; i < multipliers.length; i++)
                if (multipliers[i] > 1) {
                    ret.push("x");
                    ret.push(String(multipliers[i]))
                }
            ret.push("=")
        }
    }
    ret.push(this.FormatValue(amount));
    return ret.join(" ")
};
GUIMessageResultWin.prototype.FormatValue = function(value) {
    if (this.WinLineHasCoins()) return String(CoinManager.ConvertMoneyToCoins(value));
    if (this.formatOptions == null) this.formatOptions = new FormatOptions;
    return LocaleManager.FormatValue(value, this.formatOptions)
};
goog.require("UHT.Engine");
WinLinesInformationDisplayer.prototype = Object.create(Component.prototype);
WinLinesInformationDisplayer.prototype.constructor = WinLinesInformationDisplayer;

function WinLineDesc() {
    this.text = "";
    this.prefixText = null;
    this.atlases = [];
    this.spriteNames = [];
    this.depths = [];
    this.spacing = 0;
    this.spacingExtraLabel = 0;
    this.thumbnailSize = 0
}

function WinLinesInformationDisplayer() {
    Component.call(this);
    this.symbolSprites = [];
    this.showLineEvent = null;
    this.hideLineEvent = null;
    this.noOfThumbnailsLabel = null;
    this.targetLabel = null;
    this.widthLabel = null;
    this.parent = null;
    this.targetPosLeft = null;
    this.targetPosCentered = null;
    this.isCentered = false;
    this.oldWidth = -1;
    this.spriteWidth = -1;
    this.currentWLDesc = null
}
WinLinesInformationDisplayer.prototype.scriptUpdatePriority = 7;
WinLinesInformationDisplayer.prototype.ShowWinLine = function(desc, centered) {
    this.currentWLDesc = desc;
    this.targetLabel.InternalSetText(desc.text, true);
    this.spriteWidth = 0;
    this.isCentered = centered;
    var pos = new UHTMath.Vector3(0, 0, 0);
    var idxInSpriteArray = 0;
    var showNoOfThumbsLabel = false;
    for (var i = 0; i < this.symbolSprites.length; i++) {
        if (idxInSpriteArray < desc.spriteNames.length) {
            if (desc.prefixText != null) {
                showNoOfThumbsLabel = true;
                this.noOfThumbnailsLabel.text = desc.prefixText;
                this.noOfThumbnailsLabel.transform.localPosition(pos);
                pos.x += desc.spacingExtraLabel;
                this.spriteWidth += desc.spacingExtraLabel
            }
            this.symbolSprites[i].width = desc.thumbnailSize;
            this.symbolSprites[i].height = desc.thumbnailSize;
            this.symbolSprites[i].atlas = desc.atlases[idxInSpriteArray];
            this.symbolSprites[i].SetSpriteName(desc.spriteNames[idxInSpriteArray]);
            this.symbolSprites[i].depth = i + desc.depths[idxInSpriteArray] * this.symbolSprites.length;
            this.symbolSprites[i].gameObject.SetActive(true);
            this.symbolSprites[i].gameObject.transform.localPosition(pos);
            pos.x +=
                desc.spacing;
            this.spriteWidth += desc.spacing;
            if (desc.prefixText != null) idxInSpriteArray += desc.spriteNames.length
        } else this.symbolSprites[i].gameObject.SetActive(false);
        idxInSpriteArray++
    }
    this.noOfThumbnailsLabel.gameObject.SetActive(showNoOfThumbsLabel);
    pos.x += desc.spacingExtraLabel;
    this.spriteWidth += desc.spacingExtraLabel;
    this.targetLabel.transform.localPosition(pos);
    this.oldWidth = -1;
    this.parent.localPosition(this.targetPosLeft.localPosition());
    this.showLineEvent.Start()
};
WinLinesInformationDisplayer.prototype.HideWinLine = function() {
    this.hideLineEvent.Start()
};
WinLinesInformationDisplayer.prototype.MakeSpaceForNoOfThumbsLabel = function() {
    if (this.currentWLDesc == null) return;
    var pos = new UHTMath.Vector3(0, 0, 0);
    pos.x += this.noOfThumbnailsLabel.GetWidth();
    pos.x += this.currentWLDesc.spacingExtraLabel;
    this.symbolSprites[0].transform.localPosition(pos);
    pos.x += this.currentWLDesc.spacing;
    pos.x += this.currentWLDesc.spacingExtraLabel;
    this.targetLabel.transform.localPosition(pos)
};
WinLinesInformationDisplayer.prototype.Update = function() {
    if (this.isCentered) {
        var newWidth = this.spriteWidth + this.targetLabel.GetWidth();
        if (this.noOfThumbnailsLabel.gameObject.activeSelf) newWidth += this.noOfThumbnailsLabel.GetWidth();
        if (this.oldWidth != newWidth) {
            if (this.noOfThumbnailsLabel.gameObject.activeSelf) this.MakeSpaceForNoOfThumbsLabel();
            this.oldWidth = newWidth;
            var p = this.targetPosCentered.localPosition();
            this.parent.localPosition(p.x - newWidth / 2, p.y, p.z);
            if (this.widthLabel != null) this.widthLabel.width =
                _number.otoi(newWidth)
        }
    }
};
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
GUIMessageZoneSettings.prototype = Object.create(ArrangeableBase.prototype);
GUIMessageZoneSettings.prototype.constructor = GUIMessageZoneSettings;

function SymbolThumbnailDesc() {
    this.id = -1;
    this.atlas = null;
    this.sprite = "";
    this.depth = 0
}

function GUIMessageZoneSettings() {
    ArrangeableBase.call(this);
    this.thumbnails = [];
    this.spacing = 33;
    this.spacingMobile_landscape = 33;
    this.spacingMobile_portrait = 85;
    this.spacingExtraLabel = 5;
    this.spacingExtraLabelMobile_landscape = 5;
    this.spacingExtraLabelMobile_portrait = 5;
    this.thumbnailSize = 28;
    this.thumbnailSizeMobile_landscape = 32;
    this.thumbnailSizeMobile_portrait = 80;
    this.miniResize = .4;
    this.portraitOrientation = false
}
GUIMessageZoneSettings.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(InterfaceVars.GUIMessageZoneSettings, this)
};
GUIMessageZoneSettings.prototype.GetSpacing = function() {
    if (XT.GetBool(InterfaceVars.IsMobileGUI)) return this.portraitOrientation ? this.spacingMobile_portrait : this.spacingMobile_landscape / (Globals.isMini ? this.miniResize : 1);
    else return this.spacing
};
GUIMessageZoneSettings.prototype.GetSpacingExtraLabel = function() {
    if (XT.GetBool(InterfaceVars.IsMobileGUI)) return this.portraitOrientation ? this.spacingExtraLabelMobile_portrait : this.spacingExtraLabelMobile_landscape / (Globals.isMini ? this.miniResize : 1);
    else return this.spacingExtraLabel
};
GUIMessageZoneSettings.prototype.GetThumbnailSize = function() {
    if (XT.GetBool(InterfaceVars.IsMobileGUI)) return this.portraitOrientation ? this.thumbnailSizeMobile_portrait : Math.floor(this.thumbnailSizeMobile_landscape / (Globals.isMini ? this.miniResize : 1));
    else return this.thumbnailSize
};
GUIMessageZoneSettings.prototype.OnSwitchToPortrait = function() {
    this.portraitOrientation = true
};
GUIMessageZoneSettings.prototype.OnSwitchToLandscape = function() {
    this.portraitOrientation = false
};
GUIMessageZoneSettings.prototype.GetThumbnail = function(id) {
    for (var i = 0; i < this.thumbnails.length; ++i)
        if (this.thumbnails[i].id == id) return this.thumbnails[i];
    return null
};
goog.require("UHT.Engine");
HasCoinsSwitcher.prototype = Object.create(XTLink.prototype);
HasCoinsSwitcher.prototype.constructor = HasCoinsSwitcher;

function HasCoinsSwitcher() {
    XTLink.call(this);
    this.visibleIfCoins = null;
    this.visibleIfNoCoins = null
}
HasCoinsSwitcher.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.HasCoins, this.OnHasCoinsChanged, this)
};
HasCoinsSwitcher.prototype.OnDestroy = function() {
    XT.UnregisterCallbackBool(this.OnHasCoinsChanged, this)
};
HasCoinsSwitcher.prototype.OnHasCoinsChanged = function(newVal) {
    var i = 0;
    for (i = 0; i < this.visibleIfCoins.length; i++)
        if (this.visibleIfCoins[i] != null) this.visibleIfCoins[i].SetActive(newVal);
    for (i = 0; i < this.visibleIfNoCoins.length; i++)
        if (this.visibleIfNoCoins[i] != null) this.visibleIfNoCoins[i].SetActive(!newVal)
};
goog.require("UHT.XTLink");
ValueControlledActive.prototype = Object.create(XTLink.prototype);
ValueControlledActive.prototype.constructor = ValueControlledActive;

function ValueControlledActive() {
    XTLink.call(this);
    this.vdVariable = null;
    this.visibleWhenPositive = null;
    this.visibleWhenZeroOrNegative = null
}
ValueControlledActive.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackDouble(this.vdVariable.variable.name, this.OnTargetValueChanged, this)
};
ValueControlledActive.prototype.OnTargetValueChanged = function(value) {
    var positive = value > 0;
    for (var i = 0; i < this.visibleWhenPositive.length; ++i) this.visibleWhenPositive[i].SetActive(positive);
    for (var i = 0; i < this.visibleWhenZeroOrNegative.length; ++i) this.visibleWhenZeroOrNegative[i].SetActive(!positive)
};
goog.require("UHT.Engine");
CheckBoxControl.prototype = Object.create(Component.prototype);
CheckBoxControl.prototype.constructor = CheckBoxControl;

function CheckBoxControl() {
    Component.call(this);
    this.checkedGO = null;
    this.uncheckedGO = null;
    this.checkedByDefault = false;
    this.isChecked = false;
    this.needsInit = true;
    this.allowChange = true
}
CheckBoxControl.prototype.Awake = function() {
    if (this.needsInit) this.SetValue(this.checkedByDefault)
};
CheckBoxControl.prototype.SetValue = function(newValue) {
    this.isChecked = newValue;
    this.needsInit = false;
    this.checkedGO.SetActive(newValue);
    this.uncheckedGO.SetActive(!newValue)
};
CheckBoxControl.prototype.GetValue = function() {
    return this.isChecked
};
CheckBoxControl.prototype.OnClick = function() {
    if (this.allowChange) this.SetValue(!this.isChecked)
};
CheckBoxControl.prototype.Check = function() {
    if (!this.isChecked) this.gameObject.SendMessage("OnClick")
};
goog.require("UHT.Engine");
GameHistoryButton.prototype = Object.create(XTLink.prototype);
GameHistoryButton.prototype.constructor = GameHistoryButton;

function GameHistoryButton() {
    XTLink.call(this);
    this.wasTouchMove = false;
    this.touchStartHandler = null;
    this.touchMoveHandler = null;
    this.touchEndHandler = null
}
GameHistoryButton.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.HasGameHistory, this.OnValueChanged, this)
};
GameHistoryButton.prototype.OnDestroy = function() {
    XT.UnregisterCallbackBool(this.OnValueChanged, this)
};
GameHistoryButton.prototype.OnValueChanged = function(newValue) {
    var b = this.gameObject.GetComponent(ButtonEnabler);
    if (newValue) b.EnableButton();
    else b.DisableButton()
};
GameHistoryButton.prototype.Awake = function() {
    if (createjs.BrowserDetect.isIOS) {
        this.touchStartHandler = new EventHandler(this, this.OnTouchStart);
        this.touchMoveHandler = new EventHandler(this, this.OnTouchMove);
        globalColliderInputManager.addEventHandler(ColliderEvent.ButtonDown, this.touchStartHandler);
        globalColliderInputManager.addEventHandler(ColliderEvent.MouseMove, this.touchMoveHandler)
    }
    this.touchEndHandler = new EventHandler(this, this.OnTouchEnd);
    globalColliderInputManager.addEventHandler(ColliderEvent.ButtonUp,
        this.touchEndHandler);
    this.cachedCamera = Globals.GetCameraForObject(this.gameObject)
};
GameHistoryButton.prototype.OnTouchStart = function() {
    this.wasTouchMove = false
};
GameHistoryButton.prototype.OnTouchMove = function() {
    this.wasTouchMove = true
};
GameHistoryButton.prototype.OnTouchEnd = function() {
    if (this.gameObject.activeInHierarchy && XT.GetBool(Vars.HasGameHistory)) {
        var mask = new LayerMask;
        mask.mask = 1 << this.gameObject.layer;
        var c = globalColliderInputManager.getHoveredCollider(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition), mask);
        if (!this.wasTouchMove && c == this.gameObject.collider) {
            if (UHTInterfaceBOSS.HandleGameHistory()) return;
            if (UHT_GAME_CONFIG["openHistoryInTab"]) window.open(ServerOptions.gameHistory);
            else if (!GameHistoryWindow.IsOpen())(new GameHistoryWindow).Open()
        }
    }
};

function GameHistoryWindow() {
    this.root = null;
    this.btn = null;
    this.resizeHandler = null;
    GameHistoryWindow.I = this
}
GameHistoryWindow.I = null;
GameHistoryWindow.IsOpen = function() {
    return GameHistoryWindow.I != null
};
GameHistoryWindow.prototype.CreateElement = function(tag, attributes, append) {
    var el = document.createElement(tag);
    for (var name in attributes) el.setAttribute(name, attributes[name]);
    if (append) document.body.appendChild(el);
    return el
};
GameHistoryWindow.prototype.Open = function() {
    var hw = this;
    var frame = hw.CreateElement("iframe", {
        "src": ServerOptions.gameHistory,
        "class": "history-frame",
        "frameborder": "0"
    }, false);
    hw.btn = hw.CreateElement("div", {
        "class": "history-button"
    }, true);
    hw.btn.addEventListener("click", function() {
        hw.Close()
    }, false);
    hw.root = hw.CreateElement("div", {
        "class": "history-root"
    }, true);
    if ((window["safari"] != undefined || document.documentElement.className.indexOf("iOS") >= 0) && !window["OLD_GAMEHISTORY"]) {
        frame.style.width = "100%";
        frame.style.height = "100%";
        hw.root.style.width = "100%";
        hw.root.style.height = "100%"
    }
    hw.root.appendChild(frame);
    if ((window["safari"] != undefined || document.documentElement.className.indexOf("iOS") >= 0) && !window["OLD_GAMEHISTORY"]) {
        var iframe = window.frames[0];
        if (iframe != null) {
            document.getElementsByClassName("history-button")[0].style.cssText = "-moz-transform:scale(0.6369230769230769);-webkit-transform:scale(0.6369230769230769);-ms-transform:scale(0.6369230769230769);-o-transform:scale(0.6369230769230769);transform:scale(0.6369230769230769)";
            iframe.addEventListener("DOMContentLoaded", function() {
                this.document.addEventListener("touchmove", function(event) {
                    if (event.scale !== 1) event.preventDefault()
                }, {
                    passive: false
                });
                var historyFrame = this.frames["historyFrame"];
                if (historyFrame != null) {
                    historyFrame.contentWindow.addEventListener("touchmove", function(event) {
                        if (event.scale !== 1) event.preventDefault()
                    }, {
                        passive: false
                    });
                    this.document.getElementsByClassName("last-history-container")[0].style.width = "100%";
                    this.document.getElementsByClassName("history-detail-iframe")[0].style.width =
                        "100%";
                    this.document.getElementsByClassName("customScroll")[0].style.minHeight = "100px";
                    var mediaQueryList = window.matchMedia("(orientation: portrait)");
                    var self = this;
                    var handleOrientationChange = function(evt) {
                        if (evt.matches) {
                            self.document.getElementsByClassName("history-detail-iframe")[0].style.height = "55vh";
                            self.document.getElementsByClassName("history-detail-iframe")[0].style.minHeight = "30vh";
                            self.document.getElementsByClassName("customScroll")[0].style.height = "30vh"
                        } else {
                            self.document.getElementsByClassName("history-detail-iframe")[0].style.height =
                                "50vh";
                            self.document.getElementsByClassName("history-detail-iframe")[0].style.minHeight = "30vh";
                            self.document.getElementsByClassName("customScroll")[0].style.height = "50vh"
                        }
                    };
                    handleOrientationChange(mediaQueryList);
                    mediaQueryList.addListener(handleOrientationChange)
                } else {
                    var mediaQueryList = window.matchMedia("(orientation: portrait)");
                    var handleOrientationChange = function(evt) {
                        if (evt.matches) {
                            document.getElementsByClassName("history-frame")[0].style.height = "85%";
                            document.getElementsByClassName("history-frame")[0].style.width =
                                "100%"
                        } else {
                            document.getElementsByClassName("history-frame")[0].style.height = "100%";
                            document.getElementsByClassName("history-frame")[0].style.width = "85%"
                        }
                    };
                    handleOrientationChange(mediaQueryList);
                    mediaQueryList.addListener(handleOrientationChange)
                }
            })
        }
    } else {
        hw.resizeHandler = function() {
            hw.OnResize()
        };
        window.addEventListener("resize", hw.resizeHandler, true);
        hw.OnResize()
    }
    hw.SetVisible(true);
    Globals.InputBlocked = true
};
GameHistoryWindow.prototype.Close = function() {
    this.SetVisible(false);
    document.body.removeChild(this.root);
    document.body.removeChild(this.btn);
    window.removeEventListener("resize", this.resizeHandler, false);
    GameHistoryWindow.I = null;
    if (!ServerOptions.isReplay) Globals.InputBlocked = false
};
GameHistoryWindow.prototype.OnResize = function() {
    var width = 600;
    var height = 650;
    var zoom = 1;
    if (window.innerHeight / window.innerWidth > height / width) zoom = window.innerWidth / width;
    else zoom = window.innerHeight / height;
    var newStyle = "-moz-transform:scale(VAL);-webkit-transform:scale(VAL);-ms-transform:scale(VAL);-o-transform:scale(VAL);transform:scale(VAL)".replace(new RegExp("VAL", "g"), String(zoom));
    this.root.setAttribute("style", newStyle);
    if (!UHT_DEVICE_TYPE.DESKTOP) this.btn.setAttribute("style", newStyle)
};
GameHistoryWindow.prototype.SetVisible = function(visible) {
    var doc = document.documentElement;
    var visibleClass = "history-visible";
    var newClass = String(doc.className).replace(new RegExp(visibleClass, "g"), "").replace(/\s+/g, " ").replace(/^\s+|\s+$/g, "");
    if (visible) newClass = [newClass, visibleClass].join(" ");
    doc.className = newClass
};
goog.require("UHT.Engine");
JurisdictionPromoUrlButton.prototype = Object.create(XTLink.prototype);
JurisdictionPromoUrlButton.prototype.constructor = JurisdictionPromoUrlButton;

function JurisdictionPromoUrlButton() {
    XTLink.call(this);
    this.wasTouchMove = false;
    this.touchStartHandler = null;
    this.touchMoveHandler = null;
    this.touchEndHandler = null
}
JurisdictionPromoUrlButton.prototype.Awake = function() {
    if (createjs.BrowserDetect.isIOS) {
        this.touchStartHandler = new EventHandler(this, this.OnTouchStart);
        this.touchMoveHandler = new EventHandler(this, this.OnTouchMove);
        globalColliderInputManager.addEventHandler(ColliderEvent.ButtonDown, this.touchStartHandler);
        globalColliderInputManager.addEventHandler(ColliderEvent.MouseMove, this.touchMoveHandler)
    }
    this.touchEndHandler = new EventHandler(this, this.OnTouchEnd);
    globalColliderInputManager.addEventHandler(ColliderEvent.ButtonUp,
        this.touchEndHandler);
    this.cachedCamera = Globals.GetCameraForObject(this.gameObject)
};
JurisdictionPromoUrlButton.prototype.OnTouchStart = function() {
    this.wasTouchMove = false
};
JurisdictionPromoUrlButton.prototype.OnTouchMove = function() {
    this.wasTouchMove = true
};
JurisdictionPromoUrlButton.prototype.OnTouchEnd = function() {
    if (this.gameObject.activeInHierarchy) {
        var mask = new LayerMask;
        mask.mask = 1 << this.gameObject.layer;
        var c = globalColliderInputManager.getHoveredCollider(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition), mask);
        if (!this.wasTouchMove && c == this.gameObject.collider) window.open(ServerOptions.promotionurl)
    }
};
goog.require("UHT.Engine");
JurisdictionPromoUrl.prototype = Object.create(XTLink.prototype);
JurisdictionPromoUrl.prototype.constructor = JurisdictionPromoUrl;

function JurisdictionPromoUrl() {
    XTLink.call(this);
    this.mobile = false;
    this.newPos = null;
    this.newScale = null;
    this.settingWindows = []
}
JurisdictionPromoUrl.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_SettingsWindowOpened, this.OnShowPromo, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_SettingsWindowClosed, this.OnHidePromo, this);
    this.settingWindows = [];
    if (this.mobile) {
        this.settingWindows.push(globalRuntime.sceneRoots[1].GetComponentsInChildren(MenuWindowControllerMobile, true)[0].gameObject);
        this.settingWindows.push(globalRuntime.sceneRoots[1].GetComponentsInChildren(MenuWindowControllerMobile,
            true)[1].gameObject)
    }
};
JurisdictionPromoUrl.prototype.OnShowPromo = function() {
    if (XT.GetBool(Vars.Jurisdiction_PromotionURL))
        if (ServerOptions.promotionurl != null) this.gameObject.SetActive(true)
};
JurisdictionPromoUrl.prototype.OnEnable = function() {
    if (this.mobile)
        for (var i = 0; i < this.settingWindows.length; i++)
            if (this.settingWindows[i].activeInHierarchy) {
                this.settingWindows[i].transform.localPosition(this.newPos);
                this.settingWindows[i].transform.localScale(this.newScale)
            }
};
JurisdictionPromoUrl.prototype.OnHidePromo = function() {
    this.gameObject.SetActive(false)
};
goog.provide("UHT.SoundButtonControllerMobile");
goog.require("UHT.Engine");
SoundButtonControllerMobile.prototype = Object.create(XTLink.prototype);
SoundButtonControllerMobile.prototype.constructor = SoundButtonControllerMobile;

function SoundButtonControllerMobile() {
    XTLink.call(this);
    this.buttonOn = null;
    this.buttonOff = null;
    this.buttonDownload = null;
    this.waiting = null;
    this.mustUpdate = true;
    this.enableSoundsWhenReady = false
}
SoundButtonControllerMobile.buttonsUpdatedAfterDownload = false;
SoundButtonControllerMobile.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SoundStateChanged, this.OnSoundStateChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnSoundStateChanged, this)
};
SoundButtonControllerMobile.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnSoundStateChanged, this)
};
SoundButtonControllerMobile.prototype.OnSoundStateChanged = function() {
    if (UHTEngine.SoundsAreLoaded()) this.InternalUpdateButtons()
};
SoundButtonControllerMobile.prototype.Start = function() {
    this.buttonOn.SetActive(false);
    this.buttonOff.SetActive(false);
    this.buttonDownload.SetActive(true);
    this.waiting.SetActive(false)
};
SoundButtonControllerMobile.prototype.Update = function() {
    if (UHTEngine.SoundsAreLoading() && !this.waiting.activeInHierarchy) {
        this.buttonDownload.SetActive(false);
        this.waiting.SetActive(true)
    } else if (UHTEngine.SoundsAreLoaded() && this.mustUpdate) {
        this.mustUpdate = false;
        this.waiting.SetActive(false);
        this.buttonDownload.SetActive(false);
        this.InternalUpdateButtons();
        SoundButtonControllerMobile.buttonsUpdatedAfterDownload = true
    }
};
SoundButtonControllerMobile.prototype.SoundOffButtonClicked = function() {
    if (XT.GetObject(Vars.SoundState).gameSoundIsOn || Globals.isMini) XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_SoundBtn)
};
SoundButtonControllerMobile.prototype.SoundOnButtonClicked = function() {
    if (!XT.GetObject(Vars.SoundState).gameSoundIsOn || Globals.isMini) XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_SoundBtn)
};
SoundButtonControllerMobile.prototype.InternalUpdateButtons = function() {
    var sndState = XT.GetObject(Vars.SoundState);
    var bon = sndState.gameSoundIsOn;
    this.buttonOn.SetActive(bon);
    this.buttonOff.SetActive(!bon)
};
SoundButtonControllerMobile.prototype.SoundDownloadClicked = function() {
    UHTEngine.StartLoadingSounds();
    if (this.enableSoundsWhenReady) XT.SetBool(InterfaceVars.EnableSoundsWhenReady, true)
};
goog.require("UHT.SoundButtonControllerMobile");
SoundButtonControllerMobileV10.prototype = Object.create(SoundButtonControllerMobile.prototype);
SoundButtonControllerMobileV10.prototype.constructor = SoundButtonControllerMobileV10;

function SoundButtonControllerMobileV10() {
    SoundButtonControllerMobile.call(this);
    this.musicSlider = null;
    this.effectsSlider = null;
    this.soundSlider = null;
    this.soundSliderContent = null
}
SoundButtonControllerMobileV10.prototype.OnEnable = function() {
    if (this.soundSlider != null) {
        this.soundSlider.notifyWhenValueChanged = false;
        this.soundSlider.SetValue(XT.GetObject(Vars.SoundState).gameSoundIsOn ? 1 : 0);
        this.soundSlider.notifyWhenValueChanged = true
    }
    if (this.musicSlider != null) {
        this.musicSlider.notifyWhenValueChanged = false;
        this.musicSlider.SetValue(XT.GetObject(Vars.SoundState).musicIsOn ? 1 : 0);
        this.musicSlider.notifyWhenValueChanged = true
    }
    if (this.effectsSlider != null) {
        this.effectsSlider.notifyWhenValueChanged =
            false;
        this.effectsSlider.SetValue(XT.GetObject(Vars.SoundState).soundFXIsOn ? 1 : 0);
        this.effectsSlider.notifyWhenValueChanged = true
    }
};
SoundButtonControllerMobileV10.prototype.Start = function() {
    SoundButtonControllerMobile.prototype.Start.call(this);
    if (this.soundSliderContent != null) this.soundSliderContent.SetActive(false)
};
SoundButtonControllerMobileV10.prototype.InternalUpdateButtons = function() {
    SoundButtonControllerMobile.prototype.InternalUpdateButtons.call(this);
    if (this.soundSliderContent != null) {
        this.OnEnable();
        this.soundSliderContent.SetActive(true)
    }
};
goog.require("UHT.Engine");
MobileKeyboard.prototype = Object.create(Component.prototype);
MobileKeyboard.prototype.constructor = MobileKeyboard;

function MobileKeyboard() {
    Component.call(this);
    this.titleLabel = null;
    this.input = null;
    this.origInput = null;
    this.isHacked = false
}
MobileKeyboard.prototype.OnEnable = function() {
    if (!this.isHacked) {
        this.isHacked = true;
        this.input.validation = UIInput.Validation.Float;
        var zeroBtns = this.gameObject.transform.Find("Keys/0").GetComponentsInChildren(UIButton, true);
        var zeroBtn = null;
        for (var i = 0; i < zeroBtns.length; ++i)
            if (zeroBtns[i].target.gameObject.name == "Label") {
                zeroBtn = zeroBtns[i];
                break
            }
        var zeroMessageSender = zeroBtn.GetComponent(MessageSender);
        var xSprite = this.gameObject.transform.Find("Keys/Cancel/X/SpriteX").GetComponent(UISprite);
        xSprite.color =
            zeroBtn.color_normal;
        xSprite.width = 200;
        xSprite.height = 200;
        xSprite.spriteType = UISprite.Type.Filled;
        xSprite.fillDirection = UISprite.FillDirection.Custom;
        xSprite.fillAmountTop = .7;
        xSprite.fillAmountBottom = .4;
        xSprite.fillAmountLeft = .6;
        xSprite.fillAmountRight = .6;
        xSprite.SetSpriteName("menuIcon_info");
        xSprite.transform.localPosition(new UHTMath.Vector3(0, -50, 0));
        xSprite.transform.parent.localPosition(UHTMath.Vector3.zero);
        xSprite.transform.parent.localScale(UHTMath.Vector3.one);
        var bgSprite = this.gameObject.transform.Find("Keys/Cancel/Bg/SpriteBG").GetComponent(UISprite);
        bgSprite.color = zeroBtn.color_normal;
        var cancelBtns = this.gameObject.transform.Find("Keys/Cancel").GetComponentsInChildren(UIButton, true);
        var cancelMessageData = new MessageData(zeroMessageSender.onClickEvents[0].eventReceiver, zeroMessageSender.onClickEvents[0].methodToCall, zeroMessageSender.onClickEvents[0].useParam, ".");
        var cancelMessageSender = cancelBtns[0].gameObject.AddComponent("MessageSender");
        cancelMessageSender.onEnabledEvents = [];
        cancelMessageSender.animationEvents = [];
        cancelMessageSender.onClickEvents = [];
        cancelMessageSender.onClickEvents.push(cancelMessageData);
        for (var i = 0; i < cancelBtns.length; ++i) {
            if (cancelBtns[i].normal != "ContainerBorder") {
                cancelBtns[i].normal = xSprite.spriteName;
                cancelBtns[i].hover = xSprite.spriteName;
                cancelBtns[i].pressed = xSprite.spriteName;
                cancelBtns[i].disabled = xSprite.spriteName;
                cancelBtns[i].color_pressed = zeroBtn.color_pressed
            }
            cancelBtns[i].color_normal = zeroBtn.color_normal;
            cancelBtns[i].color_hover = zeroBtn.color_hover;
            if (cancelBtns[i].onClick != null) cancelBtns[i].onClick.splice(0)
        }
    }
};
MobileKeyboard.prototype.OnDisable = function() {
    this.gameObject.SetActive(false)
};
MobileKeyboard.prototype.ShowKeyboard = function(_label, _input) {
    this.gameObject.SetActive(true);
    this.titleLabel.text = _label.text;
    this.origInput = _input;
    this.input.SetValue([null, "", "0"].indexOf(_input.value) > -1 ? "" : _input.value);
    this.input.Select(true)
};
MobileKeyboard.prototype.CloseKeyboard = function() {
    this.gameObject.SetActive(false)
};
MobileKeyboard.prototype.ApplyAndCloseKeyboard = function() {
    this.gameObject.SetActive(false);
    this.origInput.SetValue(this.input.value)
};
goog.require("UHT.Engine");
MobileKeyboardStarter.prototype = Object.create(Component.prototype);
MobileKeyboardStarter.prototype.constructor = MobileKeyboardStarter;

function MobileKeyboardStarter() {
    Component.call(this);
    this.keyboard = null;
    this.titleLabel = null;
    this.input = null
}
MobileKeyboardStarter.prototype.OnClick = function() {
    this.keyboard.ShowKeyboard(this.titleLabel, this.input)
};
goog.provide("UHT.AutoplayControllerAdvanced");
goog.require("UHT.XTLink");
AutoplayControllerAdvanced.prototype = Object.create(XTLink.prototype);
AutoplayControllerAdvanced.prototype.constructor = AutoplayControllerAdvanced;

function AutoplayControllerAdvanced() {
    XTLink.call(this);
    this.startAutoplayButton = null;
    this.fastPlayToOn = null;
    this.fastPlayToOff = null;
    this.turboSpinToOn = null;
    this.turboSpinToOff = null;
    this.checkSpins = null;
    this.checkOnAnyWin = null;
    this.checkIfAnyFeature = null;
    this.checkIfSingleWin = null;
    this.inputWin = null;
    this.checkIfCashIncreases = null;
    this.inputCashIncrease = null;
    this.checkIfCashDecreases = null;
    this.inputCashDecrease = null;
    this.requestedAutoSpins = [10, 20, 30, 50, 70, 100];
    this.mallHacked = false;
    this.isCashDecreaseValid =
        true;
    this.wasCashDecreaseSelected = false;
    this.cashDecreaseValidColor = null;
    this.cashDecreasesUIButtons = null;
    this.cashDecreasesLabels = null;
    this.inputCashDecreaseSprite = null;
    this.startAutoplayButtonLabel = null;
    this.startAutoplayButtonSprite = null;
    this.startAutoplayUIButtons = null;
    this.startAutoplayUIButtonOnClick = null;
    this.cashDecreaseKeyboardStarter = null;
    this.validColor = null;
    this.validColorHover = null;
    this.validColorPressed = null;
    this.invalidColor = null;
    this.invalidColorHover = null;
    this.invalidColorPressed =
        null;
    this.startAutoplayInvalidColor = null
}
AutoplayControllerAdvanced.formatOptions = null;
AutoplayControllerAdvanced.layoutMode = LayoutManager.Mode.Invalid;
AutoplayControllerAdvanced.layoutSwitchedFrame = 0;
AutoplayControllerAdvanced.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayout, this.OnSwitchToLandscape, this, -1);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWide, this.OnSwitchToLandscape, this, -1);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWideFull, this.OnSwitchToLandscape, this, -1);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayout, this.OnSwitchToPortrait, this, -1);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPhone,
        this.OnSwitchToPortrait, this, -1);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPad, this.OnSwitchToPortrait, this, -1)
};
AutoplayControllerAdvanced.prototype.XTInitVariablesAndEvents = function() {
    XT.SetInt(InterfaceVars.SelectedAutoSpinsIndexAdvanced, 3);
    XT.SetObject(Vars.AdvancedAutoplaySettings, new AdvancedAutoplaySettings)
};
AutoplayControllerAdvanced.prototype.OnEnable = function() {
    if (!this.mallHacked) {
        this.mallHacked = true;
        this.inputWin.validation = UIInput.Validation.Float;
        this.inputCashIncrease.validation = UIInput.Validation.Float;
        this.inputCashDecrease.validation = UIInput.Validation.Float;
        if (XT.GetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit)) {
            this.checkIfCashDecreases.SetValue(true);
            this.checkIfCashDecreases.allowChange = false;
            this.cashDecreaseValidColor = this.inputCashDecrease.activeTextColor;
            var self = this;
            this.inputCashDecrease.TextExtraHandler =
                function(value) {
                    return self.ProcessCashDecreaseText(value)
                };
            this.cashDecreasesLabels = this.checkIfCashDecreases.GetComponentsInChildren(UILabel, true);
            this.cashDecreasesUIButtons = this.checkIfCashDecreases.GetComponentsInChildren(UIButton, true);
            this.inputCashDecreaseSprite = this.inputCashDecrease.gameObject.transform.Find("Background/Sprite").GetComponent(UISprite);
            this.cashDecreaseKeyboardStarter = this.inputCashDecrease.GetComponent(MobileKeyboardStarter);
            this.startAutoplayUIButtons = this.startAutoplayButton.GetComponents(UIButton);
            var startAPHandlersThis = [];
            var startAPHandlersOther = [];
            for (var i = 0; i < this.startAutoplayUIButtons.length; ++i) {
                var uib = this.startAutoplayUIButtons[i];
                for (var j = 0; j < uib.onClick.length; ++j)
                    if (uib.onClick[j].target == this) startAPHandlersThis.push(uib.onClick[j]);
                    else startAPHandlersOther.push(uib.onClick[j]);
                uib.onClick = []
            }
            this.startAutoplayUIButtons[0].onClick = startAPHandlersThis;
            this.startAutoplayUIButtonOnClick = startAPHandlersOther;
            this.startAutoplayButtonSprite = this.startAutoplayButton.GetComponent(UISprite);
            this.startAutoplayButtonLabel = this.startAutoplayButton.transform.parent.GetComponentInChildren(UILabel);
            this.validColor = this.RGBToColor(1, 1, 1);
            this.validColorHover = this.RGBToColor(.5294117647058824, .8823529411764706, .0705882352941176);
            this.validColorPressed = this.RGBToColor(.3058823529411765, .5372549019607843, .007843137254902);
            this.invalidColor = this.RGBToColor(1, 0, 0);
            this.invalidColorHover = this.RGBToColor(1, .5568627450980392, .5568627450980392);
            this.invalidColorPressed = this.RGBToColor(1, .1607843137254902,
                .1607843137254902);
            this.startAutoplayInvalidColor = this.RGBToColor(.4862745098039216, .4862745098039216, .4862745098039216)
        }
        var collider = this.GetComponent(Collider);
        if (collider != null) {
            var c = collider.center;
            collider.center = new UHTMath.Vector3(c.x, c.y, 20);
            collider.UpdateCachedMembers()
        }
    }
    this.wasCashDecreaseSelected = XT.GetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit);
    if (AutoplayControllerAdvanced.layoutSwitchedFrame != Time.frameCount) XT.SetObject(Vars.AdvancedAutoplaySettings, new AdvancedAutoplaySettings);
    this.UpdateAutoplayContent()
};
AutoplayControllerAdvanced.prototype.SetAutoSpinsIndex = function(strValue) {
    var i = _number.otoi(strValue);
    if (i < 0 || i >= this.requestedAutoSpins.length) return;
    XT.SetInt(InterfaceVars.SelectedAutoSpinsIndexAdvanced, i);
    this.UpdateAutoplayContent()
};
AutoplayControllerAdvanced.prototype.StartAutoplayPressed = function() {
    if (XT.GetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit) && !this.isCashDecreaseValid) {
        if (Globals.isMobile) this.cashDecreaseKeyboardStarter.OnClick();
        else this.inputCashDecrease.Select(true);
        return
    }
    this.FillAutoplaySettings();
    XT.SetInt(Vars.AutoplaySpinsRequested, this.requestedAutoSpins[XT.GetInt(InterfaceVars.SelectedAutoSpinsIndexAdvanced)]);
    XT.TriggerEvent(Vars.Evt_DataToCode_StartAutoplay);
    if (this.startAutoplayUIButtonOnClick !=
        null)
        for (var i = 0; i < this.startAutoplayUIButtonOnClick.length; i++)
            if (this.startAutoplayUIButtonOnClick[i].target != null) this.startAutoplayUIButtonOnClick[i].target[this.startAutoplayUIButtonOnClick[i].methodName]()
};
AutoplayControllerAdvanced.prototype.UpdateAutoplayContent = function() {
    var s = XT.GetObject(Vars.AdvancedAutoplaySettings);
    this.checkOnAnyWin.SetValue(s.stopOnAnyWin);
    this.checkIfAnyFeature.SetValue(s.stopIfFeature);
    this.checkIfSingleWin.SetValue(s.stopIfSingleWinExceeds);
    this.inputWin.SetValue(String(s.singleWinValue > 0 ? s.singleWinValue : ""));
    this.checkIfCashIncreases.SetValue(s.stopIfCashIncreases);
    this.inputCashIncrease.SetValue(String(s.cashIncreasesValue > 0 ? s.cashIncreasesValue : ""));
    if (!XT.GetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit)) this.checkIfCashDecreases.SetValue(s.stopIfCashDecreases);
    this.inputCashDecrease.SetValue(String(s.cashDecreasesValue > 0 ? s.cashDecreasesValue : ""));
    var idx = XT.GetInt(InterfaceVars.SelectedAutoSpinsIndexAdvanced);
    for (var i = 0; i < this.checkSpins.length; i++) this.checkSpins[i].SetValue(i == idx);
    this.UpdateFastPlayButtons()
};
AutoplayControllerAdvanced.prototype.FillAutoplaySettings = function() {
    var s = new AdvancedAutoplaySettings;
    s.stopOnAnyWin = this.checkOnAnyWin.GetValue();
    s.stopIfFeature = this.checkIfAnyFeature.GetValue();
    s.stopIfSingleWinExceeds = this.checkIfSingleWin.GetValue();
    s.singleWinValue = _number.otod(this.inputWin.value);
    s.stopIfCashIncreases = this.checkIfCashIncreases.GetValue();
    s.cashIncreasesValue = _number.otod(this.inputCashIncrease.value);
    s.cashDecreasesValue = _number.otod(this.inputCashDecrease.value);
    s.stopIfCashDecreases =
        s.cashDecreasesValue > 0;
    s.initialBalance = XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived);
    XT.SetObject(Vars.AdvancedAutoplaySettings, s)
};
AutoplayControllerAdvanced.prototype.ProcessCashDecreaseText = function(value) {
    var val = 0;
    if (!_string.IsNullOrEmpty(value)) val = _number.otod(value);
    var ret = value;
    if (!this.wasCashDecreaseSelected && this.inputCashDecrease.isSelected) this.wasCashDecreaseSelected = true;
    if (!this.wasCashDecreaseSelected) ret = [null, "", "0"].indexOf(value) > -1 ? "" : value;
    var totalBet = CoinManager.GetNextTotalBet();
    var balance = XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived);
    this.isCashDecreaseValid = (ret == "" ||
        val > totalBet || Math.abs(val - totalBet) < UHTMath.numberError) && (val < balance || Math.abs(val - balance) < UHTMath.numberError);
    if (this.isCashDecreaseValid) {
        this.inputCashDecrease.label.SetColor(this.cashDecreaseValidColor);
        this.startAutoplayButtonLabel.SetColor(this.validColor);
        this.startAutoplayButtonSprite.color = this.validColor;
        this.inputCashDecreaseSprite.color = this.validColor;
        this.UpdateUIButtonsColors(this.startAutoplayUIButtons, this.validColor, this.validColorHover, this.validColorPressed);
        if (Globals.isMobile)
            for (var i =
                    0; i < this.cashDecreasesLabels.length; ++i) this.cashDecreasesLabels[i].SetColor(this.cashDecreaseValidColor);
        else this.UpdateUIButtonsColors(this.cashDecreasesUIButtons, this.validColor, this.validColorHover, this.validColorPressed)
    } else {
        this.inputCashDecrease.label.SetColor(this.invalidColor);
        this.startAutoplayButtonLabel.SetColor(this.invalidColor);
        this.startAutoplayButtonSprite.color = this.invalidColor;
        this.inputCashDecreaseSprite.color = this.invalidColor;
        this.UpdateUIButtonsColors(this.startAutoplayUIButtons,
            this.startAutoplayInvalidColor, this.startAutoplayInvalidColor, this.startAutoplayInvalidColor);
        if (Globals.isMobile)
            for (var i = 0; i < this.cashDecreasesLabels.length; ++i) this.cashDecreasesLabels[i].SetColor(this.invalidColor);
        else this.UpdateUIButtonsColors(this.cashDecreasesUIButtons, this.invalidColor, this.invalidColorHover, this.invalidColorPressed)
    }
    return ret
};
AutoplayControllerAdvanced.prototype.RGBToColor = function(r, g, b) {
    var c = new Color;
    c.r = r;
    c.g = g;
    c.b = b;
    c.a = 1;
    return c
};
AutoplayControllerAdvanced.prototype.UpdateUIButtonsColors = function(buttons, normalColor, hoverColor, pressedColor) {
    for (var i = 0; i < buttons.length; ++i) {
        var b = buttons[i];
        b.color_normal = normalColor;
        b.color_hover = hoverColor;
        b.color_pressed = pressedColor;
        var s = b.curState;
        if (s == UIButton.State.None) s = b.gameObject.collider != null && b.gameObject.collider.enabled ? UIButton.State.Normal : UIButton.State.Disabled;
        buttons[i].InternalChangeState(s)
    }
};
AutoplayControllerAdvanced.prototype.UpdateFastPlayButtons = function() {
    var isFastPlay = XT.GetBool(Vars.FastPlay);
    this.fastPlayToOn.SetActive(!isFastPlay);
    this.fastPlayToOff.SetActive(isFastPlay);
    if (isFastPlay && XT.GetBool(Vars.AutoplayContinuousSpin)) this.UpdateTurboSpinButtons()
};
AutoplayControllerAdvanced.prototype.UpdateTurboSpinButtons = function() {
    XT.SetBool(Vars.AutoplayContinuousSpin, !XT.GetBool(Vars.AutoplayContinuousSpin));
    var isAutoplayContinousSpin = XT.GetBool(Vars.AutoplayContinuousSpin);
    var isFastPlay = XT.GetBool(Vars.FastPlay);
    this.turboSpinToOn.SetActive(!isAutoplayContinousSpin);
    this.turboSpinToOff.SetActive(isAutoplayContinousSpin);
    if (isAutoplayContinousSpin && isFastPlay) {
        XT.SetBool(Vars.FastPlay, !isFastPlay);
        this.fastPlayToOn.SetActive(isFastPlay);
        this.fastPlayToOff.SetActive(!isFastPlay)
    }
};
AutoplayControllerAdvanced.prototype.OnSwitchToPortrait = function() {
    this.OnLayoutSwitched(LayoutManager.Mode.Portrait)
};
AutoplayControllerAdvanced.prototype.OnSwitchToLandscape = function() {
    this.OnLayoutSwitched(LayoutManager.Mode.Landscape)
};
AutoplayControllerAdvanced.prototype.OnLayoutSwitched = function(mode) {
    if (AutoplayControllerAdvanced.layoutMode == mode) return;
    AutoplayControllerAdvanced.layoutMode = mode;
    AutoplayControllerAdvanced.layoutSwitchedFrame = Time.frameCount
};
goog.require("UHT.AutoplayControllerAdvanced");
AutoplayControllerAdvancedV10.prototype = Object.create(AutoplayControllerAdvanced.prototype);
AutoplayControllerAdvancedV10.prototype.constructor = AutoplayControllerAdvancedV10;

function AutoplayControllerAdvancedV10() {
    AutoplayControllerAdvanced.call(this);
    this.sliderSpins = null;
    this.sliderWinExceeds = null;
    this.sliderCashIncreases = null;
    this.sliderCashDecreases = null;
    this.startAutoplayButtonEnablers = null
}
AutoplayControllerAdvancedV10.prototype.OnEnable = function() {
    var canReset = AutoplayControllerAdvanced.layoutSwitchedFrame != Time.frameCount;
    if (canReset) XT.SetObject(Vars.AdvancedAutoplaySettings, new AdvancedAutoplaySettings);
    this.UpdateAutoplayContent();
    this.sliderSpins.SetValueIndex(canReset ? 3 : XT.GetInt(InterfaceVars.SelectedAutoSpinsIndexAdvanced));
    this.SetAutoSpinsIndex()
};
AutoplayControllerAdvancedV10.prototype.SetAutoSpinsIndex = function() {
    XT.SetInt(InterfaceVars.SelectedAutoSpinsIndexAdvanced, this.sliderSpins.valueIndex);
    this.UpdateAutoplayContent()
};
AutoplayControllerAdvancedV10.prototype.UpdateAutoplayContent = function() {
    var s = XT.GetObject(Vars.AdvancedAutoplaySettings);
    this.checkOnAnyWin.SetValue(s.stopOnAnyWin);
    this.checkIfAnyFeature.SetValue(s.stopIfFeature);
    var totalBet = CoinManager.GetNextTotalBet();
    this.sliderWinExceeds.maxValue = 500 * totalBet;
    this.sliderWinExceeds.SetValue(s.singleWinValue);
    this.sliderCashIncreases.maxValue = 5E3 * totalBet;
    this.sliderCashIncreases.SetValue(s.cashIncreasesValue);
    this.sliderCashDecreases.maxValue = XT.GetDouble(Vars.BalanceReceived) +
        XT.GetDouble(Vars.BonusBalanceReceived);
    this.sliderCashDecreases.SetValue(s.cashDecreasesValue);
    this.UpdateFastPlayButtons();
    this.UpdateStartAutoplayButton(s)
};
AutoplayControllerAdvancedV10.prototype.FillAutoplaySettings = function() {
    var s = new AdvancedAutoplaySettings;
    s.stopOnAnyWin = this.checkOnAnyWin.GetValue();
    s.stopIfFeature = this.checkIfAnyFeature.GetValue();
    s.singleWinValue = Math.round(this.sliderWinExceeds.value * 100) / 100;
    s.stopIfSingleWinExceeds = s.singleWinValue > 0;
    s.cashIncreasesValue = Math.round(this.sliderCashIncreases.value * 100) / 100;
    s.stopIfCashIncreases = s.cashIncreasesValue > 0;
    s.cashDecreasesValue = Math.round(this.sliderCashDecreases.value * 100) / 100;
    s.stopIfCashDecreases =
        XT.GetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit) || s.cashDecreasesValue > 0;
    s.initialBalance = XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived);
    XT.SetObject(Vars.AdvancedAutoplaySettings, s);
    this.UpdateStartAutoplayButton(s)
};
AutoplayControllerAdvancedV10.prototype.UpdateStartAutoplayButton = function(s) {
    if (XT.GetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit)) {
        if (this.startAutoplayButtonEnablers == null) this.startAutoplayButtonEnablers = this.startAutoplayButton.GetComponents(ButtonEnabler);
        if (s.cashDecreasesValue < CoinManager.GetNextTotalBet())
            for (var i = 0; i < this.startAutoplayButtonEnablers.length; ++i) this.startAutoplayButtonEnablers[i].DisableButton();
        else
            for (var i = 0; i < this.startAutoplayButtonEnablers.length; ++i) this.startAutoplayButtonEnablers[i].EnableButton()
    }
};
goog.require("UHT.Engine");
NoMoneyWindowController.prototype = Object.create(XTLink.prototype);
NoMoneyWindowController.prototype.constructor = NoMoneyWindowController;

function NoMoneyWindowController() {
    XTLink.call(this)
}
NoMoneyWindowController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_BalanceUpdated, this.OnBalanceUpdated, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_BalanceUpdatedFromResult, this.OnBalanceUpdated, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_NotEnoughMoney_pressedOK, this.OnNoMoneyPressedOK, this)
};
NoMoneyWindowController.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnBalanceUpdated, this)
};
NoMoneyWindowController.prototype.OnBalanceUpdated = function() {
    if (this.gameObject.activeSelf)
        if (CoinManager.GetNextTotalBet() <= XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived)) XT.TriggerEvent(Vars.Evt_CodeToData_HideNoMoneyWindow)
};
NoMoneyWindowController.prototype.OnNoMoneyPressedOK = function() {
    XT.TriggerEvent(Vars.Evt_CodeToData_HideNoMoneyWindow);
    if (window["UHT_DISABLEOPENCASHIEREVENT"] != true) UHTInterfaceBOSS.PostMessage("openCashier")
};
goog.require("UHT.Component");
Nike_XTEvent.prototype = Object.create(Component.prototype);
Nike_XTEvent.prototype.constructor = Nike_XTEvent;

function Nike_XTEvent() {
    Component.call(this)
}
Nike_XTEvent.prototype.JustDoIt = function(eventName) {
    XT.TriggerEvent(eventName)
};
goog.require("UHT.Engine");
SpinBlockEnabler.prototype = Object.create(Component.prototype);
SpinBlockEnabler.prototype.constructor = SpinBlockEnabler;

function SpinBlockEnabler() {
    Component.call(this)
}
SpinBlockEnabler.prototype.BlockSpin = function() {
    XT.SetBool(Vars.SpinBlockingFeatureIsRunning, true)
};
SpinBlockEnabler.prototype.UnblockSpin = function() {
    XT.SetBool(Vars.SpinBlockingFeatureIsRunning, false)
};
SpinBlockEnabler.prototype.UnBlockSpinAndResumeResult = function() {
    this.UnblockSpin();
    XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_LoopDone)
};
goog.require("UHT.Engine");
BonusRoundsTimeLeftDisplayer.prototype = Object.create(XTLink.prototype);
BonusRoundsTimeLeftDisplayer.prototype.constructor = BonusRoundsTimeLeftDisplayer;

function BonusRoundsTimeLeftDisplayer() {
    XTLink.call(this);
    this.timeLabel = null;
    this.localizedStartsInLabel_0 = null;
    this.localizedStartsInLabel_1 = null;
    this.localizedOpenLabel_0 = null;
    this.localizedOpenLabel_1 = null;
    this.localizedCloseLabel = null;
    this.localizedDayLabel_0 = null;
    this.localizedDayLabel_1 = null;
    this.localizedDaysLabel_0 = null;
    this.localizedDaysLabel_1 = null;
    this.localizedHourLabel_0 = null;
    this.localizedHourLabel_1 = null;
    this.localizedHoursLabel_0 = null;
    this.localizedHoursLabel_1 = null;
    this.localizedMinuteLabel_0 =
        null;
    this.localizedMinuteLabel_1 = null;
    this.localizedMinutesLabel_0 = null;
    this.localizedMinutesLabel_1 = null;
    this.localizedSecondLabel_0 = null;
    this.localizedSecondLabel_1 = null;
    this.localizedSecondsLabel_0 = null;
    this.localizedSecondsLabel_1 = null;
    this.maxDaysDisplayedInShortFormat = 99999;
    this.timeIsUp = null;
    this.synchedTime = 0
}
BonusRoundsTimeLeftDisplayer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackDouble(Vars.Jurisdiction_ServerTime, this.OnServerTimeChanged, this)
};
BonusRoundsTimeLeftDisplayer.prototype.OnServerTimeChanged = function(param) {
    this.synchedTime = param * .001
};
BonusRoundsTimeLeftDisplayer.prototype.Update = function() {
    this.synchedTime += Time.deltaTimeInRealTime;
    var deltaTime = Math.floor(XT.GetDouble(Vars.BonusRoundEndDateTimestamp) - this.synchedTime);
    var dhms = new Tournament.DHMS(deltaTime);
    this.timeLabel.text = this.SecondstoString(dhms)
};
BonusRoundsTimeLeftDisplayer.prototype.SecondstoString = function(dhms) {
    var ret = "";
    var d = dhms.d;
    var h = dhms.h;
    var m = dhms.m;
    var s = dhms.s;
    if (d == 1) ret += this.localizedDayLabel_0.text + d.toString() + this.localizedDayLabel_1.text;
    else if (d > 1) ret += this.localizedDaysLabel_0.text + d.toString() + this.localizedDaysLabel_1.text;
    if (d > this.maxDaysDisplayedInShortFormat) {
        ret = this.localizedDaysLabel_0.text + d.toString() + this.localizedDaysLabel_1.text;
        return ret
    }
    if (h == 1) ret += this.localizedHourLabel_0.text + h.toString() + this.localizedHourLabel_1.text;
    else if (d > 0 || h > 1) ret += this.localizedHoursLabel_0.text + h.toString() + this.localizedHoursLabel_1.text;
    var b = d == 0;
    if (b)
        if (m == 1) ret += this.localizedMinuteLabel_0.text + m.toString() + this.localizedMinuteLabel_1.text;
        else if (d > 0 || h > 0 || m > 1) ret += this.localizedMinutesLabel_0.text + m.toString() + this.localizedMinutesLabel_1.text;
    b = d == 0 && h == 0;
    if (b)
        if (d == 0)
            if (s == 1) ret += this.localizedSecondLabel_0.text + s.toString() + this.localizedSecondLabel_1.text;
            else if (d > 0 || h > 0 || m > 0 || s > 1) ret += this.localizedSecondsLabel_0.text + s.toString() +
        this.localizedSecondsLabel_1.text;
    if (d == 0 && h == 0 && m == 0 && s == 0) this.timeIsUp.Start();
    return ret
};
goog.require("UHT.Engine");
LabelTextCopy.prototype = Object.create(Component.prototype);
LabelTextCopy.prototype.constructor = LabelTextCopy;

function LabelTextCopy() {
    Component.call(this);
    this.source = null;
    this.myLabel = null
}
LabelTextCopy.prototype.Awake = function() {
    this.myLabel = this.gameObject.GetComponent(UILabel)
};
LabelTextCopy.prototype.Update = function() {
    if (this.source.text != this.myLabel.text) this.myLabel.text = this.source.text
};
goog.require("UHT.XTLink");
ClockDisplayer.prototype = Object.create(XTLink.prototype);
ClockDisplayer.prototype.constructor = ClockDisplayer;

function ClockDisplayer() {
    XTLink.call(this);
    this.hoursLabel = null;
    this.separatorLabel = null;
    this.minutesLabel = null;
    this.initialTimeZone = "";
    this.synchedTime = 0;
    this.useSynchedTime = false;
    this.isSynched = false
}
ClockDisplayer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.Jurisdiction_Clock_Server, this.OnJurisdictionClockServerChanged, this);
    XT.RegisterCallbackDouble(Vars.Jurisdiction_ServerTime, this.OnServerTimeChanged, this);
    if (window["Intl"] != undefined) this.initialTimeZone = (new Intl.DateTimeFormat).resolvedOptions().timeZone
};
ClockDisplayer.prototype.OnJurisdictionClockServerChanged = function(param) {
    this.useSynchedTime = param
};
ClockDisplayer.prototype.OnServerTimeChanged = function(param) {
    this.synchedTime = param;
    this.isSynched = true
};
ClockDisplayer.prototype.UpdateTime = function() {
    var d = new Date;
    if (this.useSynchedTime && this.isSynched)
        if (this.initialTimeZone == "" || this.initialTimeZone == undefined || window["Date"]["toLocaleString"] == undefined) d = new Date(this.synchedTime);
        else d = new Date((new Date(this.synchedTime)).toLocaleString("en-US", {
            timeZone: this.initialTimeZone
        }));
    this.hoursLabel.text = d.getHours();
    var minutes = d.getMinutes();
    this.minutesLabel.text = minutes > 9 ? minutes : "0" + minutes
};
ClockDisplayer.prototype.Update = function() {
    this.UpdateTime();
    this.synchedTime += Time.deltaTime * 1E3
};
goog.require("UHT.Engine");
SkipIntroButtonController.prototype = Object.create(XTLink.prototype);
SkipIntroButtonController.prototype.constructor = SkipIntroButtonController;

function SkipIntroButtonController() {
    XTLink.call(this);
    this.buttonSkipToOn = null;
    this.buttonSkipToOff = null
}
SkipIntroButtonController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.ShouldDisplayIntro, this.UpdateState, this)
};
SkipIntroButtonController.prototype.OnDestroy = function() {
    XT.UnregisterCallbackBool(this.UpdateState, this)
};
SkipIntroButtonController.prototype.UpdateState = function(shouldDisplay) {
    this.buttonSkipToOff.SetActive(!shouldDisplay);
    this.buttonSkipToOn.SetActive(shouldDisplay)
};
SkipIntroButtonController.prototype.OnClick = function() {
    XT.SetBool(Vars.ShouldDisplayIntro, !XT.GetBool(Vars.ShouldDisplayIntro));
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
};
goog.require("UHT.XTLink");

function PaytableScrollValues() {
    this.pagesOffset = new UHTMath.Vector3(0, -2385, 0);
    this.topPageExtraOffset = new UHTMath.Vector3(0, 0, 0);
    this.bottomPageExtraOffset = new UHTMath.Vector3(0, 1, 0);
    this.firstPageExtraDrag = new UHTMath.Vector3(0, -50, 0);
    this.lastPageExtraDrag = new UHTMath.Vector3(0, 1475, 0);
    this.scrollWheelMovement = new UHTMath.Vector3(0, 200, 0)
}
Paytable_mobile.prototype = Object.create(XTLink.prototype);
Paytable_mobile.prototype.constructor = Paytable_mobile;

function Paytable_mobile() {
    XTLink.call(this);
    this.miniScrollValues = null;
    this.miniPageFlipper = null;
    this.miniDragObject = null;
    this.miniInitialPos = null;
    this.portraitScrollValues = null;
    this.portraitPageFlipper = null;
    this.portraitDragObject = null;
    this.landscapeScrollValues = null;
    this.landscapePageFlipper = null;
    this.landscapeDragObject = null;
    this.hasAutoplayPages = true;
    this.noIntroScreenButtonPatched = false
}
Paytable_mobile.prototype.XTInitVariablesAndEvents = function() {
    this.UpdateZOrder();
    XT.SetObject(Vars.MobilePaytableObject, this);
    if (Globals.isMini) this.transform.localPosition(new UHTMath.Vector3(0, 95, -550))
};
Paytable_mobile.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableOpen, this.OnPressedPaytableOpen, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableClose, this.OnPressedPaytableClose, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableOpenHelp, this.OnShowGameHelp, this)
};
Paytable_mobile.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnPressedPaytableOpen, this);
    XT.UnregisterCallbackEvent(this.OnPressedPaytableClose, this)
};
var BT_PAYTABLE_MOBILE_SENT = false;
Paytable_mobile.prototype.OnPressedPaytableOpen = function() {
    if (!BT_PAYTABLE_MOBILE_SENT) {
        var timer = globalTracking.GetTimerValue("uht_behaviour", "Session_timer", "BehaviourTracker");
        globalTracking.SendEvent("uht_behaviour", "PAYTABLE_opened_once", timer, "BehaviourTracker");
        BT_PAYTABLE_MOBILE_SENT = true
    }
    if (Globals.isMini) this.UpdateMini();
    else this.UpdateMobile();
    this.gameObject.SetActive(true);
    if (!this.noIntroScreenButtonPatched && XT.GetBool(Vars.DisableIntroScreen)) {
        var components = this.gameObject.GetComponentsInChildren(SkipIntroButtonController,
            true);
        for (var i = 0; i < components.length; i++) components[i].gameObject.SetActive(false);
        this.noIntroScreenButtonPatched = true
    }
};
Paytable_mobile.prototype.OnPressedPaytableClose = function() {
    this.gameObject.SetActive(false)
};
Paytable_mobile.prototype.UpdateMini = function() {
    if (this.miniPageFlipper == null) this.InitMini();
    this.miniDragObject.target.position(this.miniInitialPos)
};
Paytable_mobile.prototype.InitMini = function() {
    var pageFlippers = this.GetComponentsInChildren(PageFlipper, true);
    for (var i = 0; i < pageFlippers.length; ++i) {
        var arrangeable = pageFlippers[i].GetComponent(ArrangeableActive);
        if (arrangeable == null) continue;
        if (arrangeable.activeInLandscape) {
            arrangeable.activeInLandscape = false;
            arrangeable.gameObject.SetActive(false)
        }
        if (arrangeable.activeInPortrait) {
            arrangeable.activeInLandscape = true;
            arrangeable.gameObject.SetActive(true);
            this.miniPageFlipper = pageFlippers[i];
            this.miniDragObject =
                this.miniPageFlipper.GetComponent(CustomDragObject);
            this.miniInitialPos = this.miniDragObject.target.position();
            if (XT.GetBool(Vars.Jurisdiction_Show_X_Chance)) {
                this.miniScrollValues.topPageExtraOffset.y -= 300;
                this.miniScrollValues.bottomPageExtraOffset.y -= 299;
                this.miniScrollValues.lastPageExtraDrag.y += 300
            }
            this.InitPageFlipper(this.miniPageFlipper, this.miniDragObject, this.miniScrollValues)
        }
    }
};
Paytable_mobile.prototype.UpdateMobile = function() {
    if (this.landscapePageFlipper == null) this.InitMobile();
    this.landscapeDragObject.target.position(this.landscapeDragObject.target.parent.transformPoint(this.landscapeDragObject.localPositionLimitMin));
    this.portraitDragObject.target.position(this.portraitDragObject.target.parent.transformPoint(this.portraitDragObject.localPositionLimitMin))
};
Paytable_mobile.prototype.InitMobile = function() {
    var pageFlippers = this.GetComponentsInChildren(PageFlipper, true);
    for (var i = 0; i < pageFlippers.length; ++i) {
        var arrangeable = pageFlippers[i].GetComponent(ArrangeableActive);
        if (arrangeable == null) continue;
        if (arrangeable.activeInLandscape) {
            this.landscapePageFlipper = pageFlippers[i];
            this.landscapeDragObject = this.landscapePageFlipper.GetComponent(CustomDragObject);
            this.landscapeScrollValues.pagesOffset = new UHTMath.Vector3(0, -854, 0);
            this.landscapeScrollValues.firstPageExtraDrag =
                new UHTMath.Vector3(0, -50, 0);
            if (this.hasAutoplayPages && !XT.GetBool(Vars.Jurisdiction_DisableAutoplay)) this.landscapeScrollValues.lastPageExtraDrag = XT.GetBool(Vars.HasAdvancedAutoplay) ? new UHTMath.Vector3(0, -73, 0) : new UHTMath.Vector3(0, -483, 0);
            else this.landscapeScrollValues.lastPageExtraDrag = new UHTMath.Vector3(0, -56, 0);
            if (XT.GetBool(Vars.ShowIncompleteGame)) this.landscapeScrollValues.lastPageExtraDrag = new UHTMath.Vector3(0, -433, 0);
            if (XT.GetBool(Vars.Jurisdiction_Show_X_Chance)) {
                this.landscapeScrollValues.topPageExtraOffset.y -=
                    120;
                this.landscapeScrollValues.bottomPageExtraOffset.y -= 119;
                this.landscapeScrollValues.lastPageExtraDrag.y += 120
            }
            this.landscapeScrollValues.scrollWheelMovement = new UHTMath.Vector3(0, 7.95, 0);
            this.InitPageFlipper(this.landscapePageFlipper, this.landscapeDragObject, this.landscapeScrollValues)
        }
        if (arrangeable.activeInPortrait) {
            this.portraitPageFlipper = pageFlippers[i];
            this.portraitDragObject = this.portraitPageFlipper.GetComponent(CustomDragObject);
            this.portraitScrollValues.firstPageExtraDrag = new UHTMath.Vector3(0,
                8.5, 0);
            if (this.hasAutoplayPages && !XT.GetBool(Vars.Jurisdiction_DisableAutoplay)) this.portraitScrollValues.lastPageExtraDrag = XT.GetBool(Vars.HasAdvancedAutoplay) ? new UHTMath.Vector3(0, 0, 0) : new UHTMath.Vector3(0, -1450, 0);
            else this.portraitScrollValues.lastPageExtraDrag = new UHTMath.Vector3(0, 0, 0);
            if (XT.GetBool(Vars.ShowIncompleteGame)) this.portraitScrollValues.lastPageExtraDrag = new UHTMath.Vector3(0, -1450, 0);
            if (XT.GetBool(Vars.Jurisdiction_Show_X_Chance)) {
                this.portraitScrollValues.topPageExtraOffset.y -=
                    300;
                this.portraitScrollValues.bottomPageExtraOffset.y -= 299;
                this.portraitScrollValues.lastPageExtraDrag.y += 300
            }
            this.portraitScrollValues.scrollWheelMovement = new UHTMath.Vector3(0, 23.85, 0);
            this.InitPageFlipper(this.portraitPageFlipper, this.portraitDragObject, this.portraitScrollValues)
        }
    }
};
Paytable_mobile.prototype.InitPageFlipper = function(flipper, drag, values) {
    var V3 = UHTMath.Vector3;
    flipper.isFlippingEnabled = false;
    if (!Globals.isMini) flipper.transform.localScale(new V3(.93, .93, 1));
    drag.movement = new V3(0, 1, 0);
    drag.target = flipper.transform;
    drag.cachedCamera = null;
    drag.limitPosition = true;
    var flipperPos = drag.target.localPosition();
    drag.localPositionLimitMin = V3.add(flipperPos, values.firstPageExtraDrag);
    drag.localPositionLimitMax = V3.add(flipperPos, V3.add(values.lastPageExtraDrag, V3.scale(V3.scale(V3.scale(values.pagesOffset, -1), drag.target.localScale()), flipper.topPages.length - 1)));
    drag.useScrollWheel = true;
    drag.scrollWheelMovement = this.transform.transformPoint(values.scrollWheelMovement);
    var firstPagePos = flipper.topPages[0].localPosition();
    for (var j = 0; j < flipper.topPages.length; ++j) {
        flipper.topPages[j].gameObject.SetActive(true);
        flipper.topPages[j].localPosition(V3.add(V3.add(firstPagePos, values.topPageExtraOffset), V3.scale(values.pagesOffset, j)));
        flipper.bottomPages[j].gameObject.SetActive(true);
        flipper.bottomPages[j].localPosition(V3.add(V3.add(firstPagePos,
            values.bottomPageExtraOffset), V3.scale(values.pagesOffset, j)))
    }
    var c = flipper.GetComponent(Collider);
    c.size = new V3(c.size.x, Math.abs(values.pagesOffset.y) * flipper.topPages.length, c.size.z);
    c.center = new V3(c.center.x, values.pagesOffset.y / 2 * (flipper.topPages.length - 1), c.center.z);
    var line = flipper.transform.Find("middleLine").gameObject;
    if (line != null) line.SetActive(false);
    for (var i = 0; i < flipper.topPages.length; ++i) flipper.topPages[i].Find("Content/Background").gameObject.SetActive(false);
    for (var i = 0; i <
        flipper.bottomPages.length; ++i) flipper.bottomPages[i].Find("Content/Background").gameObject.SetActive(false)
};
Paytable_mobile.prototype.UpdateZOrder = function() {
    var colliders = this.GetComponentsInChildren(Collider, true);
    for (var i = 0; i < colliders.length; ++i) {
        var p = colliders[i].transform.localPosition();
        colliders[i].transform.localPosition(new UHTMath.Vector3(p.x, p.y, 0));
        if (colliders[i].GetComponent(Paytable_mobile) != null || colliders[i].GetComponent(PageFlipper) != null) colliders[i].enabled = false
    }
};
Paytable_mobile.prototype.OnShowGameHelp = function() {
    XT.TriggerEvent(Vars.Evt_Internal_PaytableOpen);
    var landscapeGUI = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["InterfaceControllerMobile_1"]);
    var portraitGUI = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["InterfaceControllerMobile_2"]);
    if (landscapeGUI.length > 0) landscapeGUI[0].Pressed_Paytable_Open();
    if (portraitGUI.length > 0) portraitGUI[0].Pressed_Paytable_Open();
    if (landscapeGUI.length > 0)
        if (Globals.isMobile) {
            if (this.landscapePageFlipper.topPages.length >
                3) {
                var yOffset = 1591 + this.landscapeScrollValues.lastPageExtraDrag.y;
                this.landscapeDragObject.gameObject.transform.localPosition(0, this.landscapeDragObject.localPositionLimitMax.y - yOffset, 0)
            }
        } else if (this.miniPageFlipper.topPages.length > 3) this.miniDragObject.gameObject.transform.localPosition(0, this.miniDragObject.localPositionLimitMax.y - 5949, 0);
    if (portraitGUI.length > 0 && this.portraitPageFlipper.topPages.length > 3) {
        var yOffset = 4411 + this.portraitScrollValues.lastPageExtraDrag.y;
        this.portraitDragObject.gameObject.transform.localPosition(0,
            this.portraitDragObject.localPositionLimitMax.y - yOffset, 0)
    }
};
goog.require("UHT.ArrangeableBase");
MiniPaytableScrollbar.prototype = Object.create(ArrangeableBase.prototype);
MiniPaytableScrollbar.prototype.constructor = MiniPaytableScrollbar;

function MiniPaytableScrollbar() {
    ArrangeableBase.call(this);
    this.scrollbar = null;
    this.scrollbarThumb = null;
    this.scrollbarThumbDragObject = null;
    this.visiblePartOfPage = 1;
    this.blackBandsPanel = null;
    this.activeInPortrait = false;
    this.updatePaytableLayer = false;
    this.paytableLayer = null;
    this.colliderProxy = null;
    this.hasInertia = false;
    this.inertiaCurve = null;
    this.isSimpleScrollbar = false;
    this.simpleDragObject = null;
    this.simpleLocalPositionLimitMin = null;
    this.simpleLocalPositionLimitMax = null;
    this.simpleUseScrollWheel =
        false;
    this.simpleScrollWheelMovement = null;
    this.autoplayPaths = null;
    this.useYAxis = true;
    this.useStaticScroll = true;
    this.inertiaTime = 0;
    this.isInertia = false;
    this.mobilePaytable = null;
    this.isInit = false;
    this.prevThumbPos = null;
    this.prevPaytablePos = null;
    this.cachedCamera = null;
    this.scrollNonStatic = 0;
    this.scrollDelta = 0;
    this.isEnabled = true
}
MiniPaytableScrollbar.scrollStatic = 0;
MiniPaytableScrollbar.prototype.XTRegisterCallbacks = function() {
    ArrangeableBase.prototype.XTRegisterCallbacks.call(this);
    if (this.isSimpleScrollbar) return;
    XT.RegisterCallbackObject(Vars.MobilePaytableObject, this.OnMobilePaytableChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableOpen, this.OnPressedPaytableOpen, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableClose, this.OnPressedPaytableClose, this);
    if (Globals.isMini) {
        var panel = this.gameObject.GetComponent(UIPanel);
        if (panel != null) panel.depth =
            69
    }
};
MiniPaytableScrollbar.prototype.OnMobilePaytableChanged = function(param) {
    this.mobilePaytable = param;
    if (this.autoplayPaths != null && this.autoplayPaths.length > 0) {
        var roots = globalRuntime.sceneRoots;
        var found = 0;
        for (var r = 0; r < roots.length; ++r)
            for (var i = 0; i < this.autoplayPaths.length; ++i)
                if (roots[r].transform.Find(this.autoplayPaths[i]) != null) found++;
        this.mobilePaytable.hasAutoplayPages = this.autoplayPaths.length == found
    }
    if (this.updatePaytableLayer) Globals.SetLayerRecursively(this.mobilePaytable.gameObject, this.paytableLayer.value());
    var colliders = this.mobilePaytable.GetComponentsInChildren(Collider, true);
    var minZ = 0;
    for (var i = 0; i < colliders.length; ++i) {
        var z = this.transform.inverseTransformPoint(colliders[i].transform.position()).z + colliders[i].center.z;
        if (i == 0 || z < minZ) minZ = z
    }
    if (minZ <= 0) {
        var pos = this.transform.localPosition();
        this.transform.localPosition(new UHTMath.Vector3(pos.x, pos.y, pos.z + minZ - 10))
    }
    if (Globals.isMini) {
        var flippers = this.mobilePaytable.GetComponentsInChildren(PageFlipper, true);
        for (var i = 0; i < flippers.length; ++i) {
            var arrangeable =
                flippers[i].GetComponent(ArrangeableActive);
            if (arrangeable == null || arrangeable.activeInLandscape) continue;
            var maxTableDepth = Math.max(flippers[i].flippingPanelDepth, flippers[i].staticPanelDepth);
            if (this.blackBandsPanel.depth <= maxTableDepth) this.blackBandsPanel.depth = maxTableDepth + 1
        }
    } else {
        var maxPanelDepth = this.blackBandsPanel.depth;
        var flippers = this.mobilePaytable.GetComponentsInChildren(PageFlipper, true);
        for (var i = 0; i < flippers.length; ++i) {
            var maxDepth = Math.max(flippers[i].flippingPanelDepth, flippers[i].staticPanelDepth);
            if (maxDepth > maxPanelDepth) maxPanelDepth = maxDepth
        }
        var panels = this.mobilePaytable.GetComponentsInChildren(UIPanel, true);
        for (var i = 0; i < panels.length; ++i)
            if (panels[i].depth > maxPanelDepth) maxPanelDepth = panels[i].depth;
        if (this.blackBandsPanel.depth <= maxPanelDepth) this.blackBandsPanel.depth = maxPanelDepth + 1
    }
};
MiniPaytableScrollbar.prototype.OnPressedPaytableOpen = function() {
    this.gameObject.SetActive(true)
};
MiniPaytableScrollbar.prototype.OnPressedPaytableClose = function() {
    this.gameObject.SetActive(false)
};
MiniPaytableScrollbar.prototype.LateUpdate = function() {
    if (!this.isEnabled) return;
    var tableDrag = this.GetDragObject();
    var thumbDrag = this.scrollbarThumbDragObject;
    if (!this.isInit) {
        if (this.isSimpleScrollbar) {
            tableDrag.limitPosition = true;
            tableDrag.localPositionLimitMin = this.simpleLocalPositionLimitMin;
            tableDrag.localPositionLimitMax = this.simpleLocalPositionLimitMax;
            tableDrag.useScrollWheel = this.simpleUseScrollWheel;
            tableDrag.scrollWheelMovement = this.transform.transformVector(this.simpleScrollWheelMovement)
        } else {
            var flipper =
                this.GetPageFlipper();
            if (flipper == null) return;
            this.scrollbarThumb.height = this.scrollbar.height * this.visiblePartOfPage / (flipper.topPages.length * 2);
            if (this.colliderProxy != null) this.colliderProxy.boxColliders.push(tableDrag.GetComponent(Collider))
        }
        thumbDrag.limitPosition = true;
        thumbDrag.localPositionLimitMin = new UHTMath.Vector3(0, -(this.scrollbar.height - this.scrollbarThumb.height), 0);
        thumbDrag.localPositionLimitMax = UHTMath.Vector3.zero;
        this.isInit = true
    }
    var tablePos = tableDrag.target.localPosition();
    var thumbPos =
        thumbDrag.target.localPosition();
    var scroll = this.GetScroll();
    var prevScroll = scroll;
    if (this.prevPaytablePos == null || !tablePos.equals(this.prevPaytablePos)) {
        scroll = this.GetAxisValue(UHTMath.Vector3.sub(tablePos, tableDrag.localPositionLimitMin)) / this.GetAxisValue(UHTMath.Vector3.sub(tableDrag.localPositionLimitMax, tableDrag.localPositionLimitMin));
        this.scrollDelta = scroll - prevScroll;
        thumbPos = UHTMath.Vector3.lerp(thumbDrag.localPositionLimitMax, thumbDrag.localPositionLimitMin, scroll);
        thumbDrag.target.position(thumbDrag.target.parent.transformPoint(thumbPos))
    } else if (!thumbPos.equals(this.prevThumbPos)) {
        scroll =
            this.GetAxisValue(UHTMath.Vector3.sub(thumbPos, thumbDrag.localPositionLimitMax)) / this.GetAxisValue(UHTMath.Vector3.sub(thumbDrag.localPositionLimitMin, thumbDrag.localPositionLimitMax));
        this.scrollDelta = scroll - prevScroll;
        tablePos = UHTMath.Vector3.lerp(tableDrag.localPositionLimitMin, tableDrag.localPositionLimitMax, scroll);
        tableDrag.target.position(tableDrag.target.parent.transformPoint(tablePos))
    } else if (this.isInertia) {
        if (this.inertiaTime > this.inertiaCurve.keys[this.inertiaCurve.keys.length - 1].time) {
            this.isInertia =
                false;
            this.scrollDelta = 0
        }
        if (this.isInertia) {
            scroll += this.inertiaCurve.Evaluate(this.inertiaTime) * this.scrollDelta;
            scroll = UHTMath.clamp(scroll, 0, 1);
            tablePos = UHTMath.Vector3.lerp(tableDrag.localPositionLimitMin, tableDrag.localPositionLimitMax, scroll);
            tableDrag.target.position(tableDrag.target.parent.transformPoint(tablePos));
            thumbPos = UHTMath.Vector3.lerp(thumbDrag.localPositionLimitMax, thumbDrag.localPositionLimitMin, scroll);
            thumbDrag.target.position(thumbDrag.target.parent.transformPoint(thumbPos));
            this.inertiaTime += Time.deltaTime
        }
    } else this.scrollDelta = 0;
    this.prevThumbPos = thumbPos;
    this.prevPaytablePos = tablePos;
    this.SetScroll(scroll)
};
MiniPaytableScrollbar.prototype.ScrollbarClicked = function() {
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    var tableDrag = this.GetDragObject();
    var thumbDrag = this.scrollbarThumbDragObject;
    var clickPos = this.cachedCamera.ScreenToWorldPoint(Input.mousePosition);
    var thumbPos = thumbDrag.target.position();
    tableDrag.ScrollWheel(this.GetAxisValue(clickPos) < this.GetAxisValue(thumbPos) ? 1 : -1)
};
MiniPaytableScrollbar.prototype.GetPageFlipper = function() {
    if (Globals.isMini) return this.mobilePaytable.miniPageFlipper;
    else if (this.activeInPortrait) return this.mobilePaytable.portraitPageFlipper;
    return this.mobilePaytable.landscapePageFlipper
};
MiniPaytableScrollbar.prototype.GetDragObject = function() {
    if (this.isSimpleScrollbar) return this.simpleDragObject;
    if (Globals.isMini) return this.mobilePaytable.miniDragObject;
    else if (this.activeInPortrait) return this.mobilePaytable.portraitDragObject;
    return this.mobilePaytable.landscapeDragObject
};
MiniPaytableScrollbar.prototype.OnSwitchToPortrait = function() {
    if (Globals.isMini) return;
    this.isEnabled = this.activeInPortrait;
    this.OnLayoutChanged()
};
MiniPaytableScrollbar.prototype.OnSwitchToLandscape = function() {
    if (Globals.isMini) return;
    this.isEnabled = !this.activeInPortrait;
    this.OnLayoutChanged()
};
MiniPaytableScrollbar.prototype.OnLayoutChanged = function() {
    if (!this.isEnabled || !this.gameObject.activeInHierarchy) return;
    this.isInertia = false;
    var drag = this.GetDragObject();
    var pos = UHTMath.Vector3.lerp(drag.localPositionLimitMin, drag.localPositionLimitMax, this.GetScroll());
    drag.target.position(drag.target.parent.transformPoint(pos))
};
MiniPaytableScrollbar.prototype.OnColliderReleased = function() {
    if (this.isEnabled && this.hasInertia && this.scrollDelta != 0) {
        this.inertiaTime = 0;
        this.isInertia = true
    }
};
MiniPaytableScrollbar.prototype.OnColliderPressed = function() {
    if (this.isEnabled && this.hasInertia) {
        this.isInertia = false;
        this.scrollDelta = 0
    }
};
MiniPaytableScrollbar.prototype.SetScroll = function(value) {
    if (this.useStaticScroll) MiniPaytableScrollbar.scrollStatic = value;
    else this.scrollNonStatic = value
};
MiniPaytableScrollbar.prototype.GetScroll = function() {
    return this.useStaticScroll ? MiniPaytableScrollbar.scrollStatic : this.scrollNonStatic
};
MiniPaytableScrollbar.prototype.GetAxisValue = function(vector) {
    return this.useYAxis ? vector.y : vector.x
};
goog.require("UHT.Engine");
VS_GambleVisual.prototype = Object.create(XTLink.prototype);
VS_GambleVisual.prototype.constructor = VS_GambleVisual;

function VS_GambleVisual() {
    XTLink.call(this);
    this.colorMultiplier = 2;
    this.suitMultiplier = 4;
    this.currentWin = 0;
    this.openedResultWindow = ""
}
VS_GambleVisual.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackDouble(Vars.Gamble_CurrentBalance, this.OnGambleBalanceReceived, this);
    XT.RegisterCallbackDouble(Vars.Gamble_ColorMultiplier, this.OnColorMultiplierUpdate, this);
    XT.RegisterCallbackDouble(Vars.Gamble_SuitMultiplier, this.OnSuitMultiplierUpdate, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Gamble_UpdateDisplayedLabels, this.UpdateDisplayedLabels, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GambleCloseCurrentResultWindow,
        this.OnResultWindowClose, this);
    XT.RegisterCallbackBool(Vars.GameHasCustomGamble, this.OnGameHasCustomGamble, this)
};
VS_GambleVisual.prototype.OnGameHasCustomGamble = function(param) {
    if (param) this.OnDestroy()
};
VS_GambleVisual.prototype.OnDestroy = function() {
    XT.UnregisterCallbackDouble(this.OnGambleBalanceReceived, this);
    XT.UnregisterCallbackDouble(this.OnColorMultiplierUpdate, this);
    XT.UnregisterCallbackDouble(this.OnSuitMultiplierUpdate, this);
    XT.UnregisterCallbackEvent(this.UpdateDisplayedLabels, this);
    XT.UnregisterCallbackEvent(this.OnResultWindowClose, this);
    XT.UnregisterCallbackBool(this.OnGameHasCustomGamble, this)
};
VS_GambleVisual.prototype.UpdateDisplayedLabels = function() {
    XT.SetDouble(Vars.Gamble_CurrentBalanceDisplayed, this.currentWin);
    this.UpdatePossibleWins(this.currentWin)
};
VS_GambleVisual.prototype.UpdatePossibleWins = function(currentWin) {
    XT.SetDouble(Vars.Gamble_ColorWinDisplayed, currentWin * this.colorMultiplier);
    XT.SetDouble(Vars.Gamble_SuitWinDisplayed, currentWin * this.suitMultiplier)
};
VS_GambleVisual.prototype.OnGambleBalanceReceived = function(win) {
    this.currentWin = win
};
VS_GambleVisual.prototype.OnColorMultiplierUpdate = function(multiplier) {
    this.colorMultiplier = multiplier
};
VS_GambleVisual.prototype.OnSuitMultiplierUpdate = function(multiplier) {
    this.suitMultiplier = multiplier
};
VS_GambleVisual.prototype.OnResultWindowClose = function() {
    if (this.openedResultWindow == "WIN") XT.TriggerEvent(Vars.Evt_CodeToData_GambleCloseResultWindowWin);
    else if (this.openedResultWindow == "LOSE") XT.TriggerEvent(Vars.Evt_CodeToData_GambleCloseResultWindowLose);
    this.openedResultWindow = ""
};
VS_GambleVisual.prototype.ShowResultWindow = function(param) {
    this.openedResultWindow = param;
    if (param == "WIN") {
        XT.SetDouble(Vars.Gamble_FinalBalanceDisplayed, this.currentWin);
        XT.TriggerEvent(Vars.Evt_CodeToData_GambleShowResultWindowWin)
    } else XT.TriggerEvent(Vars.Evt_CodeToData_GambleShowResultWindowLose)
};
goog.require("UHT.Engine");
VS_GambleProgressDisplayer.prototype = Object.create(XTLink.prototype);
VS_GambleProgressDisplayer.prototype.constructor = VS_GambleProgressDisplayer;

function GambleProgressObject() {
    this.itemIndex = 0;
    this.itemID = 0;
    this.isFromInit = false
}

function VS_GambleProgressDisplayer() {
    XTLink.call(this)
}
VS_GambleProgressDisplayer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Gamble_DisplayHistory, this.OnHistoryDisplayed, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Gamble_DisplayProgress, this.OnProgressDisplayed, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Gamble_ClearProgress, this.OnProgressClear, this);
    XT.RegisterCallbackBool(Vars.GameHasCustomGamble, this.OnGameHasCustomGamble, this)
};
VS_GambleProgressDisplayer.prototype.OnGameHasCustomGamble = function(param) {
    if (param) this.OnDestroy()
};
VS_GambleProgressDisplayer.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnHistoryDisplayed, this);
    XT.UnregisterCallbackEvent(this.OnProgressDisplayed, this);
    XT.UnregisterCallbackEvent(this.OnProgressClear, this);
    XT.UnregisterCallbackBool(this.OnGameHasCustomGamble, this)
};
VS_GambleProgressDisplayer.prototype.OnHistoryDisplayed = function() {
    var histoyObj = XT.GetObject(Vars.FromServer_GambleHistory);
    var history = histoyObj.History;
    for (var i = 0; i < history.length; i++) {
        var progObj = XT.GetObject(Vars.Gamble_CurrentProgressObject);
        progObj.isFromInit = true;
        progObj.itemIndex = i + 1;
        progObj.itemID = history[i].GetCard();
        XT.TriggerEvent(Vars.Evt_Internal_Gamble_UpdateCurrentProgress)
    }
};
VS_GambleProgressDisplayer.prototype.OnProgressDisplayed = function() {
    var progObj = XT.GetObject(Vars.Gamble_CurrentProgressObject);
    progObj.isFromInit = false;
    var gamblingResp = XT.GetObject(Vars.FromServer_GambleResult);
    progObj.itemID = gamblingResp.GetCard();
    progObj.itemIndex++;
    XT.TriggerEvent(Vars.Evt_Internal_Gamble_UpdateCurrentProgress)
};
VS_GambleProgressDisplayer.prototype.OnProgressClear = function() {
    var progObj = XT.GetObject(Vars.Gamble_CurrentProgressObject);
    progObj.itemIndex = 0
};
goog.require("UHT.Engine");
VS_GambleProgressItem.prototype = Object.create(XTLink.prototype);
VS_GambleProgressItem.prototype.constructor = VS_GambleProgressItem;

function VS_GambleProgressItem() {
    XTLink.call(this);
    this.itemIndex = 0;
    this.Cat = null;
    this.EventSetRed = null;
    this.EventSetBlack = null;
    this.EventShowOnInit = null;
    this.EventShowAfterPick = null;
    this.EventReset = null
}
VS_GambleProgressItem.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Gamble_ClearProgress, this.OnProgressClear, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Gamble_UpdateCurrentProgress, this.OnProgressUpdate, this);
    XT.RegisterCallbackBool(Vars.GameHasCustomGamble, this.OnGameHasCustomGamble, this)
};
VS_GambleProgressItem.prototype.OnGameHasCustomGamble = function(param) {
    if (param) this.OnDestroy()
};
VS_GambleProgressItem.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnProgressClear, this);
    XT.UnregisterCallbackEvent(this.OnProgressUpdate, this);
    XT.UnregisterCallbackBool(this.OnGameHasCustomGamble, this)
};
VS_GambleProgressItem.prototype.OnProgressClear = function() {
    this.Cat.StartEvent(this.EventReset.id)
};
VS_GambleProgressItem.prototype.OnProgressUpdate = function() {
    var progObj = XT.GetObject(Vars.Gamble_CurrentProgressObject);
    if (this.itemIndex != progObj.itemIndex) return;
    switch (Math.floor(progObj.itemID / 26)) {
        case 0:
            this.Cat.StartEvent(this.EventSetBlack.id);
            break;
        case 1:
            this.Cat.StartEvent(this.EventSetRed.id);
            break
    }
    if (progObj.isFromInit) this.Cat.StartEvent(this.EventShowOnInit.id);
    else this.Cat.StartEvent(this.EventShowAfterPick.id)
};
goog.require("UHT.Engine");
Interface_GambleCard.prototype = Object.create(XTLink.prototype);
Interface_GambleCard.prototype.constructor = Interface_GambleCard;

function Interface_GambleCard() {
    XTLink.call(this);
    this.animatedObject = null;
    this.stopInLoops = 2;
    this.loopsBeforeStop = 0;
    this.isRed = false;
    this.mustStop = false
}
Interface_GambleCard.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Gamble_PickResult_Handled, this.OnResultHandled, this);
    XT.RegisterCallbackBool(Vars.GameHasCustomGamble, this.OnGameHasCustomGamble, this)
};
Interface_GambleCard.prototype.OnGameHasCustomGamble = function(param) {
    if (param) this.OnDestroy()
};
Interface_GambleCard.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnResultHandled, this);
    XT.UnregisterCallbackBool(this.OnGameHasCustomGamble, this)
};
Interface_GambleCard.prototype.OnDisable = function() {
    XT.TriggerEvent(Vars.Evt_Internal_StopGambleShuffleCard)
};
Interface_GambleCard.prototype.OnResultHandled = function() {
    var pickedID = XT.GetInt(Vars.Gamble_PickResult_ItemID);
    if (pickedID < 26) this.SetAsBlack();
    else this.SetAsRed()
};
Interface_GambleCard.prototype.IsVisibleRed = function() {
    if (this.mustStop) this.loopsBeforeStop--;
    if (this.mustStop && this.isRed)
        if (this.loopsBeforeStop < 1) {
            this.animatedObject.animation.GetAnimationState(this.animatedObject.animation.clip.name).speed = 0;
            XT.TriggerEvent(Vars.Evt_Internal_StopGambleShuffleCard);
            XT.TriggerEvent(Vars.Evt_Internal_PlayGambleShufflingStop)
        }
};
Interface_GambleCard.prototype.IsVisibleBlack = function() {
    if (this.mustStop) this.loopsBeforeStop--;
    if (this.mustStop && !this.isRed)
        if (this.loopsBeforeStop < 1) {
            this.animatedObject.animation.GetAnimationState(this.animatedObject.animation.clip.name).speed = 0;
            XT.TriggerEvent(Vars.Evt_Internal_StopGambleShuffleCard);
            XT.TriggerEvent(Vars.Evt_Internal_PlayGambleShufflingStop)
        }
};
Interface_GambleCard.prototype.SetAsRed = function() {
    this.isRed = true
};
Interface_GambleCard.prototype.SetAsBlack = function() {
    this.isRed = false
};
Interface_GambleCard.prototype.StartShuffling = function() {
    this.mustStop = false;
    this.loopsBeforeStop = this.stopInLoops;
    if (!this.animatedObject.animation.isPlaying) this.animatedObject.animation.Play();
    this.animatedObject.animation.GetAnimationState(this.animatedObject.animation.clip.name).speed = 1;
    XT.TriggerEvent(Vars.Evt_Internal_PlayGambleShuffleCard)
};
Interface_GambleCard.prototype.StopShuffling = function() {
    this.mustStop = true
};
goog.require("UHT.Engine");
RatingWindowController.prototype = Object.create(XTLink.prototype);
RatingWindowController.prototype.constructor = RatingWindowController;

function RatingWindowController() {
    XTLink.call(this);
    this.showWindow = null;
    this.hideWindow = null;
    this.rateLucky = null;
    this.rateLuckyUpdateState = null;
    this.ratePretty = null;
    this.ratePrettyUpdateState = null;
    this.okButton = null;
    this.happyRating = 3;
    this.numberOfWinsBeforeRating = 30;
    this.disabled = true;
    this.luckyRating = 0;
    this.prettyRating = 0;
    this.numberOfWins = 0;
    this.mustShowWindow = false;
    this.numSkipClicked = 0;
    this.numClicksToSkip = 3
}
RatingWindowController.prototype.ShowWindow = function() {
    this.SwitchOkButton();
    this.showWindow.Start()
};
RatingWindowController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
};
RatingWindowController.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(Vars.GameIsRated, false);
    XT.SetBool(Vars.RatingSkipped, false)
};
RatingWindowController.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGameInit, this)
};
RatingWindowController.prototype.OnGameInit = function() {
    if (ServerOptions.noRating || this.disabled) return;
    if (!XT.GetBool(Vars.GameIsRated) && !XT.GetBool(Vars.RatingSkipped)) XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinEnded, this.OnSpinEnded, this)
};
RatingWindowController.prototype.OnSpinEnded = function() {
    if (XT.GetDouble(Vars.WinReceived) > 0) {
        this.numberOfWins++;
        if (this.numberOfWins >= this.numberOfWinsBeforeRating) this.mustShowWindow = true
    } else {
        var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
        var isFreeSpin = fsr != null && fsr.IsFreeSpin;
        var isAutoSpin = XT.GetInt(Vars.AutoplaySpinsLeft) > 0;
        if (this.mustShowWindow && !isFreeSpin && !isAutoSpin) {
            this.ShowWindow();
            XT.UnregisterCallbackEvent(this.OnSpinEnded, this)
        }
    }
};
RatingWindowController.prototype.RateLucky = function(idx) {
    var index = _number.otoi(idx);
    var rating = index + 1;
    var updateState = this.luckyRating != rating && (this.luckyRating >= this.happyRating && rating < this.happyRating || this.luckyRating < this.happyRating && rating >= this.happyRating);
    if (updateState) this.rateLuckyUpdateState[index].Start();
    else this.rateLucky[index].Start();
    this.luckyRating = rating;
    this.SwitchOkButton()
};
RatingWindowController.prototype.RatePretty = function(idx) {
    var index = _number.otoi(idx);
    var rating = index + 1;
    var updateState = this.prettyRating != rating && (this.prettyRating >= this.happyRating && rating < this.happyRating || this.prettyRating < this.happyRating && rating >= this.happyRating);
    if (updateState) this.ratePrettyUpdateState[index].Start();
    else this.ratePretty[index].Start();
    this.prettyRating = rating;
    this.SwitchOkButton()
};
RatingWindowController.prototype.SwitchOkButton = function() {
    var buttons = this.okButton.GetComponents(UIButton);
    var isEnabled = this.luckyRating > 0 && this.prettyRating > 0;
    for (var i = 0; i < buttons.length; ++i) buttons[i].SetEnabled(isEnabled)
};
RatingWindowController.prototype.OkButtonClicked = function() {
    globalTracking.SendTimer("Rating", "Lucky", this.luckyRating * 1E3, "RatingTracker");
    globalTracking.SendTimer("Rating", "Pretty", this.prettyRating * 1E3, "RatingTracker");
    XT.SetBool(Vars.GameIsRated, true);
    XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer);
    this.hideWindow.Start()
};
RatingWindowController.prototype.CloseButtonClicked = function() {
    globalTracking.SendTimer("Rating", "SkippedLucky", this.luckyRating * 1E3, "RatingTracker");
    globalTracking.SendTimer("Rating", "SkippedPretty", this.prettyRating * 1E3, "RatingTracker");
    XT.SetBool(Vars.RatingSkipped, true);
    XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer);
    this.hideWindow.Start()
};
RatingWindowController.prototype.SkipButtonClicked = function() {
    ++this.numSkipClicked;
    if (this.numSkipClicked >= this.numClicksToSkip) {
        XT.SetBool(Vars.GameIsRated, true);
        XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
        XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer);
        this.hideWindow.Start()
    }
};
goog.require("UHT.XTLink");
QuickSpinWindowController.prototype = Object.create(XTLink.prototype);
QuickSpinWindowController.prototype.constructor = QuickSpinWindowController;

function QuickSpinWindowController() {
    XTLink.call(this);
    this.showWindow = null;
    this.disableWindow = null;
    this.numberOfSpinsBeforeWindow = 5;
    this.numberOfStopsBeforeWindow = 3;
    this.numberOfSpins = 0;
    this.numberOfStops = 0;
    this.isFreeSpin = false;
    this.isAutoSpin = false;
    this.spinStopped = false
}
QuickSpinWindowController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
};
QuickSpinWindowController.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(InterfaceVars.ShowFastPlayHint, true)
};
QuickSpinWindowController.prototype.OnGameInit = function() {
    if (XT.GetBool(Vars.FastPlay) || !XT.GetBool(InterfaceVars.ShowFastPlayHint) || XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) {
        this.disableWindow.Start();
        return
    }
    XT.RegisterCallbackBool(Vars.Logic_IsFreeSpin, this.OnIsFreeSpinChanged, this);
    XT.RegisterCallbackBool(Vars.FastPlay, this.OnQuickSpinChanged, this);
    XT.RegisterCallbackBool(Vars.ContinuousSpin, this.OnQuickSpinChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinEnded, this.OnSpinEnded,
        this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelManager_StopSpin, this.OnStopSpin, this);
    XT.RegisterCallbackInt(Vars.AutoplaySpinsLeft, this.OnAutoplaySpinsLeftChanged, this)
};
QuickSpinWindowController.prototype.OnAutoplaySpinsLeftChanged = function(param) {
    this.isAutoSpin = param >= 0;
    if (this.isAutoSpin) {
        this.numberOfSpins = 0;
        this.numberOfStops = 0;
        this.spinStopped = false
    }
};
QuickSpinWindowController.prototype.OnIsFreeSpinChanged = function(param) {
    this.isFreeSpin = param;
    if (this.isFreeSpin) {
        this.numberOfSpins = 0;
        this.numberOfStops = 0;
        this.spinStopped = false
    }
};
QuickSpinWindowController.prototype.OnQuickSpinChanged = function(param) {
    if (param) this.xtEnabled = false
};
QuickSpinWindowController.prototype.OnStopSpin = function() {
    if (this.isFreeSpin || this.isAutoSpin) return;
    this.spinStopped = true
};
QuickSpinWindowController.prototype.OnSpinEnded = function() {
    if (this.isFreeSpin || this.isAutoSpin) return;
    this.numberOfSpins++;
    if (this.spinStopped) this.numberOfStops++;
    else this.numberOfStops = 0;
    this.spinStopped = false;
    if (XT.GetDouble(Vars.WinReceived) <= 0)
        if (this.numberOfSpins >= this.numberOfSpinsBeforeWindow && this.numberOfStops >= this.numberOfStopsBeforeWindow) {
            this.showWindow.Start();
            this.xtEnabled = false;
            XT.SetBool(InterfaceVars.ShowFastPlayHint, false);
            XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer,
                true);
            XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
        }
};

function RandomAwardsResponse() {
    this.awardIndex = -1;
    this.awardPositionInReel = -1;
    this.currentReelIndex = -1;
    this.nextReelIndex = -1
}
RandomAwardsResponse.prototype.Clone = function() {
    var clone = new RandomAwardsResponse;
    clone.awardIndex = this.awardIndex;
    clone.awardPositionInReel = this.awardPositionInReel;
    clone.currentReelIndex = this.currentReelIndex;
    clone.nextReelIndex = this.nextReelIndex;
    return clone
};
goog.provide("UHT.FreeSpinsResponse");

function FreeSpinsResponse() {
    this._currentSpin = 0;
    this._maxSpins = 0;
    this._oldMaxSpins = 0;
    this._additionalSpins = 0;
    this._totalSpins = 0;
    this._totalMultiplier = 1;
    this._currentWin = 0;
    this._currentWinMultiplied = 0;
    this._totalWin = 0;
    this._totalWinMultiplied = 0;
    this._pickedOptionIndex = -1;
    this._bonusGameData = null;
    this._mysteryScatter = [];
    this._needGetMysteryScatter = false;
    this._isFreeSpin = false;
    this._isFreeSpinsStart = false;
    this._isFreeSpinsGambled = false;
    Object.defineProperty(this, "CurrentSpin", {
        get: function() {
            return this._currentSpin
        }
    });
    Object.defineProperty(this, "MaxSpins", {
        get: function() {
            return this._maxSpins
        }
    });
    Object.defineProperty(this, "OldMaxSpins", {
        get: function() {
            return this._oldMaxSpins
        }
    });
    Object.defineProperty(this, "AdditionalSpins", {
        get: function() {
            return this._additionalSpins
        }
    });
    Object.defineProperty(this, "TotalSpins", {
        get: function() {
            return this._totalSpins
        },
        set: function(value) {
            this._totalSpins = value
        }
    });
    Object.defineProperty(this, "TotalMultiplier", {
        get: function() {
            return this._totalMultiplier
        }
    });
    Object.defineProperty(this,
        "CurrentWin", {
            get: function() {
                return this._currentWin
            },
            set: function(value) {
                this._currentWin = value
            }
        });
    Object.defineProperty(this, "CurrentWinMultiplied", {
        get: function() {
            return this._currentWinMultiplied
        }
    });
    Object.defineProperty(this, "TotalWin", {
        get: function() {
            return this._totalWin
        }
    });
    Object.defineProperty(this, "TotalWinMultiplied", {
        get: function() {
            return this._totalWinMultiplied
        }
    });
    Object.defineProperty(this, "PickedOptionIndex", {
        get: function() {
            return this._pickedOptionIndex
        }
    });
    Object.defineProperty(this,
        "IsFreeSpin", {
            get: function() {
                return this._isFreeSpin
            }
        });
    Object.defineProperty(this, "IsFreeSpinsStart", {
        get: function() {
            return this._isFreeSpinsStart || this.IsFreeSpinsCollected && this._bonusGameData != null
        }
    });
    Object.defineProperty(this, "IsLastFreeSpin", {
        get: function() {
            return this.IsFreeSpin && this.TotalSpins > 0
        }
    });
    Object.defineProperty(this, "IsFreeSpinsCollected", {
        get: function() {
            return this.IsFreeSpin && this._currentSpin == 0 && this._maxSpins == 0 && this._totalSpins == 0
        }
    });
    Object.defineProperty(this, "IsFreeSpinsGambled", {
        get: function() {
            return this._isFreeSpinsGambled
        },
        set: function(value) {
            this._isFreeSpinsGambled = value
        }
    });
    Object.defineProperty(this, "IsNeedGetMysteryScatter", {
        get: function() {
            return this._needGetMysteryScatter
        }
    });
    Object.defineProperty(this, "BonusGameData", {
        get: function() {
            return this._bonusGameData
        },
        set: function(value) {
            this._bonusGameData = value
        }
    });
    Object.defineProperty(this, "MysteryScatter", {
        get: function() {
            return this._mysteryScatter
        }
    });
    this.FreeSpinsType = -1
}
FreeSpinsResponse.prototype.CurrentSpin = 0;
FreeSpinsResponse.prototype.MaxSpins = 0;
FreeSpinsResponse.prototype.OldMaxSpins = 0;
FreeSpinsResponse.prototype.AdditionalSpins = 0;
FreeSpinsResponse.prototype.TotalSpins = 0;
FreeSpinsResponse.prototype.TotalMultiplier = 0;
FreeSpinsResponse.prototype.CurrentWin = 0;
FreeSpinsResponse.prototype.CurrentWinMultiplied = 0;
FreeSpinsResponse.prototype.TotalWin = 0;
FreeSpinsResponse.prototype.TotalWinMultiplied = 0;
FreeSpinsResponse.prototype.PickedOptionIndex = 0;
FreeSpinsResponse.prototype.IsFreeSpin = false;
FreeSpinsResponse.prototype.IsFreeSpinsStart = false;
FreeSpinsResponse.prototype.IsLastFreeSpin = false;
FreeSpinsResponse.prototype.IsFreeSpinsCollected = false;
FreeSpinsResponse.prototype.IsFreeSpinsGambled = false;
FreeSpinsResponse.prototype.IsNeedGetMysteryScatter = false;
FreeSpinsResponse.prototype.BonusGameData = null;
FreeSpinsResponse.prototype.MysteryScatter = [];
FreeSpinsResponse.prototype.SetFreeSpinsResponse = function(_fsResponse) {
    if (_fsResponse == null) {
        this._isFreeSpin = false;
        this._isFreeSpinsStart = false;
        this._isFreeSpinsGambled = false;
        return
    }
    if (_fsResponse.BonusGame != null) {
        var cloned_bonus_game = _fsResponse.BonusGame.Clone();
        this._bonusGameData = new FreeSpinsResponse.BonusGame;
        this._bonusGameData.GameOver = cloned_bonus_game.GameOver;
        this._bonusGameData.Level = cloned_bonus_game.Level;
        this._bonusGameData.Lifes = cloned_bonus_game.Lifes;
        this._bonusGameData.MultipliersWin =
            cloned_bonus_game.MultipliersWin;
        this._bonusGameData.SpinsWin = cloned_bonus_game.SpinsWin;
        this._bonusGameData.SetBonusItems(cloned_bonus_game.BonusItems)
    } else this._bonusGameData = null;
    this._currentSpin = _fsResponse.GetCurrentNumber();
    if (this._maxSpins != 0) this._oldMaxSpins = this._maxSpins;
    this._maxSpins = _fsResponse.GetMaxNumber();
    this._totalSpins = _fsResponse.GetTotalNumber();
    this._totalMultiplier = _fsResponse.GetTotalMultipl();
    this._currentWin = _fsResponse.GetCurrentWin();
    this._currentWinMultiplied = _fsResponse.GetCurrentWinMultiplied();
    this._totalWin = _fsResponse.GetTotalWin();
    this._totalWinMultiplied = _fsResponse.GetTotalWinMultiplied();
    this._pickedOptionIndex = _fsResponse.PickedOptionIndex;
    this._mysteryScatter = _fsResponse.GetMysteryScatter();
    this._needGetMysteryScatter = _fsResponse.IsNeedGetMysteryScatter();
    this._isFreeSpinsStart = this._currentSpin == 1;
    this._isFreeSpin = true;
    this.FreeSpinsType = _fsResponse.fstype;
    if (this._isFreeSpinsStart) {
        this._oldMaxSpins = 0;
        this._additionalSpins = 0
    } else {
        if (this._oldMaxSpins == 0) this._oldMaxSpins = this._maxSpins;
        this._additionalSpins = this._maxSpins - this._oldMaxSpins
    }
};
FreeSpinsResponse.BonusGame = function() {
    this._gameOver = false;
    this._level = 0;
    this._lifes = null;
    this._spinsWin = 0;
    this._multipliersWin = 0;
    this._bonusItems = [];
    Object.defineProperty(this, "GameOver", {
        get: function() {
            return this._gameOver
        },
        set: function(value) {
            this._gameOver = value
        }
    });
    Object.defineProperty(this, "Level", {
        get: function() {
            return this._level
        },
        set: function(value) {
            this._level = value
        }
    });
    Object.defineProperty(this, "Lifes", {
        get: function() {
            return this._lifes
        },
        set: function(value) {
            this._lifes = value
        }
    });
    Object.defineProperty(this,
        "SpinsWin", {
            get: function() {
                return this._spinsWin
            },
            set: function(value) {
                this._spinsWin = value
            }
        });
    Object.defineProperty(this, "MultipliersWin", {
        get: function() {
            return this._multipliersWin
        },
        set: function(value) {
            this._multipliersWin = value
        }
    });
    Object.defineProperty(this, "BonusItems", {
        get: function() {
            return this._bonusItems
        },
        set: function(value) {
            this._bonusItems = value
        }
    })
};
FreeSpinsResponse.BonusGame.prototype.GameOver = false;
FreeSpinsResponse.BonusGame.prototype.Level = 0;
FreeSpinsResponse.BonusGame.prototype.Lifes = null;
FreeSpinsResponse.BonusGame.prototype.SpinsWin = 0;
FreeSpinsResponse.BonusGame.prototype.MultipliersWin = 0;
FreeSpinsResponse.BonusGame.prototype.BonusItems = null;
FreeSpinsResponse.BonusGame.prototype.SetBonusItems = function(ngcBonusItems) {
    this._bonusItems = [];
    for (var i = 0; i < ngcBonusItems.length; ++i) {
        var ngc_bi = ngcBonusItems[i];
        var new_bi = new FreeSpinsResponse.BonusItem(ngc_bi.Value, FreeSpinsResponse.BonusItem.ParseNgcBonusItemStatus(ngc_bi.Status), FreeSpinsResponse.BonusItem.ParseNgcBonusItemType(ngc_bi.Type));
        this._bonusItems.push(new_bi)
    }
};
FreeSpinsResponse.BonusItem = function(value, status, type) {
    this._value = value;
    this._status = status;
    this._type = type;
    Object.defineProperty(this, "Status", {
        get: function() {
            return this._status
        },
        set: function(value) {
            this._status = value
        }
    });
    Object.defineProperty(this, "Type", {
        get: function() {
            return this._type
        },
        set: function(value) {
            this._type = value
        }
    });
    Object.defineProperty(this, "Value", {
        get: function() {
            return this._value
        },
        set: function(value) {
            this._value = value
        }
    })
};
FreeSpinsResponse.BonusItem.BonusItemStatus = {
    Available: 0,
    Selected: 1
};
FreeSpinsResponse.BonusItem.BonusItemType = {
    Spin: 0,
    Multiplier: 1
};
FreeSpinsResponse.BonusItem.ParseNgcBonusItemStatus = function(status) {
    switch (status) {
        case VsFreeSpinBonusGame.BonusItem.BonusItemStatus.Selected:
            return FreeSpinsResponse.BonusItem.BonusItemStatus.Selected;
        default:
            return FreeSpinsResponse.BonusItem.BonusItemStatus.Available
    }
};
FreeSpinsResponse.BonusItem.ParseNgcBonusItemType = function(type) {
    switch (type) {
        case VsFreeSpinBonusGame.BonusItem.BonusItemType.Multiplier:
            return FreeSpinsResponse.BonusItem.BonusItemType.Multiplier;
        default:
            return FreeSpinsResponse.BonusItem.BonusItemType.Spin
    }
};
FreeSpinsResponse.BonusItem.prototype.Status = FreeSpinsResponse.BonusItem.BonusItemStatus.Available;
FreeSpinsResponse.BonusItem.prototype.Type = FreeSpinsResponse.BonusItem.BonusItemType.Spin;
FreeSpinsResponse.BonusItem.prototype.Value = 0;
FreeSpinsResponse.BonusItem.prototype.ToString = function() {
    return "BonusItem {" + "Status=" + this._status + ", Type=" + this._type + ", Value=" + this._value + "}"
};

function BonusData() {
    this.Coef = 0;
    this.GameOver = false;
    this.Level = 0;
    this.Life = 0;
    this.RealWin = 0;
    this.WinPoints = 0;
    this.PossibleWins = null;
    this.ItemsMarkers = null;
    this.ItemsStatus = null;
    this.ItemsWins = null;
    this.WinsMask = null;
    this.MultipliersMarkers = null;
    this.MultipliersStatus = null;
    this.MultipliersWins = null;
    this.LifeWins = null;
    this.MultiplierStep = false;
    this.numberOfLevels = 0;
    this.isBonusGambled = false;
    this.currentBonusRespin = 0;
    this.maxBonusRespins = 0;
    this.respinSymbols = null;
    this.PremultipliedWin = 0;
    this.MultipliedSymbolPositions =
        null;
    this.RespinsTotalMultiplier = -1;
    this.ExtraRespinsWon = -1;
    this.ExtraRetriggersWon = -1;
    this.BGItemValues = null;
    this.BGItemMasks = null;
    this.GameID = 0;
    this.GameType = 0;
    this.WheelOfFortune = null;
    this.Map = null;
    this.justReceived = false
}
BonusData.prototype.HasMultipliers = function() {
    return this.MultipliersStatus != null
};
BonusData.prototype.HasMultipleLevels = function() {
    return this.ItemsMarkers != null
};
BonusData.prototype.ConstrainedLevel = function() {
    return Math.min(this.numberOfLevels, this.GameOver ? this.Level + 1 : this.Level)
};
BonusData.prototype.GetCurrentLevelIndex = function() {
    var rv = this.Level;
    if (rv >= this.numberOfLevels) rv = this.numberOfLevels - 1;
    return rv
};
goog.require("UHT.XTLink");
var FeatureManagerParamType = {
    None: 0,
    Bool: 1,
    Int: 2,
    Float: 3,
    Double: 4,
    String: 5,
    XT_Bool: 6,
    XT_Int: 7,
    XT_Float: 8,
    XT_Double: 9,
    XT_String: 10,
    XT_Object: 11
};
var FeatureManagerCallbackType = {
    XT_Event: 0,
    XT_Object: 1,
    XT_String: 2,
    XT_Double: 3,
    XT_Float: 4,
    XT_Int: 5,
    XT_Bool: 6
};
var FeatureManagerIDSource = {
    None: 0,
    Bonus: 1,
    FreeSpin: 2,
    RandomAward: 3,
    RandomAwardFreeSpin: 4
};

function FeatureManagerMessage() {
    this.eventReceiver = null;
    this.methodToCall = "";
    this.paramType = FeatureManagerParamType.None;
    this.param = ""
}

function FeatureManagerXTCallback() {
    this.onlyDuringFeature = true;
    this.type = FeatureManagerCallbackType.XT_Event;
    this.name = "";
    this.priority = 0;
    this.cat = null;
    this.messages = null;
    this.mng = null
}
FeatureManagerXTCallback.prototype.RegisterCallback = function(param) {
    this.mng = param;
    switch (this.type) {
        case FeatureManagerCallbackType.XT_Event:
            XT.RegisterCallbackEvent(this.name, this.OnEvent, this, this.priority);
            break;
        case FeatureManagerCallbackType.XT_Object:
            XT.RegisterCallbackObject(this.name, this.OnObject, this);
            break;
        case FeatureManagerCallbackType.XT_String:
            XT.RegisterCallbackString(this.name, this.OnString, this);
            break;
        case FeatureManagerCallbackType.XT_Double:
            XT.RegisterCallbackDouble(this.name,
                this.OnDouble, this);
            break;
        case FeatureManagerCallbackType.XT_Float:
            XT.RegisterCallbackFloat(this.name, this.OnFloat, this);
            break;
        case FeatureManagerCallbackType.XT_Int:
            XT.RegisterCallbackInt(this.name, this.OnInt, this);
            break;
        case FeatureManagerCallbackType.XT_Bool:
            XT.RegisterCallbackBool(this.name, this.OnBool, this);
            break
    }
};
FeatureManagerXTCallback.prototype.OnEvent = function() {
    this.mng.XTCallback(this)
};
FeatureManagerXTCallback.prototype.OnObject = function(param) {
    this.mng.XTCallback(this)
};
FeatureManagerXTCallback.prototype.OnString = function(param) {
    this.mng.XTCallback(this)
};
FeatureManagerXTCallback.prototype.OnDouble = function(param) {
    this.mng.XTCallback(this)
};
FeatureManagerXTCallback.prototype.OnFloat = function(param) {
    this.mng.XTCallback(this)
};
FeatureManagerXTCallback.prototype.OnInt = function(param) {
    this.mng.XTCallback(this)
};
FeatureManagerXTCallback.prototype.OnBool = function(param) {
    this.mng.XTCallback(this)
};
FeatureManager.prototype = Object.create(XTLink.prototype);
FeatureManager.prototype.constructor = FeatureManager;

function FeatureManager() {
    XTLink.call(this);
    this.featureID = 0;
    this.featureIDSources = null;
    this.XTCallbacks = null;
    this.awardsConfig = null;
    this.awardsResponse = null;
    this.freeSpinsResponse = null;
    this.bonusData = null
}
FeatureManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.RandomAwardsConfig, this.OnAwardsConfig, this);
    XT.RegisterCallbackObject(Vars.RandomAwardsResponse, this.OnAwardsResponse, this);
    XT.RegisterCallbackObject(Vars.ReceivedFreeSpinsResponse, this.OnFreeSpinsResponse, this);
    XT.RegisterCallbackObject(Vars.BonusData, this.OnBonusData, this);
    for (var i = 0; i < this.XTCallbacks.length; ++i) this.XTCallbacks[i].RegisterCallback(this)
};
FeatureManager.prototype.OnBonusData = function(param) {
    this.bonusData = param
};
FeatureManager.prototype.OnFreeSpinsResponse = function(param) {
    this.freeSpinsResponse = param
};
FeatureManager.prototype.OnAwardsConfig = function(obj) {
    this.awardsConfig = obj
};
FeatureManager.prototype.OnAwardsResponse = function(obj) {
    this.awardsResponse = obj
};
FeatureManager.prototype.XTCallback = function(param) {
    if (param.onlyDuringFeature) {
        var id = -1;
        for (var i = 0; i < this.featureIDSources.length; ++i) switch (this.featureIDSources[i]) {
            case FeatureManagerIDSource.Bonus:
                if (this.bonusData != null) id = this.bonusData.GameID;
                break;
            case FeatureManagerIDSource.FreeSpin:
                if (this.freeSpinsResponse != null && this.freeSpinsResponse.IsFreeSpin) id = this.freeSpinsResponse.FreeSpinsType;
                break;
            case FeatureManagerIDSource.RandomAward:
                if (this.awardsConfig != null && this.awardsResponse != null) id =
                    this.awardsConfig.awardSymbolsNormal[this.awardsResponse.awardIndex].FeatureID;
                break;
            case FeatureManagerIDSource.RandomAwardFreeSpin:
                if (this.awardsConfig != null && this.awardsResponse != null) id = this.awardsConfig.awardSymbolsFreeSpins[this.awardsResponse.awardIndex].FeatureID;
                break
        }
        if (this.featureID != id) return
    }
    if (param.cat != null) param.cat.Start();
    for (var i = 0; i < param.messages.length; ++i) {
        var msg = param.messages[i];
        switch (msg.paramType) {
            case FeatureManagerParamType.Bool:
                msg.eventReceiver.SendMessage(msg.methodToCall,
                    _bool.Parse(msg.param));
                break;
            case FeatureManagerParamType.Int:
                msg.eventReceiver.SendMessage(msg.methodToCall, _number.otoi(msg.param));
                break;
            case FeatureManagerParamType.Float:
                msg.eventReceiver.SendMessage(msg.methodToCall, _number.otod(msg.param));
                break;
            case FeatureManagerParamType.Double:
                msg.eventReceiver.SendMessage(msg.methodToCall, _number.otod(msg.param));
                break;
            case FeatureManagerParamType.String:
                msg.eventReceiver.SendMessage(msg.methodToCall, msg.param);
                break;
            case FeatureManagerParamType.XT_Bool:
                msg.eventReceiver.SendMessage(msg.methodToCall,
                    XT.GetBool(msg.param));
                break;
            case FeatureManagerParamType.XT_Int:
                msg.eventReceiver.SendMessage(msg.methodToCall, XT.GetInt(msg.param));
                break;
            case FeatureManagerParamType.XT_Float:
                msg.eventReceiver.SendMessage(msg.methodToCall, XT.GetFloat(msg.param));
                break;
            case FeatureManagerParamType.XT_Double:
                msg.eventReceiver.SendMessage(msg.methodToCall, XT.GetDouble(msg.param));
                break;
            case FeatureManagerParamType.XT_String:
                msg.eventReceiver.SendMessage(msg.methodToCall, XT.GetString(msg.param));
                break;
            case FeatureManagerParamType.XT_Object:
                msg.eventReceiver.SendMessage(msg.methodToCall,
                    XT.GetObject(msg.param));
                break;
            default:
                msg.eventReceiver.SendMessage(msg.methodToCall);
                break
        }
    }
};
goog.require("UHT.Engine");
OrderedCATStarter.prototype = Object.create(Component.prototype);
OrderedCATStarter.prototype.constructor = OrderedCATStarter;

function OrderedCATStarter() {
    Component.call(this);
    this.cats = null;
    this.resetAutomatically = false;
    this.nextCAT = 0
}
OrderedCATStarter.prototype.StartMextCAT = function() {
    if (this.resetAutomatically && this.nextCAT >= this.cats.length) this.ResetCATCount();
    if (this.nextCAT >= this.cats.length || this.cats[this.nextCAT].cat == null) return;
    this.cats[this.nextCAT].Start();
    this.nextCAT++
};
OrderedCATStarter.prototype.ResetCATCount = function() {
    this.nextCAT = 0
};
OrderedCATStarter.prototype.SetNextCAT = function(next) {
    this.nextCAT = next
};
goog.require("UHT.Engine");
CATContentLooper.prototype = Object.create(Component.prototype);
CATContentLooper.prototype.constructor = CATContentLooper;

function CATContentLooper() {
    Component.call(this);
    this.show = null;
    this.hide = null;
    this.duration = null;
    this.playAutomatically = false;
    this.resetOnStart = false;
    this.ignoreFirstShow = false;
    this.isLooping = true;
    this.index = 0;
    this.time = 0;
    this.internalIsLooping = false;
    this.isHidden = false
}
CATContentLooper.prototype.SwitchTo = function(idx) {
    idx = _number.otoi(idx);
    idx %= this.show.length;
    if (this.index == idx) return;
    this.Hide();
    this.InternalShow(idx)
};
CATContentLooper.prototype.Awake = function() {
    if (!this.ignoreFirstShow) this.isHidden = true
};
CATContentLooper.prototype.Update = function() {
    if (this.internalIsLooping) {
        this.time += Time.deltaTime;
        if (this.time > this.duration[this.index]) this.SwitchTo(this.index + 1)
    }
};
CATContentLooper.prototype.OnEnable = function() {
    if (this.playAutomatically) this.StartLooping()
};
CATContentLooper.prototype.StartLooping = function() {
    if (this.isHidden) this.InternalShow(this.resetOnStart ? 0 : this.index);
    this.internalIsLooping = this.isLooping
};
CATContentLooper.prototype.StopLooping = function() {
    this.Hide();
    this.internalIsLooping = false
};
CATContentLooper.prototype.InternalShow = function(idx) {
    this.index = idx;
    this.Show()
};
CATContentLooper.prototype.Show = function() {
    if (this.show[this.index].IsRunning()) this.show[this.index].Stop();
    this.show[this.index].Start();
    this.isHidden = false;
    this.time = 0
};
CATContentLooper.prototype.Hide = function() {
    if (this.hide[this.index].IsRunning()) this.hide[this.index].Stop();
    this.hide[this.index].Start();
    this.isHidden = true
};
CATContentLooper.prototype.ResetTime = function() {
    this.time = 0
};
CATContentLooper.prototype.SetLooping = function(value) {
    this.isLooping = value
};
goog.provide("UHT.FOXLink");
goog.require("UHT.XTLink");
var FOXVars = {
    FOX_Response: "FOX_Response",
    Evt_FOX_InitReceived: "Evt_FOX_InitReceived",
    Evt_FOX_SpinReceived: "Evt_FOX_SpinReceived",
    Evt_FOX_CollectReceived: "Evt_FOX_CollectReceived",
    Evt_FOX_InitBonusReceived: "Evt_FOX_InitBonusReceived",
    Evt_FOX_PickBonusReceived: "Evt_FOX_PickBonusReceived",
    Evt_FOX_BonusRespinReceived: "Evt_FOX_BonusRespinReceived",
    Evt_FOX_CollectBonusReceived: "Evt_FOX_CollectBonusReceived",
    Evt_FOX_GambleReceived: "Evt_FOX_GambleReceived",
    Evt_FOX_GambleCollectReceived: "Evt_FOX_GambleCollectReceived",
    Evt_FOX_JackpotCollectReceived: "Evt_FOX_JackpotCollectReceived",
    Evt_FOX_PlayJackpotReceived: "Evt_FOX_PlayJackpotReceived",
    Evt_FOX_PickFSOptionReceived: "Evt_FOX_PickFSOptionReceived",
    Evt_FOX_InitFSBGReceived: "Evt_FOX_InitFSBGReceived",
    Evt_FOX_PickFSBGReceived: "Evt_FOX_PickFSBGReceived",
    Evt_FOX_GetMysteryScatterReceived: "Evt_FOX_GetMysteryScatterReceived",
    Evt_FOX_AfterInitReceived: "Evt_FOX_AfterInitReceived",
    Evt_FOX_AfterSpinReceived: "Evt_FOX_AfterSpinReceived",
    Evt_FOX_AfterCollectReceived: "Evt_FOX_AfterCollectReceived",
    Evt_FOX_AfterInitBonusReceived: "Evt_FOX_AfterInitBonusReceived",
    Evt_FOX_AfterPickBonusReceived: "Evt_FOX_AfterPickBonusReceived",
    Evt_FOX_AfterBonusRespinReceived: "Evt_FOX_AfterBonusRespinReceived",
    Evt_FOX_AfterCollectBonusReceived: "Evt_FOX_AfterCollectBonusReceived",
    Evt_FOX_AfterGambleReceived: "Evt_FOX_AfterGambleReceived",
    Evt_FOX_AfterGambleCollectReceived: "Evt_FOX_AfterGambleCollectReceived",
    Evt_FOX_AfterJackpotCollectReceived: "Evt_FOX_AfterJackpotCollectReceived",
    Evt_FOX_AfterPlayJackpotReceived: "Evt_FOX_AfterPlayJackpotReceived",
    Evt_FOX_AfterPickFSOptionReceived: "Evt_FOX_AfterPickFSOptionReceived",
    Evt_FOX_AfterInitFSBGReceived: "Evt_FOX_AfterInitFSBGReceived",
    Evt_FOX_AfterPickFSBGReceived: "Evt_FOX_AfterPickFSBGReceived",
    Evt_FOX_AfterGetMysteryScatterReceived: "Evt_FOX_AfterGetMysteryScatterReceived",
    Evt_FOX_TriggerAfterEvent: "Evt_FOX_TriggerAfterEvent"
};
FOXLink.prototype = Object.create(XTLink.prototype);
FOXLink.prototype.constructor = FOXLink;

function FOXLink() {
    XTLink.call(this);
    this.afterResponseProcessed = false;
    this.priority = 0
}
FOXLink.prototype.XTRegisterCallbacks = function() {
    if (this.afterResponseProcessed) {
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_AfterInitReceived, this.OnInitReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_AfterSpinReceived, this.OnSpinReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_AfterCollectReceived, this.OnCollectReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_AfterInitBonusReceived, this.OnInitBonusReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_AfterPickBonusReceived,
            this.OnPickBonusReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_AfterBonusRespinReceived, this.OnBonusRespinReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_AfterCollectBonusReceived, this.OnCollectBonusReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_AfterGambleReceived, this.OnGambleReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_AfterGambleCollectReceived, this.OnGambleCollectReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_AfterJackpotCollectReceived,
            this.OnJackpotCollectReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_AfterPickFSOptionReceived, this.OnPickFSOptionReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_AfterInitFSBGReceived, this.OnInitFSBGReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_AfterPickFSBGReceived, this.OnPickFSBGReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_AfterGetMysteryScatterReceived, this.OnGetMysteryScatterReceived, this, this.priority)
    } else {
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_InitReceived,
            this.OnInitReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_SpinReceived, this.OnSpinReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_CollectReceived, this.OnCollectReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_InitBonusReceived, this.OnInitBonusReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_PickBonusReceived, this.OnPickBonusReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_BonusRespinReceived,
            this.OnBonusRespinReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_CollectBonusReceived, this.OnCollectBonusReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_GambleReceived, this.OnGambleReceived, this);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_GambleCollectReceived, this.OnGambleCollectReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_JackpotCollectReceived, this.OnJackpotCollectReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_PickFSOptionReceived,
            this.OnPickFSOptionReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_InitFSBGReceived, this.OnInitFSBGReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_PickFSBGReceived, this.OnPickFSBGReceived, this, this.priority);
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_GetMysteryScatterReceived, this.OnGetMysteryScatterReceived, this, this.priority)
    }
};
FOXLink.prototype.GetResponse = function() {
    return XT.GetObject(FOXVars.FOX_Response)
};
FOXLink.prototype.OnInitReceived = function() {
    this.HandleInitResponse(this.GetResponse())
};
FOXLink.prototype.OnSpinReceived = function() {
    this.HandleSpinResponse(this.GetResponse())
};
FOXLink.prototype.OnCollectReceived = function() {
    this.HandleCollectResponse(this.GetResponse())
};
FOXLink.prototype.OnInitBonusReceived = function() {
    this.HandleInitBonusResponse(this.GetResponse())
};
FOXLink.prototype.OnPickBonusReceived = function() {
    this.HandlePickBonusResponse(this.GetResponse())
};
FOXLink.prototype.OnBonusRespinReceived = function() {
    this.HandleBonusRespinResponse(this.GetResponse())
};
FOXLink.prototype.OnCollectBonusReceived = function() {
    this.HandleBonusCollectResponse(this.GetResponse())
};
FOXLink.prototype.OnGambleReceived = function() {
    this.HandleGambleResponse(this.GetResponse())
};
FOXLink.prototype.OnGambleCollectReceived = function() {
    this.HandleGambleCollectResponse(this.GetResponse())
};
FOXLink.prototype.OnJackpotCollectReceived = function() {
    this.HandleJackpotCollectResponse(this.GetResponse())
};
FOXLink.prototype.OnPickFSOptionReceived = function() {
    this.HandlePickFSOptionResponse(this.GetResponse())
};
FOXLink.prototype.OnInitFSBGReceived = function() {
    this.HandleInitFSBGResponse(this.GetResponse())
};
FOXLink.prototype.OnPickFSBGReceived = function() {
    this.HandlePickFSBGResponse(this.GetResponse())
};
FOXLink.prototype.OnGetMysteryScatterReceived = function() {
    this.HandleGetMysteryScatterResponse(this.GetResponse())
};
FOXLink.prototype.HandleInitResponse = function(param) {};
FOXLink.prototype.HandleSpinResponse = function(param) {};
FOXLink.prototype.HandleCollectResponse = function(param) {};
FOXLink.prototype.HandleInitBonusResponse = function(param) {};
FOXLink.prototype.HandlePickBonusResponse = function(param) {};
FOXLink.prototype.HandleBonusRespinResponse = function(param) {};
FOXLink.prototype.HandleBonusCollectResponse = function(param) {};
FOXLink.prototype.HandleGambleResponse = function(param) {};
FOXLink.prototype.HandleGambleCollectResponse = function(param) {};
FOXLink.prototype.HandleJackpotCollectResponse = function(param) {};
FOXLink.prototype.HandlePickFSOptionResponse = function(param) {};
FOXLink.prototype.HandleInitFSBGResponse = function(param) {};
FOXLink.prototype.HandlePickFSBGResponse = function(param) {};
FOXLink.prototype.HandleGetMysteryScatterResponse = function(param) {};
goog.require("UHT.FOXLink");
goog.require("UHT.TournamentConnection");
TournamentConnectionXTLayer.prototype = Object.create(FOXLink.prototype);
TournamentConnectionXTLayer.prototype.constructor = TournamentConnectionXTLayer;

function TournamentConnectionXTLayer() {
    FOXLink.call(this);
    this.connection = null;
    this.isFirstResult = true;
    this.useResultDisplayerDoLoop = true;
    this.isPrizeDrop = false
}
TournamentConnectionXTLayer.prototype.XTRegisterCallbacks = function() {
    FOXLink.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_Prepare, this.OnResultDisplayerPrepare, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop, this.OnResultDisplayerDoLoop, this);
    XT.RegisterCallbackBool(Vars.LastWinIsCounting, this.OnLastWinIsCountingChanged, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_WinShown,
        this.OnPromotionWinShown, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionsOpen, this.OnPromotionsOpen, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionsClosed, this.OnPromotionsClosed, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_DataToCode_LeaderboardOpen, this.OnLeaderboardOpen, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_DataToCode_LeaderboardClosed, this.OnLeaderboardClosed, this);
    XT.RegisterCallbackString(TournamentVars.SelectedTournamentID, this.OnSelectedTournamentIDChanged,
        this)
};
TournamentConnectionXTLayer.prototype.XTInitVariablesAndEvents = function() {
    XT.SetString(TournamentVars.Promotion_WinID, "");
    XT.SetDouble(TournamentVars.Promotion_WinReceived, 0);
    XT.SetString(TournamentVars.Promotion_GiftReceived, "");
    XT.SetDouble(TournamentVars.PrizeDropWin_Bet, 0);
    XT.SetInt(TournamentVars.PrizeDropWin_BetMultiplier, 0);
    XT.SetInt(TournamentVars.PrizeDropWin_PrizeType, TournamentProtocol.PrizeType.Invalid);
    XT.SetBool(TournamentVars.PrizeDropManuallyCredited, false);
    XT.SetBool(TournamentVars.TournamentEnforced_Jurisdiction_TournamentOptOut, false);
    XT.SetString(TournamentVars.PrizeDropWin_FreeRoundsType, "N");
    this.SetTournaments(null)
};
TournamentConnectionXTLayer.prototype.OnGameInit = function() {
    if (UHT_GAME_CONFIG["demoMode"]) return;
    this.connection = new TournamentConnection;
    this.connection.xtLayer = this
};
TournamentConnectionXTLayer.prototype.OnResultDisplayerPrepare = function() {
    if (this.connection == null) return;
    if (this.isPrizeDrop) XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_PrepareForWin);
    if (this.connection.hasUpdates) {
        this.useResultDisplayerDoLoop = false;
        XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_Prepare)
    }
    this.UpdatePromotions();
    if (this.isFirstResult) {
        this.isFirstResult = false;
        this.OnLastWinIsCountingChanged(XT.GetBool(Vars.LastWinIsCounting))
    }
};
TournamentConnectionXTLayer.prototype.OnResultDisplayerDoLoop = function() {
    if (!this.useResultDisplayerDoLoop || this.connection == null) return;
    if (this.connection.hasUpdates) this.OnResultDisplayerPrepare()
};
TournamentConnectionXTLayer.prototype.OnLastWinIsCountingChanged = function(isCounting) {};
TournamentConnectionXTLayer.prototype.UpdatePromotions = function() {
    if (this.isPrizeDrop) XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_ShowWin);
    else this.connection.canUpdate = true
};
TournamentConnectionXTLayer.prototype.OnPromotionWinShown = function() {
    this.connection.canUpdate = true;
    this.isPrizeDrop = false
};
TournamentConnectionXTLayer.prototype.Update = function() {
    if (this.connection != null) this.connection.Update()
};
TournamentConnectionXTLayer.prototype.SetServerTime = function(time) {
    XT.SetInt(TournamentVars.ServerTime, time)
};
TournamentConnectionXTLayer.prototype.SetTournaments = function(tournaments) {
    XT.SetObject(TournamentVars.Tournaments, tournaments);
    XT.TriggerEvent(TournamentVars.Evt_Internal_TournamentsUpdated)
};
TournamentConnectionXTLayer.prototype.SetDetails = function(details) {
    XT.SetObject(TournamentVars.TournamentDetails, details)
};
TournamentConnectionXTLayer.prototype.SetLeaderboards = function(leaderboards) {
    XT.SetObject(TournamentVars.TournamentLeaderboards, leaderboards)
};
TournamentConnectionXTLayer.prototype.AnnouncePromotions = function() {
    XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_Announce)
};
TournamentConnectionXTLayer.prototype.HandleSpinResponse = function(dict) {
    this.isPrizeDrop = false;
    var promoWinUID = "";
    var promoWinAmount = 0;
    var promoWinGift = "";
    var promoWinBet = 0;
    var promoWinMultiplier = 0;
    var promoWinPrizeType = TournamentProtocol.PrizeType.Invalid;
    var promoFreeRounds = "";
    var promoFreeRoundType = "N";
    var promoFreeRoundAmount = -1;
    if (dict["ev"] != undefined) {
        var split = dict["ev"].split("~");
        if (split.length > 1 && split[0] == "MR") {
            split = split[1].split(",");
            if (split.length > 1) {
                var uid = PromotionsHelper.GetUID(_number.otoi(split[0]),
                    TournamentProtocol.PromoType.Race);
                var promo = PromotionsHelper.FindPromotion(uid);
                if (promo != null && promo.clientMode == TournamentProtocol.ClientMode.Visible) {
                    if (split[1] == "A") promoWinAmount = _number.otod(split[2]);
                    else if (split[1] == "G") promoWinGift = decodeURIComponent(atob(split[2]).split("").map(function(c) {
                        return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2)
                    }).join(""));
                    else if (split[1] == "BM") {
                        promoWinAmount = _number.otod(split[2]);
                        promoWinBet = _number.otod(split[3]);
                        promoWinMultiplier = _number.otoi(split[4])
                    } else if (split[1] ==
                        "FR") {
                        promoFreeRoundType = split[3];
                        promoWinBet = _number.otod(split[2]);
                        promoFreeRoundAmount = _number.otoi(split[4])
                    }
                    promoWinUID = uid;
                    this.isPrizeDrop = true;
                    this.connection.racePrizesTimer = this.connection.reloadRacePrizesInterval;
                    this.connection.raceWinnersTimer = this.connection.reloadRaceWinnersInterval;
                    promoWinPrizeType = TournamentProtocol.PrizeTypeConverter.Convert(split[1])
                }
            }
        }
    }
    XT.SetString(TournamentVars.Promotion_WinID, promoWinUID);
    XT.SetDouble(TournamentVars.Promotion_WinReceived, promoWinAmount);
    XT.SetString(TournamentVars.Promotion_GiftReceived,
        promoWinGift);
    XT.SetDouble(TournamentVars.PrizeDropWin_Bet, promoWinBet);
    XT.SetInt(TournamentVars.PrizeDropWin_BetMultiplier, promoWinMultiplier);
    XT.SetInt(TournamentVars.PrizeDropWin_PrizeType, promoWinPrizeType);
    XT.SetString(TournamentVars.PrizeDropWin_FreeRoundsType, promoFreeRoundType);
    XT.SetInt(TournamentVars.PrizeDropWin_FreeRoundsAmount, promoFreeRoundAmount)
};
TournamentConnectionXTLayer.prototype.OnPromotionsOpen = function() {
    this.connection.PromotionsOpen();
    this.connection.SelectedTournamentIDChanged(XT.GetString(TournamentVars.SelectedTournamentID))
};
TournamentConnectionXTLayer.prototype.OnPromotionsClosed = function() {
    this.connection.PromotionsClosed()
};
TournamentConnectionXTLayer.prototype.OnLeaderboardOpen = function() {
    this.connection.LeaderboardOpen()
};
TournamentConnectionXTLayer.prototype.OnLeaderboardClosed = function() {
    this.connection.LeaderboardClosed()
};
TournamentConnectionXTLayer.prototype.OnSelectedTournamentIDChanged = function(uid) {
    if (this.connection != null) this.connection.SelectedTournamentIDChanged(uid)
};
goog.require("UHT.FOXLink");
TournamentPointsNotification.prototype = Object.create(FOXLink.prototype);
TournamentPointsNotification.prototype.constructor = TournamentPointsNotification;

function TournamentPointsNotification() {
    FOXLink.call(this);
    this.notificationQueue = [];
    this.canShowNextNotification = true;
    this.notificationIsShowing = false;
    this.landscapeNotificationMessage = null;
    this.portraitNotificationMessage = null;
    this.localizedLabels = [];
    this.showNotification = null
}
var TournamentPointsVars = {
    ShowTournamentPointsNotification: "ShowTournamentPointsNotification"
};
TournamentPointsNotification.TournamentGeneralPoints = function() {
    this.tournamentId = -1;
    this.winMultiplier = -1;
    this.consecutiveWinsCounter = -1;
    this.consecutiveWinsScore = -1;
    this.consecutiveLossesCounter = -1;
    this.consecutiveLossesScore = -1
};
TournamentPointsNotification.prototype.XTRegisterCallbacks = function() {
    if (ServerOptions.isReplay) return;
    FOXLink.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackEvent("ShowTournamentPointsNotification", this.OnShowNextNotification, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this)
};
TournamentPointsNotification.prototype.XTInitVariablesAndEvents = function() {};
TournamentPointsNotification.prototype.OnSpinStarted = function() {
    this.canShowNextNotification = false
};
TournamentPointsNotification.prototype.OnShowNextNotification = function() {
    this.canShowNextNotification = true
};
TournamentPointsNotification.prototype.HandleInitResponse = function(dict) {
    this.ParseTournamentGeneralPoints(dict)
};
TournamentPointsNotification.prototype.HandleSpinResponse = function(dict) {
    this.ParseTournamentGeneralPoints(dict)
};
TournamentPointsNotification.prototype.HandleCollectResponse = function(dict) {
    this.ParseTournamentGeneralPoints(dict)
};
TournamentPointsNotification.prototype.ParseTournamentGeneralPoints = function(dict) {
    if (dict["tgp"] != undefined) {
        var tgpItems = dict["tgp"].split(";");
        for (var i = 0; i < tgpItems.length; ++i) {
            var item = tgpItems[i].split("~");
            var tgpItem = new TournamentPointsNotification.TournamentGeneralPoints;
            if (item.length > 1) {
                tgpItem.tournamentId = _number.otoi(item[0]);
                var pointData = item[1].split(",");
                tgpItem.winMultiplier = _number.otoi(pointData[0]);
                tgpItem.consecutiveWinsCounter = _number.otoi(pointData[1]);
                tgpItem.consecutiveWinsScore =
                    _number.otoi(pointData[2]);
                tgpItem.consecutiveLossesCounter = _number.otoi(pointData[3]);
                tgpItem.consecutiveLossesScore = _number.otoi(pointData[4])
            }
            var tournamentName = this.GetTournamentName(tgpItem.tournamentId);
            if (tournamentName != "") {
                if (tgpItem.winMultiplier > 0) {
                    var text = this.localizedLabels[0].text;
                    this.GenerateNotificationMessage(text, tournamentName, tgpItem.winMultiplier.toString())
                }
                if (tgpItem.consecutiveWinsScore > 0) {
                    var text = this.localizedLabels[1].text;
                    this.GenerateNotificationMessage(text, tournamentName,
                        tgpItem.consecutiveWinsScore.toString())
                }
                if (tgpItem.consecutiveLossesScore > 0) {
                    var text = this.localizedLabels[2].text;
                    this.GenerateNotificationMessage(text, tournamentName, tgpItem.consecutiveLossesScore.toString())
                }
            }
        }
    }
};
TournamentPointsNotification.prototype.GenerateNotificationMessage = function(messageTemplate, tournamentName, points) {
    var message = tournamentName + "REPLACE_ME" + messageTemplate.replace("{0}", points);
    this.notificationQueue.push(message)
};
TournamentPointsNotification.prototype.GetTournamentName = function(id) {
    var tournaments = XT.GetObject(TournamentVars.Tournaments);
    if (tournaments != null)
        for (var i = 0; i < tournaments.length; i++)
            if (tournaments[i].id == id) return tournaments[i].name;
    return ""
};
TournamentPointsNotification.prototype.SetNotificationState = function(value) {
    this.notificationIsShowing = value
};
TournamentPointsNotification.prototype.ShowNextNotification = function() {
    if (this.notificationQueue.length > 0) {
        if (this.landscapeNotificationMessage != null) this.landscapeNotificationMessage.text = this.notificationQueue[0].replace("REPLACE_ME", " - ");
        if (this.portraitNotificationMessage != null) this.portraitNotificationMessage.text = this.notificationQueue[0].replace("REPLACE_ME", "\n");
        this.notificationQueue.shift();
        if (this.showNotification.IsRunning()) this.showNotification.Stop();
        this.showNotification.Start()
    } else this.canShowNextNotification =
        false
};
TournamentPointsNotification.prototype.Update = function() {
    if (!this.canShowNextNotification || this.notificationIsShowing) return;
    this.ShowNextNotification()
};
var InterfaceVars = {
    IsMobileGUI: "IsMobileGUI",
    SelectedAutoSpinsIndex: "SelectedAutoSpinsIndex",
    SelectedAutoSpinsIndexAdvanced: "SelectedAutoSpinsIndexAdvanced",
    ExtraWinMultiplier: "ExtraWinMultiplier",
    PayingSymbolsDisplayServerID: "PayingSymbolsDisplayServerID",
    ShowInterfaceThumbnailsCount: "ShowInterfaceThumbnailsCount",
    GUIMessageZoneSettings: "GUIMessageZoneSettings",
    HasGUIMessageBeforeWinCount: "HasGUIMessageBeforeWinCount",
    GUIDynamicMessageDelay: "GUIDynamicMessageDelay",
    GUIMessage_RandomSpin: "GUIMessage_RandomSpin",
    GUIMessage_RandomResultTeaser: "GUIMessage_RandomResultTeaser",
    LastResultHasNoWin: "LastResultHasNoWin",
    FSWinIsCounting: "FSWinIsCounting",
    Evt_DataToCode_CloseAllInterfaceWindows: "Evt_DataToCode_CloseAllInterfaceWindows",
    Evt_CodeToData_InterfaceWindowOpen: "Evt_CodeToData_InterfaceWindowOpen",
    EnableSoundsWhenReady: "EnableSoundsWhenReady",
    GUIArrangerSettings: "GUIArrangerSettings",
    Evt_DataToCode_UpdateGUIArrangerSettings: "Evt_DataToCode_UpdateGUIArrangerSettings",
    Evt_DataToCode_HidePortraitMiddleBar: "Evt_DataToCode_HidePortraitMiddleBar",
    Evt_DataToCode_ShowPortraitMiddleBar: "Evt_DataToCode_ShowPortraitMiddleBar",
    ShowCoinsAndCashHint: "ShowCoinsAndCashHint",
    ShowFastPlayHint: "ShowFastPlayHint",
    Evt_Internal_BlackBandsUpdated: "Evt_Internal_BlackBandsUpdated",
    Interface_UpdateMoveSourceComponents: "Interface_UpdateMoveSourceComponents",
    GameAnchors: "GameAnchors",
    SpinButtonPositionLandscape: "SpinButtonPositionLandscape",
    SpinButtonPositionPortrait: "SpinButtonPositionPortrait",
    SpinButtonPositionLocked: "SpinButtonPositionLocked",
    Evt_DataToCode_ToggleSpinButtonPositionLocked: "Evt_DataToCode_ToggleSpinButtonPositionLocked",
    LimitSpinButtonPositionByGameAnchors: "LimitSpinButtonPositionByGameAnchors",
    ShowGamePaysAsWinTeaser: "ShowGamePaysAsWinTeaser",
    CustomMessage: "CustomMessage",
    ShowCustomMessage: "ShowCustomMessage",
    HideCustomMessage: "HideCustomMessage",
    AllLinesMessageCustom: "AllLinesMessageCustom",
    AllLinesMessageCustomRule: "AllLinesMessageCustomRule",
    CustomFreeSpinsLeftMessage: "CustomFreeSpinsLeftMessage",
    CustomFreeSpinsLeft_UsesCATEvents: "CustomFreeSpinsLeft_UsesCATEvents",
    ShowExplicitResult: "ShowExplicitResult"
};
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
TournamentSimpleOptIn.prototype = Object.create(XTLink.prototype);
TournamentSimpleOptIn.prototype.constructor = TournamentSimpleOptIn;

function TournamentSimpleOptIn() {
    XTLink.call(this);
    this.enableOptOut = null;
    this.disableOptOut = null;
    this.enableOptOutDDW = null;
    this.disableOptOutDDW = null;
    this.isMergedDDW = false
}
TournamentSimpleOptIn.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_Announce, this.OnAnnounce, this, 1)
};
TournamentSimpleOptIn.prototype.OnAnnounce = function() {
    if (XT.GetBool(Vars.Jurisdiction_TournamentOptOut))
        if (!this.isMergedDDW) this.enableOptOut.Start();
        else this.enableOptOutDDW.Start();
    else if (XT.GetBool(TournamentVars.TournamentEnforced_Jurisdiction_TournamentOptOut))
        if (!this.isMergedDDW) this.enableOptOut.Start();
        else this.enableOptOutDDW.Start();
    else if (!this.isMergedDDW) this.disableOptOut.Start();
    else this.disableOptOutDDW.Start()
};
goog.require("UHT.XTLink");
BlackBandsArranger.prototype = Object.create(XTLink.prototype);
BlackBandsArranger.prototype.constructor = BlackBandsArranger;

function BlackBandsArranger() {
    XTLink.call(this);
    this.bands = null;
    this.isInit = false
}
BlackBandsArranger.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(InterfaceVars.Evt_Internal_BlackBandsUpdated, this.OnBlackBandsUpdated, this)
};
BlackBandsArranger.prototype.OnBlackBandsUpdated = function(param) {
    if (!this.isInit) {
        GUIArranger.InitBands(this.bands);
        this.isInit = true
    }
    GUIArranger.UpdateBands(this.bands)
};
goog.require("UHT.FOXLink");
var GameInfoVars = {
    GameInfo: "GameInfo",
    Evt_Internal_GameInfoChanged: "Evt_Internal_GameInfoChanged"
};
GameInfoFOX.prototype = Object.create(FOXLink.prototype);
GameInfoFOX.prototype.constructor = GameInfoFOX;

function GameInfoFOX() {
    FOXLink.call(this)
}
GameInfoFOX.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(GameInfoVars.GameInfo, null)
};
GameInfoFOX.prototype.HandleInitResponse = function(dict) {
    var gameInfoDictionary = {};
    if (dict["gameInfo"]) gameInfoDictionary = JSON5.parse(dict["gameInfo"]);
    if (XT.GetBool(Vars.Jurisdiction_DisableAnteBet))
        if (gameInfoDictionary["rtps"] && gameInfoDictionary["rtps"]["ante"]) delete gameInfoDictionary["rtps"]["ante"];
    if (XT.GetBool(Vars.Jurisdiction_DisableBuyFeature))
        if (gameInfoDictionary["rtps"] && gameInfoDictionary["rtps"]["purchase"]) delete gameInfoDictionary["rtps"]["purchase"];
    if (gameInfoDictionary["rtps"] !=
        null) {
        var rtpKeys = Object.keys(gameInfoDictionary["rtps"]);
        var rtpValues = [];
        for (var i = 0; i < rtpKeys.length; i++) rtpValues.push(parseFloat(gameInfoDictionary["rtps"][rtpKeys[i]]));
        if (rtpValues.length > 0) {
            rtpValues.sort();
            XT.SetDouble(Vars.ReturnToPlayer, rtpValues[rtpValues.length - 1]);
            if (rtpValues.length > 1) XT.SetDouble(Vars.ReturnToPlayerMin, rtpValues[0])
        }
    }
    XT.SetObject(GameInfoVars.GameInfo, gameInfoDictionary);
    XT.TriggerEvent(GameInfoVars.Evt_Internal_GameInfoChanged)
};
goog.require("UHT.XTLink");
AddVariablesToText.prototype = Object.create(XTLink.prototype);
AddVariablesToText.prototype.constructor = AddVariablesToText;

function Variable() {
    this.type = VarType.XT_Int;
    this.variable = null;
    this.gameInfo_Name = "";
    this.gameInfo_Key = "";
    this.value = "";
    this.valid = false;
    this.parent = null;
    this.isDisplayingCoins = false;
    this.isDisplayingDecimals = false;
    this.formatOptions = null;
    this.forceHasCoins = false
}
Variable.prototype.OnTargetValueChangedInt = function(newVal) {
    this.value = newVal.toString();
    this.valid = true;
    this.parent.OnValuesUpdate()
};
Variable.prototype.OnTargetValueChangedFloat = function(newVal) {
    this.value = newVal.toString();
    this.valid = true;
    this.parent.OnValuesUpdate()
};
Variable.prototype.OnTargetValueChangedString = function(newVal) {
    this.value = newVal;
    this.valid = _string.IsNullOrEmpty(newVal) ? false : true;
    this.parent.OnValuesUpdate()
};
Variable.prototype.OnLocaleChanged = function() {
    if (this.isDisplayingCoins && XT.GetBool(Vars.HasCoins)) return;
    LocaleManager.ApplyFontToLabel(this.formatOptions.fontId, this.parent.baseLabel);
    this.parent.OnValuesUpdate()
};
Variable.prototype.OnCoinValueChanged = function() {
    if (!this.isDisplayingCoins || !XT.GetBool(Vars.HasCoins)) return;
    this.parent.OnValuesUpdate()
};
Variable.prototype.OnHasCoinsChanged = function() {
    this.parent.OnValuesUpdate()
};
Variable.prototype.OnGameInfoChanged = function() {
    var gameInfo = XT.GetObject(GameInfoVars.GameInfo);
    if (gameInfo != null && !_string.IsNullOrEmpty(this.gameInfo_Name)) {
        if (!gameInfo[this.gameInfo_Name]) {
            console.warn("Couldn't find dictionary <" + this.gameInfo_Name + ">. GameInfo contains: <" + Object.getOwnPropertyNames(gameInfo).join() + ">.");
            return
        }
        if (!gameInfo[this.gameInfo_Name][this.gameInfo_Key]) {
            console.warn("Couldn't find key <" + this.gameInfo_Key + ">. Dictionary <" + this.gameInfo_Name + "> contains: <" + Object.getOwnPropertyNames(gameInfo[this.gameInfo_Name]).join() +
                ">.");
            return
        }
        this.value = gameInfo[this.gameInfo_Name][this.gameInfo_Key];
        this.valid = true;
        this.parent.OnValuesUpdate()
    }
};

function AddVariablesToText() {
    XTLink.call(this);
    this.baseLabel = null;
    this.initialString = null;
    this.someVariables = []
}
AddVariablesToText.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    for (var j = 0; j < this.someVariables.length; j++) {
        this.someVariables[j].parent = this;
        switch (this.someVariables[j].type) {
            case VarType.XT_Int:
                XT.RegisterCallbackInt(this.someVariables[j].variable.name, this.someVariables[j].OnTargetValueChangedInt, this.someVariables[j]);
                break;
            case VarType.XT_Float:
                XT.RegisterCallbackFloat(this.someVariables[j].variable.name, this.someVariables[j].OnTargetValueChangedFloat,
                    this.someVariables[j]);
                break;
            case VarType.XT_Double:
                XT.RegisterCallbackDouble(this.someVariables[j].variable.name, this.someVariables[j].OnTargetValueChangedFloat, this.someVariables[j]);
                break;
            case VarType.XT_String:
                XT.RegisterCallbackString(this.someVariables[j].variable.name, this.someVariables[j].OnTargetValueChangedString, this.someVariables[j]);
                break;
            case VarType.XT_GameInfo:
                XT.RegisterCallbackEvent(GameInfoVars.Evt_Internal_GameInfoChanged, this.someVariables[j].OnGameInfoChanged, this.someVariables[j]);
                break;
            default:
                console.warn("The " + this.someVariables[j].type + " case was not implemented.");
                break
        }
        XT.RegisterCallbackEvent(Vars.Evt_Internal_LocaleChanged, this.someVariables[j].OnLocaleChanged, this.someVariables[j]);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinValueChanged, this.someVariables[j].OnCoinValueChanged, this.someVariables[j]);
        XT.RegisterCallbackBool(Vars.HasCoins, this.someVariables[j].OnHasCoinsChanged, this.someVariables[j])
    }
};
AddVariablesToText.prototype.OnGameInit = function() {
    this.initialString = this.baseLabel.text;
    this.OnValuesUpdate()
};
AddVariablesToText.prototype.OnValuesUpdate = function() {
    if (this.initialString == null) return;
    this.baseLabel.text = this.initialString;
    for (var i = 0; i < this.someVariables.length; i++) {
        if (!this.someVariables[i].valid) {
            this.baseLabel.text = " ";
            return
        }
        var toReplace = "";
        toReplace = "{" + i.toString() + "}";
        if (this.someVariables[i].isDisplayingCoins && XT.GetBool(Vars.HasCoins)) {
            if (!isNaN(this.someVariables[i].value)) this.baseLabel.text = this.baseLabel.text.replace(toReplace, "" + CoinManager.ConvertMoneyToCoins(parseFloat(this.someVariables[i].value)))
        } else if (this.someVariables[i].isDisplayingDecimals) {
            if (!isNaN(this.someVariables[i].value)) this.baseLabel.text =
                this.baseLabel.text.replace(toReplace, "" + LocaleManager.FormatValue(parseFloat(this.someVariables[i].value), this.someVariables[i].formatOptions))
        } else this.baseLabel.text = this.baseLabel.text.replace(toReplace, this.someVariables[i].value)
    }
};
goog.require("UHT.Engine");
GameWindowOverrider.prototype = Object.create(XTLink.prototype);
GameWindowOverrider.prototype.constructor = GameWindowOverrider;

function DefaultGameWindowOverrideData() {
    this.customFSWinWindow = false;
    this.customFSLoseWindow = false
}

function GameWindowOverrider() {
    XTLink.call(this);
    this.FSWinWindow = null;
    this.FSLoseWindow = null
}
GameWindowOverrider.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this)
};
GameWindowOverrider.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGUIInit, this)
};
GameWindowOverrider.prototype.OnGUIInit = function() {
    var data = XT.GetObject(Vars.DefaultGameWindowOverrideData);
    if (this.FSWinWindow != null) this.FSWinWindow.isEnabled = !data.customFSWinWindow;
    if (this.FSLoseWindow != null) this.FSLoseWindow.isEnabled = !data.customFSLoseWindow
};
goog.require("UHT.XTLink");
goog.require("UHT.SoundManager");
goog.require("UHT.AudioClassesUtils");
GUI_SoundLogic.prototype = Object.create(XTLink.prototype);
GUI_SoundLogic.prototype.constructor = GUI_SoundLogic;

function GUI_SoundLogic() {
    XTLink.call(this);
    this.clipValueAnimator = null;
    this.gambleSounds = null;
    this.sndManager = null;
    this.enableSoundsWhenReady = false
}
GUI_SoundLogic.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(InterfaceVars.EnableSoundsWhenReady, false)
};
GUI_SoundLogic.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.SoundManagerObject, this.OnSoundManagerChanged, this);
    XT.RegisterCallbackBool(Vars.MusicIsOn, this.OnMusicStateChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PlayValueAnimatorSound, this.OnValueAnimatorIsCounting, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StopValueAnimatorSound, this.OnValueAnimatorFinishedCounting, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PlayGambleShuffleCard, this.OnGambleShuffleStart,
        this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PlayGambleShufflingStop, this.OnGambleShufflePlayStop, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StopGambleShuffleCard, this.OnGambleShuffleStop, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_PlayGambleNewProgressItem, this.OnGambleNewProgressItem, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_PlayGambleResultWin, this.OnGambleResultWindowWin, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_PlayGambleResultLose, this.OnGambelResultWindowLose,
        this);
    XT.RegisterCallbackBool(InterfaceVars.EnableSoundsWhenReady, this.OnEnableSoundsWhenReadyChanged, this)
};
GUI_SoundLogic.prototype.OnDestroy = function() {
    XT.UnregisterCallbackObject(this.OnSoundManagerChanged, this);
    XT.UnregisterCallbackBool(this.OnMusicStateChanged, this);
    XT.UnregisterCallbackEvent(this.OnValueAnimatorIsCounting, this);
    XT.UnregisterCallbackEvent(this.OnValueAnimatorFinishedCounting, this);
    XT.UnregisterCallbackEvent(this.OnGambleShuffleStart, this);
    XT.UnregisterCallbackEvent(this.OnGambleShuffleStop, this);
    XT.UnregisterCallbackEvent(this.OnGambleNewProgressItem, this);
    XT.UnregisterCallbackEvent(this.OnGambleResultWindowWin,
        this);
    XT.UnregisterCallbackEvent(this.OnGambelResultWindowLose, this)
};
GUI_SoundLogic.prototype.OnSoundManagerChanged = function(mgr) {
    this.sndManager = mgr
};
GUI_SoundLogic.prototype.OnMusicStateChanged = function(unused) {
    if (this.clipValueAnimator.IsPlaying()) {
        var args = {
            handle: this.clipValueAnimator.handler
        };
        this.sndManager.StopLoopingSound(args);
        this.clipValueAnimator.handler = args.handle;
        this.clipValueAnimator.handler = this.sndManager.PlayLooping(this.clipValueAnimator.GetClip(XT.GetInt(Vars.ValueAnimatorSoundIndex)))
    }
};
GUI_SoundLogic.prototype.OnGambleShuffleStart = function() {
    this.gambleSounds.shufflingCardLoopable.handler = this.sndManager.PlayLooping(this.gambleSounds.shufflingCardLoopable.GetClip())
};
GUI_SoundLogic.prototype.OnGambleShuffleStop = function() {
    if (this.gambleSounds.shufflingCardLoopable.IsPlaying()) {
        var args = {
            handle: this.gambleSounds.shufflingCardLoopable.handler
        };
        this.sndManager.StopLoopingSound(args);
        this.gambleSounds.shufflingCardLoopable.handler = args.handle
    }
};
GUI_SoundLogic.prototype.OnGambleShufflePlayStop = function() {
    this.sndManager.PlaySimple(this.gambleSounds.shufflingCardStop)
};
GUI_SoundLogic.prototype.OnGambleNewProgressItem = function() {
    this.sndManager.PlaySimple(this.gambleSounds.newProgressItem)
};
GUI_SoundLogic.prototype.OnGambleResultWindowWin = function() {
    this.sndManager.PlaySimple(this.gambleSounds.resultWindowWin)
};
GUI_SoundLogic.prototype.OnGambelResultWindowLose = function() {
    this.sndManager.PlaySimple(this.gambleSounds.resultWindowLose)
};
GUI_SoundLogic.prototype.OnValueAnimatorIsCounting = function() {
    if (this.clipValueAnimator.IsPlaying()) {
        var args = {
            handle: this.clipValueAnimator.handler
        };
        this.sndManager.StopLoopingSound(args);
        this.clipValueAnimator.handler = args.handle
    }
    this.clipValueAnimator.handler = this.sndManager.PlayLooping(this.clipValueAnimator.GetClip(XT.GetInt(Vars.ValueAnimatorSoundIndex)))
};
GUI_SoundLogic.prototype.OnValueAnimatorFinishedCounting = function() {
    if (this.clipValueAnimator.IsPlaying()) {
        var args = {
            handle: this.clipValueAnimator.handler
        };
        this.sndManager.StopLoopingSound(args);
        this.clipValueAnimator.handler = args.handle
    }
    this.sndManager.PlaySimple(this.clipValueAnimator.GetClip(ClipStage.finalStage))
};
GUI_SoundLogic.prototype.OnEnableSoundsWhenReadyChanged = function(param) {
    this.enableSoundsWhenReady = param
};
GUI_SoundLogic.prototype.Update = function() {
    if (this.enableSoundsWhenReady)
        if (UHTEngine.SoundsAreLoaded()) {
            this.enableSoundsWhenReady = false;
            if (XT.GetObject(Vars.SoundState).gameSoundIsOn == false) XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_SoundBtn)
        }
};
goog.require("UHT.XTLink");
CoinManager.prototype = Object.create(XTLink.prototype);
CoinManager.prototype.constructor = CoinManager;

function CoinManager() {
    XTLink.call(this)
}
CoinManager.instance = null;
CoinManager.isInited = false;
CoinManager.lastBet = -1;
CoinManager.lastTotalBet = -1;
CoinManager.lastIndicesPair = null;
CoinManager.isStrictMode = false;
CoinManager.canStillGoToStrictMode = false;
CoinManager.desiredBetIndex = -1;
CoinManager.desiredCoinIndex = -1;
CoinManager.desiredBet = -1;
CoinManager.savedDesiredBet = -1;
CoinManager.defaultBet = -1;
CoinManager.computedCoinValues = null;
CoinManager.betsFromServer = null;
CoinManager.initialBetsFromServer = null;
CoinManager.prototype.XTInitVariablesAndEvents = function() {
    CoinManager.instance = this;
    XT.SetObject(Vars.TotalBets, null);
    XT.SetObject(Vars.CoinValues, []);
    XT.SetInt(Vars.CoinValueIndex, -1);
    XT.SetInt(Vars.NextBetIndex, 0);
    XT.SetDouble(Vars.MinTotalBetFromServer, 0);
    XT.SetDouble(Vars.MaxTotalBetFromServer, 0)
};
CoinManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_IncreaseBet, this.IncreaseBet, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_DecreaseBet, this.DecreaseBet, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_IncreaseCoinValue, this.IncreaseCoinValue, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_DecreaseCoinValue, this.DecreaseCoinValue, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_SmartIncreaseBet,
        this.SmartIncreaseBet, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_SmartDecreaseBet, this.SmartDecreaseBet, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_RevertToLastBet, this.RevertToLastBet, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ForceUpdateBetValues, this.UpdateBetValues, this)
};
CoinManager.prototype.OnDestroy = function() {};
CoinManager.prototype.SmartIncreaseBet = function() {
    if (XT.GetBool(Vars.FromServer_AllowCoins))
        if (XT.GetBool(Vars.HasCoins)) {
            var nextBetIndex = XT.GetInt(Vars.NextBetIndex);
            var bets = XT.GetObject(Vars.Bets);
            var coinValues = XT.GetObject(Vars.CoinValues);
            var coinValueIndex = XT.GetInt(Vars.CoinValueIndex);
            if (nextBetIndex < bets.length - 1) {
                this.IncreaseBet();
                return
            }
            if (coinValueIndex < coinValues.length - 1) {
                this.IncreaseCoinValue();
                return
            }
        } else this.SetSmartBet(true);
    else this.IncreaseBet()
};
CoinManager.prototype.SmartDecreaseBet = function() {
    if (XT.GetBool(Vars.FromServer_AllowCoins))
        if (XT.GetBool(Vars.HasCoins)) {
            var nextBetIndex = XT.GetInt(Vars.NextBetIndex);
            var coinValueIndex = XT.GetInt(Vars.CoinValueIndex);
            if (nextBetIndex > 0) {
                this.DecreaseBet();
                return
            }
            if (coinValueIndex > 0) {
                this.DecreaseCoinValue();
                return
            }
        } else this.SetSmartBet(false);
    else this.DecreaseBet()
};
CoinManager.prototype.DecreaseBet = function() {
    var nextBetIndex = XT.GetInt(Vars.NextBetIndex);
    XT.SetInt(Vars.NextBetIndex, nextBetIndex - 1);
    this.UpdateBetValues()
};
CoinManager.prototype.IncreaseBet = function() {
    var nextBetIndex = XT.GetInt(Vars.NextBetIndex);
    XT.SetInt(Vars.NextBetIndex, nextBetIndex + 1);
    this.UpdateBetValues()
};
CoinManager.SetBetIndex = function(newIndex) {
    XT.SetInt(Vars.NextBetIndex, newIndex);
    CoinManager.instance.UpdateBetValues()
};
CoinManager.prototype.UpdateBetValues = function() {
    if (CoinManager.isInited == false) return;
    var nextBetIndex = XT.GetInt(Vars.NextBetIndex);
    var bets = XT.GetObject(Vars.Bets);
    if (bets == null || nextBetIndex < 0 || nextBetIndex >= bets.length) {
        console.error("Invalid bet data received!!!");
        return
    }
    XT.SetDouble(Vars.BetDisplayed, bets[nextBetIndex]);
    var lines = XT.GetInt(Vars.BetToTotalBetMultiplier);
    var totalBets = [];
    for (var i = 0; i < bets.length; i++) totalBets.push(bets[i] * 1E3 * lines / 1E3);
    XT.SetObject(Vars.TotalBets, totalBets);
    XT.SetDouble(Vars.TotalBetDisplayed, totalBets[nextBetIndex]);
    XT.SetBool(Vars.MinBetReached, nextBetIndex == 0);
    XT.SetBool(Vars.MaxBetReached, nextBetIndex == bets.length - 1);
    if (XT.GetBool(Vars.FromServer_AllowCoins)) {
        XT.SetBool(Vars.MinBetAndCoinValueReached, XT.GetBool(Vars.MinBetReached) && XT.GetBool(Vars.MinCoinValueReached));
        XT.SetBool(Vars.MaxBetAndCoinValueReached, XT.GetBool(Vars.MaxBetReached) && XT.GetBool(Vars.MaxCoinValueReached))
    } else {
        XT.SetBool(Vars.MinBetAndCoinValueReached, XT.GetBool(Vars.MinBetReached));
        XT.SetBool(Vars.MaxBetAndCoinValueReached, XT.GetBool(Vars.MaxBetReached))
    }
    XT.TriggerEvent(Vars.Evt_Internal_BetChanged)
};
CoinManager.prototype.IncreaseCoinValue = function() {
    if (XT.GetBool(Vars.WaitInResultForBigWin)) {
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        return
    }
    this.SetCoinValueIndex(XT.GetInt(Vars.CoinValueIndex) + 1)
};
CoinManager.prototype.DecreaseCoinValue = function() {
    if (XT.GetBool(Vars.WaitInResultForBigWin)) {
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        return
    }
    this.SetCoinValueIndex(XT.GetInt(Vars.CoinValueIndex) - 1)
};
CoinManager.prototype.OnSpinStarted = function() {
    var oldBet = CoinManager.lastBet;
    var betIndex = XT.GetInt(Vars.NextBetIndex);
    var tbets = XT.GetObject(Vars.TotalBets);
    CoinManager.lastTotalBet = tbets[betIndex];
    var bets = XT.GetObject(Vars.Bets);
    CoinManager.lastBet = bets[betIndex];
    var biciChanged = false;
    if (XT.GetBool(Vars.FromServer_AllowCoins)) {
        if (CoinManager.lastIndicesPair.betIndex != betIndex || CoinManager.lastIndicesPair.coinIndex != XT.GetInt(Vars.CoinValueIndex)) biciChanged = true;
        CoinManager.lastIndicesPair.betIndex =
            betIndex;
        CoinManager.lastIndicesPair.coinIndex = XT.GetInt(Vars.CoinValueIndex)
    }
    XT.TriggerEvent(Vars.Evt_Internal_LastBetsChanged);
    if (oldBet != CoinManager.lastBet || biciChanged) {
        XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
        XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
    }
};
CoinManager.IsInit = function() {
    return CoinManager.isInited
};
CoinManager.InitLastBets = function() {
    CoinManager.lastBet = CoinManager.GetNextBet();
    CoinManager.lastTotalBet = CoinManager.GetNextTotalBet();
    XT.TriggerEvent(Vars.Evt_Internal_LastBetsChanged)
};
CoinManager.GetLastBet = function() {
    return CoinManager.lastBet
};
CoinManager.GetNextBet = function() {
    var bets = XT.GetObject(Vars.Bets);
    var i = XT.GetInt(Vars.NextBetIndex);
    return bets[i]
};
CoinManager.GetLastTotalBet = function() {
    return CoinManager.lastTotalBet
};
CoinManager.GetNextTotalBet = function() {
    var bets = XT.GetObject(Vars.TotalBets);
    if (bets == null) return 0;
    var i = XT.GetInt(Vars.NextBetIndex);
    var alternativeWager = XT.GetDouble(Vars.AlternativeWager);
    if (alternativeWager >= 0) return alternativeWager;
    return bets[i]
};
CoinManager.GetLastBetIndices = function() {
    return CoinManager.lastIndicesPair
};
CoinManager.ConvertMoneyToCoins = function(value) {
    if (!CoinManager.isInited) return -69;
    var i = -1;
    if (XT.GetBool(Vars.FromServer_AllowCoins)) {
        var coinValues = XT.GetObject(Vars.CoinValues);
        i = XT.GetInt(Vars.CoinValueIndex);
        return Math.round(value / coinValues[i])
    } else return Math.round(value / CoinManager.GetLastBet())
};
CoinManager.GetFormatedMoneyValue = function(val, multiplier, hasDecimals) {
    if (hasDecimals == undefined) hasDecimals = true;
    var valInCurrency = val * multiplier;
    if (XT.GetBool(Vars.HasCoins)) return CoinManager.ConvertMoneyToCoins(valInCurrency).toString();
    else {
        var textFormat = new FormatOptions;
        textFormat.hasDecimals = hasDecimals;
        textFormat.fontId = 1;
        return LocaleManager.FormatValue(valInCurrency, textFormat)
    }
};
CoinManager.prototype.SetCoinValueIndex = function(newCoinValueIndex) {
    var coinValues = XT.GetObject(Vars.CoinValues);
    if (newCoinValueIndex < 0 || newCoinValueIndex >= coinValues.length) {
        console.error("Invalid CoinValueIndex!!!");
        return
    }
    var levels = XT.GetInt(Vars.NumberOfBetLevels);
    CoinManager.isInited = true;
    var betsPerLine = [];
    for (var j = 1; j <= levels; j++) betsPerLine.push(j * (coinValues[newCoinValueIndex] * 1E3) / 1E3);
    XT.SetObject(Vars.Bets, betsPerLine);
    XT.SetBool(Vars.MinCoinValueReached, newCoinValueIndex == 0);
    XT.SetBool(Vars.MaxCoinValueReached,
        newCoinValueIndex == coinValues.length - 1);
    XT.SetInt(Vars.CoinValueIndex, newCoinValueIndex);
    XT.SetDouble(Vars.CoinValueDisplayed, coinValues[newCoinValueIndex]);
    this.UpdateBetValues();
    XT.SetBool(Vars.MinBetAndCoinValueReached, XT.GetBool(Vars.MinBetReached) && XT.GetBool(Vars.MinCoinValueReached));
    XT.SetBool(Vars.MaxBetAndCoinValueReached, XT.GetBool(Vars.MaxBetReached) && XT.GetBool(Vars.MaxCoinValueReached));
    XT.TriggerEvent(Vars.Evt_Internal_CoinValueChanged)
};
CoinManager.ComputeCoinValuesAndCurrentBet = function(betsFromServer, lastBet, defaultBet) {
    if (CoinManager.initialBetsFromServer == null) CoinManager.initialBetsFromServer = betsFromServer;
    var maxBetLimit = XT.GetInt(Vars.Jurisdiction_MaxBetCents);
    var maxWinCents = XT.GetInt(Vars.Jurisdiction_MaxWin) * 100;
    if (maxWinCents > 0) {
        var totalBetMultiplier = XT.GetInt("WinLimit_TotalBetMultiplier");
        if (totalBetMultiplier > 0) {
            var cents = maxWinCents / totalBetMultiplier;
            if (maxBetLimit > 0) cents = Math.min(maxBetLimit, cents);
            maxBetLimit =
                cents
        }
    }
    if (maxBetLimit > 0) {
        var betM = XT.GetInt(Vars.LinesForMinBet);
        maxBetLimit = Math.min(maxBetLimit, betsFromServer[betsFromServer.length - 1] * betM * 100);
        var currentBetC = betsFromServer[0] * 100;
        if (currentBetC * betM > maxBetLimit) currentBetC = 1;
        var newBetsFromServer = [];
        do {
            newBetsFromServer.push(currentBetC / 100);
            if (currentBetC < 10) currentBetC++;
            else if (currentBetC < 100) currentBetC += 5;
            else currentBetC += 25
        } while (currentBetC * betM <= maxBetLimit);
        var maxBetC = Math.floor(maxBetLimit / betM);
        if (newBetsFromServer[newBetsFromServer.length -
                1] != maxBetC / 100) newBetsFromServer.push(maxBetC / 100);
        betsFromServer = newBetsFromServer;
        maxBetLimit = maxBetC * betM;
        lastBet = UHTMath.clamp(lastBet, newBetsFromServer[0], newBetsFromServer[newBetsFromServer.length - 1]);
        defaultBet = UHTMath.clamp(defaultBet, newBetsFromServer[0], newBetsFromServer[newBetsFromServer.length - 1]);
        XT.SetDouble(Vars.ExplicitMaxTotalBetFromServer, maxBetLimit / 100)
    }
    var linesForMinBet = XT.GetInt(Vars.LinesForMinBet);
    var linesForMaxBet = XT.GetInt(Vars.LinesForMaxBet);
    XT.SetDouble(Vars.MinTotalBetFromServer,
        betsFromServer[0] * linesForMinBet);
    XT.SetDouble(Vars.MaxTotalBetFromServer, betsFromServer[betsFromServer.length - 1] * linesForMaxBet);
    if (XT.GetDouble(Vars.MaxTotalBetFromServer) > XT.GetDouble(Vars.ExplicitMaxTotalBetFromServer)) XT.SetDouble(Vars.MaxTotalBetFromServer, XT.GetDouble(Vars.ExplicitMaxTotalBetFromServer));
    if (maxBetLimit > 0)
        if (XT.GetDouble(Vars.MaxTotalBetFromServer) > maxBetLimit / 100) XT.SetDouble(Vars.MaxTotalBetFromServer, betsFromServer[betsFromServer.length - 1] * XT.GetInt(Vars.LinesForMinBet));
    if (XT.GetBool(Vars.FromServer_AllowCoins)) {
        var minBet = betsFromServer[0];
        var maxBet = betsFromServer[betsFromServer.length - 1];
        var curve = [.05, .1, .2, .4];
        var levels = XT.GetInt(Vars.NumberOfBetLevels);
        while (minBet * levels < maxBet / levels * curve[0]) curve.unshift(curve[0] * .2);
        if (maxBet / minBet < levels) {
            levels = maxBet * 1E3 / (minBet * 1E3) | 0;
            XT.SetInt(Vars.NumberOfBetLevels, levels)
        }
        var maxCoinValue = maxBet * 1E3 / levels / 1E3;
        var x = maxCoinValue - minBet;
        var coinValues = [];
        coinValues.push(minBet);
        for (var j = 0; j < curve.length; j++) {
            var computedVal =
                CoinManager.GetNiceCoinValue(minBet + x * curve[j]);
            if (computedVal > minBet && computedVal < maxCoinValue) coinValues.push(computedVal)
        }
        coinValues.push(maxCoinValue);
        for (var i = 1; i < coinValues.length; i++)
            if (Math.abs(coinValues[i] - coinValues[i - 1]) < .001) {
                coinValues.splice(i, 1);
                i--
            }
        XT.SetObject(Vars.CoinValues, coinValues);
        CoinManager.computedCoinValues = coinValues
    } else CoinManager.betsFromServer = betsFromServer;
    CoinManager.SetDesiredBet(lastBet);
    CoinManager.SetDefaultBet(defaultBet)
};
CoinManager.GetNiceCoinValue = function(value) {
    var niceValue;
    if (value > 5) niceValue = Math.floor(value);
    else if (value >= 1) niceValue = Math.floor(value * 4) / 4;
    else {
        var niceSubUnitValues = [.01, .02, .03, .05, .07, .1, .2, .3, .5, .75];
        var minDist = 5;
        var index = -1;
        for (var i = 0; i < niceSubUnitValues.length; i++) {
            var d = Math.abs(value - niceSubUnitValues[i]);
            if (d < minDist) {
                minDist = d;
                index = i
            }
        }
        niceValue = niceSubUnitValues[index]
    }
    return niceValue
};
CoinManager.SetPreviousBetIndices = function(betIndex, coinIndex) {
    CoinManager.desiredBetIndex = betIndex;
    CoinManager.desiredCoinIndex = coinIndex
};
CoinManager.SetDesiredBet = function(bet) {
    CoinManager.desiredBet = bet;
    CoinManager.savedDesiredBet = bet;
    CoinManager.canStillGoToStrictMode = true
};
CoinManager.SetDefaultBet = function(bet) {
    CoinManager.defaultBet = bet
};
CoinManager.SetStrictBetMode = function(isStrict) {
    if (isStrict != CoinManager.isStrictMode) CoinManager.smartBets = null;
    var mustUpdateServerSettings = false;
    var i;
    if (XT.GetBool(Vars.FromServer_AllowCoins)) {
        var betIndex = 0;
        var coinIndex = CoinManager.computedCoinValues.length > 3 ? 2 : 0;
        var haveSettings = false;
        if (CoinManager.lastIndicesPair == null) CoinManager.lastIndicesPair = {};
        if (CoinManager.desiredBetIndex != -1 && CoinManager.desiredCoinIndex != -1) {
            if (CoinManager.desiredBetIndex >= 0 && CoinManager.desiredBetIndex < XT.GetInt(Vars.NumberOfBetLevels)) betIndex =
                CoinManager.desiredBetIndex;
            if (CoinManager.desiredCoinIndex >= 0 && CoinManager.desiredCoinIndex < CoinManager.computedCoinValues.length) coinIndex = CoinManager.desiredCoinIndex;
            haveSettings = true
        }
        if (isStrict && CoinManager.canStillGoToStrictMode && (!CoinManager.isStrictMode || !CoinManager.isInited || CoinManager.desiredBet > 0)) {
            CoinManager.isInited = true;
            CoinManager.canStillGoToStrictMode = false;
            CoinManager.isStrictMode = true;
            var newCoinValues = [];
            var newBetIndex = 0;
            var newCoinIndex = 0;
            newCoinValues.push(CoinManager.savedDesiredBet);
            if (haveSettings && coinIndex == CoinManager.desiredCoinIndex && betIndex == CoinManager.desiredBetIndex) {
                var newCoinVal = CoinManager.computedCoinValues[coinIndex];
                if (Math.abs(CoinManager.savedDesiredBet / newCoinVal - (betIndex + 1)) <= .001) {
                    newCoinValues = [];
                    for (i = 0; i < CoinManager.computedCoinValues.length; i++) newCoinValues.push(CoinManager.computedCoinValues[i]);
                    newCoinIndex = coinIndex;
                    newBetIndex = betIndex
                }
            }
            XT.SetObject(Vars.CoinValues, newCoinValues);
            XT.SetInt(Vars.NextBetIndex, newBetIndex);
            CoinManager.lastIndicesPair.betIndex =
                newBetIndex;
            CoinManager.lastIndicesPair.coinIndex = newCoinIndex;
            CoinManager.instance.SetCoinValueIndex(newCoinIndex)
        } else if (!isStrict && (CoinManager.isStrictMode || !CoinManager.isInited || CoinManager.desiredBet > 0)) {
            CoinManager.isInited = true;
            CoinManager.canStillGoToStrictMode = false;
            CoinManager.isStrictMode = false;
            XT.SetObject(Vars.CoinValues, CoinManager.computedCoinValues);
            var isMatching = haveSettings && Math.abs(CoinManager.savedDesiredBet - CoinManager.computedCoinValues[coinIndex] * (betIndex + 1)) < .001;
            if (CoinManager.defaultBet >
                0 && CoinManager.desiredBetIndex == -1 || !isMatching) {
                var targetBet = !isMatching ? CoinManager.savedDesiredBet : CoinManager.defaultBet;
                var p = CoinManager.GetClosestIndices(targetBet);
                betIndex = p.betIndex;
                coinIndex = p.coinIndex;
                CoinManager.defaultBet = -1;
                mustUpdateServerSettings = true
            } else if (CoinManager.desiredBet > 0) {
                var n = XT.GetInt(Vars.NumberOfBetLevels);
                var found = false;
                for (var idxLevel = 0; idxLevel < n; idxLevel++) {
                    for (var idxCoin = 0; idxCoin < CoinManager.computedCoinValues.length; idxCoin++)
                        if (Math.abs(CoinManager.desiredBet -
                                CoinManager.computedCoinValues[idxCoin] * (idxLevel + 1)) <= .001) {
                            betIndex = idxLevel;
                            coinIndex = idxCoin;
                            found = true;
                            break
                        }
                    if (found) break
                }
            }
            XT.SetInt(Vars.NextBetIndex, betIndex);
            CoinManager.lastIndicesPair.betIndex = betIndex;
            CoinManager.lastIndicesPair.coinIndex = coinIndex;
            CoinManager.instance.SetCoinValueIndex(coinIndex)
        }
    } else if (isStrict && CoinManager.canStillGoToStrictMode && (!CoinManager.isStrictMode || !CoinManager.isInited || CoinManager.desiredBet > 0)) {
        CoinManager.isInited = true;
        CoinManager.canStillGoToStrictMode =
            false;
        CoinManager.isStrictMode = true;
        XT.SetInt(Vars.NextBetIndex, 0);
        var newBets = [];
        newBets.push(CoinManager.savedDesiredBet);
        XT.SetObject(Vars.Bets, newBets);
        CoinManager.instance.UpdateBetValues()
    } else if (!isStrict && (CoinManager.isStrictMode || !CoinManager.isInited)) {
        CoinManager.isInited = true;
        CoinManager.canStillGoToStrictMode = false;
        CoinManager.isStrictMode = false;
        var betUsed = CoinManager.savedDesiredBet;
        if (CoinManager.desiredBetIndex == -1 && CoinManager.defaultBet > 0) betUsed = CoinManager.defaultBet;
        var idx =
            CoinManager.betsFromServer.length > 2 ? 2 : CoinManager.betsFromServer.length;
        for (i = 0; i < CoinManager.betsFromServer.length; i++)
            if (Math.abs(betUsed - CoinManager.betsFromServer[i]) <= .001) {
                idx = i;
                break
            }
        XT.SetInt(Vars.NextBetIndex, idx);
        XT.SetObject(Vars.Bets, CoinManager.betsFromServer);
        CoinManager.instance.UpdateBetValues()
    }
    CoinManager.desiredBet = -1;
    if (mustUpdateServerSettings) {
        XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
        XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
    }
};
CoinManager.GetClosestIndices = function(bet) {
    var ret = {};
    var dist = 1E30;
    var n = XT.GetInt(Vars.NumberOfBetLevels);
    for (var idxLevel = 0; idxLevel < n; idxLevel++)
        for (var idxCoin = 0; idxCoin < CoinManager.computedCoinValues.length; idxCoin++) {
            var d = Math.abs(bet - CoinManager.computedCoinValues[idxCoin] * (idxLevel + 1));
            if (d < dist) {
                ret.betIndex = idxLevel;
                ret.coinIndex = idxCoin;
                dist = d
            }
        }
    return ret
};
CoinManager.prototype.RevertToLastBet = function() {
    if (XT.GetBool(Vars.FromServer_AllowCoins)) {
        XT.SetInt(Vars.NextBetIndex, CoinManager.lastIndicesPair.betIndex);
        CoinManager.instance.SetCoinValueIndex(CoinManager.lastIndicesPair.coinIndex)
    } else {
        var bets = XT.GetObject(Vars.Bets);
        var betIndex = 0;
        for (var i = 0; i < bets.length; i++)
            if (CoinManager.lastBet == bets[i]) betIndex = i;
        XT.SetInt(Vars.NextBetIndex, betIndex);
        this.UpdateBetValues()
    }
};
CoinManager.SmartBet = function() {
    this.betIndex = -1;
    this.coinValueIndex = -1;
    this.betValue = 0
};
CoinManager.smartBets = null;
CoinManager.prototype.InitSmartBets = function() {
    var coinValues = XT.GetObject(Vars.CoinValues);
    var betsCount = XT.GetObject(Vars.Bets).length;
    var smartBets = [];
    var betVals = [];
    for (var i = 0; i < coinValues.length; ++i)
        for (var j = betsCount; j > 0; --j) {
            var betVal = coinValues[i] * j;
            var unique = true;
            for (var k = 0; k < betVals.length; ++k)
                if (Math.abs(betVals[k] - betVal) < 1E-6) {
                    unique = false;
                    break
                }
            if (unique) {
                var sb = new CoinManager.SmartBet;
                sb.coinValueIndex = i;
                sb.betIndex = j - 1;
                sb.betValue = betVal;
                smartBets.push(sb);
                betVals.push(betVal)
            }
        }
    CoinManager.smartBets =
        smartBets.sort(function(a, b) {
            return a.betValue > b.betValue ? 1 : b.betValue > a.betValue ? -1 : 0
        })
};
CoinManager.prototype.SetSmartBet = function(increase) {
    if (CoinManager.smartBets == null) this.InitSmartBets();
    var betIdx = XT.GetInt(Vars.NextBetIndex);
    var betVal = XT.GetObject(Vars.Bets)[betIdx];
    var smartBets = CoinManager.smartBets;
    var sb = null;
    if (increase)
        for (var i = 0; i < smartBets.length; ++i) {
            if (betVal < smartBets[i].betValue && Math.abs(betVal - smartBets[i].betValue) > 1E-6) {
                sb = smartBets[i];
                break
            }
        } else
            for (var i = smartBets.length - 1; i >= 0; --i)
                if (betVal > smartBets[i].betValue && Math.abs(betVal - smartBets[i].betValue) > 1E-6) {
                    sb =
                        smartBets[i];
                    break
                }
    if (sb == null) return;
    if (XT.GetInt(Vars.CoinValueIndex) != sb.coinValueIndex) {
        if (XT.GetBool(Vars.WaitInResultForBigWin)) {
            XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
            return
        }
        this.SetCoinValueIndex(sb.coinValueIndex)
    }
    if (betIdx != sb.betIndex) {
        XT.SetInt(Vars.NextBetIndex, sb.betIndex);
        this.UpdateBetValues()
    }
    XT.TriggerEvent("Evt_SetSmartBetFinished")
};
goog.provide("UHT.GUIArrangerSettings");
goog.require("UHT.XTLink");
GUIArrangerSettings.prototype = Object.create(XTLink.prototype);
GUIArrangerSettings.prototype.constructor = GUIArrangerSettings;

function GUIArrangerSettings() {
    XTLink.call(this);
    this.applyToExtraElements = false;
    this.commonTargets = null;
    this.logoTargetAnchorDesktop = null;
    this.logoTargetArrangeableDesktop = null;
    this.gameAnchorUpLeftDesktop = null;
    this.gameAnchorDownRightDesktop = null;
    this.TopBarSprite_base = null;
    this.logoTargetAnchorMobile = null;
    this.logoTargetArrangeableMobile = null;
    this.gameAnchorUpLeftMobile = null;
    this.gameAnchorDownRightMobile = null;
    this.portraitTargets = null;
    this.landscapeTargets = null
}
GUIArrangerSettings.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(InterfaceVars.GUIArrangerSettings, this)
};
goog.require("UHT.GUIArrangerSettings");

function GUIArrangerPortraitButtonArranger() {
    this.collider = null;
    this.animator = null
}
GUIArrangerPortraitButtonArranger.prototype.Arrange = function(src, dest, utils, useScale) {
    if (src == null || dest == null) return;
    utils.CopyPosition(src, dest);
    utils.CopyPosition(src, this.collider);
    if (useScale) {
        var sls = src.transform.localScale();
        var dls = dest.transform.localScale();
        var cls = this.collider.transform.localScale();
        dest.transform.localScale(new UHTMath.Vector3(sls.x, sls.y, dls.z));
        this.collider.transform.localScale(new UHTMath.Vector3(cls.x / dls.x * sls.x, cls.y / dls.y * sls.y, cls.z))
    }
    this.animator.from = this.animator.to =
        dest
};

function GUIArrangerCommonObjects() {
    this.camerasArrangeable = null
}

function GUIArrangerPortraitObjectsBase() {
    this.DynamicContentV11 = null;
    this.TopBar = null;
    this.TopBarBackground = null;
    this.TournamentRankLocalPosition = null;
    this.AutoplaySimpleWindow = null;
    this.autoplayButton = null;
    this.betButton = null;
    this.spinButtonObstacles = null;
    this.bottomBar = null;
    this.bottomBarCollider = null;
    this.logoArrangeable = null
}
GUIArrangerPortraitObjects.prototype = Object.create(GUIArrangerPortraitObjectsBase.prototype);
GUIArrangerPortraitObjects.prototype.constructor = GUIArrangerPortraitObjects;

function GUIArrangerPortraitObjects() {
    GUIArrangerPortraitObjectsBase.call(this);
    this.TournamentRankBackgrounds = null;
    this.TopBarSprite_base = null;
    this.TopBarExtraSprite = null;
    this.BottomBarSprite_base = null;
    this.BottomBarExtraSprite = null;
    this.betButtonArranger = null;
    this.autoplayButtonArranger = null
}
GUIArrangerSettingsPortraitObjects.prototype = Object.create(GUIArrangerPortraitObjectsBase.prototype);
GUIArrangerSettingsPortraitObjects.prototype.constructor = GUIArrangerSettingsPortraitObjects;

function GUIArrangerSettingsPortraitObjects() {
    GUIArrangerPortraitObjectsBase.call(this);
    this.TournamentRankBackground = null;
    this.TopBarSprite_base = null;
    this.TopBarSprite_extra = null;
    this.BottomBarSprite_base = null;
    this.BottomBarSprite_extra = null;
    this.TopBarColor = null;
    this.BottomBarColor = null;
    this.useAutoplayButtonScale = false;
    this.useBetButtonScale = false
}

function GUIArrangerSettingsLandscapeObjects() {
    this.BottomBar = null;
    this.AnchoredLeftButtonsLocalPosition = null;
    this.AnchoredLeftButtonsScreenAnchor = null;
    this.AnchoredRightButtonsScreenAnchor = null;
    this.TopBarSprite_base = null
}
GUIArrangerLandscapeObjects.prototype = Object.create(GUIArrangerSettingsLandscapeObjects.prototype);
GUIArrangerLandscapeObjects.prototype.constructor = GUIArrangerLandscapeObjects;

function GUIArrangerLandscapeObjects() {
    GUIArrangerSettingsLandscapeObjects.call(this);
    this.autoplayButton = null;
    this.autoplayCollider = null;
    this.betButton = null;
    this.betCollider = null
}

function BlackBands() {
    this.up = null;
    this.down = null;
    this.left = null;
    this.right = null
}

function GameAnchors(ul, dr) {
    this.upLeft = ul;
    this.downRight = dr
}
var GUIArrangerVars = {
    GUIArranger_GameSize: "GUIArranger_GameSize"
};
GUIArranger.prototype = Object.create(XTLink.prototype);
GUIArranger.prototype.constructor = GUIArranger;

function GUIArranger() {
    XTLink.call(this);
    this.logoObjectAnchor = null;
    this.logoObjectArrangeable = null;
    this.TopBarSprite_base = null;
    this.commonObjects = null;
    this.portraitObjects = null;
    this.landscapeObjects = null;
    this.gameAnchorUpLeft = null;
    this.gameAnchorDownRight = null;
    this.screenAnchorUpLeft = null;
    this.screenAnchorDownRight = null;
    this.blackBands = null;
    this.gameTitles = null;
    this.settings = null;
    this.screenAnchorUpdated = false
}
GUIArranger.I = null;
GUIArranger.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(GUIArrangerVars.GUIArranger_GameSize, UHTMath.Vector3.zero);
    XT.SetObject(InterfaceVars.GameAnchors, new GameAnchors(this.gameAnchorUpLeft.transform, this.gameAnchorDownRight.transform))
};
GUIArranger.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(InterfaceVars.GUIArrangerSettings, this.OnGUIArrangerSettingsChanged, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_DataToCode_UpdateGUIArrangerSettings, this.OnUpdateGUIArrangerSettings, this)
};
GUIArranger.prototype.OnUpdateGUIArrangerSettings = function() {
    if (this.settings != null) this.DoIt()
};
GUIArranger.prototype.OnGUIArrangerSettingsChanged = function(param) {
    this.settings = param;
    if (this.settings != null) this.DoIt()
};
GUIArranger.prototype.Awake = function() {
    XTLink.prototype.Awake.call(this);
    GUIArranger.I = this
};
GUIArranger.prototype.DoIt = function() {
    this.CopyArrangeableTransform(this.settings.commonTargets.camerasArrangeable, this.commonObjects.camerasArrangeable);
    if (Globals.isMobile) {
        this.CopyTransform(this.settings.portraitTargets.TopBar, this.portraitObjects.TopBar);
        this.CopyTransform(this.settings.portraitTargets.TopBarBackground, this.portraitObjects.TopBarBackground);
        this.CopyTransform(this.settings.portraitTargets.DynamicContentV11, this.portraitObjects.DynamicContentV11);
        this.CopySprite(this.settings.portraitTargets.TopBarSprite_base,
            this.portraitObjects.TopBarSprite_base);
        this.CopySprite(this.settings.portraitTargets.TopBarSprite_extra, this.portraitObjects.TopBarExtraSprite);
        this.CopySprite(this.settings.portraitTargets.BottomBarSprite_base, this.portraitObjects.BottomBarSprite_base);
        this.CopySprite(this.settings.portraitTargets.BottomBarSprite_extra, this.portraitObjects.BottomBarExtraSprite);
        this.CopyColor(this.settings.portraitTargets.TopBarColor, this.portraitObjects.TopBarExtraSprite);
        this.CopyColor(this.settings.portraitTargets.BottomBarColor,
            this.portraitObjects.BottomBarExtraSprite);
        this.CopyTransform(this.settings.landscapeTargets.BottomBar, this.landscapeObjects.BottomBar);
        this.CopyArrangeableTransform(this.settings.gameAnchorUpLeftMobile, this.gameAnchorUpLeft);
        this.CopyArrangeableTransform(this.settings.gameAnchorDownRightMobile, this.gameAnchorDownRight);
        if (this.settings.landscapeTargets.TopBarSprite_base != null && this.landscapeObjects.TopBarSprite_base != null) {
            this.CopySprite(this.settings.landscapeTargets.TopBarSprite_base, this.landscapeObjects.TopBarSprite_base);
            this.CopySpriteSize(this.settings.landscapeTargets.TopBarSprite_base, this.landscapeObjects.TopBarSprite_base);
            this.CopyColor(this.settings.landscapeTargets.TopBarSprite_base.color, this.landscapeObjects.TopBarSprite_base)
        }
        if (this.settings.applyToExtraElements) {
            this.CopyTransform(this.settings.portraitTargets.AutoplaySimpleWindow, this.portraitObjects.AutoplaySimpleWindow);
            this.CopyTransformLocalPosition(this.settings.portraitTargets.TournamentRankLocalPosition, this.portraitObjects.TournamentRankLocalPosition);
            for (var i = 0; i < this.portraitObjects.TournamentRankBackgrounds.length; ++i) this.CopyTransformLocalPosition(this.settings.portraitTargets.TournamentRankBackground, this.portraitObjects.TournamentRankBackgrounds[i])
        }
        var screenAnchor = this.landscapeObjects.AnchoredLeftButtonsScreenAnchor;
        var screenAnchorSettings = this.settings.landscapeTargets.AnchoredLeftButtonsScreenAnchor;
        if (screenAnchor != null && screenAnchorSettings != null) this.CopyScreenAnchor(screenAnchorSettings, screenAnchor);
        var go = this.landscapeObjects.AnchoredLeftButtonsLocalPosition;
        var gos = this.settings.landscapeTargets.AnchoredLeftButtonsLocalPosition;
        if (go != null && gos != null) {
            this.CopyLocalPosition(gos, go);
            this.CopyPosition(this.landscapeObjects.autoplayButton, this.landscapeObjects.autoplayCollider);
            this.CopyPosition(this.landscapeObjects.betButton, this.landscapeObjects.betCollider)
        }
        go = this.portraitObjects.spinButtonObstacles;
        gos = this.settings.portraitTargets.spinButtonObstacles;
        if (go != null && gos != null) this.CopyTransform(gos, go);
        screenAnchor = this.landscapeObjects.AnchoredRightButtonsScreenAnchor;
        screenAnchorSettings = this.settings.landscapeTargets.AnchoredRightButtonsScreenAnchor;
        if (screenAnchor != null && screenAnchorSettings != null) this.CopyScreenAnchor(screenAnchorSettings, screenAnchor);
        this.portraitObjects.betButtonArranger.Arrange(this.settings.portraitTargets.betButton, this.portraitObjects.betButton, this, this.settings.portraitTargets.useBetButtonScale);
        this.portraitObjects.autoplayButtonArranger.Arrange(this.settings.portraitTargets.autoplayButton, this.portraitObjects.autoplayButton, this,
            this.settings.portraitTargets.useAutoplayButtonScale);
        this.CopyTransform(this.settings.portraitTargets.bottomBar, this.portraitObjects.bottomBar);
        this.CopyTransform(this.settings.portraitTargets.bottomBarCollider, this.portraitObjects.bottomBarCollider);
        this.CopyArrangeableTransform(this.settings.portraitTargets.logoArrangeable, this.portraitObjects.logoArrangeable)
    } else {
        if (this.settings.TopBarSprite_base != null && this.TopBarSprite_base != null) {
            this.CopyTransformLocalPosition(this.settings.TopBarSprite_base.gameObject,
                this.TopBarSprite_base.gameObject);
            this.CopySprite(this.settings.TopBarSprite_base, this.TopBarSprite_base);
            this.CopyColor(this.settings.TopBarSprite_base.color, this.TopBarSprite_base);
            this.CopySpriteSize(this.settings.TopBarSprite_base, this.TopBarSprite_base)
        }
        this.CopyTransform(this.settings.gameAnchorUpLeftDesktop, this.gameAnchorUpLeft.gameObject);
        this.CopyTransform(this.settings.gameAnchorDownRightDesktop, this.gameAnchorDownRight.gameObject)
    }
};
GUIArranger.prototype.CopyTransform = function(src, dest) {
    if (src != null && dest != null) {
        dest.transform.position(src.transform.position());
        dest.transform.localScale(src.transform.localScale())
    }
};
GUIArranger.prototype.CopyTransformLocalPosition = function(src, dest) {
    if (src != null) {
        dest.transform.localPosition(src.transform.localPosition());
        dest.transform.localScale(src.transform.localScale())
    }
};
GUIArranger.prototype.CopyPosition = function(src, dest) {
    if (src != null) dest.transform.position(src.transform.position())
};
GUIArranger.prototype.CopyLocalPosition = function(src, dest) {
    if (src != null) dest.transform.localPosition(src.transform.localPosition())
};
GUIArranger.prototype.CopyArrangeableTransform = function(src, dest) {
    if (src != null && dest != null) {
        this.CopyTransform(src.gameObject, dest.gameObject);
        dest.localPositionLandscape = src.localPositionLandscape;
        dest.localScaleLandscape = src.localScaleLandscape;
        dest.localPositionPortrait = src.localPositionPortrait;
        dest.localScalePortrait = src.localScalePortrait;
        dest.separateForIPhone = src.separateForIPhone;
        dest.localPositionIPhonePortrait = src.localPositionIPhonePortrait;
        dest.localScaleIPhonePortrait = src.localScaleIPhonePortrait;
        dest.separateForIPad = src.separateForIPad;
        dest.localPositionIPadPortrait = src.localPositionIPadPortrait;
        dest.localScaleIPadPortrait = src.localScaleIPadPortrait;
        dest.separateForLandscapeWide = src.separateForLandscapeWide;
        dest.localPositionLandscapeWide = src.localPositionLandscapeWide;
        dest.localScaleLandscapeWide = src.localScaleLandscapeWide;
        dest.separateForLandscapeWideFull = src.separateForLandscapeWideFull;
        dest.localPositionLandscapeWideFull = src.localPositionLandscapeWideFull;
        dest.localScaleLandscapeWideFull =
            src.localScaleLandscapeWideFull
    }
};
GUIArranger.prototype.CopyScreenAnchor = function(src, dest) {
    if (src != null) {
        this.CopyTransform(src.gameObject, dest.gameObject);
        dest.anchorLeft = src.anchorLeft;
        dest.leftOffset = src.leftOffset;
        dest.anchorRight = src.anchorRight;
        dest.rightOffset = src.rightOffset;
        dest.limitByGameAnchors = src.limitByGameAnchors
    }
};
GUIArranger.prototype.CopyColor = function(src, dest) {
    if (dest != null) dest.color = src
};
GUIArranger.prototype.CopySprite = function(src, dest) {
    if (src != null && dest != null) {
        dest.atlas = src.atlas;
        dest.anchorX = src.anchorX;
        dest.anchorY = src.anchorY;
        dest.spriteType = src.spriteType;
        dest.SetSpriteName(src.spriteName)
    }
};
GUIArranger.prototype.CopySpriteSize = function(src, dest) {
    if (src != null && dest != null) {
        dest.width = src.width;
        dest.height = src.height
    }
};
GUIArranger.prototype.CopyBand = function(src, dest) {
    if (src == null || dest == null) return;
    dest.gameObject.SetActive(src.gameObject.activeSelf);
    if (dest.gameObject.activeSelf) {
        this.CopySpriteSize(src, dest);
        this.CopyTransform(src.gameObject, dest.gameObject)
    }
};
GUIArranger.prototype.ArrangeBlackBands = function() {
    var gUL = this.gameAnchorUpLeft.transform.localPosition();
    var gDR = this.gameAnchorDownRight.transform.localPosition();
    var sUL = this.screenAnchorUpLeft.transform.localPosition();
    var sDR = this.screenAnchorDownRight.transform.localPosition();
    var dU = Math.round(sUL.y - gUL.y);
    var dD = Math.round(sDR.y - gDR.y);
    var dL = Math.round(sUL.x - gUL.x);
    var dR = Math.round(sDR.x - gDR.x);
    var w = Math.round(sDR.x - sUL.x);
    var h = Math.round(sUL.y - sDR.y);
    this.blackBands.up.gameObject.SetActive(dU >
        0);
    if (this.blackBands.up.gameObject.activeSelf) {
        this.blackBands.up.width = w;
        this.blackBands.up.height = dU
    }
    this.blackBands.down.gameObject.SetActive(dD < 0);
    if (this.blackBands.down.gameObject.activeSelf) {
        this.blackBands.down.width = w;
        this.blackBands.down.height = -dD
    }
    this.blackBands.left.gameObject.SetActive(dL < 0);
    if (this.blackBands.left.gameObject.activeSelf) {
        this.blackBands.left.height = h;
        this.blackBands.left.width = -dL
    }
    this.blackBands.right.gameObject.SetActive(dR > 0);
    if (this.blackBands.right.gameObject.activeSelf) {
        this.blackBands.right.height =
            h;
        this.blackBands.right.width = dR
    }
    var gW = Math.round(gDR.x - gUL.x);
    var gH = Math.round(gUL.y - gDR.y);
    XT.SetObject(GUIArrangerVars.GUIArranger_GameSize, new UHTMath.Vector3(Math.min(w, gW), Math.min(h, gH), 0));
    XT.TriggerEvent(InterfaceVars.Evt_Internal_BlackBandsUpdated)
};
GUIArranger.InitBands = function(dest) {
    var I = GUIArranger.I;
    var src = I.blackBands;
    I.CopySprite(src.up, dest.up);
    I.CopySprite(src.down, dest.down);
    I.CopySprite(src.left, dest.left);
    I.CopySprite(src.right, dest.right)
};
GUIArranger.UpdateBands = function(dest) {
    var I = GUIArranger.I;
    var src = I.blackBands;
    I.CopyBand(src.up, dest.up);
    I.CopyBand(src.down, dest.down);
    I.CopyBand(src.left, dest.left);
    I.CopyBand(src.right, dest.right)
};
GUIArranger.prototype.ScreenAnchorUpdated = function() {
    this.screenAnchorUpdated = true
};
GUIArranger.prototype.LateUpdate = function() {
    if (this.screenAnchorUpdated) {
        this.ArrangeBlackBands();
        this.screenAnchorUpdated = false
    }
};
goog.require("UHT.Engine");
AutoplayReopen.prototype = Object.create(XTLink.prototype);
AutoplayReopen.prototype.constructor = AutoplayReopen;

function AutoplayReopen() {
    XTLink.call(this);
    this.shouldReopen = false;
    this.reopenAutoplay = null;
    this.oldState = VSGameState.Invalid
}
AutoplayReopen.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_StartAutoplay, this.OnStartAutoplay, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_StopAutoplay, this.OnStopAutoplay, this);
    XT.RegisterCallbackBool(Vars.CanSpin, this.OnCanSpin, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ChangeVSGameState, this.OnVSGameStateChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StoppedAutoplayByCondition, this.OnStopAutoplay, this)
};
AutoplayReopen.prototype.OnLastWinIsCountingChanged = function(val) {
    if (!val && XT.GetInt(Vars.AutoplaySpinsLeft) < 0 && this.shouldReopen) {
        this.reopenAutoplay.Start();
        this.shouldReopen = false;
        XT.UnregisterCallbackBool(this.OnLastWinIsCountingChanged, this)
    }
};
AutoplayReopen.prototype.OnStartAutoplay = function() {
    this.shouldReopen = true;
    window["globalMustStopAutoplay"] = false
};
AutoplayReopen.prototype.OnStopAutoplay = function() {
    this.shouldReopen = false
};
AutoplayReopen.prototype.OnCanSpin = function(val) {
    if (val && XT.GetInt(Vars.AutoplaySpinsLeft) < 0 && this.shouldReopen)
        if (XT.GetDouble(Vars.WinReceived) <= 0) {
            this.reopenAutoplay.Start();
            this.shouldReopen = false
        } else XT.RegisterCallbackBool(Vars.LastWinIsCounting, this.OnLastWinIsCountingChanged, this)
};
AutoplayReopen.prototype.OnVSGameStateChanged = function() {
    var newState = VSGameStateManager.GetState();
    if ((this.oldState == VSGameState.Bonus || this.oldState == VSGameState.ResultFreeSpins || this.oldState == VSGameState.Gamble || this.oldState == VSGameState.GambleCustom || this.oldState == VSGameState.Jackpot) && newState == VSGameState.Result) {
        XT.UnregisterCallbackEvent(this.OnResultDisplayerLoopDone, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_LoopDone, this.OnResultDisplayerLoopDone, this)
    }
    this.oldState =
        newState
};
AutoplayReopen.prototype.OnResultDisplayerLoopDone = function() {
    if (XT.GetInt(Vars.AutoplaySpinsLeft) < 0 && this.shouldReopen) {
        this.reopenAutoplay.Start();
        this.shouldReopen = false;
        XT.UnregisterCallbackEvent(this.OnResultDisplayerLoopDone, this)
    }
};
goog.require("UHT.Component");
var Nike_XTVariableType = {
    XT_Bool: 0,
    XT_Int: 1,
    XT_Float: 2,
    XT_Double: 3,
    XT_String: 4,
    None: 5
};
Nike_XTVariable.prototype = Object.create(Component.prototype);
Nike_XTVariable.prototype.constructor = Nike_XTVariable;

function Nike_XTVariable() {
    Component.call(this);
    this.variableType = Nike_XTVariableType.None;
    this.variableName = "";
    this.forcedValue = "";
    this.unforcedValue = ""
}
Nike_XTVariable.prototype.JustDoIt = function(value) {
    switch (this.variableType) {
        case Nike_XTVariableType.XT_Bool:
            XT.SetBool(this.variableName, _bool.Parse(value));
            break;
        case Nike_XTVariableType.XT_Int:
            XT.SetInt(this.variableName, _number.otoi(value));
            break;
        case Nike_XTVariableType.XT_Float:
            XT.SetFloat(this.variableName, _number.otod(value));
            break;
        case Nike_XTVariableType.XT_Double:
            XT.SetDouble(this.variableName, _number.otod(value));
            break;
        case Nike_XTVariableType.XT_String:
            XT.SetString(this.variableName,
                value);
            break
    }
};
Nike_XTVariable.prototype.ForceValue = function(value) {
    if (this.variableType == Nike_XTVariableType.XT_Bool) {
        this.unforcedValue = String(XT.GetBool(this.variableName));
        XT.RegisterCallbackBool(this.variableName, this.ForcedCallbackBool, this)
    } else if (this.variableType == Nike_XTVariableType.XT_Double) {
        this.unforcedValue = String(XT.GetDouble(this.variableName));
        XT.RegisterCallbackDouble(this.variableName, this.ForcedCallbackDouble, this)
    } else if (this.variableType == Nike_XTVariableType.XT_Float) {
        this.unforcedValue = String(XT.GetFloat(this.variableName));
        XT.RegisterCallbackFloat(this.variableName, this.ForcedCallbackFloat, this)
    } else if (this.variableType == Nike_XTVariableType.XT_Int) {
        this.unforcedValue = String(XT.GetInt(this.variableName));
        XT.RegisterCallbackInt(this.variableName, this.ForcedCallbackInt, this)
    } else if (this.variableType == Nike_XTVariableType.XT_String) {
        this.unforcedValue = XT.GetString(this.variableName);
        XT.RegisterCallbackString(this.variableName, this.ForcedCallbackString, this)
    }
    this.forcedValue = value;
    this.JustDoIt(value)
};
Nike_XTVariable.prototype.UnforceValue = function() {
    if (this.variableType == Nike_XTVariableType.XT_Bool) XT.UnregisterCallbackBool(this.ForcedCallbackBool, this);
    else if (this.variableType == Nike_XTVariableType.XT_Double) XT.UnregisterCallbackDouble(this.ForcedCallbackDouble, this);
    else if (this.variableType == Nike_XTVariableType.XT_Float) XT.UnregisterCallbackFloat(this.ForcedCallbackFloat, this);
    else if (this.variableType == Nike_XTVariableType.XT_Int) XT.UnregisterCallbackInt(this.ForcedCallbackInt, this);
    else if (this.variableType ==
        Nike_XTVariableType.XT_String) XT.UnregisterCallbackString(this.ForcedCallbackString, this);
    this.JustDoIt(this.unforcedValue)
};
Nike_XTVariable.prototype.ForcedCallbackBool = function(param) {
    this.JustDoIt(this.forcedValue)
};
Nike_XTVariable.prototype.ForcedCallbackDouble = function(param) {
    this.JustDoIt(this.forcedValue)
};
Nike_XTVariable.prototype.ForcedCallbackFloat = function(param) {
    this.JustDoIt(this.forcedValue)
};
Nike_XTVariable.prototype.ForcedCallbackInt = function(param) {
    this.JustDoIt(this.forcedValue)
};
Nike_XTVariable.prototype.ForcedCallbackString = function(param) {
    this.JustDoIt(this.forcedValue)
};
goog.require("UHT.Engine");
goog.provide("UHT.UserNotification");
UserNotification.prototype = Object.create(XTLink.prototype);
UserNotification.prototype.constructor = UserNotification;

function UserNotification() {
    XTLink.call(this);
    this.currentNotificationId = 0;
    this.myNotificationId = -1;
    this.mustShow = false
}
UserNotification.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.ShowPendingNotifications, this.OnShowPendingNotifications, this)
};
UserNotification.prototype.OnShowPendingNotifications = function() {
    if (this.myNotificationId == this.currentNotificationId && this.mustShow) {
        this.mustShow = false;
        this.Show()
    }
};
UserNotification.prototype.RequestToShow = function() {
    this.currentNotificationId++;
    this.myNotificationId = this.currentNotificationId;
    this.mustShow = true
};
UserNotification.prototype.Handled = function() {
    this.myNotificationId = -1;
    this.currentNotificationId--
};
UserNotification.prototype.Show = function() {};
goog.require("UHT.Engine");
goog.require("UHT.UserNotification");
TimedFreeRoundBonusManager.prototype = Object.create(UserNotification.prototype);
TimedFreeRoundBonusManager.prototype.constructor = TimedFreeRoundBonusManager;

function TimedFreeRoundBonusManager() {
    UserNotification.call(this);
    this.currentTime = 0;
    this.timeLabels = null;
    this.isActive = false;
    this.shouldUpdateTimer = false;
    this.cachedStartEvent = [];
    this.cachedbetLevel = 0;
    this.bonusRoundsData = null;
    this.showTimedFRBInfo = null;
    this.countingInBackground = false;
    this.hasDataToCheckShowWindow = false
}
TimedFreeRoundBonusManager.prototype.XTRegisterCallbacks = function() {
    UserNotification.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_BonusRoundsOnContinuePressed, this.OnContinuePressed, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_GUI_TimedBonusRoundsFinished, this.OnTimedBonusRoundsFinished, this);
    XT.RegisterCallbackObject(Vars.BonusRoundsData, this.OnBonusRoundsData, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_SpinResultReceived, this.OnSpinResultReceived,
        this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this)
};
TimedFreeRoundBonusManager.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(Vars.TimedBonusRoundIsOngoing, false);
    XT.SetInt(Vars.TimedBonusRoundsSeconds, 0);
    XT.SetBool(Vars.ShouldIgnoreNextFinishEventFromServer, false)
};
TimedFreeRoundBonusManager.prototype.OnBonusRoundsData = function(obj) {
    this.bonusRoundsData = obj;
    if (obj == null) return;
    if (this.bonusRoundsData.Type != VsFreeRound.RoundType.Timed) return;
    var evts = XT.GetObject(Vars.BonusRoundsEvents);
    if (evts != null)
        for (var i = 0; i < evts.length; i++)
            if (evts[i].Type == VsFreeRoundEvent.EventType.Start) {
                this.cachedStartEvent.push(evts[i].Clone());
                var foxResponse = XT.GetObject(FOXVars.FOX_Response);
                if (foxResponse != undefined && foxResponse["c"] != undefined) this.cachedbetLevel = parseFloat(foxResponse["c"]);
                XT.SetBool(Vars.ShouldIgnoreNextFinishEventFromServer, true);
                var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
                if (evts.length == 1 && !fsr.IsLastFreeSpin) this.RequestToShow();
                XT.SetDouble(Vars.BonusRoundEndDateTimestamp, evts[i].EndDateTimestamp);
                if (evts != null && evts.length == 1 && evts[0].Type == VsFreeRoundEvent.EventType.Start && !evts[0].IsFreeRoundPending) {
                    this.countingInBackground = true;
                    this.currentTime = this.bonusRoundsData.RoundsLeft
                }
            }
};
TimedFreeRoundBonusManager.prototype.Update = function() {
    if (!this.isActive) {
        if (this.countingInBackground)
            if (this.currentTime - Time.deltaTimeInRealTime > 0) this.currentTime -= Time.deltaTimeInRealTime;
        return
    }
    if (this.shouldUpdateTimer) this.UpdateTimer()
};
TimedFreeRoundBonusManager.prototype.UpdateTimer = function() {
    if (this.bonusRoundsData != null) {
        var clientServerDifference = this.currentTime - this.bonusRoundsData.RoundsLeft;
        if (clientServerDifference > 2) this.currentTime = this.bonusRoundsData.RoundsLeft
    }
    var elapsedTime = Math.floor(this.currentTime);
    if (elapsedTime < 0) elapsedTime = 0;
    var seconds = Math.floor(elapsedTime % 60).toString();
    var minutes = Math.floor(elapsedTime / 60 % 60).toString();
    if (seconds.length < 2) seconds = "0" + seconds;
    if (minutes.length < 2) minutes = "0" + minutes;
    if (this.currentTime < 0 && !XT.GetBool(Vars.Logic_IsFreeSpin) && !XT.GetBool(Vars.IsDifferentSpinType) && this.hasDataToCheckShowWindow) {
        var respinData = XT.GetObject(Vars.RespinData);
        var isRespin = respinData != null && !respinData.IsDone;
        if (!isRespin) {
            this.shouldUpdateTimer = false;
            if (this.cachedStartEvent.length > 0) {
                this.cachedStartEvent[0].Type = VsFreeRoundEvent.EventType.Finish;
                this.cachedStartEvent[0].Bet = this.cachedbetLevel
            }
            XT.SetBool(Vars.SpinBlockingFeatureIsRunning, true);
            this.RequestToShow()
        }
    }
    for (var i = 0; i <
        this.timeLabels.length; i++) this.timeLabels[i].text = minutes + ":" + seconds;
    this.currentTime -= Time.deltaTimeInRealTime
};
TimedFreeRoundBonusManager.prototype.OnContinuePressed = function() {
    if (this.bonusRoundsData != null && this.bonusRoundsData.Type != VsFreeRound.RoundType.Timed) return;
    var evts = XT.GetObject(Vars.BonusRoundsEvents);
    if (evts.length != 0 && evts[0].Type == VsFreeRoundEvent.EventType.Finish) {
        if (!evts[0].TurboSpinMode) this.EnableTurboSpin();
        XT.SetBool(Vars.SpinBlockingFeatureIsRunning, false);
        XT.SetInt(Vars.AutoplaySpinsLeft, -1);
        if (evts.length > 1) XT.SetInt(Vars.TimedBonusRoundsSeconds, this.bonusRoundsData.RoundsLeft);
        this.Handled();
        return
    }
    if (evts.length != 0 && evts[0].Type == VsFreeRoundEvent.EventType.Start) {
        if (!this.isActive) {
            this.isActive = true;
            if (!this.countingInBackground) this.currentTime = this.bonusRoundsData.RoundsLeft;
            this.countingInBackground = false;
            this.UpdateTimer();
            XT.SetBool(Vars.TimedBonusRoundIsOngoing, true)
        }
        if (!evts[0].TurboSpinMode) this.DisableTurboSpin()
    }
};
TimedFreeRoundBonusManager.prototype.OnSpinResultReceived = function() {
    if (this.isActive && !this.shouldUpdateTimer) this.shouldUpdateTimer = true;
    this.hasDataToCheckShowWindow = true
};
TimedFreeRoundBonusManager.prototype.OnSpinStarted = function() {
    this.hasDataToCheckShowWindow = false
};
TimedFreeRoundBonusManager.prototype.OnTimedBonusRoundsFinished = function() {
    this.isActive = false;
    XT.SetBool(Vars.TimedBonusRoundIsOngoing, false)
};
TimedFreeRoundBonusManager.prototype.Show = function() {
    var copyEvent = [];
    if (this.cachedStartEvent.length > 0) copyEvent.push(this.cachedStartEvent[0].Clone());
    XT.SetBool(Vars.ShouldIgnoreNextFinishEventFromServer, false);
    var evts = XT.GetObject(Vars.BonusRoundsEvents);
    if (evts != null)
        if (evts.length > 1)
            if (evts[1].Type == VsFreeRoundEvent.EventType.Start) copyEvent.push(evts[1]);
    XT.SetObject(Vars.BonusRoundsEvents, copyEvent);
    var brret = BonusRoundsController.HandleNextEvent(false, false, true);
    XT.SetBool(Vars.ShouldIgnoreNextFinishEventFromServer,
        true);
    if (evts != null && evts.length == 1 && evts[0].Type == VsFreeRoundEvent.EventType.Start && !evts[0].IsFreeRoundPending) {
        XT.TriggerEvent(Vars.Evt_DataToCode_BonusRoundsOnContinuePressed);
        this.shouldUpdateTimer = true;
        if (this.showTimedFRBInfo != null)
            for (var i = 0; i < this.showTimedFRBInfo.length; i++)
                if (this.showTimedFRBInfo != null) this.showTimedFRBInfo[i].Start()
    }
};
TimedFreeRoundBonusManager.prototype.DisableTurboSpin = function() {
    if (Globals.isMobile) {
        var autoplay = globalRuntime.sceneRoots[1].GetComponentsInChildren(AutoplayControllerMobile, true);
        for (var i = 0; i < autoplay.length; ++i) {
            var turboSpin = autoplay[i].transform.Find("Content/Checkboxes/TurboSpin");
            if (turboSpin != null) turboSpin.gameObject.SetActive(false)
        }
        var interfaceLandscape = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["InterfaceControllerMobile_1"], true);
        for (var i = 0; i < interfaceLandscape.length; ++i) {
            var holdForTurbo =
                interfaceLandscape[i].transform.Find("ContentInterface/DynamicContent/AnchoredRight/Normal/SpinButtons/StartSpin_Button/HoldToAutoplay");
            if (holdForTurbo != null) holdForTurbo.gameObject.SetActive(false)
        }
        var interfacePortrait = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["InterfaceControllerMobile_2"], true);
        for (var i = 0; i < interfacePortrait.length; ++i) {
            var holdForTurbo = interfacePortrait[i].transform.Find("ContentInterface/DynamicContent/ContentScale/Normal/SpinButtons/StartSpin_Button/HoldToAutoplay");
            if (holdForTurbo != null) holdForTurbo.gameObject.SetActive(false)
        }
    } else {
        var autoplay = globalRuntime.sceneRoots[1].GetComponentsInChildren(AutoplayControllerMobile, true);
        for (var i = 0; i < autoplay.length; ++i) {
            var turboSpin = autoplay[i].transform.Find("Content/Checkboxes/TurboSpin");
            if (turboSpin != null) turboSpin.gameObject.SetActive(false)
        }
        TimedFreeRoundBonusManager.OGMTS_Show = window["GUIMessageTurboSpin"].prototype.Show;
        window["GUIMessageTurboSpin"].prototype.Show = function() {
            if (this.messages != null && this.messages.length >
                0) {
                var i = Random.Range(0, this.messages.length);
                this.label.text = this.messages[i]
            }
            this.gameObject.SetActive(true)
        }
    }
    var advancedAutoplay = globalRuntime.sceneRoots[1].GetComponentsInChildren(AutoplayControllerAdvanced, true);
    for (var i = 0; i < advancedAutoplay.length; ++i) {
        var turboSpin = advancedAutoplay[i].transform.Find("Checkboxes/TurboSpin");
        if (turboSpin != null) turboSpin.gameObject.SetActive(false);
        turboSpin = advancedAutoplay[i].transform.Find("Clipped/Content/Checkboxes/TurboSpin");
        if (turboSpin != null) turboSpin.gameObject.SetActive(false)
    }
    if (!Globals.isMini) {
        var quickSpinWindow =
            globalRuntime.sceneRoots[1].GetComponentsInChildren(QuickSpinWindowController, true);
        for (var i = 0; i < quickSpinWindow.length; ++i) quickSpinWindow[i].disableWindow.Start()
    }
    XT.RegisterCallbackBool(Vars.ContinuousSpin, this.OnXTContinuousSpinChanged, this)
};
TimedFreeRoundBonusManager.prototype.EnableTurboSpin = function() {
    if (Globals.isMobile) {
        var autoplay = globalRuntime.sceneRoots[1].GetComponentsInChildren(AutoplayControllerMobile, true);
        for (var i = 0; i < autoplay.length; ++i) {
            var turboSpin = autoplay[i].transform.Find("Content/Checkboxes/TurboSpin");
            if (turboSpin != null) turboSpin.gameObject.SetActive(true)
        }
        var interfaceLandscape = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["InterfaceControllerMobile_1"], true);
        for (var i = 0; i < interfaceLandscape.length; ++i) {
            var holdForTurbo =
                interfaceLandscape[i].transform.Find("ContentInterface/DynamicContent/AnchoredRight/Normal/SpinButtons/StartSpin_Button/HoldToAutoplay");
            if (holdForTurbo != null) holdForTurbo.gameObject.SetActive(true)
        }
        var interfacePortrait = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["InterfaceControllerMobile_2"], true);
        for (var i = 0; i < interfacePortrait.length; ++i) {
            var holdForTurbo = interfacePortrait[i].transform.Find("ContentInterface/DynamicContent/ContentScale/Normal/SpinButtons/StartSpin_Button/HoldToAutoplay");
            if (holdForTurbo != null) holdForTurbo.gameObject.SetActive(true)
        }
    } else {
        var autoplay = globalRuntime.sceneRoots[1].GetComponentsInChildren(AutoplayControllerMobile, true);
        for (var i = 0; i < autoplay.length; ++i) {
            var turboSpin = autoplay[i].transform.Find("Content/Checkboxes/TurboSpin");
            if (turboSpin != null) turboSpin.gameObject.SetActive(true)
        }
        if (TimedFreeRoundBonusManager.OGMTS_Show != undefined) window["GUIMessageTurboSpin"].prototype.Show = TimedFreeRoundBonusManager.OGMTS_Show
    }
    var advancedAutoplay = globalRuntime.sceneRoots[1].GetComponentsInChildren(AutoplayControllerAdvanced,
        true);
    for (var i = 0; i < advancedAutoplay.length; ++i) {
        var turboSpin = advancedAutoplay[i].transform.Find("Checkboxes/TurboSpin");
        if (turboSpin != null) turboSpin.gameObject.SetActive(true);
        turboSpin = advancedAutoplay[i].transform.Find("Clipped/Content/Checkboxes/TurboSpin");
        if (turboSpin != null) turboSpin.gameObject.SetActive(true)
    }
    if (!Globals.isMini) {
        var quickSpinWindow = globalRuntime.sceneRoots[1].GetComponentsInChildren(QuickSpinWindowController, true);
        for (var i = 0; i < quickSpinWindow.length; ++i) quickSpinWindow[i].disableWindow.Start()
    }
    XT.UnregisterCallbackBool(this.OnXTContinuousSpinChanged,
        this)
};
TimedFreeRoundBonusManager.prototype.OnXTContinuousSpinChanged = function(isContinuousSpin) {
    if (isContinuousSpin) XT.SetBool(Vars.ContinuousSpin, false)
};
goog.require("UHT.XTLink");
JurisdictionSessionUptime.prototype = Object.create(XTLink.prototype);
JurisdictionSessionUptime.prototype.constructor = JurisdictionSessionUptime;

function JurisdictionSessionUptime() {
    XTLink.call(this);
    this.contents = null;
    this.hoursLabels = null;
    this.minutesLabels = null;
    this.hoursSeparators = null;
    this.secondsLabels = null;
    this.currentTime = 0
}
JurisdictionSessionUptime.prototype.Awake = function() {
    if (UHT_GAME_CONFIG_SRC["s_elapsed"] != null) {
        this.currentTime = UHT_GAME_CONFIG_SRC["s_elapsed"] * 60;
        return
    }
};
JurisdictionSessionUptime.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.Jurisdiction_ShowSessionUptime, this.OnJurisdictionSessionUptimeChanged, this);
    XT.RegisterCallbackBool(Vars.Jurisdiction_Clock, this.OnJurisdictionClockChanged, this)
};
JurisdictionSessionUptime.prototype.OnJurisdictionSessionUptimeChanged = function(param) {
    for (var i = 0; i < this.contents.length; i++) this.contents[i].SetActive(param)
};
JurisdictionSessionUptime.prototype.OnJurisdictionClockChanged = function(param) {
    var screenAnchor = this.gameObject.GetComponentsInChildren(ScreenAnchor, true);
    if (screenAnchor.length > 0) {
        screenAnchor[0].leftOffset = param ? 75 : 15;
        screenAnchor[0].updateIsNeeded = true
    }
};
JurisdictionSessionUptime.prototype.Update = function(param) {
    this.currentTime += Time.deltaTimeInRealTime;
    var h = Math.floor(this.currentTime / 3600);
    var m = Math.floor(this.currentTime / 60) - h * 60;
    var s = this.currentTime % 60 | 0;
    for (var i = 0; i < this.minutesLabels.length; i++) {
        if (h > 0 || XT.GetBool(Vars.Jurisdiction_ShowHoursInSessionUptime)) {
            this.hoursLabels[i].gameObject.SetActive(true);
            this.hoursSeparators[i].SetActive(true);
            this.hoursLabels[i].text = (h.toString().length == 1 ? "0" : "") + h.toString()
        }
        this.minutesLabels[i].text =
            (m.toString().length == 1 ? "0" : "") + m.toString();
        this.secondsLabels[i].text = (s.toString().length == 1 ? "0" : "") + s.toString()
    }
};
goog.require("UHT.XTLink");
TimeToSpin.prototype = Object.create(XTLink.prototype);
TimeToSpin.prototype.constructor = TimeToSpin;

function TimeToSpin() {
    XTLink.call(this);
    this.SBisActive = false;
    this.SRisActive = false;
    this.firstTimeInResult = false;
    this.isPlaying = false;
    this.lastNormalSpinUsedAutoplay = false;
    this.targetTime = 0;
    this.currentTime = 0;
    this.contents;
    this.sprites;
    this.widgetMasks
}
TimeToSpin.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.Jurisdiction_ResultMinimumTime, this.OnResultMinimumTime, this);
    XT.RegisterCallbackBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins, this.OnResultMinimumTimeBetweenSpins, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop, this.OnDoLoop, this)
};
TimeToSpin.prototype.OnDoLoop = function() {
    if (XT.GetBool(Vars.Logic_IsFreeSpin) || XT.GetBool(Vars.IsDifferentSpinType)) return;
    if (this.SRisActive && this.firstTimeInResult) {
        this.currentTime = 0;
        this.targetTime = XT.GetFloat(Vars.Jurisdiction_ResultMinimumTime_Value);
        if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins)) this.targetTime = Math.max(this.targetTime, XT.GetFloat(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins_Value) - XT.GetFloat(Vars.SpinDuration));
        for (var i = 0; i < this.sprites.length; i++) this.sprites[i].fillAmount =
            0;
        this.isPlaying = true;
        for (var i = 0; i < this.contents.length; i++) this.contents[i].SetActive(true);
        this.firstTimeInResult = false
    }
};
TimeToSpin.prototype.OnResultMinimumTime = function(param) {
    this.SRisActive = param
};
TimeToSpin.prototype.OnResultMinimumTimeBetweenSpins = function(param) {
    this.SBisActive = param
};
TimeToSpin.prototype.OnSpinStarted = function() {
    if (XT.GetBool(Vars.IsDifferentSpinType) && this.lastNormalSpinUsedAutoplay) return;
    this.firstTimeInResult = true;
    this.lastNormalSpinUsedAutoplay = XT.GetInt(Vars.AutoplaySpinsLeft) >= 0 && !XT.GetBool(Vars.IsDifferentSpinType);
    var respinData = XT.GetObject(Vars.RespinData);
    var isRespin = respinData != null && !respinData.IsDone;
    if (XT.GetInt(Vars.AutoplaySpinsLeft) >= 0 || XT.GetBool(Vars.Logic_IsFreeSpin) || isRespin) return;
    if (this.SBisActive && !this.SRisActive) {
        this.currentTime =
            XT.GetFloat(Vars.SpinDuration);
        this.targetTime = XT.GetFloat(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins_Value);
        for (var i = 0; i < this.sprites.length; i++) this.sprites[i].fillAmount = 0;
        this.isPlaying = true;
        for (var i = 0; i < this.contents.length; i++) this.contents[i].SetActive(true)
    }
};
TimeToSpin.prototype.Update = function() {
    if (!this.isPlaying) return;
    if (this.currentTime >= this.targetTime) {
        this.isPlaying = false;
        for (var i = 0; i < this.contents.length; i++) this.contents[i].SetActive(false)
    }
    this.currentTime += Time.deltaTime;
    if (this.currentTime >= this.targetTime) this.currentTime = this.targetTime;
    for (var i = 0; i < this.widgetMasks.length; i++) {
        this.widgetMasks[i].shapes[0].arc_start = -Math.PI / 2;
        this.widgetMasks[i].shapes[0].arc_end = -(Math.PI / 2) + 2 * Math.PI * this.currentTime / this.targetTime;
        this.widgetMasks[i].needUpdate =
            true
    }
};
goog.require("UHT.Engine");
GUIFreeSpinsLeft_Custom.prototype = Object.create(XTLink.prototype);
GUIFreeSpinsLeft_Custom.prototype.constructor = GUIFreeSpinsLeft_Custom;

function GUIFreeSpinsLeft_Custom() {
    XTLink.call(this);
    this.replaceFrom = null;
    this.labels = null;
    this.catCustom = null;
    this.catDefault = null;
    this.defaultTexts = []
}
GUIFreeSpinsLeft_Custom.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackString(InterfaceVars.CustomFreeSpinsLeftMessage, this.OnCustomFSLeftMessage, this)
};
GUIFreeSpinsLeft_Custom.prototype.OnCustomFSLeftMessage = function(msg) {
    if (this.labels != null) {
        var saveDefaults = this.defaultTexts.length == 0;
        for (var i = 0; i < this.labels.length; i++) {
            if (saveDefaults) this.defaultTexts.push(this.labels[i].text);
            if (msg == "default") this.labels[i].text = this.defaultTexts[i];
            else this.labels[i].text = msg
        }
    }
    if (!XT.GetBool(InterfaceVars.CustomFreeSpinsLeft_UsesCATEvents)) return;
    if (msg == "default" && this.catDefault != null) this.catDefault.Start();
    if (msg != "default" && this.catCustom != null) this.catCustom.Start()
};
goog.require("UHT.Engine");
VerifyGameAuthenticityManager.prototype = Object.create(ArrangeableBase.prototype);
VerifyGameAuthenticityManager.prototype.constructor = VerifyGameAuthenticityManager;

function VerifyGameAuthenticityManager() {
    ArrangeableBase.call(this);
    this.openIframe = null;
    this.iframeTitleLabels = null;
    this.mustOpen = false;
    this.isIframeOpen = false;
    this.buttons = null;
    this.iframeGameObject = null;
    this.iframeTitleText = "";
    this.anchorTopLeft = null;
    this.anchorBottomRight = null;
    this.styleLandscape = null;
    this.stylePortrait = null;
    this.wasTouchMove = false;
    this.touchStartHandler = null;
    this.touchMoveHandler = null;
    this.touchEndHandler = null;
    this.posC = null;
    this.posTL = null;
    this.posBR = null;
    this.iframeParent =
        null;
    this.iframe = null;
    this.css = "width:{0}px;height:{1}px;left:{2}px;top:{3}px;border-radius:0 0 BRpx BRpx;";
    this.collidersCamera = null;
    this.notificationsCamera = null;
    this.notificationsCameraDepth = 0;
    this.isNotificationOpen = false
}
VerifyGameAuthenticityManager.prototype.XTRegisterCallbacks = function() {
    ArrangeableBase.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_Internal_BlackBandsUpdated, this.OnGameSizeChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackBool(Vars.VerifyGameAuthenticity, this.OnVerifyGameAuthenticity, this);
    XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_ShowIntrusiveNotification, this.OnShowNotification, this);
    XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_ShowNonIntrusiveNotification, this.OnShowNotification, this);
    XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_HideIntrusiveNotification, this.OnHideNotification, this);
    XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_HideNonIntrusiveNotification, this.OnHideNotification, this);
    EventManager.AddHandler("EVT_UHT_RESIZE", this.OnGameSizeChanged, this)
};
VerifyGameAuthenticityManager.prototype.OnDestroy = function() {
    XT.UnregisterCallbackBool(this.OnVerifyGameAuthenticity, this)
};
VerifyGameAuthenticityManager.prototype.OnShowNotification = function() {
    this.isNotificationOpen = true;
    this.UpdateCameras()
};
VerifyGameAuthenticityManager.prototype.OnHideNotification = function() {
    this.isNotificationOpen = false;
    this.UpdateCameras()
};
VerifyGameAuthenticityManager.prototype.OnVerifyGameAuthenticity = function(newValue) {
    for (var btnIdx = 0; btnIdx < this.buttons.length; btnIdx++) this.buttons[btnIdx].SetActive(newValue)
};
VerifyGameAuthenticityManager.prototype.OnGameInit = function() {
    if (createjs.BrowserDetect.isIOS) {
        this.touchStartHandler = new EventHandler(this, this.OnTouchStart);
        this.touchMoveHandler = new EventHandler(this, this.OnTouchMove);
        globalColliderInputManager.addEventHandler(ColliderEvent.ButtonDown, this.touchStartHandler);
        globalColliderInputManager.addEventHandler(ColliderEvent.MouseMove, this.touchMoveHandler)
    }
    this.touchEndHandler = new EventHandler(this, this.OnTouchEnd);
    globalColliderInputManager.addEventHandler(ColliderEvent.ButtonUp,
        this.touchEndHandler);
    this.cachedCamera = Globals.GetCameraForObject(this.buttons[0]);
    if (ServerOptions.gameVerificationUrl != null) this.iframeTitleText = ServerOptions.gameVerificationUrl.split("/", 3).join("/")
};
VerifyGameAuthenticityManager.prototype.OnTouchStart = function() {
    this.wasTouchMove = false
};
VerifyGameAuthenticityManager.prototype.OnTouchMove = function() {
    this.wasTouchMove = true
};
var GA_SENT_AM_CLICKED = false;
VerifyGameAuthenticityManager.prototype.OnTouchEnd = function() {
    if (!XT.GetBool(Vars.VerifyGameAuthenticity)) return;
    for (var btnIdx = 0; btnIdx < this.buttons.length; btnIdx++)
        if (this.buttons[btnIdx].activeInHierarchy) {
            var mask = new LayerMask;
            mask.mask = 1 << this.buttons[btnIdx].layer;
            var c = globalColliderInputManager.getHoveredCollider(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition), mask);
            if (!this.wasTouchMove && c == this.buttons[btnIdx].collider) {
                if (!this.IsWebView()) window.open(ServerOptions.gameVerificationUrl);
                else this.mustOpen = true;
                if (!GA_SENT_AM_CLICKED) {
                    globalTracking.SendEvent("uht_behaviour", "VerifyGameAuthenticity_Clicked", 0, "BehaviourTracker");
                    GA_SENT_AM_CLICKED = true
                }
            }
        }
};
VerifyGameAuthenticityManager.prototype.OpenIframe = function() {
    if (this.isIframeOpen) return;
    var frame = _HTML.CreateElement("iframe", {
        "src": ServerOptions.gameVerificationUrl,
        "class": "replay-frame",
        "frameborder": "0"
    }, false);
    var root = _HTML.CreateElement("div", {
        "class": "replay-root"
    }, true);
    root.appendChild(frame);
    _HTML.AddClass(document.documentElement, "replay-visible");
    this.isIframeOpen = true;
    this.iframeParent = root;
    this.iframe = frame;
    this.UpdateRoundSize(true);
    this.UpdateCameras();
    for (var i = 0; i < this.iframeTitleLabels.length; i++) this.iframeTitleLabels[i].text =
        this.iframeTitleText;
    this.openIframe.Start()
};
VerifyGameAuthenticityManager.prototype.CloseIframe = function() {
    if (!this.isIframeOpen) return;
    _HTML.RemoveClass(document.documentElement, "replay-visible");
    document.body.removeChild(this.iframeParent);
    this.isIframeOpen = false;
    this.iframeParent = null;
    this.iframe = null;
    this.UpdateCameras()
};
var GA_SENT_AM_VISIBLE = false;
VerifyGameAuthenticityManager.prototype.Update = function() {
    if (!GA_SENT_AM_VISIBLE)
        for (var btnIdx = 0; btnIdx < this.buttons.length; btnIdx++)
            if (this.buttons[btnIdx].activeInHierarchy) {
                globalTracking.SendEvent("uht_behaviour", "VerifyGameAuthenticity_Visible", 0, "BehaviourTracker");
                GA_SENT_AM_VISIBLE = true
            }
    if (this.mustOpen) {
        this.mustOpen = false;
        this.OpenIframe()
    }
};
VerifyGameAuthenticityManager.prototype.UpdateCameras = function() {
    if (this.isRoundOpen && this.isNotificationOpen) {
        this.notificationsCamera.SetCameraDepth(this.notificationsCameraDepth);
        this.collidersCamera.ignoreInputBlocked = true
    } else {
        this.notificationsCamera.ResetCameraDepth();
        this.collidersCamera.ignoreInputBlocked = false
    }
};
VerifyGameAuthenticityManager.prototype.OnGameSizeChanged = function() {
    if (this.isIframeOpen) this.UpdateRoundSize(true)
};
VerifyGameAuthenticityManager.prototype.UpdateRoundSize = function(force) {
    if (!this.isIframeOpen) return;
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.iframeGameObject);
    var pC = this.cachedCamera.transform.position();
    var pTL = this.anchorTopLeft.position();
    var pBR = this.anchorBottomRight.position();
    if (!force)
        if (UHTMath.Vector3.equal(pC, this.posC) && UHTMath.Vector3.equal(pTL, this.posTL) && UHTMath.Vector3.equal(pBR, this.posBR)) return;
    var pixelRatio = window.devicePixelRatio || window.screen.deviceXDPI /
        window.screen.logicalXDPI;
    if (UHT_DEVICE_TYPE.DESKTOP == true)
        if (pixelRatio > 1.5) pixelRatio = 1.5;
    if (pixelRatio > 2) pixelRatio = 2;
    var scale = 1 / pixelRatio;
    var tl = UHTMath.Vector3.scale(this.cachedCamera.WorldToScreenPoint(pTL), scale);
    var br = UHTMath.Vector3.scale(this.cachedCamera.WorldToScreenPoint(pBR), scale);
    var width = br.x - tl.x;
    var height = br.y - tl.y;
    scale = width / this.style.defaultWidth;
    var borderRadius = this.style.defaultBorderRadius * scale;
    var style = this.css.replace("{0}", String(width)).replace("{1}", String(height)).replace("{2}",
        String(tl.x)).replace("{3}", String(tl.y)).replace(new RegExp("BR", "g"), String(borderRadius));
    this.iframeParent.setAttribute("style", style);
    this.iframe.setAttribute("style", style);
    this.posC = pC;
    this.posTL = pTL;
    this.posBR = pBR
};
VerifyGameAuthenticityManager.prototype.OnSwitchToLandscape = function() {
    this.style = this.styleLandscape
};
VerifyGameAuthenticityManager.prototype.OnSwitchToPortrait = function() {
    this.style = this.stylePortrait
};
VerifyGameAuthenticityManager.prototype.IsWebView = function() {
    var standalone = window.navigator["standalone"];
    var userAgent = window.navigator.userAgent.toLowerCase();
    var safari = /safari/.test(userAgent);
    var ios = /iphone|ipod|ipad/.test(userAgent);
    var isWebView = false;
    if (ios) {
        if (!standalone && !safari) isWebView = true
    } else if (userAgent.indexOf("wv") != -1) isWebView = true;
    return isWebView
};
goog.require("UHT.XTLink");
V3AnimatorRatioController.prototype = Object.create(XTLink.prototype);
V3AnimatorRatioController.prototype.constructor = V3AnimatorRatioController;

function V3AnimatorRatioController() {
    XTLink.call(this);
    this.ratioFrom = 0;
    this.ratioTo = 0;
    this.animators = null;
    this.useGameSize = false;
    this.ratioPercent = 0;
    this.screenWidth = 0;
    this.screenHeight = 0;
    this.gameSizeChanged = false
}
V3AnimatorRatioController.prototype.XTRegisterCallbacks = function() {
    if (this.useGameSize) XT.RegisterCallbackObject(GUIArrangerVars.GUIArranger_GameSize, this.OnGameSizeChanged, this)
};
V3AnimatorRatioController.prototype.OnGameSizeChanged = function(param) {
    this.gameSizeChanged = true;
    this.Update();
    this.gameSizeChanged = false
};
V3AnimatorRatioController.prototype.GetSize = function() {
    if (this.useGameSize) return XT.GetObject(GUIArrangerVars.GUIArranger_GameSize);
    return new UHTMath.Vector3(UHTScreen.width, UHTScreen.height, 0)
};
V3AnimatorRatioController.prototype.Update = function() {
    if (this.useGameSize && !this.gameSizeChanged) return;
    if (this.gameSizeChanged || this.screenWidth != UHTScreen.width || this.screenHeight != UHTScreen.height) {
        var size = this.GetSize();
        var ratio = size.x / Math.max(size.y, .001);
        this.ratioPercent = UHTMath.inverseLerp(this.ratioFrom, this.ratioTo, ratio);
        for (var i = 0; i < this.animators.length; ++i) this.animators[i].Sample(this.ratioPercent);
        this.screenWidth = UHTScreen.width;
        this.screenHeight = UHTScreen.height
    }
};
goog.require("UHT.Engine");
CustomNotificationButton.prototype = Object.create(Component.prototype);
CustomNotificationButton.prototype.constructor = CustomNotificationButton;

function CustomNotificationButton() {
    Component.call(this);
    this.label = null;
    this.cachedCamera = null;
    this.handlers = null
}
CustomNotificationButton.touchEndFrame = 0;
CustomNotificationButton.prototype.Awake = function() {
    globalColliderInputManager.addEventHandler(ColliderEvent.ButtonUp, new EventHandler(this, this.OnTouchEnd))
};
CustomNotificationButton.prototype.UpdateButton = function(data) {
    var hasData = data != null;
    if (hasData) {
        this.handlers = data.handlers;
        this.label.text = _string.IsNullOrEmpty(data.label) ? "" : data.label
    }
    this.gameObject.SetActive(hasData);
    this.label.gameObject.SetActive(hasData)
};
CustomNotificationButton.prototype.OnTouchEnd = function() {
    if (CustomNotificationButton.touchEndFrame == Time.frameCount) return;
    if (!this.gameObject.activeInHierarchy || this.handlers == null) return;
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    var mask = new LayerMask;
    mask.mask = 1 << this.gameObject.layer;
    if (this.gameObject.collider != globalColliderInputManager.getHoveredCollider(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition), mask)) return;
    for (var i = 0; i < this.handlers.length; ++i) this.handlers[i]();
    CustomNotificationButton.touchEndFrame = Time.frameCount
};
goog.require("UHT.XTLink");
var CustomNotificationVars = {
    CustomNotification: "CustomNotification",
    Evt_Internal_ShowIntrusiveNotification: "Evt_Internal_ShowIntrusiveNotification",
    Evt_Internal_HideIntrusiveNotification: "Evt_Internal_HideIntrusiveNotification",
    Evt_Internal_ShowNonIntrusiveNotification: "Evt_Internal_ShowNonIntrusiveNotification",
    Evt_Internal_HideNonIntrusiveNotification: "Evt_Internal_HideNonIntrusiveNotification"
};
CustomNotificationParser.prototype = Object.create(TournamentRule.prototype);
CustomNotificationParser.prototype.constructor = CustomNotificationParser;

function CustomNotificationParser() {
    TournamentRule.call(this)
}
CustomNotificationController.prototype = Object.create(XTLink.prototype);
CustomNotificationController.prototype.constructor = CustomNotificationController;

function CustomNotificationButtonsGroup() {
    this.buttons = null
}
CustomNotificationButtonsGroup.prototype.UpdateButtons = function(data) {
    if (data == null)
        for (var i = 0; i < this.buttons.length; ++i) this.buttons[i].UpdateButton(null);
    else
        for (var i = 0; i < this.buttons.length; ++i) this.buttons[i].UpdateButton(data[i])
};

function CustomNotificationExtraLayout() {
    this.scrollableList = null;
    this.parser = null;
    this.title = null;
    this.buttons = null;
    this.buttonsCat = null;
    this.textAnimator = null;
    this.responsiveLinesCat = null
}

function CustomNotificationController() {
    XTLink.call(this);
    this.defaultDelay = 7;
    this.lineDelay = 1.5;
    this.showShort = null;
    this.showLong = null;
    this.expandLong = null;
    this.hide = null;
    this.scrollableList = null;
    this.autoClicker = null;
    this.parser = null;
    this.title = null;
    this.buttons = null;
    this.useButtonsGroups = false;
    this.buttonsGroups = null;
    this.isIntrusive = false;
    this.textAnimator = null;
    this.hasExtraLayout = false;
    this.extraLayout = null;
    this.isResponsive = false;
    this.responsiveLinesCat = null;
    this.responsiveButtonsCat = null;
    this.responsiveMaxLabelWidths =
        null;
    this.ellipsis = " ...";
    this.mustHide = false;
    this.mustIgnoreInputBlocked = false;
    this.cachedCamera = null;
    this.notification = null
}
CustomNotificationController.prototype.XTRegisterCallbacks = function() {
    if (this.isIntrusive) {
        XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_ShowIntrusiveNotification, this.ShowNotification, this);
        XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_HideIntrusiveNotification, this.HideNotification, this)
    } else {
        XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_ShowNonIntrusiveNotification, this.ShowNotification, this);
        XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_HideNonIntrusiveNotification,
            this.HideNotification, this)
    }
};
CustomNotificationController.prototype.Update = function() {
    if (this.notification != null) {
        this.InternalShowNotification();
        this.mustHide = false;
        this.notification = null
    }
    if (this.mustHide) {
        this.mustHide = false;
        this.hide.Start();
        if (this.isIntrusive) this.GetCamera().ignoreInputBlocked = false;
        if (this.autoClicker != null) this.autoClicker.enabled = false
    }
    if (this.mustIgnoreInputBlocked) {
        var camera = this.GetCamera();
        if (camera != null) {
            this.mustIgnoreInputBlocked = false;
            camera.ignoreInputBlocked = true
        }
    }
};
CustomNotificationController.prototype.HideNotification = function() {
    this.mustHide = true
};
CustomNotificationController.prototype.ShowNotification = function() {
    this.notification = XT.GetObject(CustomNotificationVars.CustomNotification)
};
CustomNotificationController.prototype.InternalShowNotification = function() {
    var btnsCount = 0;
    if (this.notification.buttons != null) {
        btnsCount = Math.min(this.useButtonsGroups ? this.buttonsGroups.length : this.buttons.length, this.notification.buttons.length);
        if (this.useButtonsGroups && btnsCount > 0) this.buttonsGroups[btnsCount - 1].UpdateButtons(this.notification.buttons);
        else
            for (var i = 0; i < btnsCount; ++i) this.buttons[i].UpdateButton(this.notification.buttons[i]);
        if (this.hasExtraLayout)
            for (var i = 0; i < btnsCount; ++i) this.extraLayout.buttons[i].UpdateButton(this.notification.buttons[i])
    }
    var titleText =
        _string.IsNullOrEmpty(this.notification.title) ? "" : this.notification.title;
    if (this.hasExtraLayout) {
        this.extraLayout.title.text = titleText;
        for (var i = btnsCount; i < this.extraLayout.buttons.length; ++i) this.extraLayout.buttons[i].UpdateButton(null);
        this.extraLayout.parser.rules = "";
        this.extraLayout.parser.UpdateRules(this.notification.text);
        while (!this.extraLayout.parser.isSplit) this.extraLayout.parser.Split();
        this.extraLayout.scrollableList.SetValues(this.extraLayout.parser.splitRules);
        this.extraLayout.buttonsCat.StartEvent(btnsCount);
        this.extraLayout.textAnimator.Sample(this.extraLayout.parser.splitRules.length / this.extraLayout.parser.maxNumberOfLines);
        if (this.isResponsive) this.extraLayout.responsiveLinesCat.StartEvent(Math.min(this.extraLayout.parser.splitRules.length, this.extraLayout.parser.maxNumberOfLines))
    }
    if (this.useButtonsGroups) {
        for (var i = 0; i < btnsCount - 1; ++i) this.buttonsGroups[i].UpdateButtons(null);
        for (var i = btnsCount; i < this.buttonsGroups.length; ++i) this.buttonsGroups[i].UpdateButtons(null)
    } else
        for (var i = btnsCount; i <
            this.buttons.length; ++i) this.buttons[i].UpdateButton(null);
    if (this.isResponsive) {
        this.parser.maxLabelWidth = this.responsiveMaxLabelWidths[btnsCount];
        this.title.width = this.responsiveMaxLabelWidths[btnsCount]
    }
    this.title.text = titleText;
    this.parser.rules = "";
    this.parser.UpdateRules(this.notification.text);
    while (!this.parser.isSplit) this.parser.Split();
    var shortCount = Math.min(this.showShort.length, this.parser.splitRules.length);
    var lines = [];
    for (var i = 0; i < shortCount; ++i) lines.push(this.parser.splitRules[i]);
    var isLong = this.parser.splitRules.length > this.showShort.length;
    if (isLong && shortCount > 0) lines[shortCount - 1] = this.GetTextWithEllipsis(lines[shortCount - 1]);
    this.UpdateAutoClickerDelay(this.defaultDelay);
    this.scrollableList.SetValues(lines.length > 0 ? lines : this.parser.splitRules);
    (isLong ? this.showLong : this.showShort[this.parser.splitRules.length - 1]).Start();
    if (this.textAnimator != null) this.textAnimator.Sample(this.parser.splitRules.length / this.parser.maxNumberOfLines);
    if (this.isResponsive) {
        this.responsiveLinesCat.StartEvent(Math.min(this.parser.splitRules.length,
            this.parser.maxNumberOfLines));
        this.responsiveButtonsCat.StartEvent(btnsCount)
    }
    if (this.isIntrusive) this.mustIgnoreInputBlocked = true
};
CustomNotificationController.prototype.ShowMore = function() {
    this.UpdateAutoClickerDelay(Math.max(this.defaultDelay, this.lineDelay * this.parser.splitRules.length));
    this.scrollableList.SetValues(this.parser.splitRules);
    this.expandLong[UHTMath.clamp(this.parser.splitRules.length - 1, 0, this.expandLong.length - 1)].Start()
};
CustomNotificationController.prototype.UpdateAutoClickerDelay = function(delay) {
    if (this.autoClicker == null) return;
    this.autoClicker.delay = delay;
    this.autoClicker.delayInAutoplay = delay;
    this.autoClicker.enabled = true;
    this.autoClicker.gameObject.SetActive(false);
    this.autoClicker.gameObject.SetActive(true)
};
CustomNotificationController.prototype.GetTextWithEllipsis = function(text) {
    this.parser.sampleLabel.text = text + this.ellipsis;
    if (this.parser.sampleLabel.width <= this.parser.maxLabelWidth) return this.parser.sampleLabel.text;
    var split = text.split(" ");
    var ret = null;
    if (split.length > 1) {
        var words = [];
        for (var i = 0; i < split.length; ++i) {
            words.push(split[i]);
            this.parser.sampleLabel.text = words.join(" ") + this.ellipsis;
            if (this.parser.sampleLabel.width > this.parser.maxLabelWidth) break;
            ret = this.parser.sampleLabel.text
        }
    }
    if (ret ==
        null) ret = text.substr(0, text.length - this.ellipsis.length) + this.ellipsis;
    return ret
};
CustomNotificationController.prototype.CloseButtonClicked = function() {
    window["SystemMessageManager"]["CloseMessage"]()
};
CustomNotificationController.prototype.GetCamera = function() {
    if (this.cachedCamera == null) this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    return this.cachedCamera
};
goog.provide("UHT.VS_Symbol");
goog.require("UHT.Engine");
goog.require("UHT.CAT_Event");
VS_Symbol.prototype = Object.create(Component.prototype);
VS_Symbol.prototype.constructor = VS_Symbol;

function VS_Symbol() {
    Component.call(this);
    this.symbolId = 0;
    this.willHighlightOffAfterExciteWin = true;
    this.eventNormal = null;
    this.eventSpinStart = null;
    this.eventSpinLoop = null;
    this.eventSpinStop = null;
    this.eventHighlightOff = null;
    this.eventHighlightOn = null;
    this.eventExcited = null;
    this.eventWinExcited = null;
    this.eventWinning = null;
    this.eventSpinLoopExcited = null;
    this.eventSpinLoopExcitedImportant = null;
    this.eventFSHighlightOff = null;
    this.eventStart = null;
    this.eventStop = null;
    this.currentStateForInspector = VS_Symbol.State.Invalid;
    this.internalState = VS_Symbol.State.Invalid;
    this.lastQueuedState = VS_Symbol.State.Invalid;
    this.commands = [];
    this.stopEventSent = false;
    this.canProcessNextCommand = true
}
VS_Symbol.State = {
    Invalid: 0,
    Normal: 1,
    HighlightOn: 2,
    HighlightOff: 3,
    SpinStart: 4,
    SpinLoop: 5,
    SpinStop: 6,
    Excited: 7,
    WinExcited: 8,
    SpinLoopExcited: 9,
    Winning: 10,
    FSHighlightOff: 11,
    SpinLoopExcitedImportant: 12
};
VS_Symbol.prototype.ChangeToState = function(newState) {
    this.commands.push(newState);
    this.lastQueuedState = newState;
    this.ProcessCommands()
};
VS_Symbol.prototype.Start = function() {
    this.eventNormal.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOn.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOff.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStart.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoop.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStop.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventExcited.UnregisterCallback(this.Callback_EventEnded,
        this);
    this.eventWinExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoopExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoopExcitedImportant.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWinning.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventFSHighlightOff.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventNormal.RegisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOn.RegisterCallback(this.Callback_EventEnded,
        this);
    this.eventHighlightOff.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStart.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoop.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStop.RegisterCallback(this.Callback_EventEnded, this);
    this.eventExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWinExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoopExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoopExcitedImportant.RegisterCallback(this.Callback_EventEnded,
        this);
    this.eventWinning.RegisterCallback(this.Callback_EventEnded, this);
    this.eventFSHighlightOff.RegisterCallback(this.Callback_EventEnded, this)
};
VS_Symbol.prototype.ProcessCommands = function() {
    if (this.commands.length > 0)
        if (this.canProcessNextCommand) {
            var newState = this.commands[0];
            this.commands.splice(0, 1);
            this.canProcessNextCommand = false;
            switch (newState) {
                case VS_Symbol.State.Normal:
                    this.eventNormal.Start();
                    break;
                case VS_Symbol.State.HighlightOn:
                    this.eventHighlightOn.Start();
                    break;
                case VS_Symbol.State.HighlightOff:
                    this.eventHighlightOff.Start();
                    break;
                case VS_Symbol.State.SpinStart:
                    this.eventSpinStart.Start();
                    break;
                case VS_Symbol.State.SpinLoop:
                    this.eventSpinLoop.Start();
                    break;
                case VS_Symbol.State.SpinStop:
                    this.eventSpinStop.Start();
                    break;
                case VS_Symbol.State.Excited:
                    this.eventExcited.Start();
                    break;
                case VS_Symbol.State.WinExcited:
                    this.eventWinExcited.Start();
                    break;
                case VS_Symbol.State.Winning:
                    this.eventWinning.Start();
                    break;
                case VS_Symbol.State.SpinLoopExcited:
                    this.eventSpinLoopExcited.Start();
                    break;
                case VS_Symbol.State.SpinLoopExcitedImportant:
                    this.eventSpinLoopExcitedImportant.Start();
                    break;
                case VS_Symbol.State.FSHighlightOff:
                    this.eventFSHighlightOff.Start();
                    break;
                case VS_Symbol.State.Invalid:
                default:
                    this.canProcessNextCommand = true;
                    break
            }
            this.internalState = newState;
            this.currentStateForInspector = this.internalState
        } else if (this.stopEventSent == false) this.StopAllRunningEvents()
};
VS_Symbol.prototype.Update = function() {
    this.ProcessCommands()
};
VS_Symbol.prototype.Callback_EventEnded = function(_type, data) {
    if (_type == CAT_Event.CallbackType.EndOfEvent) this.canProcessNextCommand = true
};
VS_Symbol.prototype.StopAllRunningEvents = function() {
    if (this.eventNormal.IsRunning()) this.eventNormal.Stop();
    if (this.eventHighlightOn.IsRunning()) this.eventHighlightOn.Stop();
    if (this.eventHighlightOff.IsRunning()) this.eventHighlightOff.Stop();
    if (this.eventSpinStart.IsRunning()) this.eventSpinStart.Stop();
    if (this.eventSpinLoop.IsRunning()) this.eventSpinLoop.Stop();
    if (this.eventSpinStop.IsRunning()) this.eventSpinStop.Stop();
    if (this.eventExcited.IsRunning()) this.eventExcited.Stop();
    if (this.eventWinExcited.IsRunning()) this.eventWinExcited.Stop();
    if (this.eventWinning.IsRunning()) this.eventWinning.Stop();
    if (this.eventSpinLoopExcited.IsRunning()) this.eventSpinLoopExcited.Stop();
    if (this.eventSpinLoopExcitedImportant.IsRunning()) this.eventSpinLoopExcitedImportant.Stop();
    if (this.eventFSHighlightOff.IsRunning()) this.eventFSHighlightOff.Stop()
};
VS_Symbol.prototype.SpinStart = function() {
    this.ChangeToState(VS_Symbol.State.SpinStart)
};
VS_Symbol.prototype.SpinLoop = function() {
    this.ChangeToState(VS_Symbol.State.SpinLoop)
};
VS_Symbol.prototype.SpinStop = function() {
    this.ChangeToState(VS_Symbol.State.SpinStop)
};
VS_Symbol.prototype.SetHighlightOn = function() {
    this.ChangeToState(VS_Symbol.State.HighlightOn)
};
VS_Symbol.prototype.SetHighlightOff = function() {
    if (this.internalState != VS_Symbol.State.WinExcited && this.internalState != VS_Symbol.State.Winning || this.willHighlightOffAfterExciteWin)
        if (XT.GetBool(Vars.Logic_IsFreeSpin)) this.ChangeToState(VS_Symbol.State.FSHighlightOff);
        else this.ChangeToState(VS_Symbol.State.HighlightOff)
};
VS_Symbol.prototype.SetNormal = function() {
    this.ChangeToState(VS_Symbol.State.Normal)
};
VS_Symbol.prototype.SetExcited = function() {
    this.ChangeToState(VS_Symbol.State.Excited)
};
VS_Symbol.prototype.SetWinExcited = function() {
    this.ChangeToState(VS_Symbol.State.WinExcited)
};
VS_Symbol.prototype.SpinLoopExcited = function() {
    this.ChangeToState(VS_Symbol.State.SpinLoopExcited)
};
VS_Symbol.prototype.SpinLoopExcitedImportant = function() {
    this.ChangeToState(VS_Symbol.State.SpinLoopExcitedImportant)
};
VS_Symbol.prototype.SetWinning = function() {
    this.ChangeToState(VS_Symbol.State.Winning)
};
VS_Symbol.prototype.EventStart = function() {
    this.eventStart.Start()
};
VS_Symbol.prototype.EventStop = function() {
    this.eventStop.Start()
};
VS_Symbol.prototype.Reset = function() {
    this.commands = [];
    this.StopAllRunningEvents();
    this.canProcessNextCommand = true
};
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
goog.require("UHT.VS_Symbol");
VS_SymbolsManager.prototype = Object.create(XTLink.prototype);
VS_SymbolsManager.prototype.constructor = VS_SymbolsManager;

function VS_SymbolsManager() {
    XTLink.call(this);
    this.SpecialLoopsManager = null;
    this.hasOnlyLoops = false;
    this.pool = null;
    this.symbols = [];
    this.symbolIdToIndexMap = [];
    this.pooledSymbols = [];
    this.disablePoolNextFrame = false;
    this.defaultBufferAmount = 10;
    this.currentInitSymbol = -1
}
VS_SymbolsManager.initializing = 0;
VS_SymbolsManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Init_SymbolManager, this.OnSymbolManagerInit, this)
};
VS_SymbolsManager.prototype.XTInitVariablesAndEvents = function() {
    if (!this.hasOnlyLoops) XT.SetObject(Vars.SymbolsManagerObject, this)
};
VS_SymbolsManager.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnSymbolManagerInit, this)
};

function SymbolsManager_CheckAndSendTrackingInit() {
    if (VS_SymbolsManager.initializing + Special_SymbolsManager.initializing == 0) globalTracking.StartTimer("uht_loading", "_X_symbolsManager_duration", "LoadingTracker")
}

function SymbolsManager_CheckAndSendTrackingEnd() {
    if (VS_SymbolsManager.initializing + Special_SymbolsManager.initializing == 0) globalTracking.StopTimerAndSend("uht_loading", "_X_symbolsManager_duration", "LoadingTracker")
}
VS_SymbolsManager.prototype.OnSymbolManagerInit = function() {
    SymbolsManager_CheckAndSendTrackingInit();
    VS_SymbolsManager.initializing++;
    this.currentInitSymbol = 0;
    this.BuildSymbolIdToIndexMap();
    this.pooledSymbols = [];
    this.pool.SetActive(true);
    if (LoaderProgress.SymbolsManagers_Total == -1) LoaderProgress.SymbolsManagers_Total = this.symbols.length;
    else LoaderProgress.SymbolsManagers_Total += this.symbols.length
};
VS_SymbolsManager.prototype.Update = function() {
    if (this.currentInitSymbol >= 0) {
        if (this.currentInitSymbol < this.symbols.length) {
            var id = this.symbols[this.currentInitSymbol].symbolId;
            this.pooledSymbols[id] = [];
            for (var n = 0; n < this.defaultBufferAmount; n++) {
                var newObj = instantiate(this.symbols[this.currentInitSymbol].gameObject);
                newObj.SetActive(true);
                this.PoolSymbol(id, newObj.GetComponent(VS_Symbol))
            }
            this.currentInitSymbol++;
            LoaderProgress.SymbolsManagers_Current++
        }
        if (this.currentInitSymbol == this.symbols.length) {
            this.disablePoolNextFrame =
                false;
            VS_SymbolsManager.initializing--;
            SymbolsManager_CheckAndSendTrackingEnd();
            this.currentInitSymbol++
        }
    }
};
VS_SymbolsManager.prototype.BuildSymbolIdToIndexMap = function() {
    var highestSymbolId = -1;
    for (var i = 0; i < this.symbols.length; i++)
        if (this.symbols[i].symbolId > highestSymbolId) highestSymbolId = this.symbols[i].symbolId;
    this.symbolIdToIndexMap = new Array(highestSymbolId + 1);
    for (var j = 0; j < this.symbols.length; j++) this.symbolIdToIndexMap[this.symbols[j].symbolId] = j
};
VS_SymbolsManager.prototype.GetFromPool = function(id, parent) {
    if (this.pooledSymbols[id].length == 0) {
        console.log("Symbol pool capacity is too small! ID = " + id);
        this.pooledSymbols[id].push(instantiate(this.symbols[this.symbolIdToIndexMap[id]].gameObject).GetComponent(VS_Symbol));
        this.pooledSymbols[id][this.pooledSymbols[id].length - 1].gameObject.SetActive(true)
    }
    var pooledObject = this.pooledSymbols[id][0];
    this.pooledSymbols[id].splice(0, 1);
    pooledObject.gameObject.transform.SetParent(parent.transform, false);
    pooledObject.gameObject.transform.localPosition(UHTMath.Vector3.zero);
    pooledObject.gameObject.transform.localRotation(UHTMath.Quaternion.euler(UHTMath.Vector3.zero));
    pooledObject.gameObject.transform.localScale(UHTMath.Vector3.one);
    return pooledObject
};
VS_SymbolsManager.prototype.PoolSymbol = function(id, obj) {
    obj.Reset();
    obj.gameObject.transform.SetParent(this.pool.transform, false);
    this.pooledSymbols[id].push(obj)
};
VS_SymbolsManager.prototype.GetSymbol = function(symbolId, parent, forLoop) {
    if (forLoop == true && this.SpecialLoopsManager != null) return this.SpecialLoopsManager.GetSymbol(symbolId, parent);
    return this.GetFromPool(symbolId, parent)
};
VS_SymbolsManager.prototype.RecycleSymbol = function(symbol, forLoop) {
    if (forLoop == true && this.SpecialLoopsManager != null) this.SpecialLoopsManager.RecycleSymbol(symbol);
    else this.PoolSymbol(symbol.symbolId, symbol)
};
VS_SymbolsManager.prototype.LateUpdate = function() {
    if (this.pool.activeSelf && this.currentInitSymbol > this.symbols.length) {
        if (!this.disablePoolNextFrame) {
            this.disablePoolNextFrame = true;
            return
        }
        this.pool.SetActive(false)
    }
};
goog.require("UHT.Engine");
goog.require("UHT.VS_Symbol");
goog.provide("UHT.VS_ReelSymbolHolder");
VS_ReelSymbolHolder.prototype = Object.create(XTLink.prototype);
VS_ReelSymbolHolder.prototype.constructor = VS_ReelSymbolHolder;

function VS_ReelSymbolHolder() {
    XTLink.call(this);
    this.startAnimation = null;
    this.startAnimationFastPlay = null;
    this.loopAnimation = null;
    this.stopAnimation = null;
    this.stopAnimationFastPlay = null;
    this.positionInReel = 0;
    this.orderedSymbolIdx = 0;
    this.parentReel = null;
    this.currentSymbol = null;
    this.eventStartDelay = 0;
    this.eventStartDelayFastPlay = 0;
    this.eventStopDelay = 0;
    this.eventStopDelayFastPlay = 0;
    this.fireOnStopEvent = null;
    this.canFireStartEvent = false;
    this.canFireStopEvent = false;
    this.animationState = null;
    this.animationTime =
        0;
    this.animationIsUpdated = false;
    this.symbolIsLooper = false;
    this.speed = 1;
    this.linkedLooper = null;
    this.linkedLooperShouldBeDiscarded = false;
    this.linkedLooperOffsetY = 0;
    this.lastSymbolId = -1;
    this.rememberToChangeSymbolState = false;
    this.usingFastStartAnimation = false;
    this.usingFastStopAnimation = false;
    this.state = VS_ReelSymbolHolder.State.IDLE;
    this.posLayer;
    this.extraStopEvents = null;
    this.extraStopEventDelays = null;
    this.extraStopEventDelaysFastPlay = null;
    this.canFireExtraStopEvents = null
}
VS_ReelSymbolHolder.State = {
    IDLE: 0,
    START: 1,
    LOOP: 2,
    STOP: 3
};
VS_ReelSymbolHolder.prototype.SetPositionInReel = function(pos) {
    this.positionInReel = pos
};
VS_ReelSymbolHolder.prototype.SetOrderedSymbolIdx = function(idx) {
    this.orderedSymbolIdx = idx
};
VS_ReelSymbolHolder.prototype.GetOrderedSymbolIdx = function() {
    return this.orderedSymbolIdx
};
VS_ReelSymbolHolder.prototype.SetParentReel = function(reel) {
    this.parentReel = reel
};
VS_ReelSymbolHolder.prototype.DiscardSymbol = function() {
    if (this.currentSymbol != null) this.parentReel.reelsManager.symbolsManager.RecycleSymbol(this.currentSymbol, this.symbolIsLooper);
    this.currentSymbol = null
};
VS_ReelSymbolHolder.prototype.ReplaceSymbol = function(idx, forLoop) {
    this.symbolIsLooper = forLoop == true;
    this.DiscardSymbol();
    this.currentSymbol = this.parentReel.reelsManager.symbolsManager.GetSymbol(idx, this.gameObject, this.symbolIsLooper);
    this.lastSymbolId = this.currentSymbol.symbolId
};
VS_ReelSymbolHolder.prototype.UpdateLinkedLooperPosition = function() {
    if (this.linkedLooper != null && XT.GetBool(Vars.CanUpdateLinkedLoopersPosition)) this.linkedLooper.transform.localPosition(UHTMath.Vector3.sub(this.transform.localPosition(), new UHTMath.Vector3(0, this.linkedLooperOffsetY, 0)))
};
VS_ReelSymbolHolder.prototype.SampleAnimation = function() {
    this.animationState.enabled = true;
    this.animationState.weight = 1;
    this.animationState.time = this.animationTime;
    this.gameObject.animation.Sample();
    this.animationState.enabled = false
};
VS_ReelSymbolHolder.prototype.UpdateVisual = function() {
    if (!this.animationIsUpdated) this.animationTime += Time.deltaTime * this.speed;
    else this.animationIsUpdated = false;
    if (this.rememberToChangeSymbolState && this.animationTime > 0) {
        this.rememberToChangeSymbolState = false;
        this.ChangeSymbolState()
    }
    switch (this.state) {
        case VS_ReelSymbolHolder.State.START:
            if (this.canFireStartEvent)
                if (this.animationTime >= (this.usingFastStartAnimation ? this.eventStartDelayFastPlay : this.eventStartDelay)) {
                    this.canFireStartEvent = false;
                    this.currentSymbol.EventStart()
                }
            if (this.animationTime > this.animationState.length) {
                this.state = VS_ReelSymbolHolder.State.IDLE;
                this.DiscardSymbol();
                this.parentReel.SymbolLeftTheReel(this.positionInReel, this.animationTime - this.animationState.length);
                if (this.linkedLooperShouldBeDiscarded) {
                    this.linkedLooper.DiscardSymbol();
                    this.linkedLooperShouldBeDiscarded = false
                }
                this.linkedLooper = null
            } else this.SampleAnimation();
            break;
        case VS_ReelSymbolHolder.State.LOOP:
            if (this.animationTime > this.animationState.length) {
                this.state =
                    VS_ReelSymbolHolder.State.IDLE;
                this.DiscardSymbol();
                this.parentReel.SymbolLeftTheReel(this.positionInReel, this.animationTime - this.animationState.length)
            } else this.SampleAnimation();
            break;
        case VS_ReelSymbolHolder.State.STOP:
            for (var i = 0; i < this.extraStopEvents.length; ++i)
                if (this.animationTime >= (this.usingFastStopAnimation ? this.extraStopEventDelaysFastPlay[i] : this.extraStopEventDelays[i]) && this.canFireExtraStopEvents[i]) {
                    this.canFireExtraStopEvents[i] = false;
                    this.extraStopEvents[i].Start()
                }
            if (this.canFireStopEvent)
                if (this.animationTime >=
                    (this.usingFastStopAnimation ? this.eventStopDelayFastPlay : this.eventStopDelay)) {
                    this.canFireStopEvent = false;
                    this.fireOnStopEvent.Start();
                    this.currentSymbol.EventStop()
                }
            if (this.animationTime > this.animationState.length) {
                this.animationTime = this.animationState.length;
                this.state = VS_ReelSymbolHolder.State.IDLE;
                this.parentReel.StopFinished(this.positionInReel)
            }
            this.SampleAnimation();
            break;
        default:
            break
    }
};
VS_ReelSymbolHolder.prototype.AfterUpdateVisual = function() {
    this.animationIsUpdated = false;
    this.UpdateLinkedLooperPosition()
};
VS_ReelSymbolHolder.prototype.StartAnimation = function(clip, startTime) {
    this.gameObject.animation.clip = clip;
    this.animationState = this.gameObject.animation.GetAnimationState(clip.name);
    this.animationTime = startTime;
    this.SampleAnimation();
    this.animationIsUpdated = true;
    this.parentReel.UpdateSortedSymbolHolders()
};
VS_ReelSymbolHolder.prototype.PlayStart = function() {
    this.rememberToChangeSymbolState = false;
    this.canFireStartEvent = true;
    this.state = VS_ReelSymbolHolder.State.START;
    this.StartAnimation(this.GetStartAnimation(), 0);
    this.currentSymbol.SpinStart();
    if (this.linkedLooper != null) this.linkedLooper.currentSymbol.SpinStart()
};
VS_ReelSymbolHolder.prototype.PlayLoop = function(startTime) {
    this.rememberToChangeSymbolState = false;
    this.state = VS_ReelSymbolHolder.State.LOOP;
    this.StartAnimation(this.loopAnimation, startTime);
    if (this.parentReel.reelsManager.showTopBottomSymbols && startTime < 0) this.rememberToChangeSymbolState = true;
    else this.ChangeSymbolState()
};
VS_ReelSymbolHolder.prototype.ChangeSymbolState = function() {
    if (this.currentSymbol == null) return;
    if (this.parentReel.isExcited)
        if (this.parentReel.ExcitedImportantSymbols[this.currentSymbol.symbolId]) this.currentSymbol.SpinLoopExcitedImportant();
        else this.currentSymbol.SpinLoopExcited();
    else this.currentSymbol.SpinLoop()
};
VS_ReelSymbolHolder.prototype.PlayStop = function(startTime) {
    this.rememberToChangeSymbolState = false;
    this.canFireStopEvent = true;
    this.state = VS_ReelSymbolHolder.State.STOP;
    this.StartAnimation(this.GetStopAnimation(), startTime);
    this.currentSymbol.SpinStop();
    if (this.linkedLooper != null) this.linkedLooper.currentSymbol.SpinStop();
    if (this.canFireExtraStopEvents == null) this.canFireExtraStopEvents = _array.create(this.extraStopEvents.length);
    for (var i = 0; i < this.canFireExtraStopEvents.length; ++i) this.canFireExtraStopEvents[i] =
        true
};
VS_ReelSymbolHolder.prototype.GetStartAnimation = function() {
    this.usingFastStartAnimation = this.parentReel.useFastAnimationsInTurboSpin && XT.GetBool(Vars.ContinuousSpin) || this.parentReel.reelsManager.isFastStart;
    return this.usingFastStartAnimation ? this.startAnimationFastPlay : this.startAnimation
};
VS_ReelSymbolHolder.prototype.GetEventStartDelay = function() {
    var usingFastStartAnimation = this.parentReel.useFastAnimationsInTurboSpin && XT.GetBool(Vars.ContinuousSpin) || this.parentReel.reelsManager.isFastStart;
    return usingFastStartAnimation ? this.eventStartDelayFastPlay : this.eventStartDelay
};
VS_ReelSymbolHolder.prototype.GetStopAnimation = function() {
    if (this.stopAnimationFastPlay == null) return this.stopAnimation;
    this.usingFastStopAnimation = this.parentReel.reelsManager.isFastStart || this.parentReel.reelsManager.fastStop;
    return this.usingFastStopAnimation ? this.stopAnimationFastPlay : this.stopAnimation
};
goog.require("UHT.Engine");
goog.require("UHT.VS_ReelSymbolHolder");
goog.provide("UHT.VS_Reel");
VS_Reel.prototype = Object.create(Component.prototype);
VS_Reel.prototype.constructor = VS_Reel;

function VS_Reel() {
    Component.call(this);
    this.reelsManager = null;
    this.symbolHolders = [];
    this.symbolLoopHolders = [];
    this.sortedSymbolHolders = [];
    this.replaceEmptySymbol = false;
    this.emptySymbolReplacements = [];
    this.stopOffset = 1;
    this.spinInPlace = false;
    this.useFastAnimationsInTurboSpin = false;
    this.loopDelayAfterStart = 0;
    this.loopDelayAfterFastStart = 0;
    this.reelIndex = 0;
    this.isExcited = false;
    this.ExcitedImportantSymbols = null;
    this.randomStop = false;
    this.randomStopDelay = .25;
    this.lastPosLeftIdx = -1;
    this.mustStop = false;
    this.stopIdx = 0;
    this.symbolList = [];
    this.stopPosition = 0;
    this.rememberedStopPosition = 0;
    this.currentPosition = 0;
    this.holdersSpinning = 0;
    this.internalCounterInPlace = 0;
    this.randomizedStopIdx = [];
    this.willRandomStopIdx = 0;
    this.randomStopTimer = 0;
    this.cs_stopCounter = 0;
    this.mustSortHolders = false;
    this.lastSymbolsEntered = [];
    this.delayStopToAvoidStacks = ReelDelayStopType.NO;
    this.customDistanceSymbols = [];
    this.customDistance = 1;
    this.symbolStacksSettings = [];
    this.lastStackEntered = [];
    this.speedCurveTimer = 0;
    this.speedCurve =
        null;
    this.needToUpdateSymbolsDepth = false;
    this.reelScreenSymbols = [];
    this.applySpinInPlaceExtraSettings = false;
    this.lastLooperIndexForHolder = [];
    this.holdersStopStarted = [];
    this.randomStopIsOrdered = false;
    this.randomStopHolderOrder = [];
    this.instantStopTimeOffset = []
}
var ReelDelayStopType = {
    NO: 0,
    ALWAYS: 1,
    EXCITEDONLY: 2
};
VS_Reel.prototype.InitReel = function() {
    this.holdersStopStarted = [];
    if (this.applySpinInPlaceExtraSettings) {
        this.lastLooperIndexForHolder = [];
        for (var i = 0; i < this.symbolHolders.length; i++) {
            this.lastLooperIndexForHolder[i] = -1;
            this.holdersStopStarted[i] = false
        }
    }
    for (var i = 0; i < this.symbolHolders.length; i++) {
        this.symbolHolders[i].SetParentReel(this);
        this.symbolHolders[i].SetPositionInReel(i);
        this.sortedSymbolHolders.push(this.symbolHolders[i])
    }
    if (this.symbolHolders.length != 1) {
        this.symbolHolders[this.symbolHolders.length -
            1].linkedLooperOffsetY = this.symbolHolders[this.symbolHolders.length - 2].transform.localPosition().y - this.symbolHolders[this.symbolHolders.length - 1].transform.localPosition().y;
        this.symbolHolders[0].linkedLooperOffsetY = this.symbolHolders[1].transform.localPosition().y - this.symbolHolders[0].transform.localPosition().y
    }
    for (var j = 0; j < this.symbolLoopHolders.length; j++) {
        this.symbolLoopHolders[j].SetParentReel(this);
        if (!this.applySpinInPlaceExtraSettings) this.symbolLoopHolders[j].SetPositionInReel(j);
        else if (j >=
            this.symbolHolders.length && j < this.symbolLoopHolders.length) {
            var pos = j % this.symbolHolders.length;
            this.symbolLoopHolders[j].SetPositionInReel(pos)
        } else this.symbolLoopHolders[j].SetPositionInReel(j);
        this.sortedSymbolHolders.push(this.symbolLoopHolders[j])
    }
    this.UpdateSortedSymbolHolders();
    this.randomizedStopIdx = new Array(this.symbolHolders.length)
};
VS_Reel.prototype.SetScreenSymbols = function(ssList) {
    for (var i = 0; i < this.symbolHolders.length; i++)
        if (this.symbolHolders[this.symbolHolders.length - 1 - i].currentSymbol == null || this.symbolHolders[this.symbolHolders.length - 1 - i].currentSymbol.symbolId != ssList[this.reelIndex][i]) {
            this.symbolHolders[this.symbolHolders.length - 1 - i].ReplaceSymbol(ssList[this.reelIndex][i]);
            this.symbolHolders[i].SetOrderedSymbolIdx(i * this.reelsManager.reels.length + this.reelIndex)
        }
    var pos = this.currentPosition;
    for (var j = 0; j < this.symbolHolders.length; j++) this.currentPosition--;
    this.currentPosition += ssList[this.reelIndex].length;
    this.currentPosition %= ssList[this.reelIndex].length;
    var topSymbol;
    var bottomSymbol;
    if (XT.GetBool(Vars.HiddenMathematics)) {
        var symbolsAbove = XT.GetObject(Vars.SymbolsAboveReels);
        topSymbol = symbolsAbove[this.reelIndex];
        var symbolsBelow = XT.GetObject(Vars.SymbolsBelowReels);
        bottomSymbol = symbolsBelow[this.reelIndex]
    } else {
        topSymbol = ssList[this.reelIndex][pos % ssList[this.reelIndex].length];
        bottomSymbol = ssList[this.reelIndex][this.currentPosition % ssList[this.reelIndex].length]
    }
    this.AddBottomLinkedLooperSymbol(bottomSymbol);
    this.AddTopLinkedLooperSymbol(topSymbol);
    this.lastStackEntered = [];
    for (var i = this.symbolHolders.length - 1; i >= 0; i--) this.FilterTroughStacksSettings(this.symbolHolders[i].currentSymbol.symbolId, false);
    if (this.reelsManager.showTopBottomSymbols) this.FilterTroughStacksSettings(topSymbol, false);
    this.UpdateSortedSymbolHolders()
};
VS_Reel.prototype.GetNextSymbol = function() {
    if (this.mustStop) {
        var lastStoppingSymbolEntered = 0;
        if (this.reelsManager.stopOnScreenSymbols || this.reelsManager.forceStopOnScreenSymbols) {
            this.stopPosition--;
            this.stopPosition += this.symbolList.length;
            this.stopPosition %= this.symbolList.length;
            lastStoppingSymbolEntered = this.GetReelScreenSymbols(XT.GetObject(Vars.ResultScreenSymbols))[this.cs_stopCounter++]
        } else if (this.reelsManager.stopOnInitialScreenSymbols) {
            this.stopPosition--;
            this.stopPosition += this.symbolList.length;
            this.stopPosition %= this.symbolList.length;
            var symbolID = this.GetReelScreenSymbols(XT.GetObject(Vars.InitialResultScreenSymbols))[this.cs_stopCounter++];
            if (this.replaceEmptySymbol && symbolID == this.reelsManager.blankSymbolId) symbolID = this.emptySymbolReplacements[Math.floor(Math.random() * this.emptySymbolReplacements.length)];
            lastStoppingSymbolEntered = symbolID
        } else {
            var pos = this.stopPosition;
            this.stopPosition--;
            this.stopPosition += this.symbolList.length;
            this.stopPosition %= this.symbolList.length;
            lastStoppingSymbolEntered =
                this.symbolList[pos % this.symbolList.length]
        }
        this.FilterTroughStacksSettings(lastStoppingSymbolEntered, false);
        return lastStoppingSymbolEntered
    } else {
        var pos2 = this.currentPosition;
        this.currentPosition--;
        this.currentPosition += this.symbolList.length;
        this.currentPosition %= this.symbolList.length;
        var lastSymbolEntered = this.symbolList[pos2 % this.symbolList.length];
        lastSymbolEntered = this.FilterTroughStacksSettings(lastSymbolEntered, true);
        this.lastSymbolsEntered.push(lastSymbolEntered);
        if (this.lastSymbolsEntered.length >
            this.customDistance) this.lastSymbolsEntered.splice(0, 1);
        return lastSymbolEntered
    }
};
VS_Reel.prototype.FilterTroughStacksSettings = function(lastEntered, canForceStack) {
    var symbolID = lastEntered;
    if (this.symbolStacksSettings.length > 0) {
        if (this.lastStackEntered.length > 0) {
            var stackMatch = true;
            for (var i = 0; i < this.symbolStacksSettings.length; i++) {
                stackMatch = true;
                for (var j = 0; j < this.lastStackEntered.length; j++)
                    if (!this.symbolStacksSettings[i].IsPartOfStack(this.lastStackEntered[j])) {
                        stackMatch = false;
                        break
                    }
                if (stackMatch) {
                    if (!this.symbolStacksSettings[i].IsPartOfStack(symbolID)) {
                        var stackIncomplete = this.lastStackEntered.length <
                            this.symbolStacksSettings[i].stackSize || this.symbolStacksSettings[i].hasFixedSize && this.lastStackEntered.length % this.symbolStacksSettings[i].stackSize != 0;
                        if (stackIncomplete && canForceStack) symbolID = this.symbolStacksSettings[i].stackedSymbolIDs[Random.Range(0, this.symbolStacksSettings[i].stackedSymbolIDs.length)];
                        else stackMatch = false
                    }
                    break
                }
            }
            if (!stackMatch) this.lastStackEntered = []
        }
        this.lastStackEntered.push(symbolID)
    }
    return symbolID
};
VS_Reel.prototype.GetNextSymbolInPlace = function(positionInReel) {
    var thisHolderMustKeepSpinning = false;
    if (this.applySpinInPlaceExtraSettings && this.holdersStopStarted[positionInReel] == false) thisHolderMustKeepSpinning = true;
    var a = 2;
    if (this.mustStop && !thisHolderMustKeepSpinning)
        if (this.reelsManager.stopOnScreenSymbols || this.reelsManager.forceStopOnScreenSymbols) return this.GetReelScreenSymbols(XT.GetObject(Vars.ResultScreenSymbols))[this.symbolHolders.length - 1 - positionInReel];
        else if (this.reelsManager.stopOnInitialScreenSymbols) return this.GetReelScreenSymbols(XT.GetObject(Vars.InitialResultScreenSymbols))[this.symbolHolders.length -
        1 - positionInReel];
    else {
        var pos = this.stopPosition - (this.symbolHolders.length - 1 - positionInReel);
        pos += this.symbolList.length;
        pos %= this.symbolList.length;
        return this.symbolList[pos]
    } else {
        if (this.applySpinInPlaceExtraSettings) {
            this.currentPosition--;
            this.currentPosition += this.symbolList.length;
            this.currentPosition %= this.symbolList.length
        } else {
            this.internalCounterInPlace++;
            if (this.internalCounterInPlace == this.symbolHolders.length) {
                this.internalCounterInPlace = 0;
                this.currentPosition -= this.symbolHolders.length;
                this.currentPosition += this.symbolList.length;
                this.currentPosition %= this.symbolList.length
            }
        }
        var pos2 = this.currentPosition - positionInReel;
        pos2 += this.symbolList.length;
        pos2 %= this.symbolList.length;
        return this.symbolList[pos2]
    }
};
VS_Reel.prototype.RandomizeStops = function() {
    var allpos = [];
    for (var i = 0; i < this.randomizedStopIdx.length; i++)
        if (!this.randomStopIsOrdered) allpos.push(i);
        else this.randomizedStopIdx[i] = this.randomStopHolderOrder[i];
    if (!this.randomStopIsOrdered)
        for (var j = 0; j < this.randomizedStopIdx.length; j++) {
            var idx = Random.Range(0, allpos.length);
            this.randomizedStopIdx[j] = allpos[idx];
            for (var k = 0; k < allpos.length; k++)
                if (allpos[k] == allpos[idx]) allpos.splice(k, 1)
        }
};
VS_Reel.prototype.SetPosition = function(pos) {
    this.currentPosition = Random.Range(0, this.symbolList.length) % this.symbolList.length
};
VS_Reel.prototype.SetStopPosition = function(pos) {
    this.stopPosition = (pos + this.stopOffset) % this.symbolList.length;
    this.rememberedStopPosition = this.stopPosition
};
VS_Reel.prototype.SetSymbolList = function(list) {
    this.symbolList = [];
    for (var i = 0; i < list.length; i++) this.symbolList.push(list[i])
};
VS_Reel.prototype.Start = function() {};
VS_Reel.prototype.SetSpeedCurve = function(curve) {
    this.speedCurveTimer = 0;
    this.speedCurve = curve
};
VS_Reel.prototype.Update = function() {
    var speed = 1;
    if (this.speedCurve != null) {
        speed = this.speedCurve.Evaluate(this.speedCurveTimer);
        this.speedCurveTimer += Time.deltaTime
    }
    var i;
    for (i = this.symbolHolders.length - 1; i >= 0; i--) {
        this.symbolHolders[i].speed = speed;
        this.symbolHolders[i].UpdateVisual()
    }
    var loopersLeft = this.symbolLoopHolders.length;
    var currentLooper = (this.lastPosLeftIdx - 1 + this.symbolLoopHolders.length) % this.symbolLoopHolders.length;
    while (loopersLeft > 0) {
        this.symbolLoopHolders[currentLooper].speed = speed;
        this.symbolLoopHolders[currentLooper].UpdateVisual();
        currentLooper = (currentLooper - 1 + this.symbolLoopHolders.length) % this.symbolLoopHolders.length;
        loopersLeft--
    }
    for (var i3 = 0; i3 < this.symbolHolders.length; i3++) this.symbolHolders[i3].AfterUpdateVisual();
    for (var i4 = 0; i4 < this.symbolLoopHolders.length; i4++) this.symbolLoopHolders[i4].AfterUpdateVisual();
    this.randomStopTimer += Time.deltaTime
};
VS_Reel.prototype.GetNextLooperIndexForPosition = function(pos) {
    var nextIndex = this.lastLooperIndexForHolder[pos];
    if (nextIndex == -1) {
        this.lastLooperIndexForHolder[pos] = pos;
        return pos
    }
    nextIndex = nextIndex + this.symbolHolders.length > this.symbolLoopHolders.length - 1 ? pos : nextIndex + this.symbolHolders.length;
    this.lastLooperIndexForHolder[pos] = nextIndex;
    return nextIndex
};
VS_Reel.prototype.NewLoop = function(positionInReel, extraTime) {
    var rsh;
    if (this.spinInPlace) {
        if (this.applySpinInPlaceExtraSettings) rsh = this.symbolLoopHolders[this.GetNextLooperIndexForPosition(positionInReel)];
        else rsh = this.symbolLoopHolders[positionInReel];
        rsh.ReplaceSymbol(this.GetNextSymbolInPlace(positionInReel), true)
    } else if (positionInReel == -1 && this.symbolHolders[0].linkedLooper != null) rsh = this.symbolHolders[0].linkedLooper;
    else {
        if (positionInReel == -1) rsh = this.symbolLoopHolders[this.symbolLoopHolders.length -
            1];
        else rsh = this.symbolLoopHolders[positionInReel];
        rsh.ReplaceSymbol(this.GetNextSymbol(), true)
    }
    rsh.PlayLoop(extraTime)
};
VS_Reel.prototype.StartSpin = function() {
    if (this.applySpinInPlaceExtraSettings)
        for (var i = 0; i < this.holdersStopStarted.length; i++) this.holdersStopStarted[i] = false;
    this.mustStop = false;
    this.holdersSpinning = this.symbolHolders.length;
    for (var i1 = 0; i1 < this.symbolHolders.length; i1++) {
        this.symbolHolders[i1].PlayStart();
        if (this.applySpinInPlaceExtraSettings) this.NewLoop(i1, -this.symbolHolders[i1].GetEventStartDelay())
    }
    if (!this.spinInPlace) this.SymbolLeftTheReel(-1, -this.GetLoopDelayAfterStart());
    this.internalCounterInPlace =
        0;
    this.RandomizeStops();
    this.willRandomStopIdx = 0;
    this.randomStopTimer = this.randomStopDelay
};
VS_Reel.prototype.AddLinkedLooper = function(holderIdx, looper, symbolIdx, mustDiscardOnLeavingReel) {
    if (!this.reelsManager.showTopBottomSymbols) return;
    this.symbolLoopHolders[looper].rememberToChangeSymbolState = false;
    this.symbolLoopHolders[looper].ReplaceSymbol(symbolIdx);
    this.symbolLoopHolders[looper].currentSymbol.SpinStop();
    this.symbolHolders[holderIdx].linkedLooper = this.symbolLoopHolders[looper];
    this.symbolHolders[holderIdx].UpdateLinkedLooperPosition();
    this.symbolHolders[holderIdx].linkedLooperShouldBeDiscarded =
        mustDiscardOnLeavingReel
};
VS_Reel.prototype.AddTopLinkedLooperSymbol = function(symbolIdx) {
    this.AddLinkedLooper(0, this.symbolLoopHolders.length - 1, symbolIdx, false)
};
VS_Reel.prototype.AddBottomLinkedLooperSymbol = function(symbolIdx) {
    this.AddLinkedLooper(this.symbolHolders.length - 1, 0, symbolIdx, true)
};
VS_Reel.prototype.AddTopLinkedLooper = function() {
    var topSymbol;
    if (XT.GetBool(Vars.HiddenMathematics)) {
        var symbolsAbove = XT.GetObject(Vars.SymbolsAboveReels);
        topSymbol = symbolsAbove[this.reelIndex]
    } else topSymbol = this.symbolList[this.currentPosition % this.symbolList.length];
    this.AddTopLinkedLooperSymbol(topSymbol)
};
VS_Reel.prototype.AddBottomLinkedLooper = function() {
    var bottomSymbol;
    if (XT.GetBool(Vars.HiddenMathematics)) {
        var symbolsBelow = XT.GetObject(Vars.SymbolsBelowReels);
        bottomSymbol = symbolsBelow[this.reelIndex]
    } else bottomSymbol = this.symbolList[(this.currentPosition + this.symbolHolders.length) % this.symbolList.length];
    this.AddBottomLinkedLooperSymbol(bottomSymbol)
};
VS_Reel.prototype.GetLooperTimersAndCleanUp = function(template) {
    var list = [];
    var loopAnimationTime = this.symbolLoopHolders[0].loopAnimation.length;
    var lowestStartSymbolId = -1;
    var i;
    for (i = 0; i < this.symbolHolders.length; i++) {
        if (this.symbolHolders[i].state == VS_ReelSymbolHolder.State.START) {
            var capped = this.symbolHolders[i].animationTime;
            if (capped < this.GetLoopDelayAfterStart()) capped = this.GetLoopDelayAfterStart();
            var loopOffset = loopAnimationTime - (this.symbolHolders[i].GetStartAnimation().length - capped);
            if (loopOffset <
                0) loopOffset = 0;
            list.push(loopOffset);
            lowestStartSymbolId = this.symbolHolders[i].currentSymbol.symbolId;
            this.symbolHolders[i].DiscardSymbol();
            this.symbolHolders[i].state = VS_ReelSymbolHolder.State.IDLE
        }
        if (this.symbolHolders[i].state == VS_ReelSymbolHolder.State.STOP) {
            list.push(this.symbolHolders[i].animationTime);
            this.symbolHolders[i].DiscardSymbol();
            this.symbolHolders[i].state = VS_ReelSymbolHolder.State.IDLE
        }
        if (this.symbolHolders[i].linkedLooper)
            if (this.symbolHolders[i].linkedLooperShouldBeDiscarded) this.symbolHolders[i].linkedLooper.DiscardSymbol();
        this.symbolHolders[i].linkedLooper = null
    }
    var mostAdvancedLooperSymbolId = -1;
    var maxLoopTime = -1;
    for (i = 0; i < this.symbolLoopHolders.length; i++)
        if (this.symbolLoopHolders[i].state == VS_ReelSymbolHolder.State.LOOP) {
            var aTime = this.symbolLoopHolders[i].animationTime;
            if (aTime < 0) aTime = 0;
            list.push(aTime);
            if (aTime > maxLoopTime) {
                mostAdvancedLooperSymbolId = this.symbolLoopHolders[i].currentSymbol.symbolId;
                maxLoopTime = aTime
            }
        }
    for (i = 0; i < this.symbolLoopHolders.length; i++) {
        this.symbolLoopHolders[i].DiscardSymbol();
        this.symbolLoopHolders[i].state =
            VS_ReelSymbolHolder.State.IDLE
    }
    if (template != null) list = template;
    else {
        list.sort(function(a, b) {
            return a - b
        });
        this.reelsManager.fastStopTimeUntilFinish = this.symbolHolders[0].stopAnimation.length - list[0]
    }
    if (list.length > this.symbolHolders.length && !this.reelsManager.showTopBottomSymbols) {
        var extraLooperNeeded = true;
        if (lowestStartSymbolId != -1) this.symbolLoopHolders[0].ReplaceSymbol(lowestStartSymbolId);
        else if (mostAdvancedLooperSymbolId != -1) this.symbolLoopHolders[0].ReplaceSymbol(mostAdvancedLooperSymbolId);
        else extraLooperNeeded = false;
        if (extraLooperNeeded) this.symbolLoopHolders[0].PlayLoop(list[this.symbolHolders.length])
    }
    this.AddBottomLinkedLooper();
    this.AddTopLinkedLooper();
    return list
};
VS_Reel.prototype.StopSpin = function(fastStop, template) {
    this.cs_stopCounter = 0;
    this.stopPosition = this.rememberedStopPosition;
    this.mustStop = true;
    this.stopIdx = this.symbolHolders.length - 1;
    if (this.reelsManager.instantStop && fastStop)
        if (this.applySpinInPlaceExtraSettings) {
            for (var i = 0; i < this.sortedSymbolHolders.length; i++)
                if (this.sortedSymbolHolders[i].state != VS_ReelSymbolHolder.State.IDLE && this.sortedSymbolHolders[i].state != VS_ReelSymbolHolder.State.STOP) {
                    this.sortedSymbolHolders[i].DiscardSymbol();
                    this.sortedSymbolHolders[i].state =
                        VS_ReelSymbolHolder.State.IDLE
                }
            var timers = this.instantStopTimeOffset;
            var holderIdx = this.stopIdx;
            while (holderIdx >= 0) {
                this.symbolHolders[holderIdx].ReplaceSymbol(this.GetNextSymbol());
                this.needToUpdateSymbolsDepth = true;
                this.symbolHolders[holderIdx].PlayStop(timers[holderIdx]);
                holderIdx--
            }
            this.stopIdx = -1;
            return timers
        } else if (this.holdersSpinning == this.symbolHolders.length) {
        var timers = this.GetLooperTimersAndCleanUp(template);
        var holderIdx = this.stopIdx;
        while (holderIdx >= 0) {
            this.symbolHolders[holderIdx].ReplaceSymbol(this.GetNextSymbol());
            this.needToUpdateSymbolsDepth = true;
            this.symbolHolders[holderIdx].PlayStop(timers[holderIdx]);
            holderIdx--
        }
        this.stopIdx = -1;
        this.lastStackEntered = [];
        for (var i = this.symbolHolders.length - 1; i >= 0; i--) this.FilterTroughStacksSettings(this.symbolHolders[i].currentSymbol.symbolId, false);
        if (this.reelsManager.showTopBottomSymbols && this.symbolHolders[0].linkedLooper != null) this.FilterTroughStacksSettings(this.symbolHolders[0].linkedLooper.currentSymbol.symbolId, false);
        return timers
    }
    return null
};
VS_Reel.prototype.SymbolLeftTheReel = function(positionInReel, extraTime) {
    this.lastPosLeftIdx = positionInReel;
    if (this.mustStop)
        if (this.spinInPlace)
            if (!this.randomStop) {
                if (!this.applySpinInPlaceExtraSettings || this.holdersStopStarted[positionInReel] == false) {
                    this.symbolHolders[positionInReel].ReplaceSymbol(this.GetNextSymbolInPlace(positionInReel));
                    this.symbolHolders[positionInReel].PlayStop(extraTime)
                }
                this.holdersStopStarted[positionInReel] = true
            } else {
                if (!this.applySpinInPlaceExtraSettings || this.holdersStopStarted[positionInReel] ==
                    false)
                    if (this.randomStop && this.randomStopTimer >= this.randomStopDelay && positionInReel == this.randomizedStopIdx[this.willRandomStopIdx]) {
                        this.holdersStopStarted[positionInReel] = true;
                        this.symbolHolders[positionInReel].ReplaceSymbol(this.GetNextSymbolInPlace(positionInReel));
                        this.symbolHolders[positionInReel].PlayStop(extraTime);
                        this.willRandomStopIdx++;
                        this.randomStopTimer = 0
                    } else this.NewLoop(positionInReel, extraTime)
            }
    else if (this.stopIdx >= 0) {
        this.symbolHolders[this.stopIdx].ReplaceSymbol(this.GetNextSymbol());
        this.symbolHolders[this.stopIdx].PlayStop(extraTime);
        this.stopIdx--
    } else {
        var topSymbol;
        var bottomSymbol;
        if (XT.GetBool(Vars.HiddenMathematics)) {
            var symbolsAbove = XT.GetObject(Vars.SymbolsAboveReels);
            topSymbol = symbolsAbove[this.reelIndex];
            var symbolsBelow = XT.GetObject(Vars.SymbolsBelowReels);
            bottomSymbol = symbolsBelow[this.reelIndex]
        } else {
            topSymbol = this.symbolList[this.currentPosition % this.symbolList.length];
            bottomSymbol = this.symbolLoopHolders[positionInReel].lastSymbolId
        }
        this.AddBottomLinkedLooperSymbol(bottomSymbol);
        this.AddTopLinkedLooperSymbol(topSymbol);
        if (this.reelsManager.showTopBottomSymbols) this.FilterTroughStacksSettings(topSymbol, false)
    } else this.NewLoop(positionInReel, extraTime)
};
VS_Reel.prototype.StopFinished = function(positionInReel) {
    this.holdersSpinning--;
    if (this.holdersSpinning == 0) {
        this.reelsManager.StopFinished(this.reelIndex);
        this.currentPosition = this.stopPosition;
        this.speedCurve = null
    }
};
VS_Reel.prototype.GetLoopDelayAfterStart = function() {
    if (this.useFastAnimationsInTurboSpin && XT.GetBool(Vars.ContinuousSpin)) return this.loopDelayAfterFastStart;
    return this.reelsManager.isFastStart ? this.loopDelayAfterFastStart : this.loopDelayAfterStart
};
VS_Reel.prototype.UpdateSortedSymbolHolders = function() {
    if (this.sortedSymbolHolders != null && this.mustSortHolders) {
        for (var i = 0; i < this.sortedSymbolHolders.length - 1; i++)
            for (var j = i + 1; j < this.sortedSymbolHolders.length; j++)
                if (this.sortedSymbolHolders[j].transform._dangerous_get_localPosition().y > this.sortedSymbolHolders[i].transform._dangerous_get_localPosition().y) {
                    var rsh = this.sortedSymbolHolders[j];
                    this.sortedSymbolHolders[j] = this.sortedSymbolHolders[i];
                    this.sortedSymbolHolders[i] = rsh;
                    this.needToUpdateSymbolsDepth =
                        true
                }
        if (this.needToUpdateSymbolsDepth) {
            this.needToUpdateSymbolsDepth = false;
            XT.TriggerEvent(Vars.Evt_Internal_UpdateSymbolsDepth)
        }
    }
};
VS_Reel.prototype.SetSymbolsToNormal = function() {
    for (var i = 0; i < this.symbolHolders.length; i++)
        if (this.symbolHolders[i].currentSymbol != null) this.symbolHolders[i].currentSymbol.SetNormal()
};
VS_Reel.prototype.GetReelScreenSymbols = function(reelsSymbols) {
    if (XT.GetBool(Vars.HiddenMathematics) && this.symbolHolders.length > reelsSymbols[this.reelIndex].length) {
        if (this.cs_stopCounter == 0) {
            this.reelScreenSymbols.splice(0);
            this.reelScreenSymbols.push(XT.GetObject(Vars.SymbolsAboveReels)[this.reelIndex]);
            for (var i = 0; i < reelsSymbols[this.reelIndex].length; ++i) this.reelScreenSymbols.push(reelsSymbols[this.reelIndex][i]);
            this.reelScreenSymbols.push(XT.GetObject(Vars.SymbolsBelowReels)[this.reelIndex])
        }
        return this.reelScreenSymbols
    }
    return reelsSymbols[this.reelIndex]
};
VS_Reel.prototype.NeedToKeepSpinning = function() {
    if (this.delayStopToAvoidStacks == ReelDelayStopType.ALWAYS || this.delayStopToAvoidStacks == ReelDelayStopType.EXCITEDONLY && this.isExcited) {
        var firstResponseSymbols = [];
        if (this.reelsManager.stopOnScreenSymbols || this.reelsManager.forceStopOnScreenSymbols) firstResponseSymbols = this.GetReelScreenSymbols(XT.GetObject(Vars.ResultScreenSymbols));
        else if (this.reelsManager.stopOnInitialScreenSymbols) firstResponseSymbols = this.GetReelScreenSymbols(XT.GetObject(Vars.InitialResultScreenSymbols));
        else {
            var pos = this.stopPosition % this.symbolList.length;
            while (firstResponseSymbols.length < this.customDistance) {
                firstResponseSymbols.push(this.symbolList[pos]);
                pos--;
                pos += this.symbolList.length;
                pos %= this.symbolList.length
            }
        }
        if (this.customDistanceSymbols.length == 0)
            if (this.lastSymbolsEntered[this.lastSymbolsEntered.length - 1] == firstResponseSymbols[0]) return true;
        for (var i = 0; i < this.lastSymbolsEntered.length; i++)
            if (this.customDistanceSymbols.indexOf(this.lastSymbolsEntered[i]) != -1)
                for (var j = 0; j <= i; j++)
                    if (this.lastSymbolsEntered[i] ==
                        firstResponseSymbols[j]) return true
    }
    if (this.symbolStacksSettings.length > 0) {
        var screenSymbols = [];
        if (this.reelsManager.stopOnScreenSymbols || this.reelsManager.forceStopOnScreenSymbols) screenSymbols = this.GetReelScreenSymbols(XT.GetObject(Vars.ResultScreenSymbols));
        else if (this.reelsManager.stopOnInitialScreenSymbols) screenSymbols = this.GetReelScreenSymbols(XT.GetObject(Vars.InitialResultScreenSymbols));
        else {
            var pos = this.stopPosition % this.symbolList.length;
            while (screenSymbols.length < this.customDistance) {
                screenSymbols.push(this.symbolList[pos]);
                pos--;
                pos += this.symbolList.length;
                pos %= this.symbolList.length
            }
        }
        for (var i = 0; i < this.symbolStacksSettings.length; i++) {
            var stackMatch = true;
            for (var j = 0; j < this.lastStackEntered.length; j++)
                if (!this.symbolStacksSettings[i].IsPartOfStack(this.lastStackEntered[j])) {
                    stackMatch = false;
                    break
                }
            if (stackMatch) {
                var stackOnBottomScreen = 0;
                for (var k = 0; k < screenSymbols.length; k++)
                    if (this.symbolStacksSettings[i].IsPartOfStack(screenSymbols[k])) stackOnBottomScreen++;
                    else break;
                if (this.symbolStacksSettings[i].hasFixedSize &&
                    (this.lastStackEntered.length + stackOnBottomScreen) % this.symbolStacksSettings[i].stackSize != 0) return true;
                if (this.lastStackEntered.length + stackOnBottomScreen < this.symbolStacksSettings[i].stackSize) return true
            }
        }
    }
    return false
};

function SymbolStack() {
    this.stackedSymbolIDs = [];
    this.stackSize = 1;
    this.hasFixedSize = false
}
SymbolStack.prototype.IsPartOfStack = function(sID) {
    return this.stackedSymbolIDs.indexOf(sID) != -1
};
goog.require("UHT.XTLink");
goog.require("UHT.VS_Reel");
goog.provide("UHT.VS_ReelsManager");
VS_ReelsManager.prototype = Object.create(XTLink.prototype);
VS_ReelsManager.prototype.constructor = VS_ReelsManager;

function SpinAnimationsSpeedCurves() {
    this.startNormal = null;
    this.startFS = null;
    this.stopNormal = null;
    this.stopFS = null;
    this.stopCustom = null;
    this.stopExcitedNormal = null;
    this.stopExcitedFS = null;
    this.excitedNormal = null;
    this.excitedFS = null;
    this.excitedCustom = null
}

function VS_ReelsManager() {
    XTLink.call(this);
    this.symbolsManager = null;
    this.reels = [];
    this.reelsStartOrder = null;
    this.reelsStopOrder = null;
    this.reelDelayStart = .1;
    this.reelDelayStop = .15;
    this.extraReelDelayStop = null;
    this.extraReelDelayStart = null;
    this.validateReelSpin = [];
    this.autoStopDelay = 1.5;
    this.stopOnScreenSymbols = true;
    this.stopOnInitialScreenSymbols = false;
    this.forceStopOnScreenSymbols = false;
    this.instantStop = false;
    this.startFasterInFastPlay = false;
    this.startFasterForced = false;
    this.isFastStart = false;
    this.useCustomSpinCurves =
        null;
    this.autoStopTimer = 0;
    this.reelsSpinning = 0;
    this.startTimer = 0;
    this.reelToStart = 0;
    this.stopTimer = 0;
    this.reelToStop = 0;
    this.fastStop = false;
    this.rememberToStop = false;
    this.resultReceived = false;
    this.isStoppingFast = false;
    this.mustStopStoppingReels = false;
    this.reelIdxList = [];
    this.exciter = null;
    this.nextReels = [];
    this.fastStopTimers = null;
    this.fastStopTimeUntilFinish = 0;
    this.showTopBottomSymbols = false;
    this.justVisualSymbols = 0;
    this.blankSymbolId = 0;
    this.dragSettings = null;
    this.continuousSpinTimer = 0;
    this.logicIsFS =
        false;
    this.state = VS_ReelsManager.State.IDLE;
    this.spinCurves = null
}
VS_ReelsManager.prototype.scriptUpdatePriority = 3;
VS_ReelsManager.State = {
    IDLE: 0,
    STARTING: 1,
    SPINNING: 2,
    STOPPING: 3
};
VS_ReelsManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.ReelSymbols, this.OnReelSymbols, this);
    XT.RegisterCallbackObject(Vars.NextReelSymbols, this.OnNextReelSymbols, this);
    XT.RegisterCallbackObject(Vars.ReelInitialPositions, this.OnReelPositions, this);
    XT.RegisterCallbackObject(Vars.ExcitedImportantSymbols, this.OnExcitedImportantSymbols, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Init_ReelsManager, this.OnReelsManagerInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted,
        this.OnStartSpin, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelManager_StopSpin, this.OnStopSpin, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_SpinResultReceived, this.OnSpinResultReceived, this);
    XT.RegisterCallbackBool(Vars.AllowFastStop, this.SetAllowFastStop, this)
};
VS_ReelsManager.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.ReelsManagerObject, this);
    XT.SetObject(Vars.ReelsStartOrder, this.reelsStartOrder);
    XT.SetObject(Vars.ReelsStartOrderDefault, this.reelsStartOrder);
    XT.SetObject(Vars.ReelsStopOrder, this.reelsStopOrder);
    XT.SetObject(Vars.ReelsStopOrderDefault, this.reelsStopOrder);
    XT.SetObject(Vars.ExtraReelDelayStop, this.extraReelDelayStop);
    XT.SetObject(Vars.ExtraReelDelayStopDefault, this.extraReelDelayStop);
    XT.SetObject(Vars.ExtraReelDelayStart,
        this.extraReelDelayStart);
    XT.SetObject(Vars.ExtraReelDelayStartDefault, this.extraReelDelayStart);
    XT.SetBool(Vars.ContinuousSpin, false);
    XT.SetBool(Vars.AllowContinuousSpin, true);
    XT.SetBool(Vars.ForceContinuousSpin, false);
    XT.SetBool(Vars.AutoplayContinuousSpin, false);
    XT.SetBool(Vars.CanUpdateLinkedLoopersPosition, true);
    if (this.useCustomSpinCurves == null || this.useCustomSpinCurves.length == 0) this.useCustomSpinCurves = _array.create(this.reels.length, false);
    var reelsCanBeExcited = _array.create(this.reels.length,
        true);
    XT.SetObject(Vars.ReelsCanBeExcited, reelsCanBeExcited);
    this.PrepareVariables()
};
VS_ReelsManager.prototype.PrepareVariables = function() {
    var i = 0;
    if (this.reelsStartOrder.length < this.reels.length) {
        this.reelsStartOrder = _array.create(this.reels.length, 0);
        for (i = 0; i < this.reelsStartOrder.length; i++) this.reelsStartOrder[i] = i;
        XT.SetObject(Vars.ReelsStartOrder, this.reelsStartOrder);
        XT.SetObject(Vars.ReelsStartOrderDefault, this.reelsStartOrder)
    }
    if (this.reelsStopOrder.length < this.reels.length) {
        this.reelsStopOrder = _array.create(this.reels.length, 0);
        for (i = 0; i < this.reelsStopOrder.length; i++) this.reelsStopOrder[i] =
            i;
        XT.SetObject(Vars.ReelsStopOrder, this.reelsStopOrder);
        XT.SetObject(Vars.ReelsStopOrderDefault, this.reelsStopOrder)
    }
    if (this.extraReelDelayStop.length < this.reels.length) {
        this.extraReelDelayStop = _array.create(this.reels.length, 0);
        for (i = 0; i < this.extraReelDelayStop.length; i++) this.extraReelDelayStop[i] = 0;
        XT.SetObject(Vars.ExtraReelDelayStop, this.extraReelDelayStop);
        XT.SetObject(Vars.ExtraReelDelayStopDefault, this.extraReelDelayStop)
    }
    if (this.extraReelDelayStart.length < this.reels.length) {
        this.extraReelDelayStart =
            _array.create(this.reels.length, 0);
        for (i = 0; i < this.extraReelDelayStart.length; i++) this.extraReelDelayStart[i] = 0;
        XT.SetObject(Vars.ExtraReelDelayStart, this.extraReelDelayStart);
        XT.SetObject(Vars.ExtraReelDelayStartDefault, this.extraReelDelayStart)
    }
    if (this.validateReelSpin.length < this.reels.length) {
        this.validateReelSpin = _array.create(this.reels.length);
        for (i = 0; i < this.validateReelSpin.length; i++) this.validateReelSpin[i] = true
    }
};
VS_ReelsManager.prototype.OnReelsManagerInit = function() {
    if (XT.GetBool(Vars.HiddenMathematics))
        if (!this.stopOnScreenSymbols) this.stopOnInitialScreenSymbols = true;
    for (var i = 0; i < this.reels.length; i++) {
        this.reels[i].reelsManager = this;
        this.reels[i].reelIndex = i;
        this.reels[i].InitReel()
    }
    this.InitFirstScreenSymbols();
    this.BuildOrderedHoldersList();
    this.SetAllSymbolsToNormal();
    if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins) && this.reels.length == 3) this.autoStopDelay = Math.max(this.autoStopDelay,
        XT.GetFloat(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins_Value) - (this.reels.length - 1) * this.reelDelayStop)
};
VS_ReelsManager.prototype.OnReelSymbols = function(rsList) {
    for (var i = 0; i < this.reels.length; i++) this.reels[i].SetSymbolList(rsList[i]);
    this.exciter = XT.GetObject(Vars.SpinExciterObject)
};
VS_ReelsManager.prototype.OnNextReelSymbols = function(rsList) {
    this.nextReels = [];
    for (var i = 0; i < rsList.length; i++) this.nextReels.push(rsList[i])
};
VS_ReelsManager.prototype.OnReelPositions = function(rpList) {
    for (var i = 0; i < this.reels.length; i++) this.reels[i].SetPosition(rpList[i])
};
VS_ReelsManager.prototype.OnExcitedImportantSymbols = function(excitedImportantSymbols) {
    for (var i = 0; i < this.reels.length; i++) this.reels[i].ExcitedImportantSymbols = excitedImportantSymbols[i]
};
VS_ReelsManager.prototype.OnSpinResultReceived = function() {
    this.forceStopOnScreenSymbols = XT.GetBool(Vars.IsNoMoneySpin);
    var rspList = XT.GetObject(Vars.ReelStopPositions);
    if (rspList != null) {
        this.resultReceived = true;
        for (var i = 0; i < this.reels.length; i++) this.reels[i].SetStopPosition(rspList[i])
    }
};
VS_ReelsManager.prototype.InitFirstScreenSymbols = function() {
    var fssList = XT.GetObject(Vars.FirstScreenSymbols);
    if (this.justVisualSymbols == 1)
        for (var fssIndex = 0; fssIndex < fssList.length; fssIndex++) {
            var visualSymbolId = fssList[fssIndex][0] != this.blankSymbolId ? this.blankSymbolId : this.blankSymbolId - 1;
            fssList[fssIndex].unshift(visualSymbolId);
            fssList[fssIndex].push(visualSymbolId)
        }
    for (var ir = 0; ir < this.reels.length; ir++) this.reels[ir].SetScreenSymbols(fssList);
    this.BuildOrderedSymbolList()
};
VS_ReelsManager.prototype.SetAllSymbolsToNormal = function() {
    for (var rIndex = 0; rIndex < this.reels.length; rIndex++) this.reels[rIndex].SetSymbolsToNormal()
};
VS_ReelsManager.prototype.OnStartSpin = function() {
    if (this.state != VS_ReelsManager.State.IDLE) return;
    this.resultReceived = false;
    if (XT.GetBool(Vars.IsDifferentSpinType)) {
        XT.TriggerEvent(Vars.StartDifferentSpin);
        return
    }
    if (this.startFasterInFastPlay) this.isFastStart = this.IsFastPlayOn();
    if (this.startFasterForced) this.isFastStart = true;
    this.PrepareStart()
};
VS_ReelsManager.prototype.OnStopSpin = function() {
    this.isStoppingFast = true;
    this.fastStop = true;
    this.rememberToStop = true;
    this.mustStopStoppingReels = true
};
VS_ReelsManager.prototype.SetAllowFastStop = function(allow) {
    if (!allow) this.fastStop = false
};
VS_ReelsManager.prototype.PrepareStart = function() {
    var spinCounter = 0;
    for (var i = 0; i < this.validateReelSpin.length; i++)
        if (this.validateReelSpin[i]) spinCounter++;
    this.startTimer = this.reelDelayStart;
    if (this.IsFastPlayOn() || XT.GetBool(Vars.ContinuousSpin) || this.startFasterForced) this.startTimer = this.reelDelayStart * spinCounter;
    var currentStartOrder = XT.GetObject(Vars.ReelsStartOrder);
    if (XT.GetInt(Vars.ReelToBeSpun) == -1) {
        this.reelsSpinning = spinCounter;
        for (var i = 0; i < currentStartOrder.length; i++)
            if (this.validateReelSpin[currentStartOrder[i]]) {
                this.reelToStart =
                    currentStartOrder[i];
                break
            }
    } else {
        this.reelToStart = XT.GetInt(Vars.ReelToBeSpun);
        this.reelsSpinning = 1
    }
    this.autoStopTimer = 0;
    if (this.IsFastPlayOn() || this.startFasterForced) this.autoStopTimer = this.autoStopDelay;
    this.state = VS_ReelsManager.State.STARTING;
    if (this.nextReels.length > 0) XT.SetObject(Vars.ReelSymbols, this.nextReels);
    if (XT.GetBool(Vars.HiddenMathematics))
        for (var i = 0; i < this.reels.length; i++) this.reels[i].SetPosition(0);
    this.nextReels = [];
    this.isStoppingFast = false;
    this.rememberToStop = false;
    this.mustStopStoppingReels =
        false;
    this.fastStop = false;
    this.fastStopTimers = null;
    this.logicIsFS = XT.GetBool(Vars.Logic_IsFreeSpin)
};
VS_ReelsManager.prototype.PrepareStop = function() {
    this.stopTimer = this.reelDelayStop;
    if (this.IsFastPlayOn() || this.fastStop) this.stopTimer = this.reelDelayStop * this.reels.length;
    var currentStopOrder = XT.GetObject(Vars.ReelsStopOrder);
    if (XT.GetInt(Vars.ReelToBeSpun) == -1) {
        this.reelToStop = currentStopOrder[0];
        for (var i = 0; i < currentStopOrder.length; i++)
            if (this.validateReelSpin[currentStopOrder[i]]) {
                this.reelToStop = currentStopOrder[i];
                break
            }
    } else this.reelToStop = XT.GetInt(Vars.ReelToBeSpun);
    this.state = VS_ReelsManager.State.STOPPING
};
VS_ReelsManager.prototype.Start = function() {};
VS_ReelsManager.prototype.Init = function() {};
VS_ReelsManager.prototype.CheckAndSetContinuousSpin = function() {
    if (XT.GetBool(Vars.ForceContinuousSpin))
        if (!Input.GetMouseButton(0))
            if (XT.GetInt(Vars.AutoplaySpinsLeft) < 0) XT.SetBool(Vars.ForceContinuousSpin, false);
    var turboKeyDown = Input.GetKey(KeyCode.Space) || Input.GetKey(KeyCode.Return);
    var autoplayTurbo = XT.GetBool(Vars.AutoplayContinuousSpin) && XT.GetInt(Vars.AutoplaySpinsLeft) >= 0;
    if (!Globals.InputBlocked && XT.GetBool(Vars.AllowContinuousSpin) && (turboKeyDown || XT.GetBool(Vars.ForceContinuousSpin) ||
            autoplayTurbo)) {
        this.continuousSpinTimer += Time.deltaTime;
        if (this.continuousSpinTimer > .8 || XT.GetBool(Vars.ForceContinuousSpin) || XT.GetBool(Vars.AutoplayContinuousSpin) && XT.GetInt(Vars.AutoplaySpinsLeft) >= 0)
            if (!XT.GetBool(Vars.Jurisdiction_DisableContinousSpin)) XT.SetBool(Vars.ContinuousSpin, true)
    } else {
        XT.SetBool(Vars.ContinuousSpin, false);
        this.continuousSpinTimer = 0
    }
};
VS_ReelsManager.prototype.Update = function() {
    XT.SetFloat(Vars.SpinDuration, XT.GetFloat(Vars.SpinDuration) + Time.deltaTime);
    this.CheckAndSetContinuousSpin();
    if (this.state == VS_ReelsManager.State.SPINNING) {
        this.autoStopTimer += Time.deltaTime;
        if (this.autoStopTimer > this.autoStopDelay && this.resultReceived && !XT.GetBool(Vars.KeepSpinning)) {
            this.PrepareStop();
            this.autoStopTimer = 0
        }
    }
    if (this.state == VS_ReelsManager.State.SPINNING && this.resultReceived && !XT.GetBool(Vars.KeepSpinning))
        if (this.rememberToStop) this.PrepareStop();
    if (this.state == VS_ReelsManager.State.STARTING) {
        this.startTimer += Time.deltaTime;
        this.reelIdxList = [];
        var currentExtraDelayStart = XT.GetObject(Vars.ExtraReelDelayStart);
        var reelToStartIndex = this.GetIndexOfReelToStart(this.reelToStart);
        while (this.startTimer > this.reelDelayStart + currentExtraDelayStart[reelToStartIndex]) {
            this.startTimer -= this.reelDelayStart + currentExtraDelayStart[reelToStartIndex];
            if (this.logicIsFS) this.reels[this.reelToStart].SetSpeedCurve(this.spinCurves.startFS);
            else this.reels[this.reelToStart].SetSpeedCurve(this.spinCurves.startNormal);
            if (this.ShouldSpinReel() && this.validateReelSpin[this.reelToStart]) {
                this.reels[this.reelToStart].StartSpin();
                this.reelIdxList.push(this.reelToStart)
            }
            var currentStartOrder = XT.GetObject(Vars.ReelsStartOrder);
            var shouldGoToSpinning = true;
            for (var i = reelToStartIndex + 1; i < currentStartOrder.length; i++)
                if (this.validateReelSpin[currentStartOrder[i]]) {
                    this.reelToStart = currentStartOrder[i];
                    reelToStartIndex = this.GetIndexOfReelToStart(this.reelToStart);
                    shouldGoToSpinning = false;
                    break
                }
            if (shouldGoToSpinning || XT.GetInt(Vars.ReelToBeSpun) !=
                -1) {
                this.state = VS_ReelsManager.State.SPINNING;
                break
            }
        }
        if (this.reelIdxList.length > 0) {
            XT.SetObject(Vars.LastStartedReelIndices, this.reelIdxList);
            XT.TriggerEvent(Vars.Evt_Internal_ReelStarted)
        }
    }
    if (this.state == VS_ReelsManager.State.STOPPING && this.resultReceived) {
        this.reelIdxList = [];
        var currentExtraDelayStop = XT.GetObject(Vars.ExtraReelDelayStop);
        var currentStopOrder = XT.GetObject(Vars.ReelsStopOrder);
        var reelToStopIndex = this.GetIndexOfReelToStop(this.reelToStop);
        if (this.NeedToKeepReelSpinning(reelToStopIndex))
            if (this.stopTimer +
                Time.deltaTime <= this.reelDelayStop + currentExtraDelayStop[reelToStopIndex]) this.stopTimer += Time.deltaTime;
            else this.CanStop(this.reelToStop);
        else if (this.stopTimer + Time.deltaTime <= this.reelDelayStop + currentExtraDelayStop[reelToStopIndex] || this.CanStop(this.reelToStop)) this.stopTimer += Time.deltaTime;
        if (this.instantStop && this.mustStopStoppingReels) {
            for (var i = 0; i < reelToStopIndex; i++) {
                var idx = currentStopOrder[i];
                this.fastStopTimers = this.reels[idx].StopSpin(this.fastStop, this.fastStopTimers)
            }
            this.mustStopStoppingReels =
                false
        }
        while (this.stopTimer > this.reelDelayStop + currentExtraDelayStop[reelToStopIndex] || this.fastStop) {
            this.stopTimer -= this.reelDelayStop + currentExtraDelayStop[reelToStopIndex];
            if (this.reels[this.reelToStop].isExcited && !this.fastStop) {
                this.stopTimer -= this.exciter.extraStopDelayForNextReelOnExcite;
                if (this.logicIsFS) this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.stopExcitedFS);
                else this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.stopExcitedNormal)
            } else if (this.useCustomSpinCurves[this.reelToStop]) this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.stopCustom);
            else if (this.logicIsFS) this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.stopFS);
            else this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.stopNormal);
            this.fastStopTimers = this.reels[this.reelToStop].StopSpin(this.fastStop, this.fastStopTimers);
            this.reelIdxList.push(this.reelToStop);
            var shouldGoToIdle = true;
            for (var i = reelToStopIndex + 1; i < currentStopOrder.length; i++)
                if (this.validateReelSpin[currentStopOrder[i]]) {
                    this.reelToStop = currentStopOrder[i];
                    reelToStopIndex = this.GetIndexOfReelToStop(this.reelToStop);
                    shouldGoToIdle = false;
                    break
                }
            if (shouldGoToIdle || XT.GetInt(Vars.ReelToBeSpun) != -1) {
                this.state = VS_ReelsManager.State.IDLE;
                break
            }
            if (this.exciter != null && this.exciter.Excite(this.reelToStop)) {
                XT.SetInt(Vars.LastExcitedReelIndex, this.reelToStop);
                XT.TriggerEvent(Vars.Evt_Internal_ExcitedReel);
                this.stopTimer = -this.exciter.extraExciteTime;
                this.reels[this.reelToStop].isExcited = true;
                if (this.logicIsFS) this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.excitedFS);
                else this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.excitedNormal)
            } else if (this.useCustomSpinCurves[this.reelToStop]) this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.excitedCustom)
        }
        if (this.reelIdxList.length >
            0) {
            XT.SetObject(Vars.LastStoppedReelIndices, this.reelIdxList);
            XT.TriggerEvent(Vars.Evt_Internal_ReelStopStarted);
            for (var rsIndex = 0; rsIndex < this.reelIdxList.length; rsIndex++) this.reels[this.reelIdxList[rsIndex]].isExcited = false
        }
    }
};
VS_ReelsManager.prototype.NeedToKeepReelSpinning = function(iReelIdx) {
    var currentStopOrder = XT.GetObject(Vars.ReelsStopOrder);
    if (this.reels[currentStopOrder[iReelIdx]].NeedToKeepSpinning()) return true;
    return false
};
VS_ReelsManager.prototype.StopFinished = function(reelIdx) {
    if (this.exciter != null) this.exciter.ReelStopped(reelIdx, this.isStoppingFast);
    this.reelsSpinning--;
    XT.SetInt(Vars.LastStopEndedReelIndex, reelIdx);
    XT.TriggerEvent(Vars.Evt_Internal_ReelStopEnded);
    if (this.reelsSpinning == 0) {
        this.resultReceived = false;
        this.BuildOrderedSymbolList();
        XT.TriggerEvent(Vars.Evt_Internal_ReelManager_SpinEnded)
    }
};
VS_ReelsManager.prototype.BuildOrderedHoldersList = function() {
    var symbolIndex = 0;
    var numberOfReels = this.reels.length;
    var symbolsOnReels = this.reels[0].symbolHolders.length;
    var orderedHoldersList = [];
    for (var i = this.justVisualSymbols; i < symbolsOnReels; i++)
        for (var reelIndex = 0; reelIndex < numberOfReels; reelIndex++) {
            symbolIndex++;
            orderedHoldersList.push(this.reels[reelIndex].symbolHolders[i])
        }
    XT.SetObject(Vars.OrderedSymbolHoldersList, orderedHoldersList)
};
VS_ReelsManager.prototype.BuildOrderedSymbolList = function() {
    var symbolIndex = 0;
    var numberOfReels = this.reels.length;
    var symbolsOnReels = this.reels[0].symbolHolders.length;
    var orderedSymbolList = [];
    for (var i = 0; i < symbolsOnReels; i++)
        for (var reelIndex = 0; reelIndex < numberOfReels; reelIndex++) {
            symbolIndex++;
            orderedSymbolList.push(this.reels[reelIndex].symbolHolders[i].currentSymbol)
        }
    XT.SetObject(Vars.OrderedSymbolList, orderedSymbolList)
};
VS_ReelsManager.prototype.IsFastPlayOn = function() {
    return XT.GetBool(Vars.FastPlay)
};
VS_ReelsManager.prototype.GetIndexOfReelToStop = function(_reelToStop) {
    var currentStopOrder = XT.GetObject(Vars.ReelsStopOrder);
    var reelToStopIndex = -1;
    for (var j = 0; j < currentStopOrder.length; j++)
        if (_reelToStop == currentStopOrder[j]) reelToStopIndex = j;
    return reelToStopIndex
};
VS_ReelsManager.prototype.GetIndexOfReelToStart = function(_reelToStart) {
    var currentStartOrder = XT.GetObject(Vars.ReelsStartOrder);
    var reelToStartIndex = -1;
    for (var j = 0; j < currentStartOrder.length; j++)
        if (_reelToStart == currentStartOrder[j]) reelToStartIndex = j;
    return reelToStartIndex
};
VS_ReelsManager.prototype.ShouldSpinReel = function() {
    if (XT.GetInt(Vars.ReelToBeSpun) != -1)
        if (this.reelToStart == XT.GetInt(Vars.ReelToBeSpun)) return true;
        else return false;
    return true
};
VS_ReelsManager.prototype.CanStop = function(reelIndex) {
    return true
};
VS_ReelsManager.prototype.ChangeReelNumberOfReelSpinning = function(counter) {
    this.reelsSpinning = counter
};
goog.provide("UHT.LineInfo");

function LineInfo() {
    this.isRightToLeft = false;
    this.symbolIndices = null
}
goog.provide("UHT.VS_LinesDefinitions");
goog.require("UHT.XTLink");
goog.require("UHT.LineInfo");
VS_LinesDefinitions.prototype = Object.create(XTLink.prototype);
VS_LinesDefinitions.prototype.constructor = VS_LinesDefinitions;

function VS_LinesDefinitions() {
    XTLink.call(this);
    this.reels = 5;
    this.symbols = 3;
    this.symbolSquares = null;
    this.lines = null
}
VS_LinesDefinitions.prototype.XTRegisterCallbacks = function() {};
VS_LinesDefinitions.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.LinesDefinitionsObject, this)
};
goog.provide("UHT.VS_SpinExciter");
goog.require("UHT.XTLink");
goog.require("UHT.VS_LinesDefinitions");
goog.require("UHT.System.Misc.Utils");

function SubstitutingIDs() {
    this.realID = 0;
    this.substituteIDs = []
}
var SpecialSymbolPayType = {
    Everywhere: 0,
    OnActivePayline: 1,
    OnActivePaylineLeftToRight: 2
};
var ScatterSymbolPayType = {
    Nowhere: 0,
    Everywhere: 1,
    OnActivePayline: 2,
    OnActivePaylineLeftToRight: 3,
    OnAdjacentReelsBothWays: 4
};
var ScreenSymbolsToUse = {
    initialScreenSymbols: 0,
    finalScreenSymbols: 1,
    customScreenSymbols: 2
};

function WinLineInfo() {
    this.Id = 0;
    this.Positions = null;
    this.dominatingSymbol = 0;
    this.containsWild = false
}
VS_SpinExciter.prototype = Object.create(XTLink.prototype);
VS_SpinExciter.prototype.constructor = VS_SpinExciter;

function VS_SpinExciter() {
    XTLink.call(this);
    this.symbolList = [];
    this.allReelsSymbolList = [];
    this.PossibleWinCombo = null;
    this.AccumulatedPossibleWin = null;
    this.PossibleWinComboSymbols = null;
    this.StillPossibleWinComboPerSymbol = null;
    this.PossibleWinComboBonus = null;
    this.PossibleWinComboScatter = null;
    this.ActualWinCombo = null;
    this.ActualWinComboBonus = null;
    this.ActualWinComboScatter = null;
    this.StillPossibleWinComboBonus = null;
    this.StillPossibleWinComboScatter = null;
    this.StillPossibleWinComboWild = null;
    this.ShouldAnimateBonus =
        null;
    this.ShouldAnimateScatter = null;
    this.ExcitedImportantSymbols = null;
    this.symbolPaying = null;
    this.exciteOn = ScreenSymbolsToUse.finalScreenSymbols;
    this.symbolExciting = null;
    this.canHighlightOff = null;
    this.extraScatters = null;
    this.extraWilds = null;
    this.symbolIDSubstitutes = [];
    this.BonusPays = SpecialSymbolPayType.Everywhere;
    this.BonusMinCombo = 3;
    this.exciteForBonusSymbols = true;
    this.forceBonusOnReels = [];
    this.forceScattersOnReels = [];
    this.WildSubstitutesScatter = false;
    this.ScatterExcites = false;
    this.ScatterMustBeStacked =
        false;
    this.ScatterIsStacked = false;
    this.ScatterPays = SpecialSymbolPayType.Everywhere;
    this.ScatterMinCombo = 3;
    this.ScatterMinComboToAnimate = -1;
    this.ScatterMinComboFreeSpins = -1;
    this.ScatterMinComboFreeSpinsToAnimate = -1;
    this.exciteForScatterSymbols = true;
    this.MysteryScatterMinCombo = 3;
    this.ScatterPaysMoney = ScatterSymbolPayType.Nowhere;
    this.ScatterPaysMoneyMinCombo = 3;
    this.extraExciteTime = 1.5;
    this.extraStopDelayForNextReelOnExcite = 0;
    this.betLines = null;
    this.betLinesServer = [];
    this.linesDef = null;
    this.reelsManager =
        null;
    this.firstExcitedReel = 2;
    this.hasLoopExciteImportant = false;
    this.payoutThreshold = 3;
    this.payoutData = null
}
VS_SpinExciter.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.FirstScreenSymbols, this.OnFirstScreenSymbols, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytablePayoutUpdate, this.UpdateSymbolPayoutInformation, this);
    XT.RegisterCallbackObject(Vars.ReelSymbols, this.OnReelSymbols, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_SpinResultReceived, this.ComputeBetLinesFromServer, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_BonusResponseReceived, this.ComputeBetLinesFromServer,
        this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_InitReceived, this.ComputeBetLinesFromServer, this);
    switch (this.exciteOn) {
        case ScreenSymbolsToUse.initialScreenSymbols:
            XT.RegisterCallbackObject(Vars.InitialResultScreenSymbols, this.OnScreenSymbols, this);
            break;
        case ScreenSymbolsToUse.finalScreenSymbols:
            XT.RegisterCallbackObject(Vars.ResultScreenSymbols, this.OnScreenSymbols, this);
            break;
        case ScreenSymbolsToUse.customScreenSymbols:
            XT.RegisterCallbackObject(Vars.CustomResultScreenSymbols, this.OnScreenSymbols,
                this);
            break
    }
};
VS_SpinExciter.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.SpinExciterObject, this);
    XT.SetObject(Vars.ExtraScatters, this.extraScatters);
    XT.SetObject(Vars.AdditionalBonusScatters, null)
};
VS_SpinExciter.prototype.OnReelSymbols = function(rs) {
    this.allReelsSymbolList = [];
    for (var i = 0; i < rs.length; i++) this.allReelsSymbolList.push(rs[i])
};
VS_SpinExciter.prototype.SymbolsPresentAnywhereOnReel = function(symbol, reel) {
    var ret = 0;
    for (var i = 0; i < this.allReelsSymbolList[reel].length; i++)
        if (this.IsSameID(symbol, this.allReelsSymbolList[reel][i])) ret++;
    if (ret == 0 && this.forceBonusOnReels.length > reel && this.forceBonusOnReels[reel]) ret++;
    if (ret == 0 && this.forceScattersOnReels.length > reel && this.forceScattersOnReels[reel]) ret++;
    return ret
};
VS_SpinExciter.prototype.IsSameID = function(realID, substituteID) {
    if (realID == substituteID) return true;
    if (this.symbolIDSubstitutes != null)
        for (var i = 0; i < this.symbolIDSubstitutes.length; i++)
            if (this.symbolIDSubstitutes[i].realID == realID && this.symbolIDSubstitutes[i].substituteIDs.indexOf(substituteID) != -1) return true;
    return false
};
VS_SpinExciter.prototype.OnFirstScreenSymbols = function(_initialSymbols) {
    var initialSymbols = _initialSymbols;
    this.symbolList = [];
    for (var i = 0; i < initialSymbols.length; i++) this.symbolList.push([]);
    var reelsCount = this.symbolList.length;
    this.PossibleWinCombo = _array.create(reelsCount, false);
    this.AccumulatedPossibleWin = _array.create(reelsCount, false);
    this.PossibleWinComboSymbols = _array.create(reelsCount, false);
    this.PossibleWinComboBonus = _array.create(reelsCount, false);
    this.PossibleWinComboScatter = _array.create(reelsCount,
        false);
    this.ActualWinCombo = _array.create(reelsCount, false);
    this.ActualWinComboBonus = _array.create(reelsCount, false);
    this.ActualWinComboScatter = _array.create(reelsCount, false);
    this.StillPossibleWinComboBonus = _array.create(reelsCount, false);
    this.StillPossibleWinComboScatter = _array.create(reelsCount, false);
    this.StillPossibleWinComboWild = _array.create(reelsCount, false);
    this.ShouldAnimateBonus = _array.create(reelsCount * initialSymbols[0].length, false);
    this.ShouldAnimateScatter = _array.create(reelsCount * initialSymbols[0].length,
        false);
    var symbols = XT.GetObject(Vars.SymbolsManagerObject).symbols;
    var maxSymbolId = -1;
    for (var i = 0; i < symbols.length; ++i)
        if (symbols[i].symbolId > maxSymbolId) maxSymbolId = symbols[i].symbolId;
    var symbolsCount = maxSymbolId + 1;
    this.ExcitedImportantSymbols = [];
    for (var i = 0; i < reelsCount; i++) this.ExcitedImportantSymbols.push(_array.create(symbolsCount, false));
    XT.SetObject(Vars.ExcitedImportantSymbols, this.ExcitedImportantSymbols);
    this.linesDef = XT.GetObject(Vars.LinesDefinitionsObject);
    this.reelsManager = XT.GetObject(Vars.ReelsManagerObject);
    this.StillPossibleWinComboPerSymbol = [];
    for (var i = 0; i < reelsCount; ++i) this.StillPossibleWinComboPerSymbol[i] = new Array(symbolsCount)
};
VS_SpinExciter.prototype.OnScreenSymbols = function(_resultSymbols) {
    var resultSymbols = _resultSymbols;
    for (var i = 0; i < resultSymbols.length; i++) {
        this.symbolList[i] = [];
        for (var j = 0; j < resultSymbols[i].length; j++) this.symbolList[i].push(resultSymbols[i][resultSymbols[i].length - 1 - j])
    }
    this.ResetPossibleWins();
    this.ComputePossibleWins();
    XT.TriggerEvent(Vars.Evt_Internal_ExciterComputeEnded)
};
VS_SpinExciter.prototype.UpdateSymbolPayoutInformation = function() {
    var pD = XT.GetObject(Vars.PaytablePayoutData);
    if (pD != null) this.payoutData = pD
};
VS_SpinExciter.prototype.ResetPossibleWins = function() {
    for (var i = 0; i < this.PossibleWinCombo.length; i++) {
        this.PossibleWinCombo[i] = false;
        this.AccumulatedPossibleWin[i] = 0;
        this.PossibleWinComboSymbols[i] = false;
        this.PossibleWinComboBonus[i] = false;
        this.PossibleWinComboScatter[i] = false;
        this.ActualWinCombo[i] = false;
        this.ActualWinComboBonus[i] = false;
        this.ActualWinComboScatter[i] = false;
        this.StillPossibleWinComboBonus[i] = false;
        this.StillPossibleWinComboScatter[i] = false;
        this.StillPossibleWinComboWild[i] = false
    }
    for (var i =
            0; i < this.StillPossibleWinComboPerSymbol.length; ++i)
        for (var j = 0; j < this.StillPossibleWinComboPerSymbol[i].length; j++) this.StillPossibleWinComboPerSymbol[i][j] = false;
    for (var i = 0; i < this.ShouldAnimateBonus.length; i++) this.ShouldAnimateBonus[i] = false;
    for (var i = 0; i < this.ShouldAnimateScatter.length; i++) this.ShouldAnimateScatter[i] = false;
    for (var i = 0; i < this.ExcitedImportantSymbols.length; i++)
        for (var j = 0; j < this.ExcitedImportantSymbols[i].length; j++) this.ExcitedImportantSymbols[i][j] = false
};
VS_SpinExciter.prototype.SymbolAppearencesOnReel = function(symbolId, reelidx) {
    var ret = 0;
    for (var i = 0; i < this.symbolList[reelidx].length; i++)
        if (this.IsSameID(symbolId, this.symbolList[reelidx][i])) ret++;
    var additionalBonusScatters = XT.GetObject(Vars.AdditionalBonusScatters);
    if (additionalBonusScatters != null)
        for (var i = 0; i < additionalBonusScatters[reelidx].length; i++)
            if (this.IsSameID(symbolId, additionalBonusScatters[reelidx][i])) ret++;
    return ret
};
VS_SpinExciter.prototype.GetSymbolFromReel = function(pos, reel, isForLines) {
    var symbol = this.symbolList[reel][pos];
    if (isForLines == false) {
        var additionalBonusScatters = XT.GetObject(Vars.AdditionalBonusScatters);
        if (additionalBonusScatters != null && additionalBonusScatters[reel][pos] >= 0) symbol = additionalBonusScatters[reel][pos]
    }
    return symbol
};
VS_SpinExciter.prototype.ComputePossibleWins = function() {
    var lines = XT.GetInt(Vars.Lines);
    var reels = this.symbolList.length;
    this.betLines = _array.create(lines, null);
    for (var i = 0; i < lines; i++) {
        this.betLines[i] = new WinLineInfo;
        this.betLines[i].Id = i + 1;
        this.betLines[i].Positions = _array.create(reels, 0);
        this.betLines[i].containsWild = false;
        for (var j = 0; j < reels; j++) this.betLines[i].Positions[j] = this.linesDef.lines[i].symbolIndices[j]
    }
    if (this.BonusPays == SpecialSymbolPayType.Everywhere) {
        var bonuses = 0;
        for (var i = 0; i <
            reels; i++) {
            var moreBonusesPossible = false;
            var possibleBonuses = 0;
            var bonusIsOnReel = false;
            for (var j = i; j < reels; j++)
                if (this.SymbolsPresentAnywhereOnReel(0, j) > 0) {
                    moreBonusesPossible = true;
                    if (j != i) possibleBonuses++;
                    else bonusIsOnReel = true
                }
            if (i > 1 && bonuses >= this.BonusMinCombo - 1 && moreBonusesPossible && bonusIsOnReel) {
                this.PossibleWinCombo[i] = true;
                this.PossibleWinComboBonus[i] = true
            }
            bonuses += this.SymbolAppearencesOnReel(0, i);
            if (bonuses >= this.BonusMinCombo) {
                this.ActualWinCombo[i] = true;
                this.ActualWinComboBonus[i] =
                    true
            }
            if (bonuses + possibleBonuses >= this.BonusMinCombo) this.StillPossibleWinComboBonus[i] = true
        }
        if (bonuses >= this.BonusMinCombo)
            for (var i = 0; i < this.ShouldAnimateBonus.length; i++) this.ShouldAnimateBonus[i] = true
    }
    if (this.BonusPays == SpecialSymbolPayType.OnActivePayline || this.BonusPays == SpecialSymbolPayType.OnActivePaylineLeftToRight)
        for (var idx = 0; idx < this.betLines.length; ++idx) {
            var wli = this.betLines[idx];
            var bonuses = 0;
            for (var i = 0; i < wli.Positions.length; i++) {
                var moreBonusesPossible = false;
                var possibleBonuses =
                    0;
                var bonusIsOnReel = false;
                for (var j = i; j < wli.Positions.length; j++)
                    if (this.SymbolsPresentAnywhereOnReel(0, j) > 0) {
                        moreBonusesPossible = true;
                        if (j != i) possibleBonuses++;
                        else bonusIsOnReel = true
                    }
                var pos = wli.Positions[i];
                var reelIdx = pos % reels;
                var reelPosIdx = Math.floor(pos / reels);
                var symbol = this.GetSymbolFromReel(reelPosIdx, reelIdx, false);
                if (i > 1 && bonuses >= this.BonusMinCombo - 1 && moreBonusesPossible && bonusIsOnReel) {
                    this.PossibleWinCombo[i] = true;
                    this.PossibleWinComboBonus[i] = true
                }
                if (symbol == 0) bonuses++;
                else if (this.BonusPays ==
                    SpecialSymbolPayType.OnActivePaylineLeftToRight) break;
                if (bonuses >= this.BonusMinCombo) {
                    this.ActualWinCombo[i] = true;
                    this.ActualWinComboBonus[i] = true;
                    for (var j = 0; j <= i; j++) this.ShouldAnimateBonus[wli.Positions[j]] = true
                }
                if (bonuses + possibleBonuses >= this.BonusMinCombo) this.StillPossibleWinComboBonus[i] = true
            }
        }
    if (this.ScatterPays == SpecialSymbolPayType.Everywhere) {
        var scatters = 0;
        for (var i = 0; i < reels; i++) {
            var moreScattersPossible = false;
            var possibleScatters = 0;
            var scatterIsOnReel = false;
            for (var j = i; j < reels; j++)
                if (this.SymbolsPresentAnywhereOnReel(1,
                        j) > 0) {
                    moreScattersPossible = true;
                    if (j != i)
                        if (this.ScatterIsStacked) possibleScatters += this.symbolList[i].length;
                        else possibleScatters++;
                    else scatterIsOnReel = true
                }
            if (i > 1 && scatters >= this.ScatterMinCombo - 1 && moreScattersPossible && scatterIsOnReel) {
                this.PossibleWinCombo[i] = true;
                this.PossibleWinComboScatter[i] = true
            }
            if (this.ScatterMustBeStacked) scatters += this.SymbolAppearencesOnReel(1, i) == this.reelsManager.reels[i].symbolHolders.length ? 1 : 0;
            else {
                scatters += this.SymbolAppearencesOnReel(1, i);
                if (this.extraScatters !=
                    null && this.extraScatters.length > 0)
                    for (var esIndex = 0; esIndex < this.extraScatters.length; esIndex++) scatters += this.SymbolAppearencesOnReel(this.extraScatters[esIndex], i)
            }
            if (scatters >= this.ScatterMinCombo) {
                this.ActualWinCombo[i] = true;
                this.ActualWinComboScatter[i] = true
            }
            if (this.ScatterMustBeStacked) {
                if (scatters + possibleScatters >= this.GetScatterMinCombo() && this.SymbolAppearencesOnReel(1, i) == this.reelsManager.reels[i].symbolHolders.length) this.StillPossibleWinComboScatter[i] = true
            } else if (scatters + possibleScatters >=
                this.GetScatterMinCombo()) this.StillPossibleWinComboScatter[i] = true
        }
        if (scatters >= this.GetScatterMinCombo(true))
            for (var i = 0; i < this.ShouldAnimateScatter.length; i++) this.ShouldAnimateScatter[i] = true
    }
    if (this.ScatterPays == SpecialSymbolPayType.OnActivePayline || this.ScatterPays == SpecialSymbolPayType.OnActivePaylineLeftToRight)
        for (var idx = 0; idx < this.betLines.length; ++idx) {
            var wli = this.betLines[idx];
            var scatters = 0;
            for (var i = 0; i < wli.Positions.length; i++) {
                var moreScattersPossible = false;
                var possibleScatters =
                    0;
                var scatterIsOnReel = false;
                for (var j = i; j < wli.Positions.length; j++)
                    if (this.SymbolsPresentAnywhereOnReel(1, j) > 0) {
                        moreScattersPossible = true;
                        if (j != i) possibleScatters++;
                        else scatterIsOnReel = true
                    }
                var pos = wli.Positions[i];
                var reelIdx = pos % reels;
                var reelPosIdx = Math.floor(pos / reels);
                var symbol = this.GetSymbolFromReel(reelPosIdx, reelIdx, false);
                if (i > 1 && scatters >= this.ScatterMinCombo - 1 && moreScattersPossible && scatterIsOnReel) {
                    this.PossibleWinCombo[i] = true;
                    this.PossibleWinComboScatter[i] = true
                }
                if (symbol == 1 || symbol ==
                    2 && this.WildSubstitutesScatter) scatters++;
                else if (this.ScatterPays == SpecialSymbolPayType.OnActivePaylineLeftToRight) break;
                if (scatters >= this.GetScatterMinCombo(true)) {
                    this.ActualWinCombo[i] = true;
                    this.ActualWinComboScatter[i] = true;
                    for (var j = 0; j <= i; j++) this.ShouldAnimateScatter[wli.Positions[j]] = true
                }
                if (scatters + possibleScatters >= this.GetScatterMinCombo()) this.StillPossibleWinComboScatter[i] = true
            }
        }
    for (var idx = 0; idx < this.betLines.length; ++idx) {
        var wli = this.betLines[idx];
        var scatterIsWild = XT.GetBool(Vars.ScatterSymbolIsWild);
        var winningsymbol = 2;
        var actualwinningsymbol = -1;
        var leadingWilds = 0;
        for (var i = 0; i < wli.Positions.length; i++) {
            var pos = wli.Positions[i];
            var reelIdx = pos % reels;
            var reelPosIdx = Math.floor(pos / reels);
            var symbol = this.GetSymbolFromReel(reelPosIdx, reelIdx);
            if (actualwinningsymbol == -1) actualwinningsymbol = symbol;
            if (scatterIsWild)
                if (!this.SymbolIsWild(symbol) && symbol != 1)
                    if (symbol != winningsymbol && !this.SymbolIsWild(winningsymbol) && winningsymbol != 1 || symbol < 2) {
                        var newLength = i;
                        var newPos = _array.create(newLength, 0);
                        for (var j =
                                0; j < newLength; j++) newPos[j] = wli.Positions[j];
                        wli.Positions = newPos
                    } else {
                        winningsymbol = symbol;
                        actualwinningsymbol = symbol
                    }
            else this.StillPossibleWinComboWild[i] = true;
            else if (!this.SymbolIsWild(symbol))
                if (symbol != winningsymbol && !this.SymbolIsWild(winningsymbol) || symbol < 2) {
                    var newLength = i;
                    if (leadingWilds > 0)
                        if (this.payoutData[2][leadingWilds - 1] > this.payoutData[winningsymbol][newLength - 1]) {
                            newLength = leadingWilds;
                            winningsymbol = 2
                        }
                    var newPos = _array.create(newLength, 0);
                    for (var j = 0; j < newLength; j++) newPos[j] =
                        wli.Positions[j];
                    wli.Positions = newPos
                } else {
                    winningsymbol = symbol;
                    actualwinningsymbol = symbol
                }
            else {
                this.StillPossibleWinComboWild[i] = true;
                if (leadingWilds == i) leadingWilds++
            }
            if (!wli.containsWild) wli.containsWild = this.SymbolIsWild(symbol)
        }
        wli.dominatingSymbol = winningsymbol;
        if (actualwinningsymbol != -1) {
            var linelength = wli.Positions.length;
            for (var i = 0; i < linelength; i++) this.StillPossibleWinComboPerSymbol[i][actualwinningsymbol] = true
        }
        if (winningsymbol > (scatterIsWild ? 0 : 1))
            if (this.symbolExciting[winningsymbol] ||
                this.payoutThreshold > .001) {
                var linelength = wli.Positions.length;
                for (var i = 0; i < linelength; i++) this.ActualWinCombo[i] = true;
                if (linelength > reels - 1) linelength = reels - 1;
                for (var i = 0; i <= linelength; i++)
                    if (this.payoutData != null) this.AccumulatedPossibleWin[i] += this.payoutData[winningsymbol][i] * XT.GetDouble(Vars.CurrentWinMultiplier);
                for (var i = 0; i <= linelength; i++) {
                    this.PossibleWinCombo[i] = true;
                    this.PossibleWinComboSymbols[i] = true;
                    if (this.hasLoopExciteImportant) this.ExcitedImportantSymbols[i][winningsymbol] = true
                }
            }
    }
    this.SetWinComboSounds()
};
VS_SpinExciter.prototype.SetWinComboSounds = function() {
    XT.SetObject(Vars.PossibleWinComboSymbols, this.PossibleWinComboSymbols);
    XT.SetObject(Vars.StillPossibleWinComboPerSymbol, this.StillPossibleWinComboPerSymbol);
    XT.SetObject(Vars.StillPossibleWinComboBonus, this.StillPossibleWinComboBonus);
    XT.SetObject(Vars.StillPossibleWinComboScatter, this.StillPossibleWinComboScatter);
    XT.SetObject(Vars.StillPossibleWinComboWild, this.StillPossibleWinComboWild);
    XT.SetObject(Vars.ReelsWinInfo, this.ActualWinCombo)
};
VS_SpinExciter.prototype.Excite = function(reelToStop) {
    if (this.extraExciteTime < 0 || !XT.GetObject(Vars.ReelsCanBeExcited)[reelToStop]) return false;
    if (reelToStop >= this.firstExcitedReel) {
        if (this.PossibleWinComboScatter[reelToStop] && this.exciteForScatterSymbols || this.PossibleWinComboBonus[reelToStop] && this.exciteForBonusSymbols) return true;
        var enoughMoney = false;
        if (this.payoutData == null) enoughMoney = true;
        else {
            var lines = XT.GetInt(Vars.Lines);
            if (this.AccumulatedPossibleWin[reelToStop] >= this.payoutThreshold *
                lines) enoughMoney = true
        }
        if (this.PossibleWinCombo[reelToStop] && enoughMoney) return true
    }
    return false
};
VS_SpinExciter.prototype.CanHighlightOff = function(symbolId) {
    return this.canHighlightOff[symbolId]
};
VS_SpinExciter.prototype.UpdateSymbol = function(rsh, reelIdx, allowScatterExcite) {
    var symbolId = rsh.currentSymbol.symbolId;
    var scatterIsWild = XT.GetBool(Vars.ScatterSymbolIsWild);
    if (!this.CanHighlightOff(symbolId) && !(scatterIsWild && symbolId == 1)) return;
    if (symbolId == 1 && this.ScatterExcites && allowScatterExcite) {
        var foundWinningScatter = false;
        var foundExcitedScatter = reelIdx < this.reelsManager.reels.length - 1 && this.PossibleWinComboScatter[reelIdx + 1];
        for (var i = 0; i <= reelIdx; i++)
            if (this.ActualWinComboScatter[i]) foundWinningScatter =
                true;
        if (foundWinningScatter && foundExcitedScatter) rsh.currentSymbol.SetWinExcited();
        else if (foundWinningScatter) rsh.currentSymbol.SetWinning();
        else if (foundExcitedScatter) rsh.currentSymbol.SetExcited();
        else if (!this.CanHighlightOff(symbolId)) rsh.currentSymbol.SetNormal();
        else rsh.currentSymbol.SetHighlightOff();
        return
    }
    var orderedIdx = rsh.GetOrderedSymbolIdx();
    var maxLineLength = -1;
    for (var idx = 0; idx < this.betLines.length; ++idx) {
        var wli = this.betLines[idx];
        for (var k = 0; k < wli.Positions.length; k++)
            if (k <= reelIdx)
                if (wli.Positions[k] ==
                    orderedIdx)
                    if (maxLineLength < wli.Positions.length) maxLineLength = wli.Positions.length
    }
    var foundExcited = false;
    var foundWinning = false;
    if (maxLineLength >= this.firstExcitedReel)
        if (maxLineLength > reelIdx) foundExcited = true;
    if (maxLineLength >= this.symbolPaying[symbolId])
        if (reelIdx + 1 >= this.symbolPaying[symbolId]) foundWinning = true;
    if (foundWinning && foundExcited) rsh.currentSymbol.SetWinExcited();
    else if (foundWinning) rsh.currentSymbol.SetWinning();
    else if (foundExcited) rsh.currentSymbol.SetExcited();
    else if (!this.CanHighlightOff(symbolId) &&
        (scatterIsWild && symbolId == 1)) rsh.currentSymbol.SetNormal();
    else rsh.currentSymbol.SetHighlightOff()
};
VS_SpinExciter.prototype.ReelStopped = function(reelIdx, isStoppingFast) {
    if (isStoppingFast) return;
    if (reelIdx < this.firstExcitedReel - 1) return;
    var atLeastOneExcitedReel = false;
    var nextReelIdx = Math.min(reelIdx + 1, this.reelsManager.reels.length - 1);
    for (var i = 0; i <= nextReelIdx; i++)
        if (this.Excite(i) && this.PossibleWinComboSymbols[i]) atLeastOneExcitedReel = true;
    if (atLeastOneExcitedReel)
        for (var i = 0; i <= reelIdx; i++) {
            var reel = this.reelsManager.reels[i];
            for (var j = 0; j < reel.symbolHolders.length; j++) this.UpdateSymbol(reel.symbolHolders[j],
                reelIdx, false)
        }
    if (this.ScatterExcites)
        for (var i = 0; i <= reelIdx; i++) {
            var reel = this.reelsManager.reels[i];
            for (var j = 0; j < reel.symbolHolders.length; j++)
                if (reel.symbolHolders[j].currentSymbol.symbolId == 1) this.UpdateSymbol(reel.symbolHolders[j], reelIdx, true)
        }
};
VS_SpinExciter.prototype.GetScattersThatNeedToBeAnimated = function() {
    return this.ShouldAnimateScatter
};
VS_SpinExciter.prototype.GetBonusesThatNeedToBeAnimated = function() {
    return this.ShouldAnimateBonus
};
VS_SpinExciter.prototype.GetScatterMinCombo = function(toAnimate) {
    toAnimate = Boolean(toAnimate);
    if (XT.GetBool(Vars.Logic_IsFreeSpin))
        if (toAnimate && this.ScatterMinComboFreeSpinsToAnimate > 0) return this.ScatterMinComboFreeSpinsToAnimate;
        else if (this.ScatterMinComboFreeSpins > 0) return this.ScatterMinComboFreeSpins;
    if (toAnimate && this.ScatterMinComboToAnimate > 0) return this.ScatterMinComboToAnimate;
    return this.ScatterMinCombo
};
VS_SpinExciter.prototype.SymbolIsWild = function(id) {
    return id == 2 || this.extraWilds.indexOf(id) > -1
};
VS_SpinExciter.prototype.ComputeBetLinesFromServer = function() {
    this.betLinesServer.splice(0);
    var linesFromServer = XT.GetObject(Vars.ReceivedWinLines);
    if (linesFromServer == null) return;
    var reels = this.symbolList.length;
    var wild = 2;
    for (var i = 0; i < linesFromServer.length; i++) {
        var wli = new WinLineInfo;
        wli.Id = linesFromServer[i].LineNumber;
        wli.Positions = linesFromServer[i].WinPositions;
        wli.containsWild = false;
        var symbols = [];
        for (var j = 0; j < wli.Positions.length; ++j) {
            var symbol = this.GetSymbolFromReel(_number.otoi(wli.Positions[j] /
                reels), _number.otoi(wli.Positions[j] % reels));
            if (symbols.indexOf(symbol) < 0) symbols.push(symbol);
            if (this.SymbolIsWild(symbol)) {
                wild = symbol;
                wli.containsWild = true
            }
        }
        if (wli.containsWild) wli.dominatingSymbol = wild;
        for (var j = 0; j < symbols.length; ++j)
            if (!this.SymbolIsWild(symbols[j])) wli.dominatingSymbol = symbols[j];
        this.betLinesServer.push(wli)
    }
};
VS_SpinExciter.prototype.BetLinesFromServer = function(id) {
    for (var i = 0; i < this.betLinesServer.length; ++i)
        if (id == this.betLinesServer[i].Id) return this.betLinesServer[i];
    return null
};
goog.require("UHT.XTLink");

function ReelDragSettings() {
    this.isEnabled = false;
    this.percentageOfSymbolVisible = 0;
    this.isCustom = false;
    this.customLayer = null;
    this.customZ = 0
}
ReelDragController.prototype = Object.create(XTLink.prototype);
ReelDragController.prototype.constructor = ReelDragController;

function ReelDragController() {
    XTLink.call(this);
    this.reelId = -1;
    this.boxCollider = null;
    this.dragObject = null;
    this.animator = null;
    this.animatorReel = null;
    this.animationTime = 0;
    this.movementCurve = null;
    this.spinButtons = null;
    this.catDragStart = null;
    this.reelsManager = null;
    this.reel = null;
    this.reelLocalPos = null;
    this.reelOffset = null;
    this.prevPos = null;
    this.targetPos = null;
    this.minPos = null;
    this.maxPos = null;
    this.isEnabled = false;
    this.checkSpinButtonsActiveState = false;
    this.isDragStarted = false;
    this.extraVisible = 0;
    this.screenWidth = -69;
    this.screenHeight = -69;
    this.screenChangedFrame = -69;
    this.numberError = .001
}
ReelDragController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.ReelsManagerObject, this.OnReelsManagerObject, this)
};
ReelDragController.prototype.ScreenChanged = function() {
    if (!this.isEnabled) return;
    if (this.isDragStarted || this.animator.IsPlaying()) {
        this.animator.Stop();
        this.animatorReel.Stop();
        this.reel.transform.localPosition(this.reelLocalPos)
    }
    if (this.isDragStarted) this.dragObject.OnPress(false);
    this.boxCollider.enabled = false;
    this.screenWidth = UHTScreen.width;
    this.screenHeight = UHTScreen.height;
    this.screenChangedFrame = Time.frameCount
};
ReelDragController.prototype.OnReelsManagerObject = function(param) {
    this.reelsManager = param;
    if (!this.reelsManager.dragSettings.isEnabled) return;
    this.isEnabled = this.reelsManager.showTopBottomSymbols && this.reelId < this.reelsManager.reels.length && this.reelsManager.reels.length > 1;
    if (!this.isEnabled) return;
    this.reel = this.reelsManager.reels[this.reelId];
    this.isEnabled = this.isEnabled && this.reel.symbolHolders.length > 1;
    if (!this.isEnabled) return;
    this.dragObject.limitPosition = true;
    this.animatorReel.target = this.animatorReel.from =
        this.reel.gameObject;
    if (this.reelsManager.dragSettings.isCustom) {
        var pos = this.transform.localPosition();
        this.transform.localPosition(new UHTMath.Vector3(pos.x, pos.y, this.reelsManager.dragSettings.customZ));
        Globals.SetLayerRecursively(this.gameObject, this.reelsManager.dragSettings.customLayer.value())
    }
    this.UpdatePositionSizeAndDragLimits()
};
ReelDragController.prototype.UpdatePositionSizeAndDragLimits = function() {
    var tY = this.reel.symbolHolders[0].transform.position().y;
    var bY = this.reel.symbolHolders[this.reel.symbolHolders.length - 1].transform.position().y;
    var dY = tY - this.reel.symbolHolders[1].transform.position().y;
    var isFirst = this.reelId == 0;
    var isLast = this.reelId == this.reelsManager.reels.length - 1;
    var pos;
    var width;
    if (isFirst || isLast) {
        pos = new UHTMath.Vector3(this.reel.transform.position().x, (tY + bY) * .5, this.transform.position().z);
        width =
            isFirst ? this.reelsManager.reels[this.reelId + 1].transform.position().x - this.reel.transform.position().x : this.reel.transform.position().x - this.reelsManager.reels[this.reelId - 1].transform.position().x
    } else {
        var lX = this.reelsManager.reels[this.reelId - 1].transform.position().x;
        var rX = this.reelsManager.reels[this.reelId + 1].transform.position().x;
        pos = new UHTMath.Vector3((rX + lX) * .5, (tY + bY) * .5, this.transform.position().z);
        width = (rX - lX) * .5
    }
    this.prevPos = this.targetPos = this.transform.position(pos);
    this.reelOffset =
        UHTMath.Vector3.sub(this.reel.transform.position(), pos);
    this.reelLocalPos = this.reel.transform.localPosition();
    var size = this.TransformPoint(new UHTMath.Vector3(width, tY - bY + dY, 0));
    this.boxCollider.size = new UHTMath.Vector3(size.x, size.y, this.boxCollider.size.z);
    this.extraVisible = dY * this.reelsManager.dragSettings.percentageOfSymbolVisible;
    this.minPos = new UHTMath.Vector3(pos.x, pos.y - this.extraVisible, pos.z);
    this.maxPos = new UHTMath.Vector3(pos.x, pos.y + this.extraVisible, pos.z);
    this.dragObject.localPositionLimitMin =
        this.TransformPoint(this.minPos);
    this.dragObject.localPositionLimitMax = this.TransformPoint(this.maxPos)
};
ReelDragController.prototype.TransformPoint = function(point) {
    return this.transform.parent.inverseTransformPoint(point)
};
ReelDragController.prototype.DragStarted = function() {
    this.isDragStarted = true;
    this.catDragStart.Start();
    XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup)
};
ReelDragController.prototype.DragEnded = function() {
    this.isDragStarted = false;
    var pos = this.transform.position();
    if (this.VectorsEqual(this.targetPos, pos)) return;
    this.animator.manualTo = this.targetPos;
    this.animator.animationTime = this.animationTime * UHTMath.inverseLerp(0, this.extraVisible, Math.abs(pos.y - this.targetPos.y));
    this.animatorReel.manualTo = UHTMath.Vector3.add(this.targetPos, this.reelOffset);
    this.animatorReel.animationTime = this.animator.animationTime;
    if (this.boxCollider.enabled) {
        this.animator.Play();
        this.animatorReel.Play()
    } else {
        this.animator.Sample(1);
        this.animatorReel.Sample(1)
    }
};
ReelDragController.prototype.AnimationFinished = function() {
    if (!this.boxCollider.enabled) return;
    XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_Prepare);
    XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop)
};
ReelDragController.prototype.SpinButtonActiveStateChanged = function() {
    this.checkSpinButtonsActiveState = true
};
ReelDragController.prototype.LateUpdate = function() {
    if (!this.isEnabled) return;
    if (this.screenWidth != UHTScreen.width || this.screenHeight != UHTScreen.height) this.ScreenChanged();
    if (this.screenChangedFrame == Time.frameCount) return;
    if (this.screenChangedFrame + 1 == Time.frameCount) {
        this.UpdatePositionSizeAndDragLimits();
        this.checkSpinButtonsActiveState = true
    }
    if (this.checkSpinButtonsActiveState) {
        var isActive = false;
        for (var i = 0; i < this.spinButtons.length; ++i)
            if (this.spinButtons[i].activeInHierarchy) isActive = true;
        this.boxCollider.enabled =
            isActive;
        this.checkSpinButtonsActiveState = false;
        if (!isActive) this.dragObject.OnPress(false)
    }
    var pos = this.transform.position();
    if (this.isDragStarted && !this.VectorsEqual(this.prevPos, pos)) {
        var dY = pos.y - this.targetPos.y;
        var t = UHTMath.inverseLerp(0, this.extraVisible, Math.abs(dY));
        this.prevPos = pos;
        this.reel.transform.position(UHTMath.Vector3.add(UHTMath.Vector3.lerp(this.targetPos, dY > 0 ? this.maxPos : this.minPos, this.movementCurve.Evaluate(t)), this.reelOffset))
    }
};
ReelDragController.prototype.VectorsEqual = function(a, b) {
    return Math.abs(a.x - b.x) < this.numberError && Math.abs(a.y - b.y) < this.numberError && Math.abs(a.z - b.z) < this.numberError
};
goog.require("UHT.Engine");
MenuButton.prototype = Object.create(Component.prototype);
MenuButton.prototype.constructor = MenuButton;

function MenuButton() {
    Component.call(this);
    this.label = null;
    this.icon = null;
    this.button = null
}
MenuButton.prototype.UpdateValue = function(uil, uis) {
    this.label.text = uil.text;
    this.label.fontName = uil.fontName;
    this.label.Prepare();
    GUIArranger.I.CopySprite(uis, this.icon);
    GUIArranger.I.CopySpriteSize(uis, this.icon);
    var uibuttons = this.button.gameObject.GetComponents(UIButton);
    for (var i = 0; i < uibuttons.length; i++)
        if (uibuttons[i].target == this.icon) uibuttons[i].normal = uis.spriteName
};
goog.require("UHT.ArrangeableBase");
var MenuButtonType = {
    Invalid: 0,
    Lobby: 1,
    Tournament: 2,
    PrizeDrop: 3,
    Replay: 4
};

function MenuControllerTransform() {
    this.localPosition = null;
    this.localScale = null
}
MenuController.prototype = Object.create(ArrangeableBase.prototype);
MenuController.prototype.constructor = MenuController;

function MenuController() {
    ArrangeableBase.call(this);
    this.order = null;
    this.icons = null;
    this.labels = null;
    this.click = null;
    this.button = null;
    this.buttons = null;
    this.count = null;
    this.countArrangeable = null;
    this.countArrangementLandscape = null;
    this.countArrangementPortrait = null;
    this.collapse = null;
    this.isEnabled = null;
    this.isEnabledPrev = null;
    this.internalOrder = [];
    this.promotions = null;
    this.isCollapsed = true;
    this.isCollapsedChangedInFrame = -1;
    this.updateCountArrangement = false;
    this.countArrangement = null
}
MenuController.prototype.Awake = function() {
    ArrangeableBase.prototype.Awake.call(this);
    this.isEnabled = [];
    this.isEnabledPrev = [];
    for (var i = 0; i < this.order.length; ++i) {
        this.isEnabled[i] = false;
        this.isEnabledPrev[i] = true
    }
    this.UpdateButtons()
};
MenuController.prototype.LateUpdate = function() {
    if (this.updateCountArrangement) {
        this.updateCountArrangement = false;
        if (this.countArrangement != null && this.countArrangement.length > 0) {
            var arrangement = this.countArrangement[this.internalOrder.length];
            this.countArrangeable.localPosition(arrangement.localPosition);
            this.countArrangeable.localScale(arrangement.localScale)
        }
    }
};
MenuController.prototype.XTRegisterCallbacks = function() {
    ArrangeableBase.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackObject(TournamentVars.Tournaments, this.OnPromotions, this);
    XT.RegisterCallbackObject(LobbyVars.LobbyCategorySymbols, this.OnLobbyCategories, this);
    XT.RegisterCallbackBool(ReplayVars.Replay_WinningsEnabled, this.OnReplayWinningsEnabled, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_CodeToData_InterfaceWindowOpen, this.Collapse, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_DataToCode_CloseAllInterfaceWindows,
        this.OnCloseAllInterfaceWindows, this)
};
MenuController.prototype.OnSwitchToPortrait = function() {
    this.countArrangement = this.countArrangementPortrait;
    this.updateCountArrangement = true
};
MenuController.prototype.OnSwitchToLandscape = function() {
    this.countArrangement = this.countArrangementLandscape;
    this.updateCountArrangement = true
};
MenuController.prototype.OnCloseAllInterfaceWindows = function() {
    if (this.isCollapsedChangedInFrame < Time.frameCount) this.Collapse()
};
MenuController.prototype.OnPromotions = function(param) {
    this.promotions = param;
    this.isEnabled[this.order.indexOf(MenuButtonType.PrizeDrop)] = false;
    this.isEnabled[this.order.indexOf(MenuButtonType.Tournament)] = false;
    if (this.promotions == null || this.promotions.length == 0) {
        this.UpdateButtons();
        return
    }
    for (var i = 0; i < this.promotions.length; ++i)
        if (this.promotions[i].type == TournamentProtocol.PromoType.Race) this.isEnabled[this.order.indexOf(MenuButtonType.PrizeDrop)] = true;
        else if (this.promotions[i].type == TournamentProtocol.PromoType.Tournament) this.isEnabled[this.order.indexOf(MenuButtonType.Tournament)] =
        true;
    this.UpdateButtons()
};
MenuController.prototype.OnLobbyCategories = function(param) {
    var categories = param;
    if (categories == null || categories.length == 0) this.isEnabled[this.order.indexOf(MenuButtonType.Lobby)] = false;
    else this.isEnabled[this.order.indexOf(MenuButtonType.Lobby)] = true;
    this.UpdateButtons()
};
MenuController.prototype.OnReplayWinningsEnabled = function(param) {
    this.isEnabled[this.order.indexOf(MenuButtonType.Replay)] = param;
    this.UpdateButtons()
};
MenuController.prototype.UpdateButtons = function() {
    var needUpdate = false;
    for (var i = 0; i < this.isEnabled.length; ++i)
        if (this.isEnabledPrev[i] != this.isEnabled[i]) {
            needUpdate = true;
            this.isEnabledPrev[i] = this.isEnabled[i]
        }
    if (!needUpdate) return;
    this.internalOrder.splice(0);
    for (var i = 0; i < this.isEnabled.length; ++i)
        if (this.isEnabled[i]) this.internalOrder.push(this.order[i]);
    var buttonsCount = this.internalOrder.length;
    if (buttonsCount == 1)
        if (this.internalOrder[0] != MenuButtonType.Tournament && this.internalOrder[0] !=
            MenuButtonType.PrizeDrop) {
            var idx = this.order.indexOf(this.internalOrder[0]);
            this.button.UpdateValue(this.labels[idx], this.icons[idx])
        } else buttonsCount = 0;
    else
        for (var i = 0; i < this.internalOrder.length; ++i) {
            var idx = this.order.indexOf(this.internalOrder[i]);
            this.buttons[i].UpdateValue(this.labels[idx], this.icons[idx])
        }
    this.count[buttonsCount].Start();
    this.updateCountArrangement = true
};
MenuController.prototype.ButtonClicked = function(index) {
    var btnType = this.internalOrder[index];
    if (btnType == MenuButtonType.Tournament || btnType == MenuButtonType.PrizeDrop) {
        var curType = PromotionsHelper.GetPromotionType(XT.GetString(TournamentVars.SelectedTournamentID));
        var targetType = btnType == MenuButtonType.Tournament ? TournamentProtocol.PromoType.Tournament : TournamentProtocol.PromoType.Race;
        XT.SetInt(TournamentVars.MenuPromotionType, targetType);
        if (curType != targetType) this.SelectPromotionOfType(targetType)
    }
    if (btnType ==
        MenuButtonType.Lobby) XT.TriggerEvent(LobbyVars.Evt_DataToCode_ShowLobbyCategories);
    this.click[this.order.indexOf(btnType)].Start()
};
MenuController.prototype.SelectPromotionOfType = function(type) {
    if (this.promotions == null) return;
    for (var i = 0; i < this.promotions.length; ++i)
        if (this.promotions[i].type == type) {
            XT.SetString(TournamentVars.SelectedTournamentID, this.promotions[i].uid);
            break
        }
};
MenuController.prototype.Collapse = function() {
    if (!this.isCollapsed) this.collapse.Start()
};
MenuController.prototype.SetCollapsed = function(value) {
    this.isCollapsed = value;
    this.isCollapsedChangedInFrame = Time.frameCount
};
goog.require("UHT.ArrangeableBase");
DemoLabelPosition.prototype = Object.create(ArrangeableBase.prototype);
DemoLabelPosition.prototype.constructor = DemoLabelPosition;

function DemoLabelPosition() {
    ArrangeableBase.call(this);
    this.mobileLandscapeScale = new UHTMath.Vector3(1, 1, 1);
    this.mobilePortraitScale = new UHTMath.Vector3(1, 1, 1);
    this.defaultPosition = new UHTMath.Vector3(0, 0, 0);
    this.topBarReference = null;
    this.portraitOffSet = new UHTMath.Vector3(0, 0, 0);
    this.showDemoCAT = null
}
DemoLabelPosition.prototype.XTRegisterCallbacks = function() {
    if (this.useOnMobile && Globals.isMobile || this.useOnDesktop && !Globals.isMobile) {
        XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayout, this.OnSwitchToLandscape, this, 10);
        XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWide, this.OnSwitchToLandscapeWide, this, 10);
        XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWideFull, this.OnSwitchToLandscapeWideFull, this, 10);
        if (this.useOnMobile && Globals.isMobile) {
            XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayout,
                this.OnSwitchToPortrait, this, 10);
            XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPhone, this.OnSwitchToPortraitIPhone, this, 10);
            XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPad, this.OnSwitchToPortraitIPad, this, 10)
        }
    }
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
};
DemoLabelPosition.prototype.OnGameInit = function() {
    if (ServerOptions.isDemoMode) this.showDemoCAT.Start()
};
DemoLabelPosition.prototype.OnSwitchToPortrait = function() {
    this.transform.localScale(this.mobilePortraitScale);
    this.transform.position(this.topBarReference.transform.position());
    this.transform.localPosition(UHTMath.Vector3.add(this.transform.localPosition(), this.portraitOffSet))
};
DemoLabelPosition.prototype.OnSwitchToLandscape = function() {
    this.transform.localScale(this.mobileLandscapeScale);
    this.transform.position(this.defaultPosition)
};
goog.require("UHT.FOXLink");

function PayingSymbol() {
    this.id;
    this.amount;
    this.positions = []
}
var PayingSymbolVars = {
    PayingSymbols: "PayingSymbols",
    PayingSymbolIsScatter: "PayingSymbolIsScatter",
    PayingSymbolsScatterIndex: "PayingSymbolsScatterIndex",
    CurrentDisplayedPayingSymbolIndex: "CurrentDisplayedPayingSymbolIndex",
    Evt_Internal_ShowPayingSymbol: "Evt_Internal_ShowPayingSymbol",
    Evt_Internal_HidePayingSymbol: "Evt_Internal_HidePayingSymbol"
};
PayingSymbolFOX.prototype = Object.create(FOXLink.prototype);
PayingSymbolFOX.prototype.constructor = PayingSymbolFOX;

function PayingSymbolFOX() {
    FOXLink.call(this);
    this.payingSymbols = []
}
PayingSymbolFOX.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(PayingSymbolVars.PayingSymbols, this.payingSymbols)
};
PayingSymbolFOX.prototype.HandleResponse = function(dict) {
    this.payingSymbols.splice(0);
    var scatterIdx = -1;
    if (dict["psym"] != undefined) {
        var symbols = null;
        if (dict["s"] != undefined) symbols = _array.ConvertAll(dict["s"].split(","), _number.otoi);
        var args = dict["psym"].split(";");
        for (var i = 0; i < args.length; ++i) {
            var arg = args[i].split("~");
            if (arg.length > 1) {
                var s = new PayingSymbol;
                s.id = _number.otoi(arg[0]);
                s.amount = _number.otod(arg[1]);
                s.positions = arg.length > 2 ? _array.ConvertAll(arg[2].split(","), _number.otoi) : this.FindPositions(symbols,
                    s.id);
                this.payingSymbols.push(s);
                if (s.id == 1) scatterIdx = i
            }
        }
    }
    XT.SetInt(PayingSymbolVars.PayingSymbolsScatterIndex, scatterIdx);
    XT.SetBool(PayingSymbolVars.PayingSymbolIsScatter, this.payingSymbols.length == 1 && scatterIdx == 0)
};
PayingSymbolFOX.prototype.FindPositions = function(symbols, id) {
    var ret = [];
    if (symbols != null)
        for (var i = 0; i < symbols.length; ++i)
            if (symbols[i] == id) ret.push(i);
    return ret
};
PayingSymbolFOX.prototype.HandleInitResponse = function(param) {
    this.HandleResponse(param)
};
PayingSymbolFOX.prototype.HandleSpinResponse = function(param) {
    this.HandleResponse(param)
};
goog.require("UHT.FOXLink");
var DefaultStateVars = {
    DefaultSymbolsAbove: "DefaultSymbolsAbove",
    DefaultSymbolsBelow: "DefaultSymbolsBelow"
};
DefaultStateFOX.prototype = Object.create(FOXLink.prototype);
DefaultStateFOX.prototype.constructor = DefaultStateFOX;

function DefaultStateFOX() {
    FOXLink.call(this);
    this.initResponse = null
}
DefaultStateFOX.Keys = {
    symbols: "def_s",
    symbolsAbove: "def_sa",
    symbolsBelow: "def_sb",
    awardIndex: "def_aw",
    awardPosition: "def_aw_p"
};
DefaultStateFOX.prototype.XTRegisterCallbacks = function() {
    FOXLink.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_InitReceived, this.OnInitReceivedFromServer, this)
};
DefaultStateFOX.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(DefaultStateVars.DefaultSymbolsAbove, null);
    XT.SetObject(DefaultStateVars.DefaultSymbolsBelow, null)
};
DefaultStateFOX.prototype.HandleInitResponse = function(param) {
    this.initResponse = param
};
DefaultStateFOX.prototype.OnInitReceivedFromServer = function() {
    if (this.initResponse[DefaultStateFOX.Keys.symbols] != undefined) {
        var key = GameProtocolDictionary.winSymbols;
        GameProtocolDictionary.winSymbols = DefaultStateFOX.Keys.symbols;
        var symbols = VSProtocolParser.ParseWinScreenSymbols(this.initResponse, GameConnection.prototype.SlotHeight, GameProtocolDictionary.winSymbols);
        if (symbols.length > 0) XT.SetObject(Vars.InitialScreen, symbols);
        GameProtocolDictionary.winSymbols = key
    }
    if (this.initResponse[DefaultStateFOX.Keys.symbolsAbove] !=
        undefined) XT.SetObject(DefaultStateVars.DefaultSymbolsAbove, GameProtocolCommonParser.ParseIntList(this.initResponse, DefaultStateFOX.Keys.symbolsAbove));
    if (this.initResponse[DefaultStateFOX.Keys.symbolsBelow] != undefined) XT.SetObject(DefaultStateVars.DefaultSymbolsBelow, GameProtocolCommonParser.ParseIntList(this.initResponse, DefaultStateFOX.Keys.symbolsBelow));
    if (this.initResponse[DefaultStateFOX.Keys.awardIndex] != undefined || this.initResponse[DefaultStateFOX.Keys.awardPosition] != undefined) {
        var awardResponse =
            XT.GetObject(Vars.InitialRandomAward);
        if (awardResponse == null) {
            awardResponse = new RandomAwardsResponse;
            XT.SetObject(Vars.InitialRandomAward, awardResponse)
        }
        if (this.initResponse[DefaultStateFOX.Keys.awardIndex] != undefined) awardResponse.awardIndex = _number.otoi(this.initResponse[DefaultStateFOX.Keys.awardIndex]);
        if (this.initResponse[DefaultStateFOX.Keys.awardPosition] != undefined) awardResponse.awardPositionInReel = _number.otoi(this.initResponse[DefaultStateFOX.Keys.awardPosition])
    }
    this.initResponse = null
};
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
SB_JurisdictionCustomization.prototype = Object.create(XTLink.prototype);
SB_JurisdictionCustomization.prototype.constructor = SB_JurisdictionCustomization;

function SB_JurisdictionCustomization() {
    XTLink.call(this);
    this.disableQuickSpin = null;
    this.wasApplied = false;
    this.patchLabels = []
}
SB_JurisdictionCustomization.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins, this.OnDisableFastPlay, this);
    XT.RegisterCallbackBool(Vars.DisableFastPlay, this.OnDisableFastPlay, this);
    XT.RegisterCallbackBool(Vars.Jurisdiction_DisableAnteBet, this.OnDisableAnteBet, this)
};
SB_JurisdictionCustomization.prototype.OnDisableFastPlay = function(param) {
    var isActive = param;
    if (isActive && !this.wasApplied) {
        XT.RegisterCallbackBool(Vars.FastPlay, this.OnFastPlay, this);
        this.RemoveQuickSpinReferences();
        this.wasApplied = true
    }
};
SB_JurisdictionCustomization.prototype.OnFastPlay = function(param) {
    XT.SetBool(Vars.FastPlay, false)
};
SB_JurisdictionCustomization.prototype.RemoveQuickSpinReferences = function() {
    this.disableQuickSpin.Start()
};
SB_JurisdictionCustomization.prototype.OnDisableAnteBet = function(param) {
    if (param) {
        XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
        var paytable = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["Paytable"], true);
        if (paytable.length == 0) paytable = globalRuntime.sceneRoots[1].GetComponentsInChildren(window["Paytable_mobile"], true);
        if (paytable.length > 0) {
            var transforms = paytable[0].GetComponentsInChildren(Transform, true);
            for (var i = 0; i < transforms.length; i++)
                if (transforms[i].gameObject.name.indexOf("PreBetHolder") >
                    -1 || transforms[i].gameObject.name.indexOf("AnteBetHolder") > -1 || transforms[i].gameObject.name.indexOf("AnteHolder") > -1) {
                    transforms[i].gameObject.SetActive(false);
                    transforms[i].gameObject.name += "MMWillNeverFindMe"
                }
            var labels = paytable[0].GetComponentsInChildren(UILabel, true);
            for (var i = 0; i < labels.length; i++) {
                if (labels[i].text.toLowerCase().trim() == "ante bet") {
                    labels[i].gameObject.SetActive(false);
                    labels[i].gameObject.name += "MMWillNeverFindMe"
                }
                if (labels[i].text.toLowerCase().indexOf("ante bet") > -1 && labels[i].text.toLowerCase().indexOf("rtp") ==
                    -1) {
                    var sentences = labels[i].text.split(".");
                    if (sentences.length > 1) {
                        for (var j = 0; j < sentences.length; j++)
                            if (sentences[j].toLowerCase().indexOf("ante bet") > -1) {
                                if (labels[i].NOAB_sentenceToRemoveIndex == undefined) labels[i].NOAB_sentenceToRemoveIndex = [];
                                labels[i].NOAB_sentenceToRemoveIndex.push(j)
                            }
                        if (labels[i].NOAB_sentenceToRemoveIndex) {
                            labels[i].NOAB_sentencesCount = sentences.length;
                            this.patchLabels.push(labels[i])
                        }
                    }
                }
            }
        }
    }
};
SB_JurisdictionCustomization.prototype.OnGameInit = function() {
    for (var i = 0; i < this.patchLabels.length; i++) {
        var dotChars = [".", ""];
        for (var j = 0; j < dotChars.length; j++) {
            var sentences = this.patchLabels[i].text.split(dotChars[j]);
            if (sentences.length > 1 && sentences.length == this.patchLabels[i].NOAB_sentencesCount) {
                for (var k = this.patchLabels[i].NOAB_sentenceToRemoveIndex.length - 1; k >= 0; k--) sentences.splice(this.patchLabels[i].NOAB_sentenceToRemoveIndex[k], 1);
                this.patchLabels[i].text = sentences.join(dotChars[j]);
                break
            }
        }
    }
};
goog.require("UHT.XTLink");
JurisdictionGameSymbol.prototype = Object.create(XTLink.prototype);
JurisdictionGameSymbol.prototype.constructor = JurisdictionGameSymbol;

function JurisdictionGameSymbol() {
    XTLink.call(this);
    this.valueLabel = null;
    this.isActive = false
}
JurisdictionGameSymbol.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableOpen, this.OnPressedPaytableOpen, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableClose, this.OnPressedPaytableClose, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackBool(Vars.Jurisdiction_GameSymbol, this.OnJurisdictionInfoChanged, this)
};
JurisdictionGameSymbol.prototype.OnJurisdictionInfoChanged = function(param) {
    this.isActive = param
};
JurisdictionGameSymbol.prototype.OnPressedPaytableOpen = function() {
    if (this.isActive) this.gameObject.SetActive(true)
};
JurisdictionGameSymbol.prototype.OnPressedPaytableClose = function() {
    if (this.isActive) this.gameObject.SetActive(false)
};
JurisdictionGameSymbol.prototype.OnGameInit = function() {
    this.valueLabel.text = UHT_GAME_CONFIG["GAME_SYMBOL"]
};
goog.require("UHT.XTLink");
JurisdictionClientRevision.prototype = Object.create(XTLink.prototype);
JurisdictionClientRevision.prototype.constructor = JurisdictionClientRevision;

function JurisdictionClientRevision() {
    XTLink.call(this);
    this.valueLabel = null;
    this.isActive = false;
    this.shouldShowGameEngineVersion = false
}
JurisdictionClientRevision.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableOpen, this.OnPressedPaytableOpen, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableClose, this.OnPressedPaytableClose, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackBool(Vars.Jurisdiction_ClientRevision, this.OnJurisdictionInfoChanged, this);
    XT.RegisterCallbackBool(Vars.Jurisdiction_GameEngineVersion, this.OnJurisdictionGameEngineVersionChanged,
        this)
};
JurisdictionClientRevision.prototype.OnJurisdictionInfoChanged = function(param) {
    this.isActive = param
};
JurisdictionClientRevision.prototype.OnJurisdictionGameEngineVersionChanged = function(param) {
    this.shouldShowGameEngineVersion = param
};
JurisdictionClientRevision.prototype.OnPressedPaytableOpen = function() {
    if (this.isActive || this.shouldShowGameEngineVersion) this.gameObject.SetActive(true)
};
JurisdictionClientRevision.prototype.OnPressedPaytableClose = function() {
    this.gameObject.SetActive(false)
};
JurisdictionClientRevision.prototype.OnGameInit = function() {
    this.valueLabel.text = UHT_REVISION.common;
    if (this.shouldShowGameEngineVersion) {
        var response = XT.GetObject(FOXVars.FOX_Response);
        if (response["gever"] != undefined) {
            this.valueLabel.text = response["gever"];
            if (this.transform.parent.gameObject.name == "Portrait") this.valueLabel.transform.localPosition(-20, 0, 0);
            this.valueLabel.effectStyle = 2;
            this.valueLabel.effectHeight = 2;
            this.valueLabel.effectWidth = 2;
            this.valueLabel.init(true)
        }
    }
};
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
LineByLineSkipper.prototype = Object.create(XTLink.prototype);
LineByLineSkipper.prototype.constructor = LineByLineSkipper;

function LineByLineSkipper() {
    XTLink.call(this)
}
LineByLineSkipper.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.LastWinIsCounting, this.OnLastWinIsCounting, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowAllLinesWin, this.OnShowAllLinesWin, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this)
};
LineByLineSkipper.prototype.OnDestroy = function() {
    XT.UnregisterCallbackBool(this.OnLastWinIsCounting, this);
    XT.UnregisterCallbackEvent(this.OnSpinStarted, this)
};
LineByLineSkipper.prototype.OnLastWinIsCounting = function(b) {
    if (!b) return;
    if (!XT.GetBool(Vars.Jurisdiction_LineByLineGlobal) && !XT.GetBool(Vars.Jurisdiction_LineByLineFreespin)) return;
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr.IsFreeSpin || XT.GetInt(Vars.AutoplaySpinsLeft) != -1 || XT.GetObject(Vars.TumblingData) != null) this.gameObject.SetActive(true)
};
LineByLineSkipper.prototype.OnShowAllLinesWin = function() {
    if (!XT.GetBool(Vars.Jurisdiction_LineByLineGlobal) && !XT.GetBool(Vars.Jurisdiction_LineByLineFreespin)) return;
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr.IsFreeSpin || XT.GetInt(Vars.AutoplaySpinsLeft) != -1 || XT.GetObject(Vars.TumblingData) != null) this.gameObject.SetActive(true)
};
LineByLineSkipper.prototype.ClickedLineByLineSkipperCollider = function() {
    var rqm = XT.GetObject(Vars.RQManagerObject);
    var markerIndexes = [];
    for (var i = 0; i < rqm.rqiList.length; i++)
        if (rqm.rqiList[i].constructor.name == "RQIMarker") markerIndexes.push(i);
    while (markerIndexes.length > 0) {
        var tmp = rqm.rqiList[markerIndexes[0]];
        if (tmp.type == RQIMarker.MarkerType.StartLineByLine) {
            rqm.rqiList.splice(markerIndexes[0], markerIndexes[1] - markerIndexes[0] + 1);
            markerIndexes.splice(0, 2)
        } else {
            rqm.rqiList.splice(0, markerIndexes[0]);
            markerIndexes.splice(0, 1)
        }
    }
    XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_Spin);
    this.gameObject.SetActive(false)
};
LineByLineSkipper.prototype.OnSpinStarted = function() {
    this.gameObject.SetActive(false)
};
LineByLineSkipper.prototype.ActivateOnFSResume = function() {
    if (!XT.GetBool(Vars.Jurisdiction_LineByLineGlobal) && !XT.GetBool(Vars.Jurisdiction_LineByLineFreespin)) this.gameObject.SetActive(false)
};
goog.provide("UHT.BonusGameMultiplePicks");
goog.require("UHT.XTLink");
BonusGameMultiplePicks.prototype = Object.create(XTLink.prototype);
BonusGameMultiplePicks.prototype.constructor = BonusGameMultiplePicks;

function BonusGameMultiplePicks() {
    XTLink.call(this);
    this.show = null;
    this.resume = null;
    this.close = null;
    this.reset = null;
    this.indicatorShow = null;
    this.indicatorGameOver = null;
    this.indicatorResume = null;
    this.indicatorReset = null;
    this.pickItems = []
}
BonusGameMultiplePicks.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(BGVars.Evt_Internal_ShowLevel, this.ShowBonusGame, this);
    XT.RegisterCallbackEvent(BGVars.Evt_Internal_ResumeLevel, this.ResumeBonusGame, this);
    XT.RegisterCallbackEvent(BGVars.Evt_DataToCode_BonusPickItemClicked, this.OnPickableItemClick, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_BonusResponseReceived, this.OnLevelResponseReceived, this)
};
BonusGameMultiplePicks.prototype.XTInitVariablesAndEvents = function() {
    if (this.indicatorGameOver == null || this.indicatorGameOver.cat == null) this.indicatorGameOver = this.indicatorShow
};
BonusGameMultiplePicks.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.ShowBonusGame, this);
    XT.UnregisterCallbackEvent(this.ResumeBonusGame, this);
    XT.UnregisterCallbackEvent(this.OnPickableItemClick, this);
    XT.UnregisterCallbackEvent(this.OnLevelResponseReceived, this)
};
BonusGameMultiplePicks.prototype.ActivatePicks = function(type, data) {
    if (type == CAT_Event.CallbackType.EndOfEvent) this.indicatorShow.cat.UnregisterCallback(this.indicatorShow.id, this.ActivatePicks, this);
    var bonusData = XT.GetObject(Vars.BonusData);
    XT.SetInt(Vars.BonusTotalWinDisplayed, bonusData.WinPoints);
    for (var itemIndex = 0; itemIndex < this.pickItems.length; itemIndex++) {
        if (itemIndex >= bonusData.ItemsStatus.length) continue;
        this.pickItems[itemIndex].ActivateInput(bonusData.ItemsStatus[itemIndex] <= 0)
    }
};
BonusGameMultiplePicks.prototype.GameOver = function(type, data) {
    if (type == CAT_Event.CallbackType.EndOfEvent) {
        this.indicatorGameOver.cat.UnregisterCallback(this.indicatorGameOver.id, this.GameOver, this);
        this.AnnounceGameOver()
    }
};
BonusGameMultiplePicks.prototype.UpdatePickableItems = function(_resume) {
    var bonusData = XT.GetObject(Vars.BonusData);
    for (var itemIndex = 0; itemIndex < this.pickItems.length; itemIndex++) {
        if (itemIndex >= bonusData.ItemsStatus.length) continue;
        if (_resume) {
            if (bonusData.ItemsStatus[itemIndex] > 0) this.pickItems[itemIndex].ItemResume(bonusData, itemIndex)
        } else if (!bonusData.GameOver && bonusData.ItemsStatus[itemIndex] > 0 && bonusData.ItemsStatus[itemIndex] == bonusData.Level || bonusData.GameOver && bonusData.ItemsStatus[itemIndex] ==
            bonusData.Level + 1) this.pickItems[itemIndex].ItemShow(bonusData, itemIndex)
    }
};
BonusGameMultiplePicks.prototype.AnnounceGameOver = function() {
    var bonusData = XT.GetObject(Vars.BonusData);
    XT.SetInt(Vars.BonusTotalWinDisplayed, bonusData.WinPoints);
    for (var itemIndex = 0; itemIndex < this.pickItems.length; itemIndex++) this.pickItems[itemIndex].ActivateInput(false);
    if (XT.GetBool(BGVars.ShowResultAfterBigWin)) {
        XT.SetDouble(Vars.BonusRealWinDisplayed, 0);
        XT.SetDouble(Vars.BonusRealWinDisplayed, bonusData.RealWin)
    }
    XT.TriggerEvent(BGVars.Evt_CodeToData_BonusResultWindowShow)
};
BonusGameMultiplePicks.prototype.IsResume = function(bonusData) {
    return bonusData.Level > 0
};
BonusGameMultiplePicks.prototype.ShowBonusGame = function() {
    var bonusData = XT.GetObject(Vars.BonusData);
    if (this.IsResume(bonusData)) {
        this.ResumeBonusGame();
        return
    }
    this.indicatorReset.Start();
    this.reset.Start();
    this.show.Start();
    for (var pickIndex = 0; pickIndex < this.pickItems.length; pickIndex++) this.pickItems[pickIndex].ResetItem()
};
BonusGameMultiplePicks.prototype.ResumeBonusGame = function() {
    var bonusData = XT.GetObject(Vars.BonusData);
    this.UpdatePickableItems(true);
    this.resume.Start();
    if (bonusData.GameOver) this.AnnounceGameOver()
};
BonusGameMultiplePicks.prototype.OnLevelResponseReceived = function() {
    var bonusData = XT.GetObject(Vars.BonusData);
    this.UpdatePickableItems(false);
    if (bonusData.GameOver) {
        this.indicatorGameOver.cat.RegisterCallback(this.indicatorGameOver.id, this.GameOver, this);
        this.indicatorGameOver.Start()
    } else {
        this.indicatorShow.cat.RegisterCallback(this.indicatorShow.id, this.ActivatePicks, this);
        this.indicatorShow.Start()
    }
};
BonusGameMultiplePicks.prototype.OnPickableItemClick = function() {
    var pickedItemIndex = XT.GetInt(BGVars.BonusPickItemIndex);
    for (var itemIndex = 0; itemIndex < this.pickItems.length; itemIndex++) this.pickItems[itemIndex].ActivateInput(false);
    XT.TriggerEvent(BGVars.Evt_ToServer_BonusPickedItem)
};
goog.provide("UHT.PickableItemBase");
goog.require("UHT.Engine");
PickableItemBase.prototype = Object.create(XTLink.prototype);
PickableItemBase.prototype.constructor = PickableItemBase;

function PickableItemBase() {
    XTLink.call(this);
    this.showPicked = null;
    this.resumePicked = null;
    this.resetPick = null;
    this.myCollider = null
}
PickableItemBase.prototype.ItemShow = function(bonusData, index) {};
PickableItemBase.prototype.ItemResume = function(bonusData, index) {
    this.ActivateInput(false)
};
PickableItemBase.prototype.ActivateInput = function(_activate) {
    if (this.myCollider == null) {
        var colliders = this.GetComponentsInChildren(Collider, true);
        if (colliders == null || colliders.length < 1) return;
        this.myCollider = colliders[0]
    }
    this.myCollider.enabled = _activate
};
PickableItemBase.prototype.ResetItem = function() {
    this.ActivateInput(true)
};
goog.require("UHT.FOXLink");
NetPositionFOX.prototype = Object.create(FOXLink.prototype);
NetPositionFOX.prototype.constructor = NetPositionFOX;

function NetPositionFOX() {
    FOXLink.call(this);
    this.netPositionLabel = null;
    this.currentNetPosition = 0;
    this.lastTotalWin = 0;
    this.ignoreFirstTumble = true;
    this.formatOptions = new FormatOptions
}
NetPositionFOX.prototype.XTInitVariablesAndEvents = function() {
    XT.RegisterCallbackBool(Vars.ShowNetPosition, this.OnShowNetPosition, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_UpdateDisplayedWinInUI, this.OnUpdateDisplayedWin, this);
    XT.RegisterCallbackDouble(Vars.ExtraSessionWin, this.OnExtraWinAndUpdate, this);
    XT.RegisterCallbackDouble(Vars.PlayJackpot_JackpotAmountWonDisplayed, this.OnExtraWin, this);
    XT.RegisterCallbackDouble(Vars.PlayJackpot_MultiplierAmountWonDisplayed, this.OnExtraWin, this)
};
NetPositionFOX.prototype.OnShowNetPosition = function(param) {
    this.gameObject.SetActive(param)
};
NetPositionFOX.prototype.OnUpdateDisplayedWin = function() {
    this.netPositionLabel.text = LocaleManager.FormatValue(this.currentNetPosition, this.formatOptions)
};
NetPositionFOX.prototype.HandleInitResponse = function(dict) {
    this.netPositionLabel.text = LocaleManager.FormatValue(this.currentNetPosition, this.formatOptions)
};
NetPositionFOX.prototype.HandleSpinResponse = function(dict) {
    if (dict[GameProtocolDictionary.spinCycleWin] != undefined) this.lastTotalWin = _number.otod(dict[GameProtocolDictionary.spinCycleWin]);
    if (XT.GetBool(Vars.Logic_IsFreeSpin)) return;
    if (XT.GetBool(Vars.IsDifferentSpinType))
        if (this.ignoreFirstTumble) this.ignoreFirstTumble = false;
        else return;
    var respinData = XT.GetObject(Vars.RespinData);
    var isRespin = respinData != null && !respinData.IsDone;
    if (isRespin) return;
    var lines = -1;
    var coin = -1;
    if (dict[GameProtocolDictionary.line] !=
        undefined) lines = _number.otoi(dict[GameProtocolDictionary.line]);
    else lines = XT.GetInt(Vars.BetToTotalBetMultiplier);
    if (dict[GameProtocolDictionary.coin] != undefined) coin = _number.otod(dict[GameProtocolDictionary.coin]);
    if (coin != -1 && lines != -1 && dict[GameProtocolDictionary.FreeRound.TotalWin] == undefined) this.currentNetPosition -= coin * lines;
    this.OnUpdateDisplayedWin()
};
NetPositionFOX.prototype.HandleCollectResponse = function(dict) {
    this.ignoreFirstTumble = true;
    this.currentNetPosition += this.lastTotalWin
};
NetPositionFOX.prototype.HandlePickBonusResponse = function(dict) {
    if (dict[GameProtocolDictionary.spinCycleWin] != undefined) this.lastTotalWin = _number.otod(dict[GameProtocolDictionary.spinCycleWin])
};
NetPositionFOX.prototype.HandleBonusRespinResponse = function(dict) {
    if (dict[GameProtocolDictionary.spinCycleWin] != undefined) this.lastTotalWin = _number.otod(dict[GameProtocolDictionary.spinCycleWin])
};
NetPositionFOX.prototype.HandleBonusCollectResponse = function(dict) {
    this.currentNetPosition += this.lastTotalWin;
    this.OnUpdateDisplayedWin()
};
NetPositionFOX.prototype.HandleGambleResponse = function(dict) {
    if (dict[GameProtocolDictionary.spinCycleWin] != undefined) this.lastTotalWin = _number.otod(dict[GameProtocolDictionary.spinCycleWin])
};
NetPositionFOX.prototype.HandleGambleCollectResponse = function(dict) {
    this.currentNetPosition += this.lastTotalWin
};
NetPositionFOX.prototype.OnExtraWin = function(amount) {
    this.currentNetPosition += amount
};
NetPositionFOX.prototype.OnExtraWinAndUpdate = function(amount) {
    this.currentNetPosition += amount;
    this.OnUpdateDisplayedWin()
};
goog.require("UHT.Engine");

function FreeRoundsBonusConnection() {
    this.updateInterval = 180;
    this.updateTimer = 0;
    this.endpointUrl = "/gs2c/promo/frb/available/";
    this.shouldUpdate = false;
    this.isGettingData = false;
    this.retryCount = 0;
    this.bonusRoundShown = false;
    this.cachedInitBonusCode = "";
    this.isEnabled = true;
    this.playLaterSelectedForNormalFRB = false;
    this.shouldUpdatePlayLater = true
}
FreeRoundsBonusConnection.prototype.Init = function() {
    this.endpointUrl = ServerOptions.serverUrl + this.endpointUrl + "?mgckey=" + ServerOptions.mgckey;
    XT.SetString(Vars.InitBonusCode, "");
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackBool(Vars.UserChoseToPlayLater, this.OnUserChoseToPlayLater, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_BonusRoundsStarted, this.OnBonusRoundStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_BonusRoundsFinished, this.OnBonusRoundFinished,
        this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_BonusRoundsError, this.OnBonusRoundFinished, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_BonusRoundsOnContinuePressed, this.OnContinuePressed, this)
};
FreeRoundsBonusConnection.prototype.OnGameInit = function() {
    var config = UHT_GAME_CONFIG_SRC;
    if (config != null && config["instantFrbEnabled"] != undefined && config["instantFrbUpdateSeconds"] != undefined) {
        this.isEnabled = config["instantFrbEnabled"];
        if (this.isEnabled) {
            var interval = config["instantFrbUpdateSeconds"];
            if (interval > 0) this.updateInterval = interval
        }
    }
    if (XT.GetObject(Vars.BonusRoundsEvents) == null) this.shouldUpdate = true
};
FreeRoundsBonusConnection.prototype.OnBonusRoundStarted = function() {
    this.bonusRoundShown = true
};
FreeRoundsBonusConnection.prototype.OnBonusRoundFinished = function() {
    this.bonusRoundShown = false
};
FreeRoundsBonusConnection.prototype.OnContinuePressed = function() {
    if (this.bonusRoundShown) {
        XT.SetString(Vars.InitBonusCode, this.cachedInitBonusCode);
        this.cachedInitBonusCode = ""
    }
    this.shouldUpdate = !this.bonusRoundShown;
    if (this.shouldUpdate) this.updateTimer = 0
};
FreeRoundsBonusConnection.prototype.OnUserChoseToPlayLater = function(playLater) {
    if (playLater) {
        if (this.shouldUpdatePlayLater) this.playLaterSelectedForNormalFRB = playLater;
        else this.isEnabled = false;
        this.shouldUpdate = false;
        this.bonusRoundShown = false;
        if (this.cachedInitBonusCode != "") XT.SetBool(Vars.UserChoseToPlayLater, false);
        this.cachedInitBonusCode = ""
    }
};
FreeRoundsBonusConnection.prototype.GetFreeRoundsData = function() {
    var req = new ServerRequest;
    req.Url = this.endpointUrl;
    if (this.playLaterSelectedForNormalFRB) req.Url += "&playLaterSelected=true";
    req.Handler = new EventHandler(this, this.OnFreeRoundsData);
    req.Method = "GET";
    RequestManager.AddRequest(req)
};
FreeRoundsBonusConnection.prototype.OnFreeRoundsData = function(param, statusCode) {
    if (statusCode != 200 && this.retryCount++ < 5) {
        this.GetFreeRoundsData();
        return
    }
    var dict;
    try {
        dict = JSON.parse(param)
    } catch (e) {
        console.error(e.message);
        return
    }
    if (dict == null) return;
    if (dict["freeRounds"])
        if (dict["freeRounds"].length > 0) this.ParseFreeRoundData(dict["freeRounds"][0]);
    this.updateTimer = 0;
    this.isGettingData = false
};
FreeRoundsBonusConnection.prototype.ParseFreeRoundData = function(data) {
    var brData = new VsFreeRound;
    var brEvents = new VsFreeRoundEvent;
    brEvents.PromoType = data["promoType"] != null ? data["promoType"] : "";
    brData.Type = VsFreeRound.RoundType.Spins;
    var type = data["freeRoundsType"];
    switch (type) {
        case "N":
            brData.Type = VsFreeRound.RoundType.Spins;
            break;
        case "T":
            brData.Type = VsFreeRound.RoundType.Timed;
            break;
        case "F":
            brData.Type = VsFreeRound.RoundType.BonusBoost;
            break;
        default:
            break
    }
    brData.RoundsLeft = _number.otoi(data["freeRoundsNumber"]);
    brEvents.RoundsLeft = _number.otoi(data["freeRoundsNumber"]);
    brEvents.Bet = _number.otod(data["betPerLine"]);
    brEvents.Lines = _number.otoi(data["numberOfLines"]);
    brEvents.TurboSpinMode = _bool.Parse(data["turboSpinMode"]);
    brEvents.PlayLaterAvailable = _bool.Parse(data["playLaterAvailable"]);
    brEvents.EndDateTimestamp = _number.otod(data["expirationDate"]);
    brEvents.IsFreeRoundPending = _bool.Parse(data["freeRoundPending"]);
    brEvents.PromoLocalizedName = data["promoLocalizedName"] != null ? data["promoLocalizedName"] : "";
    brEvents.Type = VsFreeRoundEvent.EventType.Start;
    this.cachedInitBonusCode = data["bonusCode"];
    var events = [];
    events.push(brEvents);
    XT.SetObject(Vars.BonusRoundsData, brData);
    XT.SetObject(Vars.BonusRoundsEvents, events);
    this.shouldUpdatePlayLater = false;
    XT.SetBool(Vars.UserChoseToPlayLater, false);
    XT.TriggerEvent(Vars.Evt_Internal_BonusRoundsInfoUpdated)
};
FreeRoundsBonusConnection.prototype.Update = function() {
    if (!this.isEnabled || !this.shouldUpdate) return;
    if (this.updateTimer > this.updateInterval && !this.isGettingData) {
        this.isGettingData = true;
        this.GetFreeRoundsData()
    }
    this.updateTimer += Time.deltaTime
};
var BGVars = {
    Evt_Internal_ShowLevel: "Evt_Internal_ShowLevel",
    Evt_Internal_ResumeLevel: "Evt_Internal_ResumeLevel",
    Evt_DataToCode_BonusPickItemClicked: "Evt_DataToCode_BonusPickItemClicked",
    Evt_DataToCode_BonusMultiplierItemClicked: "Evt_DataToCode_BonusMultiplierItemClicked",
    Evt_ToServer_BonusPickedItem: "Evt_ToServer_BonusPickedItem",
    Evt_ToServer_BonusPickedCustomItem: "Evt_ToServer_BonusPickedCustomItem",
    Evt_ToServer_SendBonusRespin: "Evt_ToServer_SendBonusRespin",
    Evt_ToServer_BonusGameFinished: "Evt_ToServer_BonusGameFinished",
    BonusPickItemIndex: "BonusPickItemIndex",
    Evt_CodeToData_BonusResultWindowShow: "Evt_CodeToData_BonusResultWindowShow",
    Evt_DataToCode_BonusResultWindowCollect: "Evt_DataToCode_BonusResultWindowCollect",
    Evt_DataToCode_BonusResultWindowClosed: "Evt_DataToCode_BonusResultWindowClosed",
    Evt_CodeToData_BonusResultWindowClose: "Evt_CodeToData_BonusResultWindowClose",
    BonusRealWinDisplayed: "BonusRealWinDisplayed",
    BonusBetPerLine: "BonusBetPerLine",
    BonusDataReceived: "BonusDataReceived",
    HasMultipleLevelsNoItemMarkers: "HasMultipleLevelsNoItemMarkers",
    ShowResultAfterBigWin: "ShowResultAfterBigWin"
};
var Vars = {
    Evt_Internal_GameInit: "Evt_Internal_GameInit",
    Evt_Internal_Init_SoundManager: "Evt_Internal_Init_SoundManager",
    Evt_Internal_Init_SymbolManager: "Evt_Internal_Init_SymbolManager",
    Evt_Internal_Init_ReelsManager: "Evt_Internal_Init_ReelsManager",
    Evt_Internal_GUIInit: "Evt_Internal_GUIInit",
    GameHasCustomGamble: "GameHasCustomGamble",
    ScatterSymbolIsWild: "ScatterSymbolIsWild",
    DefaultGameWindowOverrideData: "DefaultGameWindowOverrideData",
    Evt_Internal_Init_CustomData: "Evt_Internal_Init_CustomData",
    Evt_Internal_CustomDataIsInitialized: "Evt_Internal_CustomDataIsInitialized",
    GameHasIntro: "GameHasIntro",
    ShouldDisplayIntro: "ShouldDisplayIntro",
    Evt_DataToCode_IntroClosePressed: "Evt_DataToCode_IntroClosePressed",
    MobileTapToStopMessageShowCount: "MobileTapToStopMessageShowCount",
    DesktopTurboSpinMessageShowCount: "DesktopTurboSpinMessageShowCount",
    GameIsRated: "GameIsRated",
    RatingSkipped: "RatingSkipped",
    BrowserWarningShown: "BrowserWarningShown",
    Evt_ToServer_UpdateSettingsOnServer: "Evt_ToServer_UpdateSettingsOnServer",
    SkipCooldownWhenUpdatingSettingsOnServer: "SkipCooldownWhenUpdatingSettingsOnServer",
    HasGameHistory: "HasGameHistory",
    VerifyGameAuthenticity: "VerifyGameAuthenticity",
    Jurisdiction_LineByLineFreespin: "Jurisdiction_LineByLineFreespin",
    Jurisdiction_LineByLineGlobal: "Jurisdiction_LineByLineGlobal",
    Jurisdiction_ClientRevision: "Jurisdiction_ClientRevision",
    Jurisdiction_GameSymbol: "Jurisdiction_GameSymbol",
    HasAdvancedAutoplay: "HasAdvancedAutoplay",
    Jurisdiction_SpinLimit: "Jurisdiction_SpinLimit",
    Jurisdiction_SpinLimit_Value: "Jurisdiction_SpinLimit_Value",
    Jurisdiction_MandatoryAutoplayLossLimit: "Jurisdiction_MandatoryAutoplayLossLimit",
    Jurisdiction_ResultMinimumTime: "Jurisdiction_ResultMinimumTime",
    Jurisdiction_ResultMinimumTime_Value: "Jurisdiction_ResultMinimumTime_Value",
    Jurisdiction_ResultMinimumTimeTurbo: "Jurisdiction_ResultMinimumTimeTurbo",
    Jurisdiction_ResultMinimumTimeTurbo_Value: "Jurisdiction_ResultMinimumTimeTurbo_Value",
    Jurisdiction_MaxBetCents: "Jurisdiction_MaxBetCents",
    Jurisdiction_MaxWin: "Jurisdiction_MaxWin",
    Jurisdiction_ResultMinimumTimeBetweenSpins: "Jurisdiction_ResultMinimumTimeBetweenSpins",
    Jurisdiction_ResultMinimumTimeBetweenSpins_Value: "Jurisdiction_ResultMinimumTimeBetweenSpins_Value",
    Jurisdiction_GameEngineVersion: "Jurisdiction_GameEngineVersion",
    Jurisdiction_NoSpinToWin: "Jurisdiction_NoSpinToWin",
    Jurisdiction_NoSmallWinCount: "Jurisdiction_NoSmallWinCount",
    SpinDuration: "SpinDuration",
    Jurisdiction_FinishCountersBeforeSpin: "Jurisdiction_FinishCountersBeforeSpin",
    Jurisdiction_Clock: "Jurisdiction_Clock",
    Jurisdiction_Clock_Server: "Jurisdiction_Clock_Server",
    Jurisdiction_ServerTime: "Jurisdiction_ServerTime",
    Jurisdiction_DisableAutoplay: "Jurisdiction_DisableAutoplay",
    Jurisdiction_GameTitle: "Jurisdiction_GameTitle",
    Jurisdiction_SplitBalance: "Jurisdiction_SplitBalance",
    Jurisdiction_PromotionURL: "Jurisdiction_PromotionURL",
    Jurisdiction_CLMBcurrency: "Jurisdiction_CLMBcurrency",
    AdvancedAutoplaySettings: "AdvancedAutoplaySettings",
    BatterySaver: "BatterySaver",
    HasCoins: "HasCoins",
    FromServer_AllowCoins: "FromServer_AllowCoins",
    AlternativeFreeRoundsText: "AlternativeFreeRoundsText",
    DontShowFRBEndWindowOnInit: "DontShowFRBEndWindowOnInit",
    Jurisdiction_TournamentOptOut: "Jurisdiction_TournamentOptOut",
    Jurisdiction_DisableBuyFeature: "Jurisdiction_DisableBuyFeature",
    Jurisdiction_GameLobbyInfoVisible: "Jurisdiction_GameLobbyInfoVisible",
    Jurisdiction_GameHistoryInfoVisible: "Jurisdiction_GameHistoryInfoVisible",
    Jurisdiction_Text_DE: "Jurisdiction_Text_DE",
    Jurisdiction_Show_X_Chance: "Jurisdiction_Show_X_Chance",
    Jurisdiction_Autoplay_StopOnFeatureWin: "Jurisdiction_Autoplay_StopOnFeatureWin",
    Jurisdiction_Autoplay_NoSkipScreens: "Jurisdiction_Autoplay_NoSkipScreens",
    DisableIntroScreen: "DisableIntroScreen",
    DisableStopButton: "DisableStopButton",
    DisableFastPlay: "DisableFastPlay",
    DisableNoMoneyMessageFromServer: "DisableNoMoneyMessageFromServer",
    ShowIncompleteGame: "ShowIncompleteGame",
    ShowNetPosition: "ShowNetPosition",
    Jurisdiction_DisableAnteBet: "Jurisdiction_DisableAnteBet",
    Jurisdiction_DisableSuperSpin: "Jurisdiction_DisableSuperSpin",
    Jurisdiction_ShowSessionUptime: "Jurisdiction_ShowSessionUptime",
    Jurisdiction_ShowHoursInSessionUptime: "Jurisdiction_ShowHoursInSessionUptime",
    Jurisdiction_DisableContinousSpin: "Jurisdiction_DisableContinousSpin",
    Jurisdiction_WinUp_Text: "Jurisdiction_WinUp_Text",
    Evt_Internal_ChangeVSGameState: "Evt_Internal_ChangeVSGameState",
    UpdateVSGameStateOnSpin: "UpdateVSGameStateOnSpin",
    ResetProgressMode: "ResetProgressMode",
    KeepSpinning: "KeepSpinning",
    Evt_Internal_SpinRequested: "Evt_Internal_SpinRequested",
    Evt_Internal_SpinStarted: "Evt_Internal_SpinStarted",
    Evt_Internal_SpinEnded: "Evt_Internal_SpinEnded",
    SpinNeedsConfirmation: "SpinNeedsConfirmation",
    CanUpdateLinkedLoopersPosition: "CanUpdateLinkedLoopersPosition",
    IsDifferentSpinType: "IsDifferentSpinType",
    StartDifferentSpin: "StartDifferentSpin",
    Evt_CodeToData_ShowSpinConfirmationWindow: "Evt_CodeToData_ShowSpinConfirmationWindow",
    Evt_DataToCode_ConfirmSpinStart: "Evt_DataToCode_ConfirmSpinStart",
    Evt_Internal_UpdateSymbolsDepth: "Evt_Internal_UpdateSymbolsDepth",
    Evt_Internal_StartIdleSpinCounter: "Evt_Internal_StartIdleSpinCounter",
    Evt_Internal_StopIdleSpinCounter: "Evt_Internal_StopIdleSpinCounter",
    Evt_Internal_EnterIdleSpinState: "Evt_Internal_EnterIdleSpinState",
    Evt_Internal_ExitIdleSpinState: "Evt_Internal_ExitIdleSpinState",
    IdleStateActive: "IdleStateActive",
    LastExcitedReelIndex: "LastExcitedReelIndex",
    ReelsCanBeExcited: "ReelsCanBeExcited",
    LastStopEndedReelIndex: "LastStopEndedReelIndex",
    LastStartedReelIndices: "LastStartedReelIndices",
    LastStoppedReelIndices: "LastStoppedReelIndices",
    ReelsStartOrder: "ReelsStartOrder",
    ReelsStopOrder: "ReelsStopOrder",
    ReelsStartOrderDefault: "ReelsStartOrderDefault",
    ReelsStopOrderDefault: "ReelsStopOrderDefault",
    ReelsWinInfo: "ReelsWinInfo",
    ExtraReelDelayStop: "ExtraReelDelayStop",
    ExtraReelDelayStopDefault: "ExtraReelDelayStopDefault",
    ExtraReelDelayStart: "ExtraReelDelayStart",
    ExtraReelDelayStartDefault: "ExtraReelDelayStartDefault",
    PossibleWinComboSymbols: "PossibleWinComboSymbols",
    StillPossibleWinComboPerSymbol: "StillPossibleWinComboPerSymbol",
    StillPossibleWinComboBonus: "StillPossibleWinComboBonus",
    StillPossibleWinComboScatter: "StillPossibleWinComboScatter",
    StillPossibleWinComboWild: "StillPossibleWinComboWild",
    ExcitedImportantSymbols: "ExcitedImportantSymbols",
    Evt_Internal_ReelStarted: "Evt_Internal_ReelStarted",
    Evt_Internal_ReelStopStarted: "Evt_Internal_ReelStopStarted",
    Evt_Internal_ReelStopEnded: "Evt_Internal_ReelStopEnded",
    Evt_Internal_ExcitedReel: "Evt_Internal_ExcitedReel",
    ResultSymbolWinID: "ResultSymbolWinID",
    Evt_Internal_ResultSymbolWinPlaySound: "Evt_Internal_ResultSymbolWinPlaySound",
    Evt_Internal_StartVSLogicSounds: "Evt_Internal_StartVSLogicSounds",
    Evt_Internal_StopVSLogicSounds: "Evt_Internal_StopVSLogicSounds",
    Evt_Internal_StartBGLogicSounds: "Evt_Internal_StartBGLogicSounds",
    Evt_Internal_StopBGLogicSounds: "Evt_Internal_StopBGLogicSounds",
    Evt_Internal_StartFSBGLogicSounds: "Evt_Internal_StartFSBGLogicSounds",
    Evt_Internal_StopFSBGLogicSounds: "Evt_Internal_StopFSBGLogicSounds",
    ValueAnimatorSoundIndex: "ValueAnimatorSoundIndex",
    Evt_Internal_PlayValueAnimatorSound: "Evt_Internal_PlayValueAnimatorSound",
    Evt_Internal_StopValueAnimatorSound: "Evt_Internal_StopValueAnimatorSound",
    Evt_Internal_PlayGambleShuffleCard: "Evt_Internal_PlayGambleShuffleCard",
    Evt_Internal_PlayGambleShufflingStop: "Evt_Internal_PlayGambleShufflingStop",
    Evt_Internal_StopGambleShuffleCard: "Evt_Internal_StopGambleShuffleCard",
    Evt_DataToCode_PlayGambleNewProgressItem: "Evt_DataToCode_PlayGambleNewProgressItem",
    Evt_DataToCode_PlayGambleResultWin: "Evt_DataToCode_PlayGambleResultWin",
    Evt_DataToCode_PlayGambleResultLose: "Evt_DataToCode_PlayGambleResultLose",
    SoundManagerObject: "SoundManagerObject",
    TRexManagerObject: "TRexManagerObject",
    MusicLogicObject: "MusicLogicObject",
    MusicDuckByOneShotObject: "MusicDuckByOneShotObject",
    OneShotCooldownObject: "OneShotCooldownObject",
    SoundState: "SoundState",
    MusicIsOn: "MusicIsOn",
    CanPlayReelStopSounds: "CanPlayReelStopSounds",
    Evt_Internal_SoundStateChanged: "Evt_Internal_SoundStateChanged",
    Evt_Internal_SwitchToFSSounds: "Evt_Internal_SwitchToFSSounds",
    Evt_CodeToData_SettingsWindowOpened: "Evt_CodeToData_SettingsWindowOpened",
    Evt_CodeToData_SettingsWindowClosed: "Evt_CodeToData_SettingsWindowClosed",
    Evt_Internal_MuteMusic: "Evt_Internal_MuteMusic",
    Evt_Internal_UnmuteMusic: "Evt_Internal_UnmuteMusic",
    Evt_DataToCode_Pressed_SoundBtn: "Evt_DataToCode_Pressed_SoundBtn",
    Evt_DataToCode_Pressed_MusicBtn: "Evt_DataToCode_Pressed_MusicBtn",
    Evt_DataToCode_Pressed_SoundFXBtn: "Evt_DataToCode_Pressed_SoundFXBtn",
    VSSoundLogic_IgnoreFastStop: "VSSoundLogic_IgnoreFastStop",
    Evt_Internal_LocaleChanged: "Evt_Internal_LocaleChanged",
    CustomGameStoredData: "CustomGameStoredData",
    Evt_Internal_CustomGameStoredDataReceived: "Evt_Internal_CustomGameStoredDataReceived",
    TotalNumberOfLines: "TotalNumberOfLines",
    Lines: "Lines",
    GameHasWaysInsteadOfLines: "GameHasWaysInsteadOfLines",
    GameHasLinesWithBetMultiplier: "GameHasLinesWithBetMultiplier",
    LinesPaysBothWays: "LinesPaysBothWays",
    HasReelAwareSymbolContent: "HasReelAwareSymbolContent",
    HiddenMathematics: "HiddenMathematics",
    LinesForMinBet: "LinesForMinBet",
    LinesForMaxBet: "LinesForMaxBet",
    FastPlay: "FastPlay",
    FastPlayChangesBetweenSpins: "FastPlayChangesBetweenSpins",
    ContinuousSpin: "ContinuousSpin",
    AllowContinuousSpin: "AllowContinuousSpin",
    ForceContinuousSpin: "ForceContinuousSpin",
    AutoplayContinuousSpin: "AutoplayContinuousSpin",
    AutoplaySpinsRequested: "AutoplaySpinsRequested",
    AutoplaySpinsLeft: "AutoplaySpinsLeft",
    AutoplaySpinsLeftDisplayed: "AutoplaySpinsLeftDisplayed",
    InstantAutoplay: "InstantAutoplay",
    Evt_DataToCode_StartAutoplay: "Evt_DataToCode_StartAutoplay",
    Evt_DataToCode_StopAutoplay: "Evt_DataToCode_StopAutoplay",
    Evt_Internal_StoppedAutoplayByCondition: "Evt_Internal_StoppedAutoplayByCondition",
    WinReceived: "WinReceived",
    WinDisplayed: "WinDisplayed",
    SpinCycleWinReceived: "SpinCycleWinReceived",
    SpinCycleWinDisplayed: "SpinCycleWinDisplayed",
    ExtraAwardWin: "ExtraAwardWin",
    RespinCycleWin: "RespinCycleWin",
    RespinCycleWinDisplayed: "RespinCycleWinDisplayed",
    TotalLinesWinReceived: "TotalLinesWinReceived",
    TotalLinesWinDisplayed: "TotalLinesWinDisplayed",
    TotalScattersWinDisplayed: "TotalScattersWinDisplayed",
    MysteryScatterWinDisplayed: "MysteryScatterWinDisplayed",
    CanUpdateBalanceDisplayed: "CanUpdateBalanceDisplayed",
    BalanceReceived: "BalanceReceived",
    BalanceDisplayed: "BalanceDisplayed",
    BonusBalance: "BonusBalance",
    BonusBalanceReceived: "BonusBalanceReceived",
    BalanceDisplayedIsAnimating: "BalanceDisplayedIsAnimating",
    Evt_FromServer_BalanceUpdated: "Evt_FromServer_BalanceUpdated",
    IgnoreServerBalanceRequest: "IgnoreServerBalanceRequest",
    Evt_FromServer_BalanceUpdatedFromResult: "Evt_FromServer_BalanceUpdatedFromResult",
    Evt_Internal_FinalizeDisplayedWin: "Evt_Internal_FinalizeDisplayedWin",
    Evt_Internal_UpdateDisplayedWinInUI: "Evt_Internal_UpdateDisplayedWinInUI",
    Evt_Internal_UpdateDisplayedWin: "Evt_Internal_UpdateDisplayedWin",
    RespinData: "RespinData",
    ManualRespin: "ManualRespin",
    RespinsLeft: "RespinsLeft",
    RespinsAmountWon: "RespinsAmountWon",
    RespinInProgress: "RespinInProgress",
    ProgressiveFeatureConfig: "ProgressiveFeatureConfig",
    ProgressiveFeatureData: "ProgressiveFeatureData",
    MoneySymbolConfig: "MoneySymbolConfig",
    MoneySymbolData: "MoneySymbolData",
    StickySymbolsData: "StickySymbolsData",
    MergingSymbolsData: "MergingSymbolsData",
    Bets: "Bets",
    TotalBets: "TotalBets",
    BetToTotalBetMultiplier: "BetToTotalBetMultiplier",
    NextBetIndex: "NextBetIndex",
    NumberOfBetLevels: "NumberOfBetLevels",
    CoinValues: "CoinValues",
    CoinValueIndex: "CoinValueIndex",
    Evt_Internal_CoinValueChanged: "Evt_Internal_CoinValueChanged",
    Evt_Internal_LastBetsChanged: "Evt_Internal_LastBetsChanged",
    Evt_Internal_BetChanged: "Evt_Internal_BetChanged",
    TotalBetDisplayed: "TotalBetDisplayed",
    BetDisplayed: "BetDisplayed",
    CoinValueDisplayed: "CoinValueDisplayed",
    AccumulatedWinProgress: "AccumulatedWinProgress",
    Evt_DataToCode_RevertToLastBet: "Evt_DataToCode_RevertToLastBet",
    Evt_Internal_ForceUpdateBetValues: "Evt_Internal_ForceUpdateBetValues",
    MaxBetReached: "MaxBetReached",
    MinBetReached: "MinBetReached",
    MaxTotalBetFromServer: "MaxTotalBetFromServer",
    ExplicitMaxTotalBetFromServer: "ExplicitMaxTotalBetFromServer",
    MinTotalBetFromServer: "MinTotalBetFromServer",
    Evt_DataToCode_IncreaseBet: "Evt_DataToCode_IncreaseBet",
    Evt_DataToCode_DecreaseBet: "Evt_DataToCode_DecreaseBet",
    MaxCoinValueReached: "MaxCoinValueReached",
    MinCoinValueReached: "MinCoinValueReached",
    Evt_DataToCode_IncreaseCoinValue: "Evt_DataToCode_IncreaseCoinValue",
    Evt_DataToCode_DecreaseCoinValue: "Evt_DataToCode_DecreaseCoinValue",
    Evt_DataToCode_SmartIncreaseBet: "Evt_DataToCode_SmartIncreaseBet",
    Evt_DataToCode_SmartDecreaseBet: "Evt_DataToCode_SmartDecreaseBet",
    MaxBetAndCoinValueReached: "MaxBetAndCoinValueReached",
    MinBetAndCoinValueReached: "MinBetAndCoinValueReached",
    AlternativeWager: "AlternativeWager",
    StackedSymbolIndex: "StackedSymbolIndex",
    ReelSets: "ReelSets",
    ReelSetIndexPrevious: "ReelSetIndexPrevious",
    ReelSetIndexCurrent: "ReelSetIndexCurrent",
    ReelSymbols: "ReelSymbols",
    NextReelSymbols: "NextReelSymbols",
    ReelInitialPositions: "ReelInitialPositions",
    ReelStopPositions: "ReelStopPositions",
    FirstScreenSymbols: "FirstScreenSymbols",
    ResultScreenSymbols: "ResultScreenSymbols",
    InitialResultScreenSymbols: "InitialResultScreenSymbols",
    CustomResultScreenSymbols: "CustomResultScreenSymbols",
    SymbolsAboveReels: "SymbolsAboveReels",
    SymbolsBelowReels: "SymbolsBelowReels",
    NextReelsSymbolsList: "NextReelsSymbolsList",
    ExtraScatters: "ExtraScatters",
    MarkedSymbolPositions: "MarkedSymbolPositions",
    AdditionalBonusScatters: "AdditionalBonusScatters",
    NudgedSymbols: "NudgedSymbols",
    LinesDefinitionsObject: "LinesDefinitionsObject",
    SpinExciterObject: "SpinExciterObject",
    Evt_Internal_ExciterComputeEnded: "Evt_Internal_ExciterComputeEnded",
    FloatingWinEventsObject: "FloatingWinEventsObject",
    ReelsManagerObject: "ReelsManagerObject",
    SymbolsManagerObject: "SymbolsManagerObject",
    ReceivedWinLines: "ReceivedWinLines",
    ProcessedWinLines: "ProcessedWinLines",
    RQManagerObject: "RQManagerObject",
    Evt_Internal_InjectRQIOnResultDisplayerLoopStarts: "Evt_Internal_InjectRQIOnResultDisplayerLoopStarts",
    Evt_Internal_InjectRQIAfterBonusAnimate: "Evt_Internal_InjectRQIAfterBonusAnimate",
    Evt_Internal_InjectRQIBeforeLinesShow: "Evt_Internal_InjectRQIBeforeLinesShow",
    Evt_Internal_InjectRQIAfterLinesShow: "Evt_Internal_InjectRQIAfterLinesShow",
    Evt_Internal_InjectRQIBeforeEndOfDisplayLoop: "Evt_Internal_InjectRQIBeforeEndOfDisplayLoop",
    Evt_Internal_InjectRQIWhileShowingAllLines: "Evt_Internal_InjectRQIWhileShowingAllLines",
    SpinRoutineQueue: "SpinRoutineQueue",
    Evt_Internal_InjectRQIBeforeSpinStart: "Evt_Internal_InjectRQIBeforeSpinStart",
    StackedSymbolsData: "StackedSymbolsData",
    Evt_ToServer_OnShowResult: "Evt_ToServer_OnShowResult",
    Evt_ToServer_RequestInit: "Evt_ToServer_RequestInit",
    Evt_ToServer_RequestSpin: "Evt_ToServer_RequestSpin",
    ToServer_RequestExtraParams: "ToServer_RequestExtraParams",
    Evt_FromServer_InitReceived: "Evt_FromServer_InitReceived",
    Evt_FromServer_SpinResultReceived: "Evt_FromServer_SpinResultReceived",
    NASymbolId: "NASymbolId",
    WildRandomLineMpConfig: "WildRandomLineMpConfig",
    WRLMResponse: "WRLMResponse",
    WRLMCurrentSets: "WRLMCurrentSets",
    RandomAwardsConfig: "RandomAwardsConfig",
    RandomAwardsResponse: "RandomAwardsResponse",
    FreeSpinsPurchaseConfig: "FreeSpinsPurchaseConfig",
    FreeSpinsPurchaseData: "FreeSpinsPurchaseData",
    FeaturePurchase: "FeaturePurchase",
    BetLevelSettings: "BetLevelSettings",
    BetLevelChanged: "BetLevelChanged",
    HasAnteBet: "HasAnteBet",
    RandomSymbolMultipliers: "RandomSymbolMultipliers",
    PossibleRandomSymbolMultipliers: "PossibleRandomSymbolMultipliers",
    FreeSpinsChainData: "FreeSpinsChainData",
    OpeningSymbolsData: "OpeningSymbolsData",
    RandomMysterySymbolId: "RandomMysterySymbolId",
    InitialMysterySymbolId: "InitialMysterySymbolId",
    InitBGItemValues: "InitBGItemValues",
    InitBGItemMasks: "InitBGItemMasks",
    InitBGIData: "InitBGIData",
    PatternedMysterySymbols: "PatternedMysterySymbols",
    SpinOneReelData: "SpinOneReelData",
    ReelToBeSpun: "ReelToBeSpun",
    TumblingData: "TumblingData",
    TumblingWin: "TumblingWin",
    TumblingWinDisplayed: "TumblingWinDisplayed",
    RandomWildsData: "RandomWildsData",
    UpSymbols_RandomWilds: "UpSymbols_RandomWilds",
    Evt_Internal_RandomWildsDataSet: "Evt_Internal_RandomWildsDataSet",
    WildRandomMultipliers: "WildRandomMultipliers",
    Evt_Internal_WildRandomMultipliersReceived: "Evt_Internal_WildRandomMultipliersReceived",
    Evt_Internal_ShowStackedSymbols: "Evt_Internal_ShowStackedSymbols",
    Evt_Internal_ResumeStackedSymbols: "Evt_Internal_ResumeStackedSymbols",
    CurrentAnimatingStackedReel: "CurrentAnimatingStackedReel",
    ExpandingSymbolsData: "ExpandingSymbolsData",
    ExpandableDelayNeededAtTheEnd: "ExpandableDelayNeededAtTheEnd",
    Evt_Internal_ExpandingSymbolsDataSet: "Evt_Internal_ExpandingSymbolsDataSet",
    Evt_Internal_ShowExpandingSymbol: "Evt_Internal_ShowExpandingSymbol",
    CurrentAnimatingExpandingSymbolID: "CurrentAnimatingExpandingSymbolID",
    FreeSpinOptions: "FreeSpinOptions",
    MustResumeFreeSpinOptions: "MustResumeFreeSpinOptions",
    Logic_IsFreeSpin: "Logic_IsFreeSpin",
    Evt_CodeToData_ShowFSWonBeforeResult: "Evt_CodeToData_ShowFSWonBeforeResult",
    FreeSpinsEndedOverride: "FreeSpinsEndedOverride",
    FSStartNeedsConfirmation: "FSStartNeedsConfirmation",
    Evt_DataToCode_ConfirmFSStart: "Evt_DataToCode_ConfirmFSStart",
    Evt_Internal_FreeSpinsStarted: "Evt_Internal_FreeSpinsStarted",
    Evt_CodeToData_FreeSpinsShowWindowWin: "Evt_CodeToData_FreeSpinsShowWindowWin",
    Evt_CodeToData_FreeSpinsShowWindowLose: "Evt_CodeToData_FreeSpinsShowWindowLose",
    Evt_CodeToData_FreeSpinsCloseWindowWin: "Evt_CodeToData_FreeSpinsCloseWindowWin",
    Evt_CodeToData_FreeSpinsCloseWindowLose: "Evt_CodeToData_FreeSpinsCloseWindowLose",
    Evt_DataToCode_FreeSpinsWindowWinCollectPressed: "Evt_DataToCode_FreeSpinsWindowWinCollectPressed",
    Evt_DataToCode_FreeSpinsWindowLoseCollectPressed: "Evt_DataToCode_FreeSpinsWindowLoseCollectPressed",
    Evt_Internal_FreeSpinsEnded: "Evt_Internal_FreeSpinsEnded",
    Evt_ToServer_OnFreeSpinsClosed: "Evt_ToServer_OnFreeSpinsClosed",
    ReceivedFreeSpinsResponse: "ReceivedFreeSpinsResponse",
    TruncatedFreeSpinsResponse: "TruncatedFreeSpinsResponse",
    TruncateFSResponseDuringRespin: "TruncateFSResponseDuringRespin",
    UpdateFSResponseOnBonusPick: "UpdateFSResponseOnBonusPick",
    PartiallyUpdateSpinResponseOnBonusPick: "PartiallyUpdateSpinResponseOnBonusPick",
    UpdateBonusPickDataDuringRespins: "UpdateBonusPickDataDuringRespins",
    UpdateRespinDataOnBonusPick: "UpdateRespinDataOnBonusPick",
    NoInitBonusGameTypes: "NoInitBonusGameTypes",
    NoInitBonusGameIds: "NoInitBonusGameIds",
    CurrentFreeSpinDisplayed: "CurrentFreeSpinDisplayed",
    FreeSpinsLeftDisplayed: "FreeSpinsLeftDisplayed",
    MaxFreeSpinsDisplayed: "MaxFreeSpinsDisplayed",
    AdditionalFreeSpinsWon: "AdditionalFreeSpinsWon",
    AdditionalFreeSpinsWonDisplayed: "AdditionalFreeSpinsWonDisplayed",
    TotalFreeSpinsDisplayed: "TotalFreeSpinsDisplayed",
    TotalFreeSpinsChainDisplayed: "TotalFreeSpinsChainDisplayed",
    FreeSpinsTotalMultiplierDisplayed: "FreeSpinsTotalMultiplierDisplayed",
    FreeSpinsWinDisplayed: "FreeSpinsWinDisplayed",
    FreeSpinsLastWinDisplayed: "FreeSpinsLastWinDisplayed",
    FreeSpinsWinMultipliedDisplayed: "FreeSpinsWinMultipliedDisplayed",
    FreeSpinsTotalWinDisplayed: "FreeSpinsTotalWinDisplayed",
    FreeSpinsTotalWinMultipliedDisplayed: "FreeSpinsTotalWinMultipliedDisplayed",
    FSResultWindowTotalWinMultipliedDisplayed: "FSResultWindowTotalWinMultipliedDisplayed",
    FreeSpinsConsolationPrize: "FreeSpinsConsolationPrize",
    Evt_Internal_ReelManager_StopSpin: "Evt_Internal_ReelManager_StopSpin",
    Evt_Internal_ReelManager_SpinEnded: "Evt_Internal_ReelManager_SpinEnded",
    AllowFastStop: "AllowFastStop",
    Evt_DataToCode_Pressed_Spin: "Evt_DataToCode_Pressed_Spin",
    Evt_DataToCode_Pressed_Stop: "Evt_DataToCode_Pressed_Stop",
    Evt_CodeToData_NotEnoughMoneyForSpin: "Evt_CodeToData_NotEnoughMoneyForSpin",
    Evt_CodeToData_HideNoMoneyWindow: "Evt_CodeToData_HideNoMoneyWindow",
    Evt_DataToCode_NotEnoughMoney_pressedOK: "Evt_DataToCode_NotEnoughMoney_pressedOK",
    CurrentDisplayedWinLineId: "CurrentDisplayedWinLineId",
    Evt_Internal_ShowWinLine: "Evt_Internal_ShowWinLine",
    Evt_Internal_HideWinLine: "Evt_Internal_HideWinLine",
    ShowSymbolSquaresOnLineVisual: "ShowSymbolSquaresOnLineVisual",
    ResultDisplayerMinimalMode: "ResultDisplayerMinimalMode",
    ForceResultMinimalMode: "ForceResultMinimalMode",
    Evt_Internal_ResultDisplayer_SkipNextLoopOccasion: "Evt_Internal_ResultDisplayer_SkipNextLoopOccasion",
    ResultDisplayer_CanAnimateScatters: "ResultDisplayer_CanAnimateScatters",
    ResultDisplayer_CanAnimateBonuses: "ResultDisplayer_CanAnimateBonuses",
    Evt_Internal_ResultDisplayer_Prepare: "Evt_Internal_ResultDisplayer_Prepare",
    Evt_Internal_ResultDisplayer_DoLoop: "Evt_Internal_ResultDisplayer_DoLoop",
    Evt_Internal_ResultDisplayer_DoCleanup: "Evt_Internal_ResultDisplayer_DoCleanup",
    Evt_Internal_ResultDisplayer_LoopDone: "Evt_Internal_ResultDisplayer_LoopDone",
    Evt_CodeToData_ShowAllLinesWin: "Evt_CodeToData_ShowAllLinesWin",
    Evt_CodeToData_HideAllLinesWin: "Evt_CodeToData_HideAllLinesWin",
    Evt_CodeToData_ShowJackpotWin: "Evt_CodeToData_ShowJackpotWin",
    Evt_CodeToData_HideJackpotWin: "Evt_CodeToData_HideJackpotWin",
    CurrentDisplayedWinLineIndex: "CurrentDisplayedWinLineIndex",
    CurrentDisplayedWinLineWin: "CurrentDisplayedWinLineWin",
    CurrentWinMultiplier: "CurrentWinMultiplier",
    Evt_CodeToData_ShowScattersWin: "Evt_CodeToData_ShowScattersWin",
    Evt_CodeToData_HideScattersWin: "Evt_CodeToData_HideScattersWin",
    Evt_Internal_UpdateCurrentDisplayedWinLineIndex: "Evt_Internal_UpdateCurrentDisplayedWinLineIndex",
    Evt_Internal_StartDisplayWinLine: "Evt_Internal_StartDisplayWinLine",
    Evt_Internal_StopDisplayWinLine: "Evt_Internal_StopDisplayWinLine",
    Evt_CodeToData_ShowMysteryScatterWin: "Evt_CodeToData_ShowMysteryScatterWin",
    Evt_CodeToData_HideMysteryScatterWin: "Evt_CodeToData_HideMysteryScatterWin",
    OrderedSymbolList: "OrderedSymbolList",
    OrderedSymbolHoldersList: "OrderedSymbolHoldersList",
    FromServer_CanGambleSpinWin: "FromServer_CanGambleSpinWin",
    ForceDisableGambleSpinWin: "ForceDisableGambleSpinWin",
    Evt_Internal_EnableGambleButton: "Evt_Internal_EnableGambleButton",
    Evt_Internal_DisableGambleButton: "Evt_Internal_DisableGambleButton",
    CanGamble_Spin: "CanGamble_Spin",
    CanGamble_FreeSpin: "CanGamble_FreeSpin",
    CanGamble_Bonus: "CanGamble_Bonus",
    Gamble_ColorMultiplier: "Gamble_ColorMultiplier",
    Gamble_SuitMultiplier: "Gamble_SuitMultiplier",
    Gamble_CurrentBalance: "Gamble_CurrentBalance",
    Gamble_CurrentBalanceDisplayed: "Gamble_CurrentBalanceDisplayed",
    Gamble_FinalBalanceDisplayed: "Gamble_FinalBalanceDisplayed",
    Gamble_ColorWinDisplayed: "Gamble_ColorWinDisplayed",
    Gamble_SuitWinDisplayed: "Gamble_SuitWinDisplayed",
    Evt_DataToCode_Pressed_Gamble: "Evt_DataToCode_Pressed_Gamble",
    Evt_DataToCode_Pressed_Gamble_FreeSpinsResult: "Evt_DataToCode_Pressed_Gamble_FreeSpinsResult",
    Evt_DataToCode_Pressed_Gamble_BonusResult: "Evt_DataToCode_Pressed_Gamble_BonusResult",
    Evt_DataToCode_Pressed_GamblePick: "Evt_DataToCode_Pressed_GamblePick",
    Evt_DataToCode_Pressed_GambleCollect: "Evt_DataToCode_Pressed_GambleCollect",
    FromServer_GambleResult: "FromServer_GambleResult",
    FromServer_GambleHistory: "FromServer_GambleHistory",
    Evt_Internal_Gamble_DisplayHistory: "Evt_Internal_Gamble_DisplayHistory",
    Evt_DataToCode_Gamble_DisplayProgress: "Evt_DataToCode_Gamble_DisplayProgress",
    Evt_Internal_Gamble_ClearProgress: "Evt_Internal_Gamble_ClearProgress",
    Gamble_CurrentProgressObject: "Gamble_CurrentProgressObject",
    Evt_Internal_Gamble_UpdateCurrentProgress: "Evt_Internal_Gamble_UpdateCurrentProgress",
    Evt_DataToCode_Gamble_UpdateDisplayedLabels: "Evt_DataToCode_Gamble_UpdateDisplayedLabels",
    Evt_CodeToData_Gamble_PickResult_Win: "Evt_CodeToData_Gamble_PickResult_Win",
    Evt_CodeToData_Gamble_PickResult_Lose: "Evt_CodeToData_Gamble_PickResult_Lose",
    Evt_CodeToData_Gamble_PickResult_WinLimit: "Evt_CodeToData_Gamble_PickResult_WinLimit",
    Gamble_PickResult_ItemID: "Gamble_PickResult_ItemID",
    Evt_Internal_Gamble_PickResult_Handled: "Evt_Internal_Gamble_PickResult_Handled",
    Gamble_Choice: "Gamble_Choice",
    Evt_ToServer_GamblePicked: "Evt_ToServer_GamblePicked",
    Evt_ToServer_RequestGambleOpen: "Evt_ToServer_RequestGambleOpen",
    Evt_ToServer_RequestGambleClose: "Evt_ToServer_RequestGambleClose",
    Evt_FromServer_GambleOpen: "Evt_FromServer_GambleOpen",
    Evt_FromServer_GambleClose: "Evt_FromServer_GambleClose",
    Evt_CodeToData_GambleShowResultWindowWin: "Evt_CodeToData_GambleShowResultWindowWin",
    Evt_CodeToData_GambleCloseResultWindowWin: "Evt_CodeToData_GambleCloseResultWindowWin",
    Evt_CodeToData_GambleShowResultWindowLose: "Evt_CodeToData_GambleShowResultWindowLose",
    Evt_CodeToData_GambleCloseResultWindowLose: "Evt_CodeToData_GambleCloseResultWindowLose",
    Evt_Internal_GambleCloseCurrentResultWindow: "Evt_Internal_GambleCloseCurrentResultWindow",
    Evt_CodeToData_ShowBonusWonBeforeResult: "Evt_CodeToData_ShowBonusWonBeforeResult",
    TriggerBonusBeforeResult: "TriggerBonusBeforeResult",
    BonusWinIsSeparated: "BonusWinIsSeparated",
    BonusData: "BonusData",
    BonusItemsIndexes: "BonusItemsIndexes",
    MustOpenBonus: "MustOpenBonus",
    InstantlyCollectBonus: "InstantlyCollectBonus",
    MustOpenAnotherBonus: "MustOpenAnotherBonus",
    Evt_FromServer_BonusInitDone: "Evt_FromServer_BonusInitDone",
    Evt_BonusAfterInit: "Evt_BonusAfterInit",
    Evt_FromServer_BonusResponseReceived: "Evt_FromServer_BonusResponseReceived",
    Evt_DataToCode_Pressed_BonusPickItem: "Evt_DataToCode_Pressed_BonusPickItem",
    Evt_DataToCode_BonusGameLevelChange: "Evt_DataToCode_BonusGameLevelChange",
    Evt_DataToCode_BonusGameActNext: "Evt_DataToCode_BonusGameActNext",
    BonusPickItemIndex: "BonusPickItemIndex",
    Evt_ToServer_BonusPickItem: "Evt_ToServer_BonusPickItem",
    Evt_ToServer_BonusGameFinished: "Evt_ToServer_BonusGameFinished",
    BonusPickItemIndexLocal: "BonusPickItemIndexLocal",
    Evt_DataToCode_BonusResultShowWindow: "Evt_DataToCode_BonusResultShowWindow",
    Evt_DataToCode_BonusResultWindow_PressedCollect: "Evt_DataToCode_BonusResultWindow_PressedCollect",
    Evt_CodeToData_BonusResultShowWindow: "Evt_CodeToData_BonusResultShowWindow",
    Evt_CodeToData_BonusResultCloseWindow: "Evt_CodeToData_BonusResultCloseWindow",
    BonusRealWinDisplayed: "BonusRealWinDisplayed",
    BonusBetPerLine: "BonusBetPerLine",
    BonusTotalWinDisplayed: "BonusTotalWinDisplayed",
    BonusFSPremultipliedWinDisplayed: "BonusFSPremultipliedWinDisplayed",
    BonusFSPickMultiplierDisplayed: "BonusFSPickMultiplierDisplayed",
    BonusTriggersFSBG: "BonusTriggersFSBG",
    BonusTriggeredFSBGIsMystery: "BonusTriggeredFSBGIsMystery",
    OpenFSBGForMysteryScatter: "OpenFSBGForMysteryScatter",
    SendSeparateMysteryScatter: "SendSeparateMysteryScatter",
    Evt_ToServer_SendGetMysteryScatter: "Evt_ToServer_SendGetMysteryScatter",
    PaytablePayoutData: "PaytablePayoutData",
    Evt_Internal_PaytablePayoutUpdate: "Evt_Internal_PaytablePayoutUpdate",
    Evt_Internal_PaytableOpen: "Evt_Internal_PaytableOpen",
    Evt_Internal_PaytableClose: "Evt_Internal_PaytableClose",
    Evt_Internal_PaytableOpenHelp: "Evt_Internal_PaytableOpenHelp",
    Evt_DataToCode_Pressed_PaytableClosed: "Evt_DataToCode_Pressed_PaytableClosed",
    Evt_DataToCode_Pressed_PaytableNext: "Evt_DataToCode_Pressed_PaytableNext",
    Evt_DataToCode_Pressed_PaytablePrevious: "Evt_DataToCode_Pressed_PaytablePrevious",
    Evt_Internal_PaytableMobileUpdatePages: "Evt_Internal_PaytableMobileUpdatePages",
    Evt_Internal_PlaySpinEndedBWSound: "Evt_Internal_PlaySpinEndedBWSound",
    SpinResultIsBigWin: "SpinResultIsBigWin",
    SpinResultBigWinLevel: "SpinResultBigWinLevel",
    SpinResultWinLevel: "SpinResultWinLevel",
    BigWinLevel: "BigWinLevel",
    Evt_Internal_ShowBigWin: "Evt_Internal_ShowBigWin",
    Evt_Internal_ClearBigWin: "Evt_Internal_ClearBigWin",
    Evt_DataToCode_BigWinHasFinished: "Evt_DataToCode_BigWinHasFinished",
    WaitInResultForBigWin: "WaitInResultForBigWin",
    VAWBWCounters: "VAWBWCounters",
    LastWinIsCounting: "LastWinIsCounting",
    BalanceIsCounting: "BalanceIsCounting",
    SkipNextBigWin: "SkipNextBigWin",
    CanAnimateValues: "CanAnimateValues",
    CurrentCoinCountTarget: "CurrentCoinCountTarget",
    Evt_Internal_CoinCounterStart: "Evt_Internal_CoinCounterStart",
    Evt_Internal_CoinCounterStop: "Evt_Internal_CoinCounterStop",
    CoinCounterObject: "CoinCounterObject",
    CanTriggerBigWinBeforeBonus: "CanTriggerBigWinBeforeBonus",
    FromStageName: "FromStageName",
    ToStageName: "ToStageName",
    Evt_Internal_UpdateJackpotUI: "Evt_Internal_UpdateJackpotUI",
    CurrentlyDisplayedJackpot: "CurrentlyDisplayedJackpot",
    FromServer_IsJackpotWin: "FromServer_IsJackpotWin",
    FromServer_JackpotAmountWon: "FromServer_JackpotAmountWon",
    FromServer_JackpotWonID: "FromServer_JackpotWonID",
    FromServer_JackpotWonOrder: "FromServer_JackpotWonOrder",
    FromServer_JackpotsInformation: "FromServer_JackpotsInformation",
    FromServer_LastValidJackpotsInformation: "FromServer_LastValidJackpotsInformation",
    DisplayedJackpotAmount: "DisplayedJackpotAmount",
    JackpotAmountWonDisplayed: "JackpotAmountWonDisplayed",
    Evt_DataToCode_CollectJackpotPressed: "Evt_DataToCode_CollectJackpotPressed",
    Evt_DataToCode_ContinueWithJackpot: "Evt_DataToCode_ContinueWithJackpot",
    Evt_Internal_InjectRQIForMysteryJackpotWin: "Evt_Internal_InjectRQIForMysteryJackpotWin",
    Evt_Internal_JackpotCounterStart: "Evt_Internal_JackpotCounterStart",
    Evt_Internal_JackpotCounterEnded: "Evt_Internal_JackpotCounterEnded",
    Evt_Internal_ShowMysteryJackpotWon: "Evt_Internal_ShowMysteryJackpotWon",
    Evt_Internal_HideMysteryJackpotWon: "Evt_Internal_HideMysteryJackpotWon",
    MustShowJackpotWon: "MustShowJackpotWon",
    CurrentJackpotAmountDisplayedMini: "CurrentJackpotAmountDisplayedMini",
    CurrentJackpotAmountDisplayedMaxi: "CurrentJackpotAmountDisplayedMaxi",
    CurrentJackpotAmountDisplayedMajor: "CurrentJackpotAmountDisplayedMajor",
    CurrentJackpotAmountDisplayedMega: "CurrentJackpotAmountDisplayedMega",
    MinimumJackpotBigWinDuration: "MinimumJackpotBigWinDuration",
    JackpotMinBetEligible: "JackpotMinBetEligible",
    ReturnToPlayerWithJackpot: "ReturnToPlayerWithJackpot",
    ReturnToPlayerMinWithJackpot: "ReturnToPlayerMinWithJackpot",
    CurrentJackpotCommunityWinnerAmountDisplayedMini: "CurrentJackpotCommunityWinnerAmountDisplayedMini",
    CurrentJackpotCommunityWinnerAmountDisplayedMaxi: "CurrentJackpotCommunityWinnerAmountDisplayedMaxi",
    CurrentJackpotCommunityWinnerAmountDisplayedMajor: "CurrentJackpotCommunityWinnerAmountDisplayedMajor",
    CurrentJackpotCommunityWinnerAmountDisplayedMega: "CurrentJackpotCommunityWinnerAmountDisplayedMega",
    CurrentJackpotCommunitySharedPercentageDisplayedMini: "CurrentJackpotCommunitySharedPercentageDisplayedMini",
    CurrentJackpotCommunitySharedPercentageDisplayedMaxi: "CurrentJackpotCommunitySharedPercentageDisplayedMaxi",
    CurrentJackpotCommunitySharedPercentageDisplayedMajor: "CurrentJackpotCommunitySharedPercentageDisplayedMajor",
    CurrentJackpotCommunitySharedPercentageDisplayedMega: "CurrentJackpotCommunitySharedPercentageDisplayedMega",
    PrevJackpotAmountWonDisplayedMini: "PrevJackpotAmountWonDisplayedMini",
    PrevJackpotAmountWonDisplayedMaxi: "PrevJackpotAmountWonDisplayedMaxi",
    PrevJackpotAmountWonDisplayedMajor: "PrevJackpotAmountWonDisplayedMajor",
    PrevJackpotAmountWonDisplayedMega: "PrevJackpotAmountWonDisplayedMega",
    PlayJackpotData: "PlayJackpotData",
    MustPlayJackpot: "MustPlayJackpot",
    Evt_ToServer_RequestPlayJackpot: "Evt_ToServer_RequestPlayJackpot",
    Evt_FromServer_PlayJackpotResponse: "Evt_FromServer_PlayJackpotResponse",
    PlayJackpot_MultiplierInstance: "PlayJackpot_MultiplierInstance",
    PlayJackpot_JackpotInstance: "PlayJackpot_JackpotInstance",
    PlayJackpot_JackpotInformation: "PlayJackpot_JackpotInformation",
    PlayJackpot_JackpotAmountWonDisplayed: "PlayJackpot_JackpotAmountWonDisplayed",
    PlayJackpot_MultiplierWonDisplayed: "PlayJackpot_MultiplierWonDisplayed",
    PlayJackpot_MultiplierAmountWonDisplayed: "PlayJackpot_MultiplierAmountWonDisplayed",
    ExtraSessionWin: "ExtraSessionWin",
    Evt_Internal_UpdatePlayJackpotData: "Evt_Internal_UpdatePlayJackpotData",
    Evt_CodeToData_ConfirmPlayJackpot: "Evt_CodeToData_ConfirmPlayJackpot",
    Evt_DataToCode_PlayJackpotConfirmed: "Evt_DataToCode_PlayJackpotConfirmed",
    Evt_CodeToData_ShowPlayJackpot: "Evt_CodeToData_ShowPlayJackpot",
    Evt_CodeToData_ShowPlayJackpotResult: "Evt_CodeToData_ShowPlayJackpotResult",
    Evt_DataToCode_PlayJackpotResultShown: "Evt_DataToCode_PlayJackpotResultShown",
    Evt_CodeToData_PlayJackpot_ShowMysteryJackpot: "Evt_CodeToData_PlayJackpot_ShowMysteryJackpot",
    Evt_CodeToData_ShowPlayJackpotWinJackpot: "Evt_CodeToData_ShowPlayJackpotWinJackpot",
    Evt_CodeToData_ShowPlayJackpotWinNoJackpot: "Evt_CodeToData_ShowPlayJackpotWinNoJackpot",
    Evt_DataToCode_PlayJackpotWinShown: "Evt_DataToCode_PlayJackpotWinShown",
    Evt_CodeToData_ClosePlayJackpot: "Evt_CodeToData_ClosePlayJackpot",
    Evt_DataToCode_PlayJackpotClosed: "Evt_DataToCode_PlayJackpotClosed",
    Evt_DataToCode_PlayJackpot_UpdateJackpotVisual: "Evt_DataToCode_PlayJackpot_UpdateJackpotVisual",
    Evt_DataToCode_PlayJackpot_ShowJackpotVisualWin: "Evt_DataToCode_PlayJackpot_ShowJackpotVisualWin",
    Evt_DataToCode_PlayJackpot_HideJackpotVisualWin: "Evt_DataToCode_PlayJackpot_HideJackpotVisualWin",
    JackpotVisualization: "JackpotVisualization",
    GoldSymbol: "GoldSymbol",
    SymbolReplacementData: "SymbolReplacementData",
    FromServer_MustOpenFSBG: "FromServer_MustOpenFSBG",
    Internal_FSBGJustClosed: "Internal_FSBGJustClosed",
    Evt_CodeToData_StartMysteryFSBG_Resume: "Evt_CodeToData_StartMysteryFSBG_Resume",
    Evt_CodeToData_StartMysteryFSBG: "Evt_CodeToData_StartMysteryFSBG",
    Evt_CodeToData_StopMysteryFSBG: "Evt_CodeToData_StopMysteryFSBG",
    Evt_CodeToData_MysteryScatterIsVisible: "Evt_CodeToData_MysteryScatterIsVisible",
    Evt_DataToCode_StopMysteryFSBG: "Evt_DataToCode_StopMysteryFSBG",
    MysteryScatterSymbolIds: "MysteryScatterSymbolIds",
    MysteryScatterSymbol_GameObject: "MysteryScatterSymbol_GameObject",
    MysteryScatterSymbol_ParentGameObject: "MysteryScatterSymbol_ParentGameObject",
    Evt_Internal_MysteryScatterSymbol_Show: "Evt_Internal_MysteryScatterSymbol_Show",
    Evt_Internal_MysteryScatterSymbol_Hide: "Evt_Internal_MysteryScatterSymbol_Hide",
    NextGameActionIsMysteryScatter: "NextGameActionIsMysteryScatter",
    PickedItemIndexLocal_FSBGPick: "PickedItemIndexLocal_FSBGPick",
    SpinsWon_FSBGPick: "SpinsWon_FSBGPick",
    MultiplierWon_FSBGPick: "MultiplierWon_FSBGPick",
    Evt_FromServer_InitFSBGPick: "Evt_FromServer_InitFSBGPick",
    Evt_FromServer_ResponseFSBGPick: "Evt_FromServer_ResponseFSBGPick",
    Evt_ToServer_ItemPickedFSBGPick: "Evt_ToServer_ItemPickedFSBGPick",
    Evt_CodeToData_ShowFSBGPick: "Evt_CodeToData_ShowFSBGPick",
    Evt_CodeToData_ResumeFSBGPick: "Evt_CodeToData_ResumeFSBGPick",
    Evt_CodeToData_InitReceivedFSBGPick: "Evt_CodeToData_InitReceivedFSBGPick",
    Evt_CodeToData_EndGameFSBGPick: "Evt_CodeToData_EndGameFSBGPick",
    Evt_DataToCode_InfoClosedFSBGPick: "Evt_DataToCode_InfoClosedFSBGPick",
    Evt_DataToCode_ShowGameOverFSBGPick: "Evt_DataToCode_ShowGameOverFSBGPick",
    Evt_DataToCode_ItemPickedFSBGPick: "Evt_DataToCode_ItemPickedFSBGPick",
    Evt_DataToCode_EndGameFSBGPick: "Evt_DataToCode_EndGameFSBGPick",
    Evt_DataToCode_FSBG_CloseConfirmation: "Evt_DataToCode_FSBG_CloseConfirmation",
    Evt_ToServer_OpenCashier: "Evt_ToServer_OpenCashier",
    Evt_ToServer_CloseGame: "Evt_ToServer_CloseGame",
    Evt_ToServer_ReloadGame: "Evt_ToServer_ReloadGame",
    CanSpin: "CanSpin",
    CanSpinAfterResultMinimumTime: "CanSpinAfterResultMinimumTime",
    SpinBlockingFeatureIsRunning: "SpinBlockingFeatureIsRunning",
    DynamicColorSet: "DynamicColorSet",
    BonusRoundsLeftDisplayed: "BonusRoundsLeftDisplayed",
    BonusRoundsWinDisplayed: "BonusRoundsWinDisplayed",
    BonusRoundsEvents: "BonusRoundsEvents",
    BonusRoundsData: "BonusRoundsData",
    Evt_Internal_BonusRoundsInfoUpdated: "Evt_Internal_BonusRoundsInfoUpdated",
    Evt_CodeToData_GUI_BonusRoundsStarted: "Evt_CodeToData_GUI_BonusRoundsStarted",
    Evt_CodeToData_GUI_BonusRoundsFinished: "Evt_CodeToData_GUI_BonusRoundsFinished",
    Evt_CodeToData_GUI_BonusRoundsError: "Evt_CodeToData_GUI_BonusRoundsError",
    Evt_CodeToData_GUI_TimedBonusRoundsStarted: "Evt_CodeToData_GUI_TimedBonusRoundsStarted",
    Evt_CodeToData_GUI_TimedBonusRoundsFinished: "Evt_CodeToData_GUI_TimedBonusRoundsFinished",
    Evt_CodeToData_GUI_TimedBonusRoundsError: "Evt_CodeToData_GUI_TimedBonusRoundsError",
    Evt_CodeToData_GUI_BoostBonusRoundsStarted: "Evt_CodeToData_GUI_BoostBonusRoundsStarted",
    Evt_CodeToData_GUI_BoostBonusRoundsFinished: "Evt_CodeToData_GUI_BoostBonusRoundsFinished",
    Evt_CodeToData_GUI_BoostBonusRoundsError: "Evt_CodeToData_GUI_BoostBonusRoundsError",
    Evt_CodeToData_BonusRoundsStarted: "Evt_CodeToData_BonusRoundsStarted",
    Evt_CodeToData_BonusRoundsFinished: "Evt_CodeToData_BonusRoundsFinished",
    Evt_CodeToData_BonusRoundsError: "Evt_CodeToData_BonusRoundsError",
    Evt_CodeToData_TimedBonusRoundsStarted: "Evt_CodeToData_TimedBonusRoundsStarted",
    Evt_CodeToData_TimedBonusRoundsFinished: "Evt_CodeToData_TimedBonusRoundsFinished",
    Evt_CodeToData_TimedBonusRoundsError: "Evt_CodeToData_TimedBonusRoundsError",
    TimedBonusRoundIsOngoing: "TimedBonusRoundIsOngoing",
    TimedBonusRoundsSeconds: "TimedBonusRoundsSeconds",
    ShouldIgnoreNextFinishEventFromServer: "ShouldIgnoreNextFinishEventFromServer",
    BonusRoundCanBePlayedLater: "BonusRoundCanBePlayedLater",
    UserChoseToPlayLater: "UserChoseToPlayLater",
    BonusRoundEndDateTimestamp: "BonusRoundEndDateTimestamp",
    BonusRoundWonFromDDW: "BonusRoundWonFromDDW",
    BonusRoundPromoType: "BonusRoundPromoType",
    InitBonusCode: "InitBonusCode",
    Evt_CodeToData_CloseOtherOpenedBonusRoundsWindows: "Evt_CodeToData_CloseOtherOpenedBonusRoundsWindows",
    Evt_DataToCode_BonusRoundsOnContinuePressed: "Evt_DataToCode_BonusRoundsOnContinuePressed",
    ReturnToPlayer: "ReturnToPlayer",
    ReturnToPlayerMin: "ReturnToPlayerMin",
    LevelSymbolIndex: "LevelSymbolIndex",
    Evt_AnimateLevelIndicatorOnReel: "Evt_AnimateLevelIndicatorOnReel",
    LevelIndicatorAnimTarget: "LevelIndicatorAnimTarget",
    Autoplay_SkipScreens: "Autoplay_SkipScreens",
    Evt_CodeToData_IntroClosedOrSkipped: "Evt_CodeToData_IntroClosedOrSkipped",
    OpaqueInterface: "OpaqueInterface",
    ShowInGameTutorial: "ShowInGameTutorial",
    Evt_Internal_ProgressiveFeaturePickedSymbolPositionUpdated: "Evt_Internal_ProgressiveFeaturePickedSymbolPositionUpdated",
    ProgressiveFeaturePointsWon: "ProgressiveFeaturePointsWon",
    GambleV2Data: "GambleV2Data",
    MustOpenGambleV2: "MustOpenGambleV2",
    Evt_FromServer_GambleV2Response: "Evt_FromServer_GambleV2Response",
    Evt_Internal_GambleV2Closed: "Evt_Internal_GambleV2Closed",
    GoldenReelsIndexes: "GoldenReelsIndexes",
    ShowedRandomWildPosition: "ShowedRandomWildPosition",
    Evt_Internal_ShowedRandomWild: "Evt_Internal_ShowedRandomWild",
    MobilePaytableObject: "MobilePaytableObject",
    SoundVolume: "SoundVolume",
    Evt_DataToCode_BlockSpin: "Evt_DataToCode_BlockSpin",
    Evt_DataToCode_UnblockSpin: "Evt_DataToCode_UnblockSpin",
    InitialScreen: "InitialScreen",
    IsNoMoneySpin: "IsNoMoneySpin",
    InitialRandomAward: "InitialRandomAward",
    GameTitle: "GameTitle",
    ShowPendingNotifications: "ShowPendingNotifications",
    WinLimitReached: "WinLimitReached"
};

function SoundState() {
    this.globalSoundIsOn = true;
    this.gameSoundIsOn = true;
    this.musicIsOn = true;
    this.soundFXIsOn = true;
    this.oldMusicIsOn = false;
    this.oldSoundFXIsOn = false
}
goog.provide("UHT.Paytable");
goog.require("UHT.Engine");
Paytable.prototype = Object.create(XTLink.prototype);
Paytable.prototype.constructor = Paytable;
var PageContentType = {
    Normal: 0,
    Jackpot: 1
};

function Paytable() {
    XTLink.call(this);
    this.cat = null;
    this.paytable = null;
    this.pages = [];
    this.pageContentType = [];
    this.gamblePageIndex = -1;
    this.jackpotPageCounter = 0;
    this.currentPageIndex = 1;
    this.pagesCount = 0;
    this.pageIndexLabel = null;
    this.paytableActive = false;
    this.pageIdx = 0;
    this.pageRoot = [];
    this.hasFeatureDependentPages = false;
    this.hasRequirementAwarePages = false;
    this.jpData = null;
    this.firstHelpPageIdx = -1
}

function CAT_Set() {
    this.show = null;
    this.hide = null
}
Paytable.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableOpen, this.OnPressedPaytableOpen, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableClose, this.OnPressedPaytableClose, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_PaytableNext, this.OnPressedPaytableNext, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_PaytablePrevious, this.OnPressedPaytablePrevious, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit,
        this);
    EventManager.AddHandler(JackpotEvents.evtJackpotStateChanged, this.OnJackpotStateChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableOpenHelp, this.OnShowGameHelp, this)
};
Paytable.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.MobilePaytableObject, this)
};
Paytable.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnPressedPaytableOpen, this);
    XT.UnregisterCallbackEvent(this.OnPressedPaytableClose, this);
    XT.UnregisterCallbackEvent(this.OnPressedPaytableNext, this);
    XT.UnregisterCallbackEvent(this.OnPressedPaytablePrevious, this);
    XT.UnregisterCallbackEvent(this.OnGUIInit, this)
};
Paytable.prototype.OnJackpotStateChanged = function(param) {
    this.jpData = param
};
Paytable.prototype.OnGUIInit = function() {
    if (XT.GetBool(Vars.CanGamble_Spin) == false && this.gamblePageIndex >= 0) this.pages.splice(this.gamblePageIndex, 1);
    this.pageRoot = [];
    for (var pageID = 0; pageID < this.pages.length; pageID++)
        for (var evIdx = 0; evIdx < this.cat.events.length; evIdx++)
            if (this.cat.events[evIdx].id == this.pages[pageID].show.id) {
                var action = this.cat.events[evIdx].actions[0];
                if (action.ToEnableList.length > 0) this.pageRoot.push(action.ToEnableList[0]);
                if (action.ToEnableList[0].name.indexOf("Info1") != -1) this.firstHelpPageIdx =
                    pageID;
                break
            }
    this.ProcessJackpotPages();
    this.ProcessRequirementChecker()
};
Paytable.prototype.ProcessJackpotPages = function() {
    if (!this.hasFeatureDependentPages && this.jpData != null && !this.jpData.IsActive && this.pageContentType.indexOf(PageContentType.Jackpot) != -1) {
        this.hasFeatureDependentPages = true;
        this.jackpotPageCounter = 0;
        for (var j = 0; j < this.pageContentType.length; j++)
            if (this.pageContentType[j] != PageContentType.Normal) this.jackpotPageCounter++;
        var activePageID = 0;
        for (var pageID = 0; pageID < this.pageRoot.length; pageID++) {
            var childArray = this.pageRoot[pageID].transform.children;
            for (var cIdx =
                    0; cIdx < childArray.length; cIdx++)
                if (childArray[cIdx].gameObject.name == "PageIndicator") {
                    var removalCount = this.jackpotPageCounter;
                    var activePageWasSet = false;
                    var dotArray = childArray[cIdx].transform.children;
                    for (var dIdx = 0; dIdx < dotArray.length; dIdx++)
                        if (removalCount > 0) {
                            dotArray[dIdx].transform.gameObject.SetActive(false);
                            removalCount--
                        } else if (this.pageContentType[pageID] == PageContentType.Normal) {
                        var dotSprite = dotArray[dIdx].transform.gameObject.GetComponentsInChildren(UISprite, true)[0];
                        if (dotSprite ==
                            null) break;
                        if (removalCount + activePageID == 0) {
                            dotSprite.spriteName = "PaytablePageDot_Over";
                            activePageID++;
                            activePageWasSet = true
                        } else dotSprite.spriteName = "PaytablePageDot_Normal";
                        if (!activePageWasSet) removalCount--
                    }
                }
        }
    }
    if (this.pageContentType.length != 0 && !this.hasFeatureDependentPages) this.pagesCount = this.pages.length;
    else this.pagesCount = this.pages.length - this.jackpotPageCounter;
    if (this.gameObject.transform.Find("PaytableCommonExtra/PageIndexHolder/PageIndexLabel") != null) this.pageIndexLabel = this.gameObject.transform.Find("PaytableCommonExtra/PageIndexHolder/PageIndexLabel").GetComponent(UILabel)
};
Paytable.prototype.ChangePaytableStatus = function(active) {
    if (this.paytableActive != active) {
        this.paytableActive = active;
        this.cat.StartEvent(active ? this.paytable.show.id : this.paytable.hide.id)
    }
};
var BT_PAYTABLE_SENT = false;
Paytable.prototype.OnPressedPaytableOpen = function() {
    if (!BT_PAYTABLE_SENT) {
        var timer = globalTracking.GetTimerValue("uht_behaviour", "Session_timer", "BehaviourTracker");
        globalTracking.SendEvent("uht_behaviour", "PAYTABLE_opened_once", timer, "BehaviourTracker");
        BT_PAYTABLE_SENT = true
    }
    this.ChangePaytableStatus(true);
    this.currentPageIndex = 1;
    if (this.pageIndexLabel != null) this.pageIndexLabel.text = this.currentPageIndex + "/" + this.pagesCount
};
Paytable.prototype.OnPressedPaytableClose = function() {
    this.ChangePaytableStatus(false)
};
Paytable.prototype.OnPressedPaytableNext = function() {
    this.ShowPageInt(this.pageIdx + 1);
    if (this.currentPageIndex + 1 > this.pagesCount) this.currentPageIndex = 1;
    else this.currentPageIndex = this.currentPageIndex + 1;
    if (this.pageIndexLabel != null) this.pageIndexLabel.text = this.currentPageIndex + "/" + this.pagesCount
};
Paytable.prototype.OnPressedPaytablePrevious = function() {
    this.ShowPageInt(this.pageIdx - 1);
    if (this.currentPageIndex - 1 <= 0) this.currentPageIndex = this.pagesCount;
    else this.currentPageIndex = this.currentPageIndex - 1;
    if (this.pageIndexLabel != null) this.pageIndexLabel.text = this.currentPageIndex + "/" + this.pagesCount
};
Paytable.prototype.ShowPageInt = function(index) {
    if (!this.hasFeatureDependentPages && !this.hasRequirementAwarePages) {
        this.cat.StartEvent(this.pages[this.pageIdx].hide.id);
        this.pageIdx = index < 0 ? this.pages.length - 1 : index % this.pages.length;
        this.cat.StartEvent(this.pages[this.pageIdx].show.id)
    } else {
        var next = 1;
        if (index < this.pageIdx) next *= -1;
        this.pageIdx = index < 0 ? this.pageRoot.length - 1 : index % this.pageRoot.length;
        var shouldSkip = false;
        var rac = this.pageRoot[this.pageIdx].GetComponent(window["RequirementChecker"]);
        if (rac != null) shouldSkip = !rac.isActive;
        if (shouldSkip) {
            this.ShowPageInt(this.pageIdx + next);
            return
        }
        if (this.hasFeatureDependentPages && this.pageContentType.length > this.pageIdx && this.pageContentType[this.pageIdx] != PageContentType.Normal) {
            this.ShowPageInt(this.pageIdx + next);
            return
        }
        for (var pageID = 0; pageID < this.pageRoot.length; pageID++) this.pageRoot[pageID].SetActive(pageID == this.pageIdx)
    }
};
Paytable.prototype.ShowPage = function(index) {
    this.ShowPageInt(_number.otoi(index))
};
Paytable.prototype.ProcessRequirementChecker = function() {
    var hideCounter = 0;
    for (var i = 0; i < this.pageRoot.length; i++) {
        var rac = this.pageRoot[i].GetComponent(window["RequirementChecker"]);
        if (rac != null && !rac.isActive) hideCounter++
    }
    if (hideCounter > 0) this.hasRequirementAwarePages = true;
    var activePageID = 0;
    for (var pageID = 0; pageID < this.pageRoot.length; pageID++) {
        var childArray = this.pageRoot[pageID].transform.children;
        for (var cIdx = 0; cIdx < childArray.length; cIdx++)
            if (childArray[cIdx].gameObject.name == "PageIndicator") {
                var removalCount =
                    hideCounter;
                var activePageWasSet = false;
                var dotArray = childArray[cIdx].transform.children;
                for (var dIdx = 0; dIdx < dotArray.length; dIdx++)
                    if (removalCount > 0) {
                        dotArray[dIdx].transform.gameObject.SetActive(false);
                        removalCount--
                    } else {
                        var rac = this.pageRoot[pageID].GetComponent(window["RequirementChecker"]);
                        if (rac != null && rac.isActive) {
                            var dotSprite = dotArray[dIdx].transform.gameObject.GetComponentsInChildren(UISprite, true)[0];
                            if (dotSprite == null) break;
                            if (removalCount + activePageID == 0) {
                                dotSprite.spriteName = "PaytablePageDot_Over";
                                activePageID++;
                                activePageWasSet = true
                            } else dotSprite.spriteName = "PaytablePageDot_Normal";
                            if (!activePageWasSet) removalCount--
                        }
                    }
            }
    }
    this.pagesCount -= hideCounter;
    if (this.gameObject.transform.Find("PaytableCommonExtra/PageIndexHolder/PageIndexLabel") != null) this.pageIndexLabel = this.gameObject.transform.Find("PaytableCommonExtra/PageIndexHolder/PageIndexLabel").GetComponent(UILabel)
};
Paytable.prototype.OnShowGameHelp = function() {
    if (this.firstHelpPageIdx != -1) {
        XT.TriggerEvent(Vars.Evt_Internal_PaytableOpen);
        this.ChangePaytableStatus(true);
        this.currentPageIndex = this.firstHelpPageIdx + 1;
        if (this.pageIndexLabel != null) this.pageIndexLabel.text = this.currentPageIndex + "/" + this.pagesCount;
        this.ShowPage(this.firstHelpPageIdx.toString())
    }
};
goog.provide("UHT.JackpotVisualBase");
goog.require("UHT.Component");
JackpotVisualBase.prototype = Object.create(Component.prototype);
JackpotVisualBase.prototype.constructor = JackpotVisualBase;

function JackpotVisualBase() {
    Component.call(this);
    this.currentJackpotInformation = null
}
JackpotVisualBase.prototype.ShowJackpotVisual = function() {};
JackpotVisualBase.prototype.HideJackpotVisual = function() {};
JackpotVisualBase.prototype.SetJackpotInformation = function(_jackpotData) {};
goog.require("UHT.JackpotVisualBase");
JackpotVisualMystery.prototype = Object.create(JackpotVisualBase.prototype);
JackpotVisualMystery.prototype.constructor = JackpotVisualMystery;

function JackpotVisualMystery() {
    JackpotVisualBase.call(this);
    this.contents = null;
    this.contentAmount = null;
    this.contentShut = null;
    this.community = null;
    this.communityWinnerAmount = null;
    this.communityShow = null;
    this.communityHide = null;
    this.singleJackpotContent = null;
    this.singleJackpotAmount = null;
    this.singleJackpotShut = null;
    this.singleCommunity = null;
    this.singleCommunityWinnerAmount = null;
    this.singleCommunityShow = null;
    this.singleCommunityHide = null;
    this.showJackpotVisual = null;
    this.hideJackpotVisual = null;
    this.showJackpotVisualWin =
        null;
    this.hideJackpotVisualWin = null;
    this.useShowJackpotVisualWinIfRunning = false;
    this.showJackpotVisualWinIfRunningStop = null;
    this.showJackpotVisualWinIfRunningStart = null;
    this.useJackpotDecreased = false;
    this.jackpotDecreased = null;
    this.singleJackpotDecreased = null;
    this.jackpotDecreasedAmount = null;
    this.singleJackpotDecreasedAmount = null;
    this.jackpotDecreasedAmountCommunity = null;
    this.singleJackpotDecreasedAmountCommunity = null;
    this.displayedVarName = "";
    this.communityWinnerAmountDisplayedVarName = "";
    this.communitySharedPercentageDisplayedVarName =
        "";
    this.skipUpdate = false
}
JackpotVisualMystery.possibleVarNames = [Vars.CurrentJackpotAmountDisplayedMini, Vars.CurrentJackpotAmountDisplayedMaxi, Vars.CurrentJackpotAmountDisplayedMajor, Vars.CurrentJackpotAmountDisplayedMega];
JackpotVisualMystery.communityWinnerAmountPossibleVarNames = [Vars.CurrentJackpotCommunityWinnerAmountDisplayedMini, Vars.CurrentJackpotCommunityWinnerAmountDisplayedMaxi, Vars.CurrentJackpotCommunityWinnerAmountDisplayedMajor, Vars.CurrentJackpotCommunityWinnerAmountDisplayedMega];
JackpotVisualMystery.communitySharedPercentagePossibleVarNames = [Vars.CurrentJackpotCommunitySharedPercentageDisplayedMini, Vars.CurrentJackpotCommunitySharedPercentageDisplayedMaxi, Vars.CurrentJackpotCommunitySharedPercentageDisplayedMajor, Vars.CurrentJackpotCommunitySharedPercentageDisplayedMega];
JackpotVisualMystery.prevAmountWonOrderedVarNames = [Vars.PrevJackpotAmountWonDisplayedMini, Vars.PrevJackpotAmountWonDisplayedMaxi, Vars.PrevJackpotAmountWonDisplayedMajor, Vars.PrevJackpotAmountWonDisplayedMega];
JackpotVisualMystery.prototype.ShowJackpotVisual = function() {
    if (!this.showJackpotVisual.IsRunning()) {
        if (!this.skipUpdate) {
            if (XT.GetDouble(this.displayedVarName) > this.currentJackpotInformation.JackpotAmount) {
                XT.SetDouble(this.displayedVarName, 0);
                this.StartJackpotDecreased()
            }
            XT.SetDouble(this.displayedVarName, this.currentJackpotInformation.JackpotAmount);
            var communityDetails = this.currentJackpotInformation.JackpotCommunityDetails;
            if (communityDetails != null) {
                if (XT.GetDouble(this.communityWinnerAmountDisplayedVarName) >
                    communityDetails.winnerAmount) XT.SetDouble(this.communityWinnerAmountDisplayedVarName, 0);
                XT.SetDouble(this.communityWinnerAmountDisplayedVarName, communityDetails.winnerAmount);
                if (XT.GetDouble(this.communitySharedPercentageDisplayedVarName) > communityDetails.sharedPercentage) XT.SetDouble(this.communitySharedPercentageDisplayedVarName, 0);
                XT.SetDouble(this.communitySharedPercentageDisplayedVarName, communityDetails.sharedPercentage)
            }
        }
        this.showJackpotVisual.Start()
    }
};
JackpotVisualMystery.prototype.HideJackpotVisual = function() {
    if (!this.hideJackpotVisual.IsRunning()) this.hideJackpotVisual.Start()
};
JackpotVisualMystery.prototype.SetJackpotInformation = function(jpInfo) {
    if (this.skipUpdate) return;
    this.currentJackpotInformation = jpInfo;
    var jpOrder = jpInfo.JackpotOrder;
    this.displayedVarName = JackpotVisualMystery.possibleVarNames[jpOrder];
    this.communityWinnerAmountDisplayedVarName = JackpotVisualMystery.communityWinnerAmountPossibleVarNames[jpOrder];
    this.communitySharedPercentageDisplayedVarName = JackpotVisualMystery.communitySharedPercentagePossibleVarNames[jpOrder];
    if (jpInfo.JackpotGroupType == "S") {
        if (this.singleJackpotContent !=
            null) {
            this.singleJackpotContent.SetActive(true);
            var isStatusActive = jpInfo.JackpotStatus == "A";
            this.singleJackpotAmount.SetActive(isStatusActive);
            this.singleJackpotShut.SetActive(!isStatusActive);
            if (this.singleCommunity != null) {
                var active = jpInfo.JackpotCommunityDetails != null;
                this.singleCommunity.SetActive(active);
                (active ? this.singleCommunityShow : this.singleCommunityHide).Start()
            }
        }
        for (var i = 0; i < this.contents.length; i++) this.contents[i].SetActive(false)
    } else {
        if (this.singleJackpotContent != null) this.singleJackpotContent.SetActive(false);
        for (var i = 0; i < this.contents.length; i++) {
            var isActive = i == jpOrder;
            this.contents[i].SetActive(isActive);
            if (isActive) {
                var isStatusActive = jpInfo.JackpotStatus == "A";
                this.contentAmount[i].SetActive(isStatusActive);
                this.contentShut[i].SetActive(!isStatusActive);
                if (this.community != null && i < this.community.length) {
                    var active = jpInfo.JackpotCommunityDetails != null;
                    this.community[i].SetActive(active);
                    (active ? this.communityShow[i] : this.communityHide[i]).Start()
                }
            }
        }
    }
};
JackpotVisualMystery.prototype.ShowJackpotVisualWin = function() {
    if (this.useShowJackpotVisualWinIfRunning && this.showJackpotVisualWinIfRunningStop.IsRunning()) {
        this.showJackpotVisualWinIfRunningStop.Stop();
        this.StartCATLink(this.showJackpotVisualWinIfRunningStart, true)
    }
    this.showJackpotVisualWin.Start()
};
JackpotVisualMystery.prototype.HideJackpotVisualWin = function() {
    this.hideJackpotVisualWin.Start()
};
JackpotVisualMystery.prototype.StartJackpotDecreased = function() {
    if (!this.useJackpotDecreased) return;
    var info = this.currentJackpotInformation;
    var status = JackpotsManager.I.GetJackpotStatus(info.JackpotID);
    var wonAmount = status == null ? 0 : status.prevWonAmount;
    XT.SetDouble(JackpotVisualMystery.prevAmountWonOrderedVarNames[info.JackpotOrder], wonAmount);
    this.StartCATLink(this.GetJackpotDecreasedCAT(info, wonAmount > 1E-4, info.JackpotCommunityDetails != null), true)
};
JackpotVisualMystery.prototype.GetJackpotDecreasedCAT = function(info, amount, community) {
    if (info.JackpotGroupType == "S") return amount ? community ? this.singleJackpotDecreasedAmountCommunity : this.singleJackpotDecreasedAmount : this.singleJackpotDecreased;
    return (amount ? community ? this.jackpotDecreasedAmountCommunity : this.jackpotDecreasedAmount : this.jackpotDecreased)[info.JackpotOrder]
};
JackpotVisualMystery.prototype.StartCATLink = function(link, canStop) {
    if (link == null || link.cat == null) return;
    if (link.IsRunning() && canStop) link.Stop();
    link.Start()
};
goog.require("UHT.XTLink");
JackpotVisualManager.prototype = Object.create(XTLink.prototype);
JackpotVisualManager.prototype.constructor = JackpotVisualManager;

function JackpotVisualManager() {
    XTLink.call(this);
    this.showTitle = null;
    this.hideTitle = null;
    this.backgrounds = null;
    this.backgroundSingle = null;
    this.visuals = null;
    this.animators = null;
    this.communityWinnerAmountAnimators = null;
    this.positions_4_jackpots = null;
    this.positions_3_jackpots = null;
    this.positions_2_jackpots = null;
    this.positions_1_jackpot = null;
    this.hideWhileCountingJackpot = true;
    this.skipUpdateInPlayJackpot = false;
    this.activeJackpots = [];
    this.jackpotCounting = false;
    this.skipJackpotUpdate = true;
    this.arrangeableOnMobile =
        false;
    this.arrangeableOnDesktop = false;
    this.useLocalizedLabels = false;
    this.localizedDayLabel_0 = null;
    this.localizedDayLabel_1 = null;
    this.localizedDaysLabel_0 = null;
    this.localizedDaysLabel_1 = null;
    this.localizedHourLabel_0 = null;
    this.localizedHourLabel_1 = null;
    this.localizedHoursLabel_0 = null;
    this.localizedHoursLabel_1 = null;
    this.localizedMinuteLabel_0 = null;
    this.localizedMinuteLabel_1 = null;
    this.localizedMinutesLabel_0 = null;
    this.localizedMinutesLabel_1 = null;
    this.localizedSecondLabel_0 = null;
    this.localizedSecondLabel_1 =
        null;
    this.localizedSecondsLabel_0 = null;
    this.localizedSecondsLabel_1 = null;
    this.visualWin = null
}
JackpotVisualManager.I = null;
JackpotVisualManager.prototype.XTInitVariablesAndEvents = function() {
    JackpotVisualManager.I = this;
    XT.SetDouble(Vars.JackpotMinBetEligible, 0);
    XT.SetDouble(Vars.ReturnToPlayerWithJackpot, -69);
    XT.SetDouble(Vars.ReturnToPlayerMinWithJackpot, -69)
};
JackpotVisualManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.FromServer_JackpotsInformation, this.JackpotsInformationReceived, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_JackpotCounterStart, this.JackpotCountingStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_JackpotCounterEnded, this.JackpotCountingEnded, this);
    EventManager.AddHandler(JackpotEvents.evtJackpotStateChanged, this.OnJackpotStateChanged, this);
    if (this.arrangeableOnMobile && Globals.isMobile || this.arrangeableOnDesktop &&
        !Globals.isMobile) {
        XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayout, this.OnLayoutChanged, this, 1);
        XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWide, this.OnLayoutChanged, this, 1);
        XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWideFull, this.OnLayoutChanged, this, 1);
        if (this.arrangeableOnMobile && Globals.isMobile) {
            XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayout, this.OnLayoutChanged, this, 1);
            XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPhone,
                this.OnLayoutChanged, this, 1);
            XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPad, this.OnLayoutChanged, this, 1)
        }
    }
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowPlayJackpot, this.OnShowPlayJackpot, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_PlayJackpotClosed, this.OnPlayJackpotClosed, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_PlayJackpot_ShowJackpotVisualWin, this.OnShowJackpotVisualWin, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_PlayJackpot_HideJackpotVisualWin,
        this.OnHideJackpotVisualWin, this)
};
JackpotVisualManager.prototype.OnDestroy = function() {
    XT.UnregisterCallbackObject(this.JackpotsInformationReceived, this);
    XT.UnregisterCallbackEvent(this.JackpotCountingStarted, this);
    XT.UnregisterCallbackEvent(this.JackpotCountingEnded, this)
};
JackpotVisualManager.prototype.JackpotsInformationReceived = function(_jackpotsData) {
    if (this.activeJackpots == null && _jackpotsData != null) {
        for (var i = 0; i < this.animators.length; i++) this.animators[i].animateWhenIncreasing = false;
        if (this.communityWinnerAmountAnimators != null)
            for (var i = 0; i < this.communityWinnerAmountAnimators.length; i++) this.communityWinnerAmountAnimators[i].animateWhenIncreasing = false
    } else if (this.activeJackpots != null && _jackpotsData != null) {
        for (var j = 0; j < this.animators.length; j++) this.animators[j].animateWhenIncreasing =
            true;
        if (this.communityWinnerAmountAnimators != null)
            for (var i = 0; i < this.communityWinnerAmountAnimators.length; i++) this.communityWinnerAmountAnimators[i].animateWhenIncreasing = true
    }
    this.activeJackpots = _jackpotsData;
    if (this.activeJackpots != null) {
        var positions = null;
        if (this.activeJackpots.length == 4) positions = this.positions_4_jackpots;
        else if (this.activeJackpots.length == 3) positions = this.positions_3_jackpots;
        else if (this.activeJackpots.length == 2) positions = this.positions_2_jackpots;
        else positions = this.positions_1_jackpot;
        var allJackpotsRTP = 0;
        var multipliersRTP = 0;
        for (var i = 0; i < this.activeJackpots.length; i++) {
            this.visuals[i].SetJackpotInformation(this.activeJackpots[i]);
            this.visuals[i].transform.localPosition(positions[i].localPosition());
            this.visuals[i].transform.localScale(positions[i].localScale());
            XT.SetDouble(Vars.JackpotMinBetEligible, this.activeJackpots[i].JackpotMinBet);
            allJackpotsRTP += this.activeJackpots[i].contributePercent * 1E3;
            multipliersRTP += this.activeJackpots[i].multipliersRTP * 1E3
        }
        allJackpotsRTP += multipliersRTP /
            this.activeJackpots.length;
        XT.SetDouble(Vars.ReturnToPlayerMinWithJackpot, (allJackpotsRTP + XT.GetDouble(Vars.ReturnToPlayerMin) * 1E3) / 1E3);
        XT.SetDouble(Vars.ReturnToPlayerWithJackpot, (allJackpotsRTP + XT.GetDouble(Vars.ReturnToPlayer) * 1E3) / 1E3)
    }
    this.UpdateJackpots()
};
JackpotVisualManager.prototype.UpdateJackpots = function() {
    if (this.activeJackpots == null || this.jackpotCounting && this.hideWhileCountingJackpot) {
        this.ShowJackpotVisuals(false);
        this.showTitle.Start()
    } else {
        this.hideTitle.Start();
        this.ShowJackpotVisuals(true)
    }
    this.ShowBackgrounds()
};
JackpotVisualManager.prototype.JackpotCountingStarted = function() {
    this.jackpotCounting = true;
    this.UpdateJackpots()
};
JackpotVisualManager.prototype.JackpotCountingEnded = function() {
    this.jackpotCounting = false;
    for (var i = 0; i < this.visuals.length; i++) this.visuals[i].skipUpdate = false;
    this.UpdateJackpots()
};
JackpotVisualManager.prototype.ShowJackpotVisuals = function(visible) {
    var n = this.activeJackpots != null ? this.activeJackpots.length : 0;
    for (var i = 0; i < n; i++)
        if (visible) this.visuals[i].ShowJackpotVisual();
        else this.visuals[i].HideJackpotVisual();
    for (var j = n; j < this.visuals.length; j++) this.visuals[j].HideJackpotVisual()
};
JackpotVisualManager.prototype.ShowBackgrounds = function() {
    var n = this.activeJackpots != null && !(this.jackpotCounting && this.hideWhileCountingJackpot) ? this.activeJackpots.length - 1 : -1;
    if (n < 0) {
        if (this.backgroundSingle != null) this.backgroundSingle.SetActive(false);
        for (var i = 0; i < this.backgrounds.length; i++) this.backgrounds[i].SetActive(false)
    } else if (this.activeJackpots[n].JackpotGroupType == "S") {
        if (this.backgroundSingle != null) this.backgroundSingle.SetActive(true);
        for (var i = 0; i < this.backgrounds.length; i++) this.backgrounds[i].SetActive(false)
    } else {
        if (this.backgroundSingle !=
            null) this.backgroundSingle.SetActive(false);
        for (var i = 0; i < this.backgrounds.length; i++) this.backgrounds[i].SetActive(i == n)
    }
};
JackpotVisualManager.prototype.OnLayoutChanged = function() {
    if (this.activeJackpots != null) {
        var positions = null;
        if (this.activeJackpots.length == 4) positions = this.positions_4_jackpots;
        else if (this.activeJackpots.length == 3) positions = this.positions_3_jackpots;
        else if (this.activeJackpots.length == 2) positions = this.positions_2_jackpots;
        else positions = this.positions_1_jackpot;
        for (var i = 0; i < this.activeJackpots.length; i++) {
            this.visuals[i].transform.localPosition(positions[i].localPosition());
            this.visuals[i].transform.localScale(positions[i].localScale())
        }
    }
};
JackpotVisualManager.prototype.OnJackpotStateChanged = function(param) {
    var jpData = param;
    if (!jpData.IsWin || jpData.IsWin && this.skipJackpotUpdate) {
        this.skipJackpotUpdate = false;
        return
    }
    var currentJackpot = jpData.JackpotOrder;
    if (currentJackpot >= 0) {
        if (currentJackpot < this.animators.length) this.animators[currentJackpot].Stop();
        this.visuals[currentJackpot].skipUpdate = true;
        this.visuals[currentJackpot].contentAmount[currentJackpot].GetComponent(ValueDisplayer).SetValueManually(jpData.WinJackpotAmount)
    }
};
JackpotVisualManager.prototype.OnShowJackpotVisualWin = function() {
    this.visualWin = null;
    var jpData = XT.GetObject(Vars.PlayJackpotData);
    var jpInfo = XT.GetObject(Vars.PlayJackpot_JackpotInformation);
    var jpOrder = jpData.JackpotOrder;
    if (jpOrder < 0) return;
    if (jpOrder < this.animators.length) this.animators[jpOrder].Stop();
    if (this.communityWinnerAmountAnimators != null && jpOrder < this.communityWinnerAmountAnimators.length) this.communityWinnerAmountAnimators[jpOrder].Stop();
    this.visualWin = this.visuals[jpOrder];
    this.visualWin.skipUpdate =
        true;
    var winnerAmount = jpData.WinJackpotAmount;
    var jpAmount = winnerAmount;
    var isCommunityJP = jpInfo.JackpotCommunityDetails != null;
    if (isCommunityJP) {
        var sharePercent = jpInfo.JackpotCommunityDetails.sharedPercentage;
        var shareAmount = sharePercent / (100 - sharePercent) * winnerAmount;
        jpAmount = shareAmount + winnerAmount
    }
    if (jpInfo.JackpotGroupType == "S") {
        if (this.visualWin.singleJackpotAmount != null) this.visualWin.singleJackpotAmount.GetComponent(ValueDisplayer).SetValueManually(jpAmount);
        if (isCommunityJP && this.visualWin.singleCommunityWinnerAmount !=
            null) this.visualWin.singleCommunityWinnerAmount.SetValueManually(winnerAmount)
    } else {
        this.visualWin.contentAmount[jpOrder].GetComponent(ValueDisplayer).SetValueManually(jpAmount);
        if (isCommunityJP && this.visualWin.communityWinnerAmount != null && jpOrder < this.visualWin.communityWinnerAmount.length) this.visualWin.communityWinnerAmount[jpOrder].SetValueManually(winnerAmount)
    }
    this.visualWin.ShowJackpotVisualWin()
};
JackpotVisualManager.prototype.OnHideJackpotVisualWin = function() {
    if (this.visualWin == null) return;
    this.visualWin.skipUpdate = false;
    this.visualWin.HideJackpotVisualWin()
};
JackpotVisualManager.prototype.OnShowPlayJackpot = function() {
    if (this.skipUpdateInPlayJackpot)
        for (var i = 0; i < this.visuals.length; ++i) this.visuals[i].skipUpdate = true
};
JackpotVisualManager.prototype.OnPlayJackpotClosed = function() {
    if (this.skipUpdateInPlayJackpot)
        for (var i = 0; i < this.visuals.length; ++i) this.visuals[i].skipUpdate = false
};
JackpotVisualManager.prototype.FormatSeconds = function(seconds) {
    if (!this.useLocalizedLabels) return seconds.toString();
    var ret = "";
    var dhms = new Tournament.DHMS(seconds);
    var d = dhms.d;
    var h = dhms.h;
    var m = dhms.m;
    var s = dhms.s;
    if (d == 1) ret += this.localizedDayLabel_0.text + d.toString() + this.localizedDayLabel_1.text;
    else if (d > 1) ret += this.localizedDaysLabel_0.text + d.toString() + this.localizedDaysLabel_1.text;
    if (h == 1) ret += this.localizedHourLabel_0.text + h.toString() + this.localizedHourLabel_1.text;
    else if (h > 1) ret +=
        this.localizedHoursLabel_0.text + h.toString() + this.localizedHoursLabel_1.text;
    if (m == 1) ret += this.localizedMinuteLabel_0.text + m.toString() + this.localizedMinuteLabel_1.text;
    else if (m > 1) ret += this.localizedMinutesLabel_0.text + m.toString() + this.localizedMinutesLabel_1.text;
    if (s == 1) ret += this.localizedSecondLabel_0.text + s.toString() + this.localizedSecondLabel_1.text;
    else if (s > 1) ret += this.localizedSecondsLabel_0.text + s.toString() + this.localizedSecondsLabel_1.text;
    return _string.Trim(ret)
};
goog.provide("UHT.VideoSlotsConnection");
goog.require("UHT.Engine");
goog.require("UHT.JackpotHelpers");
var VSCStagedHandler = {
    None: 0,
    Spin: 1
};
var VSCHandlerStage = {
    Stage_0: 0,
    Stage_1: 1,
    Stage_2: 2
};
VideoSlotsConnection.prototype = Object.create(Component.prototype);
VideoSlotsConnection.prototype.constructor = VideoSlotsConnection;

function VideoSlotsConnection() {
    Component.call(this);
    this.xtLayer = null;
    this.serverRequestSent = false;
    this.realMoney = false;
    this.isInit = true;
    this.lastResponse = null;
    this.fsbgLastResponse = null;
    this.fsgbResponse = null;
    this.storedPaytable = null;
    this.storedMaxFS = -1;
    this.Bets = null;
    this.gambleResponse = null;
    this.gambleColorMultiplier = -1;
    this.gambleSuitMultiplier = -1;
    this.gambleDiceMultiplier = -1;
    this.gambleCardHistory = null;
    this.canGamble = false;
    this.stagedHandler = VSCStagedHandler.None;
    this.handlerStage = VSCHandlerStage.Stage_0
}
VideoSlotsConnection.cleanupPreviousWin = false;
VideoSlotsConnection.isUnfinishedGame = false;
VideoSlotsConnection.prototype.Awake = function() {
    this.Bets = [.01, .02, .05, .1, .25, .5, 1, 3, 5]
};
VideoSlotsConnection.prototype.Update = function() {
    if (this.stagedHandler == VSCStagedHandler.None) return;
    switch (this.stagedHandler) {
        case VSCStagedHandler.Spin:
            this.HandlerSpinResult(this.lastResponse);
            break
    }
};
VideoSlotsConnection.prototype.AddServerCallbacks = function() {
    EventManager.AddHandler(GameEvents.evtInitResponse + this.xtLayer.gameSymbol, this.HandlerGameInit, this);
    EventManager.AddHandler(GameEvents.evtSpinResponse + this.xtLayer.gameSymbol, this.HandlerSpinResult, this);
    EventManager.AddHandler(GameEvents.evtNoMoneySpinResponse, this.HandlerNoMoneySpinResult, this);
    EventManager.AddHandler(GameEvents.evtConfigSwitchedResponse + this.xtLayer.gameSymbol, this.HandlerConfigSwitched, this);
    EventManager.AddHandler(GameEvents.evtGambleResponse +
        this.xtLayer.gameSymbol, this.HandlerGambleV2Response, this);
    EventManager.AddHandler(GameEvents.evtMustPlayJackpot + this.xtLayer.gameSymbol, this.HandlerMustPlayJackpot, this);
    EventManager.AddHandler(GameEvents.evtPlayJackpotResponse + this.xtLayer.gameSymbol, this.HandlerPlayJackpotResponse, this);
    EventManager.AddHandler(JackpotEvents.evtJackpotsUpdated, this.HandlerJackpotsUpdated, this);
    EventManager.AddHandler(GameEvents.evtFSBGInitResponse + this.xtLayer.gameSymbol, this.HandlerFSBGInit, this);
    EventManager.AddHandler(GameEvents.evtFSBGPickResponse +
        this.xtLayer.gameSymbol, this.HandlerFSBGResponse, this);
    EventManager.AddHandler(GameEvents.evtMysteryScatterResponse + this.xtLayer.gameSymbol, this.HandlerMysteryScatter, this);
    EventManager.AddHandler(GameEvents.evtFreeRoundsUpdate, this.HandlerFreeRoundUpdate, this);
    EventManager.AddHandler(GameEvents.evtFSOptionsUpdate + this.xtLayer.gameSymbol, this.HandlerFreeSpinOptionsUpdate, this);
    EventManager.AddHandler(GameEvents.evtServerTimeUpdate, this.HandlerServerTimeUpdate, this);
    EventManager.AddHandler(ApplicationEvents.evtServerOptionsParsed,
        this.OnServerOptionsParsed, this)
};
VideoSlotsConnection.prototype.OnServerOptionsParsed = function() {
    this.xtLayer.RequirementsSetup()
};
VideoSlotsConnection.prototype.SpinPressed = function(lines, betPerLine) {
    var request = new VsRequest;
    request.Symbol = String(this.xtLayer.gameSymbol);
    request.Bet = betPerLine;
    request.Line = lines;
    var progressiveConfig = XT.GetObject(Vars.ProgressiveFeatureConfig);
    if (progressiveConfig != null && progressiveConfig.pickedSymbolPosition != -1) request.ProgressPick = progressiveConfig.pickedSymbolPosition;
    console.log("Sending spin request");
    this.serverRequestSent = true;
    EventManager.Trigger(GameEvents.evtSpinRequest + this.xtLayer.gameSymbol,
        request)
};
VideoSlotsConnection.prototype.InitReels = function() {
    this.xtLayer.InitReelSymbols(this.lastResponse.VsInitData.ReelSymbols);
    if (this.lastResponse.ReelPositions == null) {
        XT.SetBool(Vars.HiddenMathematics, true);
        this.lastResponse.ReelPositions = [];
        for (var i = 0; i < this.lastResponse.WinScreenSymbols.length; i++) this.lastResponse.ReelPositions.push(0)
    }
    this.xtLayer.InitReelsPositions(this.lastResponse.ReelPositions);
    this.xtLayer.SetReelStopPositions(this.lastResponse.ReelPositions)
};
VideoSlotsConnection.prototype.InitNextReels = function() {
    var nextReelSymbols = [];
    if (this.lastResponse.ReelSetIndex >= 0) {
        var reelSets = XT.GetObject(Vars.ReelSets);
        nextReelSymbols = reelSets[this.lastResponse.ReelSetIndex]
    } else nextReelSymbols = this.lastResponse.VsInitData.NextReelSymbols;
    this.xtLayer.InitNextReelSymbols(nextReelSymbols)
};
VideoSlotsConnection.prototype.InitReelSets = function() {
    this.xtLayer.UpdateReelSetIndexes(this.lastResponse.ReelSetIndexCurrent);
    this.xtLayer.SetReelSets(this.lastResponse.VsInitData.ReelSets)
};
VideoSlotsConnection.prototype.Start = function() {};
VideoSlotsConnection.prototype.Init = function() {
    console.log("VideoSlotsConnection - Init")
};
VideoSlotsConnection.prototype.OnDestroy = function() {};
VideoSlotsConnection.prototype.OnShowResult = function() {};
VideoSlotsConnection.prototype.OnFreeSpinsClosed = function() {
    EventManager.Trigger(GameEvents.evtFreespinsFinished + this.xtLayer.gameSymbol, null)
};
VideoSlotsConnection.prototype.IsInit = function() {
    return this.isInit
};
VideoSlotsConnection.prototype.Vs_InitData = function() {
    return this.lastResponse.VsInitData
};
VideoSlotsConnection.prototype.GetSymbolPaytable = function(symbolId) {
    return this.storedPaytable[symbolId]
};
VideoSlotsConnection.prototype.WonTheJackpot = function() {
    if (this.lastResponse != null) return this.lastResponse.IsJackpotWin();
    else return false
};
VideoSlotsConnection.prototype.IsFreeSpin = function() {
    return this.lastResponse.IsFreeSpins() && this.lastResponse.VsFreeSpin.GetMaxNumber() != 0
};
VideoSlotsConnection.prototype.IsNeedMysteryScatter = function() {
    return this.lastResponse.VsFreeSpin.IsNeedGetMysteryScatter()
};
VideoSlotsConnection.prototype.HasMysteryScatter = function() {
    return this.lastResponse.IsFreeSpins() && this.lastResponse.VsFreeSpin.GetMysteryScatter().length > 0
};
VideoSlotsConnection.prototype.GetMysteryScatter = function() {
    return this.lastResponse.VsFreeSpin.GetMysteryScatter()
};
VideoSlotsConnection.prototype.SetLastFreesSpinsNull = function() {
    this.lastResponse.SetVsFreeSpin(null)
};
VideoSlotsConnection.prototype.GetWinValue = function() {
    return this.lastResponse.Win
};
VideoSlotsConnection.prototype.IsFreeSpinWin = function() {
    if (this.IsFreeSpin())
        if (this.FreeSpinMaxNumber() > 0 && this.storedMaxFS < this.FreeSpinMaxNumber()) {
            this.storedMaxFS = this.FreeSpinMaxNumber();
            return true
        } else return false;
    this.storedMaxFS = -1;
    return false
};
VideoSlotsConnection.prototype.IsLastFreeSpin = function() {
    return this.lastResponse.IsFreeSpins() && this.lastResponse.VsFreeSpin.IsLastFreeSpin()
};
VideoSlotsConnection.prototype.FreeSpinTotalNumber = function() {
    return this.lastResponse.VsFreeSpin.GetTotalNumber()
};
VideoSlotsConnection.prototype.FreeSpinCurrentNumber = function() {
    return this.lastResponse.VsFreeSpin.GetCurrentNumber()
};
VideoSlotsConnection.prototype.FreeSpinMaxNumber = function() {
    return this.lastResponse.VsFreeSpin.GetMaxNumber()
};
VideoSlotsConnection.prototype.FreeSpinTotalMultipl = function() {
    return this.lastResponse.VsFreeSpin.GetTotalMultipl()
};
VideoSlotsConnection.prototype.FreeSpinCurrentWin = function() {
    return this.lastResponse.VsFreeSpin.GetCurrentWin()
};
VideoSlotsConnection.prototype.FreeSpinTotalWin = function() {
    return this.lastResponse.VsFreeSpin.GetTotalWin()
};
VideoSlotsConnection.prototype.FreeSpinCurrentWinMultiplied = function() {
    return this.lastResponse.VsFreeSpin.GetCurrentWinMultiplied()
};
VideoSlotsConnection.prototype.FreeSpinTotalWinMultiplied = function() {
    return this.lastResponse.VsFreeSpin.GetTotalWinMultiplied()
};
VideoSlotsConnection.prototype.GambleGetBalance = function() {
    return this.gambleResponse.Balance
};
VideoSlotsConnection.prototype.GambleGetCard = function() {
    return this.gambleResponse.Card
};
VideoSlotsConnection.prototype.GambleGetDice1 = function() {
    return this.gambleResponse.Dice1
};
VideoSlotsConnection.prototype.GambleGetDice2 = function() {
    return this.gambleResponse.Dice2
};
VideoSlotsConnection.prototype.GambleIsNoMoney = function() {
    return this.gambleResponse.NoMoney
};
VideoSlotsConnection.prototype.HasFreeSpinOptions = function() {
    return this.lastResponse.HasFreeSpinOptions()
};
VideoSlotsConnection.prototype.IsFreeSpinsBonusGame = function() {
    return this.lastResponse.IsFreeSpinBonusGame()
};
VideoSlotsConnection.prototype.FSBG_GameOver = function() {
    return this.fsbgLastResponse.VsFreeSpin.BonusGame.GameOver
};
VideoSlotsConnection.prototype.FSBG_Lives = function() {
    return Number(this.fsbgLastResponse.VsFreeSpin.BonusGame.Lifes)
};
VideoSlotsConnection.prototype.FSBG_Level = function() {
    return this.fsbgLastResponse.VsFreeSpin.BonusGame.Level
};
VideoSlotsConnection.prototype.FSBG_Items = function() {
    return this.fsbgLastResponse.VsFreeSpin.BonusGame.BonusItems
};
VideoSlotsConnection.prototype.FSBG_Close = function() {
    var vsfs = this.fsbgLastResponse.VsFreeSpin;
    vsfs.SetCurrentNumber(1);
    vsfs.SetMaxNumber(vsfs.BonusGame.SpinsWin);
    vsfs.SetTotalMultipl(vsfs.BonusGame.MultipliersWin);
    vsfs.BonusGame = null;
    this.lastResponse.SetVsFreeSpin(vsfs);
    this.IsFreeSpinWin()
};
VideoSlotsConnection.prototype.FSBG_WinMultipliers = function() {
    return this.fsbgLastResponse.VsFreeSpin.BonusGame.MultipliersWin
};
VideoSlotsConnection.prototype.FSBG_WinSpins = function() {
    return this.fsbgLastResponse.VsFreeSpin.BonusGame.SpinsWin
};
VideoSlotsConnection.prototype.FSBG_InProgress = function() {
    if (this.fsbgLastResponse != null) {
        if (this.fsbgLastResponse.VsFreeSpin.BonusGame.GameOver) return true;
        if (this.fsbgLastResponse.VsFreeSpin.BonusGame.BonusItems != null && this.fsbgLastResponse.VsFreeSpin.BonusGame.BonusItems.length > 0)
            for (var i = 0; i < this.fsbgLastResponse.VsFreeSpin.BonusGame.BonusItems.length; ++i)
                if (this.fsbgLastResponse.VsFreeSpin.BonusGame.BonusItems[i].Status == VsFreeSpinBonusGame.BonusItem.BonusItemStatus.Selected) return true
    }
    return false
};
VideoSlotsConnection.prototype.InitFakeGambleState = function() {
    if (this.gambleResponse == null) this.gambleResponse = new VsGamblingResponse;
    this.gambleResponse.State = GamblingState.Win
};
VideoSlotsConnection.prototype.SendGambleOpen = function() {
    this.InitFakeGambleState();
    XT.TriggerEvent(Vars.Evt_FromServer_GambleOpen)
};
VideoSlotsConnection.prototype.SendGambleBack = function() {
    XT.TriggerEvent(Vars.Evt_FromServer_GambleClose);
    EventManager.Trigger(GameEvents.evtGambleClose + this.xtLayer.gameSymbol, null)
};
VideoSlotsConnection.prototype.SendGambleChoice = function(choice) {
    var gambleRequest = new VsGamblingRequest;
    gambleRequest.Choice = choice;
    this.serverRequestSent = true;
    EventManager.Trigger(GameEvents.evtGambleRequest + this.xtLayer.gameSymbol, gambleRequest)
};
VideoSlotsConnection.prototype.FSOption_SendPick = function(itemIndex) {
    var choice = new VsBonusGamePlayerChoice(itemIndex);
    EventManager.Trigger(GameEvents.evtFSOptionPickRequest + this.xtLayer.gameSymbol, choice)
};
VideoSlotsConnection.prototype.FSBG_SendPick = function(itemIndex) {
    var choice = new VsBonusGamePlayerChoice(itemIndex);
    EventManager.Trigger(GameEvents.evtFSBGPickRequest + this.xtLayer.gameSymbol, choice)
};
VideoSlotsConnection.prototype.SendGetJackpots = function() {};
VideoSlotsConnection.prototype.SendGetJackpotsGames = function() {};
VideoSlotsConnection.prototype.HandlerJackpotsUpdated = function(jackpots) {
    this.xtLayer.SetJackpotsInfo(jackpots)
};
VideoSlotsConnection.prototype.HandlerGameInit = function(vsResponse) {
    console.log("VideoSlotsConnection - this.HandlerGameInit");
    this.isInit = true;
    this.lastResponse = vsResponse;
    if (this.lastResponse == null) {
        console.error("Null response from server!");
        return
    }
    if (VideoSlotsConnection.cleanupPreviousWin) {
        if (this.lastResponse.VsBonusGame != null)
            if (this.lastResponse.VsBonusGame.currentBonusRespin == this.lastResponse.VsBonusGame.maxBonusRespins && this.lastResponse.VsBonusGame.currentBonusRespin != 0) this.lastResponse.VsBonusGame =
                null;
        if (this.IsLastFreeSpin()) {
            this.lastResponse.VsFreeSpin = null;
            this.lastResponse.StickySymbols = null
        }
        this.lastResponse.Win = 0;
        this.lastResponse.VsWinLines = [];
        if (!VideoSlotsConnection.isUnfinishedGame) this.lastResponse.SpinCycleWin = 0
    }
    this.storedPaytable = this.lastResponse.VsInitData.Paytable;
    this.xtLayer.SetPaytableInfo(this.storedPaytable);
    var gambleSettings = this.lastResponse.VsInitData.GamblingSettings;
    if (gambleSettings != null) {
        if (gambleSettings.GetGamblingSettings(GamblingType.CardColor) != null) this.gambleColorMultiplier =
            Number(gambleSettings.GetGamblingSettings(GamblingType.CardColor));
        if (gambleSettings.GetGamblingSettings(GamblingType.Suit) != null) this.gambleSuitMultiplier = Number(gambleSettings.GetGamblingSettings(GamblingType.Suit));
        var b1 = gambleSettings.IsOccasionEnable(GamblingOccasions.Spin);
        var b2 = gambleSettings.IsOccasionEnable(GamblingOccasions.FreeSpin);
        var b3 = gambleSettings.IsOccasionEnable(GamblingOccasions.Bonus);
        this.xtLayer.SetGambleSettings(b1, b2, b3, this.gambleColorMultiplier, this.gambleSuitMultiplier)
    }
    var gamblingHistory =
        this.lastResponse.VsInitData.GamblingHistory;
    if (gamblingHistory != null) {
        var gHistory = gamblingHistory.History;
        this.gambleCardHistory = [];
        for (var i = 0; i < gHistory.length; ++i) this.gambleCardHistory[i] = gHistory[i].Card;
        this.gambleResponse = gamblingHistory.History[gamblingHistory.History.length - 1];
        this.gambleResponse.Balance = gamblingHistory.WinAmount
    }
    this.xtLayer.SetGambleHistory(gamblingHistory);
    this.canGamble = this.lastResponse.VsGamblingButtonState.GamblingOnSpinAvailable;
    if (this.canGamble && gamblingHistory !=
        null && gambleSettings.InitGamblingOccasion == GamblingOccasions.Spin) this.canGamble = false;
    this.xtLayer.SetCanGambleSpinWin(this.canGamble);
    var gameHasGamble = gambleSettings.IsOccasionEnable(GamblingOccasions.Bonus) || gambleSettings.IsOccasionEnable(GamblingOccasions.Spin) || gambleSettings.IsOccasionEnable(GamblingOccasions.FreeSpin);
    if (gameHasGamble && (gambleSettings.SkipGambleOnInit || this.lastResponse.Win <= 0)) this.xtLayer.SkipResultDisplayOnInit();
    if (this.IsFreeSpin()) this.storedMaxFS = this.FreeSpinMaxNumber();
    this.InitReels();
    this.InitReelSets();
    if (this.lastResponse.VsInitData != null && this.lastResponse.VsInitData.NextReelSymbols != null || this.lastResponse.ReelSetIndex >= 0) this.InitNextReels();
    this.xtLayer.SetStackedSymbolIndex(this.lastResponse.StackedSymbolIndex);
    this.xtLayer.SetBetLines(this.lastResponse.VsInitData.Line);
    this.xtLayer.SetRandomWildsData(this.lastResponse.RandomWildsData, this.lastResponse.UpSymbols);
    this.xtLayer.SetWildRandomLineMpConfig(this.lastResponse.VsInitData.WildRandomLineMpConfig);
    this.xtLayer.SetNASymbolId(this.lastResponse.VsInitData.naSymbolId);
    this.xtLayer.SetWRLMResponse(this.lastResponse.WRLMResponse);
    this.xtLayer.SetWRLMCurrentSets(this.lastResponse.WRLMCurrentSets);
    this.xtLayer.SetRandomAwardsConfig(this.lastResponse.VsInitData.RandomAwardConfig);
    this.xtLayer.SetRandomAwardResponse(this.lastResponse.RandomAwardResponse);
    this.xtLayer.SetRandomSymbolMultipliers(this.lastResponse.RandomSymbolMultipliers);
    this.xtLayer.SetPossibleRandomSymbolMultipliers(this.lastResponse.PossibleRandomSymbolMultipliers);
    this.xtLayer.SetFreeSpinsChainData(this.lastResponse.FreeSpinsChainData);
    this.xtLayer.SetOpeningSymbolsData(this.lastResponse.OpeningSymbolsData);
    this.xtLayer.SetRandomMysterySymbolsIds(this.lastResponse.RandomMysterySymbolId);
    this.xtLayer.SetPatternedMysterySymbols(this.lastResponse.PatternedMysterySymbols);
    this.xtLayer.SetInitialMysterySymbolsIds(this.lastResponse.VsInitData.InitialMysterySymbolId);
    this.xtLayer.SetInitialBGItemValues(this.lastResponse.VsInitData.BGItemValues);
    this.xtLayer.SetInitialBGItemMasks(this.lastResponse.VsInitData.BGItemMasks);
    this.xtLayer.InitFirstScreenSymbols(this.lastResponse.WinScreenSymbols);
    if (this.lastResponse.SymbolsBeforeExpanding != null && this.lastResponse.SymbolsBeforeExpanding.length > 0) this.xtLayer.SetInitialResultScreenSymbols(this.lastResponse.SymbolsBeforeExpanding);
    else this.xtLayer.SetInitialResultScreenSymbols(this.lastResponse.WinScreenSymbols);
    this.xtLayer.SetGoldSymbol(this.lastResponse.GoldSymbol);
    this.xtLayer.SetSymbolReplacementData(this.lastResponse.SymbolReplacementData);
    this.xtLayer.SetResultScreenSymbols(this.lastResponse.WinScreenSymbols);
    this.xtLayer.SetSymbolsAbove(this.lastResponse.SymbolsAbove);
    this.xtLayer.SetSymbolsBelow(this.lastResponse.SymbolsBelow);
    this.xtLayer.SetNextReelsSymbolsList(this.lastResponse.NextReelsSymbolsList);
    this.xtLayer.SetHasCoins(ServerOptions.amountType != "CURRENCY");
    this.Bets = this.lastResponse.VsInitData.Bets;
    this.xtLayer.SetExplicitMaxTotalBet(this.lastResponse.VsInitData.ExplicitMaxTotalBet);
    if (ServerOptions.isReplay) {
        this.Bets = [this.lastResponse.VsInitData.Bet];
        this.lastResponse.VsInitData.DefaultBet =
            this.lastResponse.VsInitData.Bet
    }
    this.xtLayer.SetBets(this.Bets, this.lastResponse.VsInitData.Bet, this.lastResponse.VsInitData.DefaultBet);
    this.xtLayer.SetBalance(this.lastResponse.Balance, false);
    this.xtLayer.SetWinValue(this.lastResponse.Win);
    this.xtLayer.SetSpinCycleWinValue(this.lastResponse.SpinCycleWin);
    this.xtLayer.SetExtraAwardWin(this.lastResponse.ExtraAwardWin);
    this.xtLayer.SetRespinCycleWin(this.lastResponse.RespinCycleWin);
    var linesWin = 0;
    for (var i = 0; i < this.lastResponse.VsWinLines.length; ++i) {
        var vswl =
            this.lastResponse.VsWinLines[i];
        linesWin += vswl.WinAmount
    }
    this.xtLayer.SetLinesWinValue(linesWin);
    this.xtLayer.SetWinLines(this.lastResponse.VsWinLines);
    var isGamble = this.lastResponse.isGambleV2();
    this.xtLayer.SetGambleV2Response(this.lastResponse.gambleV2Data);
    this.xtLayer.SetMustOpenGambleV2(isGamble);
    this.xtLayer.SetMustOpenBonus(this.lastResponse.IsBonus() && !isGamble, this.lastResponse.IsBonusGameOver() && this.lastResponse.NextGameActions.indexOf(NextGameAction.Bonus) > -1);
    this.isInit = false;
    this.xtLayer.SetExpandingSymbolsData(this.lastResponse.ExpandingSymbolsData);
    this.xtLayer.SetRespinData(this.lastResponse.Respin);
    this.xtLayer.SetProgressiveFeatureConfig(this.lastResponse.VsInitData.ProgressiveConfig);
    this.xtLayer.SetProgressiveFeatureData(this.lastResponse.ProgressiveData);
    this.xtLayer.SetMoneySymbolConfig(this.lastResponse.VsInitData.MoneySymbolConfig);
    this.xtLayer.SetMoneySymbolData(this.lastResponse.MoneySymbolData);
    this.xtLayer.SetStickySymbolsData(this.lastResponse.StickySymbols);
    this.xtLayer.SetMergingSymbolsData(this.lastResponse.MergingSymbols);
    this.xtLayer.SetJackpotState(this.lastResponse.VsJackpotData);
    if (this.WonTheJackpot()) {
        var jpData = this.lastResponse.VsJackpotData;
        this.xtLayer.SetJackpotWon(jpData.JackpotID, jpData.JackpotOrder, jpData.WinJackpotAmount)
    }
    this.xtLayer.SetJackpotVisualization(this.lastResponse.JackpotVisualisation);
    if (this.HasFreeSpinOptions()) this.xtLayer.MustOpenFSOptions(this.lastResponse.FreeSpinsOptions);
    if (this.IsFreeSpinsBonusGame() && this.lastResponse.VsFreeSpin.BonusGame.GameOver) {
        this.fsgbResponse = this.lastResponse.Clone();
        this.fsgbResponse.VsFreeSpin.SetTotalMultipl(this.lastResponse.VsFreeSpin.BonusGame.MultipliersWin);
        this.fsgbResponse.VsFreeSpin.SetMaxNumber(this.lastResponse.VsFreeSpin.BonusGame.SpinsWin);
        this.fsgbResponse.VsFreeSpin.SetCurrentNumber(1);
        this.xtLayer.SetFreeSpinResponseReceived(this.fsgbResponse.VsFreeSpin)
    } else {
        this.xtLayer.SetFreeSpinResponseReceived(this.lastResponse.VsFreeSpin);
        if (XT.GetBool(Vars.TruncateFSResponseDuringRespin)) this.xtLayer.SetTruncatedFSResponseReceived(this.lastResponse.TruncatedVsFreeSpin)
    }
    if ((this.lastResponse.GetVsFreeSpin() !=
            null && this.lastResponse.GetVsFreeSpin().IsLastFreeSpin() || this.lastResponse.GetVsFreeSpin() == null) && XT.GetBool(Vars.OpenFSBGForMysteryScatter)) this.xtLayer.SetStartFSBG(false);
    if (this.lastResponse.VsFreeSpin != null) {
        var msList = this.lastResponse.VsFreeSpin.GetMysteryScatter();
        if (msList.length > 0) this.xtLayer.SetMysteryScatterSymbolIds(msList)
    }
    if (this.IsFreeSpin() && this.IsNeedMysteryScatter()) {
        this.fsgbResponse = this.lastResponse.Clone();
        this.xtLayer.SetStartFSBG(true)
    } else if (this.IsFreeSpinsBonusGame() &&
        !this.lastResponse.VsFreeSpin.BonusGame.GameOver) {
        this.fsgbResponse = this.lastResponse.Clone();
        this.xtLayer.SetStartFSBG(false)
    }
    this.xtLayer.SetWildRandomMultipliers(this.lastResponse.WildRandomMultipliers);
    this.xtLayer.UpdateBonusRoundsInfo(this.lastResponse);
    this.xtLayer.SetReturnToPlayer(this.lastResponse.ReturnToPlayer);
    this.xtLayer.SetReturnToPlayerMin(this.lastResponse.ReturnToPlayerMin);
    this.xtLayer.SetNudgedSymbolsData(this.lastResponse.NudgedSymbolsData);
    this.xtLayer.SetSpinOneReelValues(this.lastResponse.SpinOneReelData);
    this.xtLayer.SetTumblingWin(this.lastResponse.TumblingWin);
    this.xtLayer.SetTumblingData(this.lastResponse.TumblingData);
    this.xtLayer.SetBetLevelSettings(this.lastResponse.VsInitData.BetLevelSettings);
    this.xtLayer.SetFSPurchaseConfig(this.lastResponse.VsInitData.FreeSpinsPurchaseConfig);
    this.xtLayer.SetFSPurchaseData(this.lastResponse.FreeSpinsPurchaseData);
    XT.TriggerEvent(FOXVars.Evt_FOX_AfterInitReceived);
    this.xtLayer.InitReceived();
    this.xtLayer.SetBonusBalance(this.lastResponse.BonusBalance)
};
VideoSlotsConnection.prototype.HandlerConfigSwitched = function(arg) {
    console.log("VideoSlotsConnection - HandlerConfigSwitched");
    this.lastResponse = arg;
    if (this.lastResponse == null) {
        console.error("Null response from server!");
        return
    }
    this.storedPaytable = this.lastResponse.VsInitData.Paytable;
    this.xtLayer.SetPaytableInfo(this.storedPaytable);
    var gambleSettings = this.lastResponse.VsInitData.GamblingSettings;
    if (gambleSettings != null) {
        if (gambleSettings.GetGamblingSettings(GamblingType.CardColor) != null) this.gambleColorMultiplier =
            Number(gambleSettings.GetGamblingSettings(GamblingType.CardColor));
        if (gambleSettings.GetGamblingSettings(GamblingType.Suit) != null) this.gambleSuitMultiplier = Number(gambleSettings.GetGamblingSettings(GamblingType.Suit));
        var b1 = gambleSettings.IsOccasionEnable(GamblingOccasions.Spin);
        var b2 = gambleSettings.IsOccasionEnable(GamblingOccasions.FreeSpin);
        var b3 = gambleSettings.IsOccasionEnable(GamblingOccasions.Bonus);
        this.xtLayer.SetGambleSettings(b1, b2, b3, this.gambleColorMultiplier, this.gambleSuitMultiplier)
    }
    this.InitReels();
    this.InitReelSets();
    if (this.lastResponse.VsInitData != null && this.lastResponse.VsInitData.NextReelSymbols != null || this.lastResponse.ReelSetIndex >= 0) this.InitNextReels();
    this.xtLayer.SetStackedSymbolIndex(this.lastResponse.StackedSymbolIndex);
    this.xtLayer.SetReturnToPlayer(this.lastResponse.ReturnToPlayer);
    this.xtLayer.SetReturnToPlayerMin(this.lastResponse.ReturnToPlayerMin)
};
VideoSlotsConnection.prototype.HandlerSpinResult = function(arg) {
    console.log("VideoSlotsConnection - this.HandlerSpinResult");
    this.serverRequestSent = false;
    this.lastResponse = arg;
    if (this.lastResponse != null) switch (this.handlerStage) {
        case VSCHandlerStage.Stage_0:
            if (this.lastResponse.VsInitData != null && this.lastResponse.VsInitData.ReelSymbols != null) this.InitReels();
            if (this.lastResponse.ReelSetIndexCurrent >= 0) {
                this.xtLayer.UpdateReelSetIndexes(this.lastResponse.ReelSetIndexCurrent);
                this.xtLayer.InitReelSymbols(XT.GetObject(Vars.ReelSets)[this.lastResponse.ReelSetIndexCurrent])
            }
            if (this.lastResponse.VsInitData !=
                null && this.lastResponse.VsInitData.NextReelSymbols != null || this.lastResponse.ReelSetIndex >= 0) this.InitNextReels();
            this.canGamble = this.lastResponse.VsGamblingButtonState.GamblingOnSpinAvailable;
            this.xtLayer.SetStackedSymbolIndex(this.lastResponse.StackedSymbolIndex);
            this.xtLayer.SetCanGambleSpinWin(this.canGamble);
            this.xtLayer.SetWRLMResponse(this.lastResponse.WRLMResponse);
            this.xtLayer.SetWinLines(this.lastResponse.VsWinLines);
            if (this.lastResponse.ReelPositions == null) {
                this.lastResponse.ReelPositions = [];
                for (var i = 0; i < this.lastResponse.WinScreenSymbols.length; i++) this.lastResponse.ReelPositions.push(0)
            }
            this.xtLayer.SetReelStopPositions(this.lastResponse.ReelPositions);
            this.xtLayer.SetExpandingSymbolsData(this.lastResponse.ExpandingSymbolsData);
            this.xtLayer.SetRandomWildsData(this.lastResponse.RandomWildsData, this.lastResponse.UpSymbols);
            this.xtLayer.SetWRLMCurrentSets(this.lastResponse.WRLMCurrentSets);
            this.xtLayer.SetRandomAwardResponse(this.lastResponse.RandomAwardResponse);
            this.xtLayer.SetRandomSymbolMultipliers(this.lastResponse.RandomSymbolMultipliers);
            this.xtLayer.SetPossibleRandomSymbolMultipliers(this.lastResponse.PossibleRandomSymbolMultipliers);
            this.xtLayer.SetFreeSpinsChainData(this.lastResponse.FreeSpinsChainData);
            this.xtLayer.SetOpeningSymbolsData(this.lastResponse.OpeningSymbolsData);
            this.xtLayer.SetSpinOneReelValues(this.lastResponse.SpinOneReelData);
            this.xtLayer.SetTumblingWin(this.lastResponse.TumblingWin);
            this.xtLayer.SetTumblingData(this.lastResponse.TumblingData);
            this.xtLayer.SetRandomMysterySymbolsIds(this.lastResponse.RandomMysterySymbolId);
            this.xtLayer.SetPatternedMysterySymbols(this.lastResponse.PatternedMysterySymbols);
            if (this.lastResponse.SymbolsBeforeExpanding != null && this.lastResponse.SymbolsBeforeExpanding.length > 0) this.xtLayer.SetInitialResultScreenSymbols(this.lastResponse.SymbolsBeforeExpanding);
            else this.xtLayer.SetInitialResultScreenSymbols(this.lastResponse.WinScreenSymbols);
            this.xtLayer.SetGoldSymbol(this.lastResponse.GoldSymbol);
            this.xtLayer.SetSymbolReplacementData(this.lastResponse.SymbolReplacementData);
            this.xtLayer.SetResultScreenSymbols(this.lastResponse.WinScreenSymbols);
            this.xtLayer.SetSymbolsAbove(this.lastResponse.SymbolsAbove);
            this.xtLayer.SetSymbolsBelow(this.lastResponse.SymbolsBelow);
            this.xtLayer.SetNextReelsSymbolsList(this.lastResponse.NextReelsSymbolsList);
            this.stagedHandler = VSCStagedHandler.Spin;
            this.handlerStage = VSCHandlerStage.Stage_1;
            break;
        case VSCHandlerStage.Stage_1:
            this.xtLayer.SetRespinData(this.lastResponse.Respin);
            this.xtLayer.SetProgressiveFeatureData(this.lastResponse.ProgressiveData);
            this.xtLayer.SetMoneySymbolData(this.lastResponse.MoneySymbolData);
            this.xtLayer.SetStickySymbolsData(this.lastResponse.StickySymbols);
            this.xtLayer.SetMergingSymbolsData(this.lastResponse.MergingSymbols);
            this.xtLayer.SetJackpotState(this.lastResponse.VsJackpotData);
            if (this.WonTheJackpot()) {
                var jpData = this.lastResponse.VsJackpotData;
                this.xtLayer.SetJackpotWon(jpData.JackpotID, jpData.JackpotOrder, jpData.WinJackpotAmount)
            }
            this.xtLayer.SetJackpotVisualization(this.lastResponse.JackpotVisualisation);
            this.xtLayer.SetBalance(this.lastResponse.Balance, true);
            this.xtLayer.SetBonusBalance(this.lastResponse.BonusBalance);
            this.xtLayer.SetWinValue(this.lastResponse.Win);
            this.xtLayer.SetSpinCycleWinValue(this.lastResponse.SpinCycleWin);
            this.xtLayer.SetExtraAwardWin(this.lastResponse.ExtraAwardWin);
            this.xtLayer.SetRespinCycleWin(this.lastResponse.RespinCycleWin);
            var linesWin = 0;
            for (var vswl in this.lastResponse.VsWinLines) linesWin += this.lastResponse.VsWinLines[vswl].WinAmount;
            this.xtLayer.SetLinesWinValue(linesWin);
            if (this.HasFreeSpinOptions()) this.xtLayer.MustOpenFSOptions(this.lastResponse.FreeSpinsOptions);
            this.xtLayer.SetFreeSpinResponseReceived(this.lastResponse.GetVsFreeSpin());
            this.xtLayer.SetFSPurchaseData(this.lastResponse.FreeSpinsPurchaseData);
            if (XT.GetBool(Vars.TruncateFSResponseDuringRespin)) this.xtLayer.SetTruncatedFSResponseReceived(this.lastResponse.TruncatedVsFreeSpin);
            if ((this.lastResponse.GetVsFreeSpin() != null && this.lastResponse.GetVsFreeSpin().IsLastFreeSpin() || this.lastResponse.GetVsFreeSpin() == null) && XT.GetBool(Vars.OpenFSBGForMysteryScatter)) this.xtLayer.SetStartFSBG(false);
            if (this.IsFreeSpin() && this.IsNeedMysteryScatter()) {
                this.fsgbResponse = this.lastResponse.Clone();
                this.xtLayer.SetStartFSBG(true)
            } else if (this.IsFreeSpinsBonusGame()) {
                this.fsgbResponse = this.lastResponse.Clone();
                this.xtLayer.SetStartFSBG(false)
            }
            this.xtLayer.SetWildRandomMultipliers(this.lastResponse.WildRandomMultipliers);
            this.xtLayer.SetMustOpenBonus(this.lastResponse.IsBonus(), false);
            this.xtLayer.UpdateBonusRoundsInfo(this.lastResponse);
            this.xtLayer.SetGambleV2Response(this.lastResponse.gambleV2Data);
            this.xtLayer.SetNudgedSymbolsData(this.lastResponse.NudgedSymbolsData);
            this.handlerStage = VSCHandlerStage.Stage_2;
            break;
        case VSCHandlerStage.Stage_2:
            XT.TriggerEvent(FOXVars.Evt_FOX_AfterSpinReceived);
            this.xtLayer.SpinResultReceived();
            this.stagedHandler = VSCStagedHandler.None;
            this.handlerStage = VSCHandlerStage.Stage_0;
            break
    }
};
VideoSlotsConnection.prototype.HandlerNoMoneySpinResult = function(param) {
    var response = new VsResponse;
    response.ReelPositions = this.lastResponse.ReelPositions;
    response.SymbolsAbove = this.lastResponse.SymbolsAbove;
    response.SymbolsBelow = this.lastResponse.SymbolsBelow;
    response.RandomAwardResponse = this.lastResponse.RandomAwardResponse;
    response.ProgressiveData = this.lastResponse.ProgressiveData;
    response.WinScreenSymbols = XT.GetObject(Vars.InitialScreen);
    if (response.WinScreenSymbols == null) response.WinScreenSymbols =
        XT.GetObject(Vars.FirstScreenSymbols);
    var defSymbols = XT.GetObject(DefaultStateVars.DefaultSymbolsAbove);
    if (defSymbols != null) response.SymbolsAbove = defSymbols;
    defSymbols = XT.GetObject(DefaultStateVars.DefaultSymbolsBelow);
    if (defSymbols != null) response.SymbolsBelow = defSymbols;
    var rar = XT.GetObject(Vars.InitialRandomAward);
    if (rar != null && response.RandomAwardResponse != null) {
        response.RandomAwardResponse.awardIndex = rar.awardIndex;
        response.RandomAwardResponse.awardPositionInReel = rar.awardPositionInReel
    }
    XT.SetBool(Vars.IsNoMoneySpin,
        true);
    var dict = param;
    if (dict != null) {
        var balanceData = GameProtocolCommonParser.ParseBalance(dict);
        if (balanceData != null) {
            response.Balance = balanceData.Balance;
            response.BonusBalance = balanceData.BonusBalance
        }
        var freeRoundEvents = VSProtocolParser.ParseVsFreeRoundEvents(dict);
        response.FreeRoundEvents = freeRoundEvents
    }
    this.HandlerSpinResult(response);
    this.HandlerSpinResult(response);
    this.HandlerSpinResult(response);
    XT.SetBool(Vars.IsNoMoneySpin, false);
    window["globalMustStopAutoplay"] = true
};
VideoSlotsConnection.prototype.HandlerMysteryScatter = function(arg) {
    console.log("VideoSlotsConnection - HandlerMysteryScatter");
    this.fsbgLastResponse = arg;
    if (this.fsbgLastResponse != null) {
        this.fsbgLastResponse.VsFreeSpin.BonusGame = new VsFreeSpinBonusGame;
        this.fsbgLastResponse.VsFreeSpin.BonusGame.SpinsWin = this.fsbgLastResponse.VsFreeSpin.GetMaxNumber();
        this.fsbgLastResponse.VsFreeSpin.BonusGame.MultipliersWin = this.fsbgLastResponse.VsFreeSpin.GetTotalMultipl();
        this.fsbgLastResponse.VsFreeSpin.BonusGame.BonusItems = [];
        this.fsbgLastResponse.VsFreeSpin.BonusGame.BonusItems.push(new VsFreeSpinBonusGame.BonusItem(this.fsbgLastResponse.VsFreeSpin.GetMysteryScatter().length > 0 ? this.fsbgLastResponse.VsFreeSpin.GetMysteryScatter()[0] : -1, VsFreeSpinBonusGame.BonusItem.BonusItemStatus.Available, VsFreeSpinBonusGame.BonusItem.BonusItemType.Spin));
        if (this.fsgbResponse == null) this.fsgbResponse = this.fsbgLastResponse.Clone();
        this.fsgbResponse.VsFreeSpin.SetMysteryScatter(this.fsbgLastResponse.VsFreeSpin.GetMysteryScatter());
        this.fsgbResponse.VsFreeSpin.SetNeedGetMysteryScatter(false);
        this.xtLayer.SetMysteryScatterSymbolIds(this.fsbgLastResponse.VsFreeSpin.GetMysteryScatter());
        this.xtLayer.SetFreeSpinResponseReceived(this.fsgbResponse.VsFreeSpin);
        XT.TriggerEvent(FOXVars.Evt_FOX_AfterGetMysteryScatterReceived)
    }
};
VideoSlotsConnection.prototype.SendGetMysteryScatter = function() {
    EventManager.Trigger(GameEvents.evtMysteryScatterRequest + this.xtLayer.gameSymbol, null)
};
VideoSlotsConnection.prototype.HandlerGambleResponse = function(arg) {
    console.log("VideoSlotsConnection - this.HandlerGambleResponse");
    this.serverRequestSent = false;
    this.gambleResponse = arg;
    if (this.gambleResponse != null) this.xtLayer.SetGambleResponse(this.gambleResponse)
};
VideoSlotsConnection.prototype.HandlerGambleStatus = function(arg) {
    console.log("VideoSlotsConnection - HandlerGambleStatus " + arg)
};
VideoSlotsConnection.prototype.HandlerResourceLoadingStarted = function(arg) {
    console.log("VideoSlotsConnection - HandlerResourceLoadingStarted")
};
VideoSlotsConnection.prototype.HandlerResourceLoadingFinished = function(arg) {
    console.log("VideoSlotsConnection - HandlerResourceLoadingFinished")
};
VideoSlotsConnection.prototype.HandlerResourceLoadingError = function(arg) {
    console.error("VideoSlotsConnection - HandlerResourceLoadingError");
    throw new Error("There was an error during resources loading!");
};
VideoSlotsConnection.prototype.HandlerFSBGInit = function(arg) {
    console.log("VideoSlotsConnection - this.HandlerFSBGInit");
    this.fsbgLastResponse = arg;
    if (this.fsbgLastResponse != null) {
        this.fsgbResponse.VsFreeSpin.BonusGame = this.fsbgLastResponse.VsFreeSpin.Clone().BonusGame;
        this.xtLayer.SetFreeSpinResponseReceived(this.fsgbResponse.VsFreeSpin);
        XT.TriggerEvent(FOXVars.Evt_FOX_AfterInitFSBGReceived);
        this.xtLayer.SendFSBGInitDone()
    }
};
VideoSlotsConnection.prototype.HandlerFSBGResponse = function(arg) {
    console.log("VideoSlotsConnection - this.HandlerFSBGResponse");
    this.fsbgLastResponse = arg;
    if (this.fsbgLastResponse != null) {
        var bonus_game = this.fsbgLastResponse.VsFreeSpin.Clone().BonusGame;
        this.fsgbResponse.VsFreeSpin.BonusGame = bonus_game;
        if (bonus_game.GameOver) {
            this.fsgbResponse.VsFreeSpin.SetTotalMultipl(bonus_game.MultipliersWin);
            this.fsgbResponse.VsFreeSpin.SetMaxNumber(bonus_game.SpinsWin);
            this.fsgbResponse.VsFreeSpin.SetCurrentNumber(1)
        }
        this.xtLayer.SetFreeSpinResponseReceived(this.fsgbResponse.VsFreeSpin);
        XT.TriggerEvent(FOXVars.Evt_FOX_AfterPickFSBGReceived);
        this.xtLayer.SendFSBGResponseReceived()
    }
};
VideoSlotsConnection.prototype.HandlerFreeRoundUpdate = function(param) {
    var vsResponse = param;
    if (vsResponse != null) this.xtLayer.UpdateBonusRoundsInfo(vsResponse)
};
VideoSlotsConnection.prototype.HandlerFreeSpinOptionsUpdate = function(param) {
    var vsResponse = param;
    if (vsResponse != null) this.xtLayer.FreeSpinOptionsResponseReceived(vsResponse)
};
VideoSlotsConnection.prototype.UpdateBonusFSResponseValues = function(res) {
    if (res != null) this.fsgbResponse = res.Clone()
};
VideoSlotsConnection.prototype.SendGambleV2Choice = function(choice) {
    EventManager.Trigger(GameEvents.evtGambleRequest + this.xtLayer.gameSymbol, choice)
};
VideoSlotsConnection.prototype.HandlerGambleV2Response = function(arg) {
    console.log("VideoSlotsConnection - HandlerGambleV2Response");
    this.xtLayer.SetGambleV2Response(arg)
};
VideoSlotsConnection.prototype.HandlerMustPlayJackpot = function(arg) {
    console.log("VideoSlotsConnection - HandlerMustPlayJackpot");
    this.xtLayer.MustPlayJackpot()
};
VideoSlotsConnection.prototype.SendPlayJackpotRequest = function() {
    console.log("VideoSlotsConnection - SendPlayJackpotRequest");
    EventManager.Trigger(GameEvents.evtPlayJackpotRequest + this.xtLayer.gameSymbol, null)
};
VideoSlotsConnection.prototype.HandlerPlayJackpotResponse = function(arg) {
    console.log("VideoSlotsConnection - HandlerPlayJackpotResponse");
    this.xtLayer.PlayJackpotResponse(arg)
};
VideoSlotsConnection.prototype.HandlerServerTimeUpdate = function(param) {
    this.xtLayer.SetServerTime(param)
};
goog.provide("UHT.BonusPickConnection");
goog.require("UHT.Component");
BonusPickConnection.prototype = Object.create(Component.prototype);
BonusPickConnection.prototype.constructor = BonusPickConnection;

function BonusPickConnection() {
    Component.call(this);
    this.lastResponse = null;
    this.vsResponse = null;
    this.xtLayer = null
}
BonusPickConnection.prototype.Init = function() {};
BonusPickConnection.prototype.Coef = function() {
    return this.lastResponse.Coef
};
BonusPickConnection.prototype.GameOver = function() {
    return this.lastResponse.GameOver
};
BonusPickConnection.prototype.Level = function() {
    if (this.lastResponse.Level != -1) {
        if (this.lastResponse.GameOver) return this.lastResponse.Level - 1;
        return Number(this.lastResponse.Level)
    }
    return 0
};
BonusPickConnection.prototype.CurrentBonusRespin = function() {
    return this.lastResponse.currentBonusRespin
};
BonusPickConnection.prototype.MaxBonusRespins = function() {
    return this.lastResponse.maxBonusRespins
};
BonusPickConnection.prototype.RespinSymbols = function() {
    return this.lastResponse.respinSymbols
};
BonusPickConnection.prototype.Life = function() {
    var rv = 0;
    if (this.lastResponse.Life != null) rv = this.lastResponse.Life;
    return rv
};
BonusPickConnection.prototype.RealWin = function() {
    return this.lastResponse.RealWin
};
BonusPickConnection.prototype.WinPoints = function() {
    return this.lastResponse.WinPoints
};
BonusPickConnection.prototype.PossibleWins = function() {
    return this.lastResponse.IWins
};
BonusPickConnection.prototype.ItemsMarkers = function() {
    if (this.lastResponse.BonusTable.Markers != null) return this.lastResponse.BonusTable.Markers;
    return null
};
BonusPickConnection.prototype.ItemStatus = function(index) {
    return this.lastResponse.BonusTable.Status[index]
};
BonusPickConnection.prototype.ItemsStatus = function() {
    if (this.lastResponse.BonusTable.Status != null) return this.lastResponse.BonusTable.Status;
    return null
};
BonusPickConnection.prototype.ItemWin = function(index) {
    return this.lastResponse.BonusTable.Wins[index]
};
BonusPickConnection.prototype.ItemsWins = function() {
    if (this.lastResponse.BonusTable.Wins != null) return this.lastResponse.BonusTable.Wins;
    return null
};
BonusPickConnection.prototype.WinsMask = function() {
    return this.lastResponse.BonusTable.WinsMask
};
BonusPickConnection.prototype.LifeWins = function() {
    return this.lastResponse.lifeWins
};
BonusPickConnection.prototype.MultipliersMarkers = function() {
    return this.lastResponse.MultipliersTable.Markers
};
BonusPickConnection.prototype.MultiplierStatus = function(index) {
    return this.lastResponse.MultipliersTable.Status[index]
};
BonusPickConnection.prototype.MultipliersStatus = function() {
    return this.lastResponse.MultipliersTable.Status
};
BonusPickConnection.prototype.MultiplierWin = function(index) {
    return this.lastResponse.MultipliersTable.Wins[index]
};
BonusPickConnection.prototype.MultipliersWins = function() {
    return this.lastResponse.MultipliersTable.Wins
};
BonusPickConnection.prototype.MultiplierStep = function() {
    return this.lastResponse.MultiplierStep
};
BonusPickConnection.prototype.MultipliedSymbolPositions = function() {
    return this.lastResponse.MultipliedSymbolPositions
};
BonusPickConnection.prototype.SendItemPick = function(itemId) {
    if (this.lastResponse.GameOver) console.error("You can't pick when the game is over!");
    else {
        var option = new VsBonusGamePlayerChoice(itemId);
        EventManager.Trigger(GameEvents.evtBonusPickRequest + this.xtLayer.gameSymbol, option)
    }
};
BonusPickConnection.prototype.SendCustomItemPick = function(itemId, pickType) {
    if (this.lastResponse.GameOver) console.error("You can't pick when the game is over!");
    else {
        var option = new VsBonusGamePlayerChoice(itemId);
        option.PickType = pickType;
        EventManager.Trigger(GameEvents.evtBonusPickRequest + this.xtLayer.gameSymbol, option)
    }
};
BonusPickConnection.prototype.SendBonusRespin = function() {
    if (this.lastResponse.GameOver || this.lastResponse.currentBonusRespin == this.lastResponse.maxBonusRespins && this.lastResponse.ExtraRetriggersWon <= 0) console.error("You can't request more bonus respins.");
    else EventManager.Trigger(GameEvents.evtBonusRespinRequest + this.xtLayer.gameSymbol, null)
};
BonusPickConnection.prototype.OnBonusGameFinished = function() {
    if (this.GameOver() || this.lastResponse.currentBonusRespin == this.lastResponse.maxBonusRespins && this.lastResponse.currentBonusRespin != 0 && this.lastResponse.maxBonusRespins != 0) EventManager.Trigger(GameEvents.evtBonusFinishRequest + this.xtLayer.gameSymbol, null);
    else console.error("You just broke bonus game, gratz!")
};
BonusPickConnection.prototype.SetupHandlers = function() {
    console.log("BonusPickConnection - Setup handlers");
    EventManager.AddHandler(GameEvents.evtBonusInitResponse + this.xtLayer.gameSymbol, this.HandlerBonusGameInit, this);
    EventManager.AddHandler(GameEvents.evtBonusPickResponse + this.xtLayer.gameSymbol, this.HandlerPlayerSelection, this);
    EventManager.AddHandler(GameEvents.evtBonusRespinResponse + this.xtLayer.gameSymbol, this.HandlerBonusRespin, this)
};
BonusPickConnection.prototype.OnDestroy = function() {};
BonusPickConnection.prototype.HandlerBonusGameInit = function(arg) {
    console.log("BonusPickConnection - this.HandlerBonusGameInit");
    this.vsResponse = arg;
    this.lastResponse = arg.GetVsBonusGameData();
    if (this.lastResponse != null) {
        this.xtLayer.SetSpinCycleWinValue(arg.SpinCycleWin);
        this.xtLayer.SendBonusInitDone()
    }
};
BonusPickConnection.prototype.HandlerPlayerSelection = function(arg) {
    console.log("BonusPickConnection - this.HandlerPlayerSelection");
    this.vsResponse = arg;
    this.xtLayer.SetProgressiveFeatureData(arg.ProgressiveData);
    if (XT.GetBool(Vars.UpdateFSResponseOnBonusPick)) this.xtLayer.SetFreeSpinResponseReceived(arg.GetVsFreeSpin());
    this.lastResponse = arg.GetVsBonusGameData();
    if (this.lastResponse != null) {
        if (arg.IsBonusGameOver() && arg.NextGameActions.indexOf(NextGameAction.Bonus) > -1) this.xtLayer.SetMustOpenBonus(true,
            false);
        if (XT.GetBool(Vars.PartiallyUpdateSpinResponseOnBonusPick)) this.SetPartialSpinResponseInBonus();
        if (XT.GetBool(Vars.UpdateRespinDataOnBonusPick)) this.xtLayer.SetRespinData(arg.Respin);
        this.xtLayer.SetOpeningSymbolsData(arg.OpeningSymbolsData);
        this.xtLayer.SetSpinCycleWinValue(arg.SpinCycleWin);
        this.xtLayer.SendBonusResponse();
        this.xtLayer.UpdateBonusFSResponseValues(arg);
        var reelSets = XT.GetObject(Vars.ReelSets);
        if (reelSets != null && arg.ReelSetIndex >= 0) this.xtLayer.InitNextReelSymbols(reelSets[arg.ReelSetIndex]);
        this.xtLayer.SetGambleV2Response(arg.gambleV2Data);
        if (arg.HasFreeSpinOptions()) this.xtLayer.MustOpenFSOptions(arg.FreeSpinsOptions);
        XT.TriggerEvent(FOXVars.Evt_FOX_AfterPickBonusReceived)
    }
};
BonusPickConnection.prototype.SetPartialSpinResponseInBonus = function() {
    if (this.vsResponse.SymbolsBeforeExpanding == null || this.vsResponse.SymbolsBeforeExpanding.length == 0) {
        this.vsResponse.SymbolsBeforeExpanding = [];
        for (var i = 0; i < this.vsResponse.WinScreenSymbols.length; i++) this.vsResponse.SymbolsBeforeExpanding.push(this.vsResponse.WinScreenSymbols[i].slice())
    }
    this.xtLayer.SetResultScreenSymbols(this.vsResponse.WinScreenSymbols);
    this.xtLayer.SetInitialResultScreenSymbols(this.vsResponse.SymbolsBeforeExpanding);
    this.xtLayer.SetWinLines(this.vsResponse.VsWinLines);
    this.xtLayer.SetWinValue(this.lastResponse.RealWin);
    this.xtLayer.SetExtraAwardWin(this.vsResponse.ExtraAwardWin);
    if (this.lastResponse.currentBonusRespin == this.lastResponse.maxBonusRespins) {
        var linesWin = 0;
        for (var vswl in this.vsResponse.VsWinLines) linesWin += this.vsResponse.VsWinLines[vswl].WinAmount;
        this.xtLayer.SetLinesWinValue(linesWin)
    }
};
BonusPickConnection.prototype.HandlerBonusRespin = function(arg) {
    console.log("BonusPickConnection - this.HandlerBonusRespin");
    this.vsResponse = arg;
    this.lastResponse = arg.GetVsBonusGameData();
    if (this.lastResponse != null) {
        this.xtLayer.SetSpinCycleWinValue(arg.SpinCycleWin);
        this.xtLayer.SetResultScreenSymbols(this.lastResponse.winSymbols != null && this.lastResponse.winSymbols.length > 0 ? this.lastResponse.winSymbols : arg.WinScreenSymbols);
        this.xtLayer.SetWinLines(arg.VsWinLines);
        this.xtLayer.SetWinValue(this.lastResponse.RealWin);
        this.xtLayer.SetExtraAwardWin(arg.ExtraAwardWin);
        this.xtLayer.SendBonusResponse();
        this.xtLayer.SetMoneySymbolData(arg.MoneySymbolData);
        if (this.lastResponse.currentBonusRespin == this.lastResponse.maxBonusRespins) {
            var linesWin = 0;
            for (var vswl in arg.VsWinLines) linesWin += arg.VsWinLines[vswl].WinAmount;
            this.xtLayer.SetLinesWinValue(linesWin)
        }
        var isFreeSpin = arg.IsFreeSpins() && arg.GetVsFreeSpin().GetMaxNumber() != 0;
        if (isFreeSpin && arg.GetVsFreeSpin().IsNeedGetMysteryScatter()) this.xtLayer.SetStartFSBG(true);
        XT.TriggerEvent(FOXVars.Evt_FOX_AfterBonusRespinReceived)
    }
};
goog.require("UHT.XTLink");
goog.require("UHT.ServerOptions");
goog.require("UHT.ResourceHelpers");
goog.require("UHT.VideoSlotsConnection");
goog.require("UHT.BonusPickConnection");
goog.require("UHT.FreeSpinsResponse");
goog.require("UHT.Paytable");
VideoSlotsConnectionXTLayer.prototype = Object.create(XTLink.prototype);
VideoSlotsConnectionXTLayer.prototype.constructor = VideoSlotsConnectionXTLayer;

function VideoSlotsConnectionXTLayer() {
    XTLink.call(this);
    this.vsc = null;
    this.bonusConnection = null;
    this.gameSymbol = null;
    this.fsr = null;
    this.bonusData = null;
    this.needToSendSettingsToServer = false;
    this.isInCoolDown = false;
    this.timeInCooldown = 0;
    this.internalGlobalSoundIsOn = false;
    this.handlerGameInitReceived = false;
    this.settingsReceived = false;
    this.resourcesLoaded = false;
    this.mustTriggerDelayedGameLoadingFinished = false;
    this.delayedGameLoadingFinishedFrameCount = 0
}
VideoSlotsConnectionXTLayer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_OnShowResult, this.OnShowResult, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_OnFreeSpinsClosed, this.OnFreeSpinClosed, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_RequestInit, this.OnRequestInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_RequestSpin, this.OnRequestSpin, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_GamblePicked, this.OnGambleV2Pick, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_RequestGambleOpen,
        this.OnRequestGambleOpen, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_RequestGambleClose, this.OnRequestGambleClose, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_BonusPickItem, this.OnBonusPick, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_BonusGameFinished, this.OnBonusGameFinished, this);
    XT.RegisterCallbackEvent(BGVars.Evt_ToServer_BonusPickedItem, this.OnBonusPick, this);
    XT.RegisterCallbackEvent(BGVars.Evt_ToServer_BonusPickedCustomItem, this.OnBonusCustomPick, this);
    XT.RegisterCallbackEvent(BGVars.Evt_ToServer_SendBonusRespin,
        this.OnSendBonusRespin, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_UpdateSettingsOnServer, this.OnUpdateSettingsOnServer, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_OpenCashier, this.OnRequestToOpenCashier, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_CloseGame, this.OnRequestToCloseGame, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_ReloadGame, this.OnRequestToReloadGame, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_ItemPickedFSBGPick, this.OnItemPickedFSBGPick, this);
    XT.RegisterCallbackBool(Vars.BatterySaver,
        this.OnBatterySaverStateChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_SendGetMysteryScatter, this.SendGetMysteryScatter, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_RequestPlayJackpot, this.OnRequestPlayJackpot, this)
};
VideoSlotsConnectionXTLayer.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.ReceivedWinLines, null);
    XT.SetObject(Vars.PaytablePayoutData, null);
    XT.SetBool(Vars.FastPlay, false);
    XT.SetObject(Vars.SoundState, new SoundState);
    XT.SetBool(Vars.ShouldDisplayIntro, true);
    XT.SetInt(Vars.MobileTapToStopMessageShowCount, 0);
    XT.SetInt(Vars.DesktopTurboSpinMessageShowCount, 0);
    XT.SetBool(Vars.FromServer_IsJackpotWin, false);
    XT.SetObject(Vars.BonusData, null);
    XT.SetInt(Vars.Lines, 0);
    XT.SetObject(Vars.ExpandingSymbolsData,
        null);
    XT.SetObject(Vars.FromServer_JackpotsInformation, null);
    XT.SetObject(Vars.ReelStopPositions, null);
    XT.SetBool(Vars.IgnoreServerBalanceRequest, false);
    XT.SetBool(Vars.CanAnimateValues, false);
    XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, false);
    XT.SetDouble(Vars.SpinCycleWinReceived, 0);
    XT.SetDouble(Vars.WinReceived, 0);
    XT.SetObject(Vars.ReceivedFreeSpinsResponse, null);
    XT.SetObject(Vars.TruncatedFreeSpinsResponse, null);
    XT.SetObject(Vars.MarkedSymbolPositions, []);
    XT.SetObject(Vars.SpinOneReelData,
        null);
    XT.SetInt(Vars.ReelToBeSpun, -1);
    XT.SetBool(Vars.HasGameHistory, false);
    XT.SetBool(Vars.VerifyGameAuthenticity, false);
    XT.SetBool(Vars.HasAdvancedAutoplay, false);
    XT.SetBool(Vars.BatterySaver, false);
    XT.SetBool(Vars.HasCoins, false);
    XT.SetDouble(Vars.AlternativeWager, -1);
    XT.SetBool(Vars.Jurisdiction_Clock, false);
    XT.SetBool(Vars.Jurisdiction_DisableAutoplay, false);
    XT.SetBool(Vars.Jurisdiction_GameTitle, false);
    XT.SetBool(Vars.Jurisdiction_SplitBalance, false);
    XT.SetBool(Vars.Jurisdiction_PromotionURL,
        false);
    XT.SetBool(Vars.Autoplay_SkipScreens, true);
    XT.SetBool(Vars.ShowInGameTutorial, true);
    XT.SetBool(Vars.KeepSpinning, false);
    XT.SetBool(Vars.Jurisdiction_SpinLimit, false);
    XT.SetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit, false);
    XT.SetBool(Vars.Jurisdiction_ResultMinimumTime, false);
    XT.SetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins, false);
    XT.SetBool(Vars.Jurisdiction_ResultMinimumTimeTurbo, false);
    XT.SetBool(Vars.Jurisdiction_FinishCountersBeforeSpin, false);
    XT.SetBool(Vars.Jurisdiction_LineByLineFreespin,
        false);
    XT.SetBool(Vars.Jurisdiction_LineByLineGlobal, false);
    XT.SetBool(Vars.Jurisdiction_ClientRevision, false);
    XT.SetBool(Vars.Jurisdiction_GameSymbol, false);
    XT.SetBool(Vars.Jurisdiction_CLMBcurrency, false);
    XT.SetBool(Vars.AlternativeFreeRoundsText, false);
    XT.SetBool(Vars.DontShowFRBEndWindowOnInit, false);
    XT.SetBool(Vars.Jurisdiction_TournamentOptOut, false);
    XT.SetBool(Vars.Jurisdiction_DisableBuyFeature, false);
    XT.SetBool(Vars.Jurisdiction_GameLobbyInfoVisible, true);
    XT.SetBool(Vars.Jurisdiction_GameHistoryInfoVisible,
        true);
    XT.SetFloat(Vars.Jurisdiction_SpinLimit_Value, 3);
    XT.SetFloat(Vars.Jurisdiction_ResultMinimumTime_Value, 3);
    XT.SetFloat(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins_Value, 3);
    XT.SetFloat(Vars.Jurisdiction_ResultMinimumTimeTurbo_Value, 3);
    XT.SetInt(Vars.Jurisdiction_MaxBetCents, 0);
    XT.SetInt(Vars.Jurisdiction_MaxWin, 0);
    XT.SetBool(Vars.Jurisdiction_Text_DE, false);
    XT.SetBool(Vars.Jurisdiction_Show_X_Chance, false);
    XT.SetBool(Vars.Jurisdiction_Autoplay_StopOnFeatureWin, false);
    XT.SetBool(Vars.Jurisdiction_Autoplay_NoSkipScreens,
        false);
    XT.SetObject(Vars.CustomGameStoredData, {});
    XT.SetInt(Vars.ReelSetIndexPrevious, -1);
    XT.SetInt(Vars.ReelSetIndexCurrent, -1);
    XT.SetBool(Vars.BonusTriggersFSBG, false);
    XT.SetBool(Vars.BonusTriggeredFSBGIsMystery, false);
    XT.SetBool(Vars.OpenFSBGForMysteryScatter, false);
    XT.SetFloat(Vars.SoundVolume, 1);
    XT.SetBool(Vars.IsNoMoneySpin, false);
    XT.SetObject(Vars.InitialScreen, null);
    XT.SetObject(Vars.InitialRandomAward, null);
    XT.SetDouble(Vars.BalanceReceived, 0);
    XT.SetDouble(Vars.BonusBalanceReceived, 0);
    XT.SetBool(Vars.InstantAutoplay,
        false);
    XT.SetObject(InterfaceVars.SpinButtonPositionLandscape, null);
    XT.SetObject(InterfaceVars.SpinButtonPositionPortrait, null);
    XT.SetBool(InterfaceVars.SpinButtonPositionLocked, true);
    XT.SetBool(Vars.DisableIntroScreen, false);
    XT.SetBool(Vars.BonusRoundCanBePlayedLater, false);
    XT.SetBool(Vars.UserChoseToPlayLater, false);
    XT.SetBool(Vars.DisableStopButton, false);
    XT.SetBool(Vars.DisableFastPlay, false);
    XT.SetBool(Vars.DisableNoMoneyMessageFromServer, false);
    XT.SetBool(Vars.ShowIncompleteGame, false);
    XT.SetBool(Vars.ShowNetPosition,
        false);
    XT.SetBool(Vars.Jurisdiction_DisableAnteBet, false);
    XT.SetBool(Vars.Jurisdiction_DisableSuperSpin, false);
    XT.SetBool(Vars.Jurisdiction_ShowSessionUptime, false);
    XT.SetBool(Vars.Jurisdiction_ShowHoursInSessionUptime, false);
    XT.SetBool(Vars.Jurisdiction_DisableContinousSpin, false);
    XT.SetBool(Vars.Jurisdiction_WinUp_Text, false);
    XT.SetDouble(Vars.BonusRoundEndDateTimestamp, -1);
    XT.SetBool(Vars.BonusRoundWonFromDDW, false);
    XT.SetString(Vars.BonusRoundPromoType, "");
    XT.SetBool(Vars.Jurisdiction_GameEngineVersion,
        false);
    XT.SetBool(Vars.Jurisdiction_NoSpinToWin, false);
    XT.SetBool(Vars.Jurisdiction_NoSmallWinCount, false);
    XT.SetObject(Vars.MysteryScatterSymbolIds, []);
    XT.SetObject(Vars.BonusRoundsEvents, null);
    XT.SetObject(Vars.PlayJackpotData, null);
    XT.SetBool(Vars.MustPlayJackpot, false);
    XT.SetDouble(Vars.ExtraSessionWin, 0)
};
VideoSlotsConnectionXTLayer.prototype.AddServerCallbacks = function() {
    EventManager.AddHandler(GameEvents.evtSoundState + this.gameSymbol, this.OnSoundState, this);
    EventManager.AddHandler(GameEvents.evtGameStatus + this.gameSymbol, this.OnGameStatus, this);
    EventManager.AddHandler(BalanceEvents.evtBalanceUpdated, this.OnServerBalanceUpdated, this);
    EventManager.AddHandler(GameEvents.evtSettingsUpdated + this.gameSymbol, this.OnSettingsUpdated, this);
    EventManager.AddHandler(GameEvents.evtSettingsNotSaved, this.OnSettingsNotSaved,
        this);
    EventManager.AddHandler(ResourceEvents.evtResourcesCompleted + this.gameSymbol, this.OnResourcesCompleted, this)
};
VideoSlotsConnectionXTLayer.prototype.OnConnectionReady = function(gameSymbol) {
    console.log("OnConnectionReady", gameSymbol);
    this.gameSymbol = gameSymbol;
    this.vsc = this.gameObject.AddComponent("VideoSlotsConnection");
    this.vsc.xtLayer = this;
    this.bonusConnection = this.gameObject.AddComponent("BonusPickConnection");
    this.bonusConnection.xtLayer = this;
    this.AddServerCallbacks();
    this.vsc.AddServerCallbacks();
    this.bonusConnection.SetupHandlers();
    this.SetInitialSoundState(ServerOptions.isExternal);
    EventManager.Trigger(GameEvents.evtInitRequest +
        gameSymbol, null);
    EventManager.Trigger(ResourceEvents.evtRequestResources, gameSymbol)
};
VideoSlotsConnectionXTLayer.prototype.OnServerBalanceUpdated = function(data) {
    this.SetBalance(data.Balance, false);
    this.SetBonusBalance(data.BonusBalance)
};
VideoSlotsConnectionXTLayer.prototype.OnBatterySaverStateChanged = function(val) {
    UHTEngine.SetBatterySaverState(val)
};
VideoSlotsConnectionXTLayer.prototype.OnSettingsUpdated = function(settings) {
    this.UpdateSettings(true, settings);
    this.settingsReceived = true;
    if (this.CanTriggerInitReady()) this.TriggerInitReady()
};
VideoSlotsConnectionXTLayer.prototype.OnSettingsNotSaved = function(param) {};
VideoSlotsConnectionXTLayer.prototype.OnUpdateSettingsOnServer = function() {
    this.timeInCooldown = 0;
    this.needToSendSettingsToServer = true;
    if (XT.GetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer)) {
        XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, false);
        this.isInCoolDown = false
    }
};
VideoSlotsConnectionXTLayer.prototype.OnResourcesCompleted = function(pack) {
    LoaderProgress.Localize_Current = 1;
    for (var i = 0; i < pack.assetBundles.length; ++i) {
        var go = UHTEngine.LoadAssetBundle(pack.assetBundles[i].mainAsset, ServerOptions.gameUrl + "packages/");
        var mm = go.GetComponent(ModificationsManager);
        var cp = go.GetComponent(CurrencyPatch);
        if (mm != null) mm.Init();
        if (cp != null) {
            cp.currencyName = ServerOptions.currency;
            cp.languageName = ServerOptions.language;
            if (XT.GetBool(Vars.Jurisdiction_CLMBcurrency)) cp.languageName +=
                "_COP";
            cp.localeName = UHT_GAME_CONFIG_SRC["locale"] != undefined ? UHT_GAME_CONFIG_SRC["locale"] : ServerOptions.language;
            if (XT.GetBool(Vars.Jurisdiction_CLMBcurrency)) cp.localeName += "_COP";
            LocaleManager.Init(cp)
        }
    }
    pack.assetBundles = [];
    if (XT.GetObject(Vars.PaytablePayoutData) != null) XT.TriggerEvent(Vars.Evt_Internal_PaytablePayoutUpdate);
    this.resourcesLoaded = true;
    ModificationsManager.Applied = true;
    if (this.CanTriggerInitReady()) this.TriggerInitReady()
};
VideoSlotsConnectionXTLayer.prototype.UpdateSettings = function(settingsReceivedFromServer, settings) {
    console.log("UpdateSettings", settingsReceivedFromServer, settings);
    var mustUpdateSettings = false;
    if (!settingsReceivedFromServer) settings.Settings = {};
    if (ServerOptions.isReplay && settingsReceivedFromServer) settings.Settings["SoundState"] = "false_false_false_true_true";
    var valueStr;
    if (settingsReceivedFromServer && settings.Settings["SoundState"] != undefined) {
        valueStr = settings.Settings["SoundState"];
        var arr = valueStr.split("_");
        this.SetSoundState(_bool.Parse(arr[0]), _bool.Parse(arr[1]), _bool.Parse(arr[2]), _bool.Parse(arr[3]), _bool.Parse(arr[4]))
    } else {
        var s = XT.GetObject(Vars.SoundState);
        settings.Settings["SoundState"] = [s.gameSoundIsOn.toString(), s.musicIsOn.toString(), s.soundFXIsOn.toString(), s.oldMusicIsOn.toString(), s.oldSoundFXIsOn.toString()].join("_");
        mustUpdateSettings = true;
        this.SetSoundState(s.gameSoundIsOn, s.musicIsOn, s.soundFXIsOn, s.oldMusicIsOn, s.oldSoundFXIsOn)
    }
    if (settingsReceivedFromServer && settings.Settings["FastPlay"] !=
        undefined) {
        valueStr = settings.Settings["FastPlay"];
        XT.SetBool(Vars.FastPlay, _bool.Parse(valueStr))
    } else {
        var fastPlay = XT.GetBool(Vars.FastPlay);
        settings.Settings["FastPlay"] = String(fastPlay);
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["Intro"] != undefined) {
        valueStr = settings.Settings["Intro"];
        XT.SetBool(Vars.ShouldDisplayIntro, _bool.Parse(valueStr))
    } else {
        var intro = XT.GetBool(Vars.ShouldDisplayIntro);
        settings.Settings["Intro"] = String(intro);
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer &&
        settings.Settings["StopMsg"] != undefined) {
        valueStr = settings.Settings["StopMsg"];
        XT.SetInt(Vars.MobileTapToStopMessageShowCount, _number.otoi(valueStr))
    } else {
        var count = XT.GetInt(Vars.MobileTapToStopMessageShowCount);
        valueStr = count.toString();
        settings.Settings["StopMsg"] = valueStr;
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["TurboSpinMsg"] != undefined) {
        valueStr = settings.Settings["TurboSpinMsg"];
        XT.SetInt(Vars.DesktopTurboSpinMessageShowCount, _number.otoi(valueStr))
    } else {
        var count =
            XT.GetInt(Vars.DesktopTurboSpinMessageShowCount);
        valueStr = count.toString();
        settings.Settings["TurboSpinMsg"] = valueStr;
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["BetInfo"] != undefined) {
        valueStr = settings.Settings["BetInfo"];
        var arr2 = valueStr.split("_");
        CoinManager.SetPreviousBetIndices(_number.otoi(arr2[0]), _number.otoi(arr2[1]))
    } else {
        var level = XT.GetInt(Vars.NextBetIndex);
        var index = XT.GetInt(Vars.CoinValueIndex);
        valueStr = (level.toString() + "_" + index.toString()).toString();
        settings.Settings["BetInfo"] = valueStr;
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["Rated"] != undefined) {
        var rated = _bool.Parse(settings.Settings["Rated"]);
        XT.SetBool(Vars.GameIsRated, rated);
        XT.SetBool(Vars.RatingSkipped, !rated)
    } else {
        var rated = XT.GetBool(Vars.GameIsRated);
        var ratingSkipped = XT.GetBool(Vars.RatingSkipped);
        if (rated || ratingSkipped) {
            settings.Settings["Rated"] = String(rated);
            mustUpdateSettings = true
        }
    }
    if (settingsReceivedFromServer && settings.Settings["BrowserWarningShown"] !=
        undefined) {
        var browserWarningShown = _bool.Parse(settings.Settings["BrowserWarningShown"]);
        XT.SetBool(Vars.BrowserWarningShown, browserWarningShown)
    } else {
        var browserWarningShown = XT.GetBool(Vars.BrowserWarningShown);
        if (browserWarningShown) {
            settings.Settings["BrowserWarningShown"] = String(browserWarningShown);
            mustUpdateSettings = true
        }
    }
    if (settingsReceivedFromServer && settings.Settings["BatterySaver"] != undefined) XT.SetBool(Vars.BatterySaver, _bool.Parse(settings.Settings["BatterySaver"]));
    else {
        settings.Settings["BatterySaver"] =
            XT.GetBool(Vars.BatterySaver).toString();
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["ShowIGT"] != undefined) XT.SetBool(Vars.ShowInGameTutorial, _bool.Parse(settings.Settings["ShowIGT"]));
    else {
        var show = XT.GetBool(Vars.ShowInGameTutorial);
        if (!show) {
            settings.Settings["ShowIGT"] = String(show);
            mustUpdateSettings = true
        }
    }
    if (settingsReceivedFromServer && settings.Settings["ShowCCH"] != undefined) XT.SetBool(InterfaceVars.ShowCoinsAndCashHint, _bool.Parse(settings.Settings["ShowCCH"]));
    else {
        settings.Settings["ShowCCH"] = String(XT.GetBool(InterfaceVars.ShowCoinsAndCashHint));
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["ShowFPH"] != undefined) XT.SetBool(InterfaceVars.ShowFastPlayHint, _bool.Parse(settings.Settings["ShowFPH"]));
    else {
        settings.Settings["ShowFPH"] = String(XT.GetBool(InterfaceVars.ShowFastPlayHint));
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["CustomGameStoredData"] != undefined) {
        var customGameStoredData = settings.BuildDictionaryFromString(settings.Settings["CustomGameStoredData"],
            "~", ":");
        XT.SetObject(Vars.CustomGameStoredData, customGameStoredData);
        XT.TriggerEvent(Vars.Evt_Internal_CustomGameStoredDataReceived)
    } else {
        var data = XT.GetObject(Vars.CustomGameStoredData);
        settings.Settings["CustomGameStoredData"] = settings.DictionaryToString(data, "~", ":");
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer) {
        var coins = false;
        if (ServerOptions.amountType != "CURRENCY")
            if (settings.Settings["Coins"] != undefined) coins = _bool.Parse(settings.Settings["Coins"]);
        XT.SetBool(Vars.HasCoins, coins)
    } else {
        settings.Settings["Coins"] =
            String(XT.GetBool(Vars.HasCoins));
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["Volume"] != undefined) XT.SetFloat(Vars.SoundVolume, _number.otod(settings.Settings["Volume"]));
    else {
        settings.Settings["Volume"] = String(XT.GetFloat(Vars.SoundVolume));
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["InitialScreen"] != undefined) {
        var s1 = [];
        var s2 = settings.Settings["InitialScreen"].split("_");
        for (var i = 0; i < s2.length; ++i) s1.push(_array.ConvertAll(s2[i].split(","),
            _number.otoi));
        XT.SetObject(Vars.InitialScreen, s1)
    } else if (this.handlerGameInitReceived) {
        var s1 = XT.GetObject(Vars.InitialScreen);
        if (s1 == null) {
            s1 = XT.GetObject(Vars.FirstScreenSymbols);
            XT.SetObject(Vars.InitialScreen, s1)
        }
        var s2 = [];
        for (var i = 0; i < s1.length; ++i) s2.push(s1[i].join(","));
        settings.Settings["InitialScreen"] = s2.join("_");
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["InitialRandomAward"] != undefined) {
        var rar = new RandomAwardsResponse;
        var s2 = settings.Settings["InitialRandomAward"].split("_");
        var tmp = parseInt(s2[0], 10);
        if (isFinite(tmp) && !isNaN(tmp)) rar.awardIndex = tmp;
        tmp = parseInt(s2[1], 10);
        if (isFinite(tmp) && !isNaN(tmp)) rar.awardPositionInReel = tmp;
        XT.SetObject(Vars.InitialRandomAward, rar)
    } else if (this.handlerGameInitReceived) {
        var rar = XT.GetObject(Vars.InitialRandomAward);
        if (rar == null) {
            rar = XT.GetObject(Vars.RandomAwardsResponse);
            XT.SetObject(Vars.InitialRandomAward, rar)
        }
        if (rar != null) {
            var s2 = [];
            s2.push(rar.awardIndex.toString());
            s2.push(rar.awardPositionInReel.toString());
            settings.Settings["InitialRandomAward"] =
                s2.join("_");
            mustUpdateSettings = true
        }
    }
    if (settingsReceivedFromServer && settings.Settings["SBPLock"] != undefined) XT.SetBool(InterfaceVars.SpinButtonPositionLocked, _bool.Parse(settings.Settings["SBPLock"]));
    else {
        settings.Settings["SBPLock"] = String(XT.GetBool(InterfaceVars.SpinButtonPositionLocked));
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["SBPLand"] != undefined) {
        var split = settings.Settings["SBPLand"].split("_");
        XT.SetObject(InterfaceVars.SpinButtonPositionLandscape, new UHTMath.Vector3(_number.otod(split[0]),
            _number.otod(split[1]), 0))
    } else {
        var obj = XT.GetObject(InterfaceVars.SpinButtonPositionLandscape);
        if (obj != null) {
            var sbp = obj;
            settings.Settings["SBPLand"] = String(sbp.x) + "_" + String(sbp.y);
            mustUpdateSettings = true
        }
    }
    if (settingsReceivedFromServer && settings.Settings["SBPPort"] != undefined) {
        var split = settings.Settings["SBPPort"].split("_");
        XT.SetObject(InterfaceVars.SpinButtonPositionPortrait, new UHTMath.Vector3(_number.otod(split[0]), _number.otod(split[1]), 0))
    } else {
        var obj = XT.GetObject(InterfaceVars.SpinButtonPositionPortrait);
        if (obj != null) {
            var sbp = obj;
            settings.Settings["SBPPort"] = String(sbp.x) + "_" + String(sbp.y);
            mustUpdateSettings = true
        }
    }
    if (mustUpdateSettings) EventManager.Trigger(GameEvents.evtUpdateSettingsRequest + this.gameSymbol, settings)
};
VideoSlotsConnectionXTLayer.prototype.OnGameStatus = function(isActive) {};
VideoSlotsConnectionXTLayer.prototype.OnSoundState = function(soundState) {
    this.internalGlobalSoundIsOn = soundState.state == CasinoSoundState.SoundOn;
    var s = XT.GetObject(Vars.SoundState);
    s.globalSoundIsOn = this.internalGlobalSoundIsOn;
    XT.TriggerEvent(Vars.Evt_Internal_SoundStateChanged)
};
VideoSlotsConnectionXTLayer.prototype.UpdateReelSetIndexes = function(reelSetIndexCurrent) {
    XT.SetInt(Vars.ReelSetIndexPrevious, XT.GetInt(Vars.ReelSetIndexCurrent));
    XT.SetInt(Vars.ReelSetIndexCurrent, reelSetIndexCurrent)
};
VideoSlotsConnectionXTLayer.prototype.InitReelSymbols = function(reelSymbols) {
    XT.SetObject(Vars.ReelSymbols, reelSymbols)
};
VideoSlotsConnectionXTLayer.prototype.InitNextReelSymbols = function(nextReelSymbols) {
    XT.SetObject(Vars.NextReelSymbols, nextReelSymbols)
};
VideoSlotsConnectionXTLayer.prototype.SetReelSets = function(reelSets) {
    XT.SetObject(Vars.ReelSets, reelSets)
};
VideoSlotsConnectionXTLayer.prototype.SetStackedSymbolIndex = function(stackedSymbolIndex) {
    XT.SetInt(Vars.StackedSymbolIndex, stackedSymbolIndex)
};
VideoSlotsConnectionXTLayer.prototype.InitReelsPositions = function(reelPositions) {
    XT.SetObject(Vars.ReelInitialPositions, reelPositions)
};
VideoSlotsConnectionXTLayer.prototype.SetReelStopPositions = function(stopPositions) {
    XT.SetObject(Vars.ReelStopPositions, stopPositions)
};
VideoSlotsConnectionXTLayer.prototype.RequirementsSetup = function() {
    var requirements = ServerOptions.jurisdictionRequirements + "," + ServerOptions.brandRequirements;
    XT.SetBool(Vars.HasGameHistory, ServerOptions.gameHistory != null);
    XT.SetBool(Vars.VerifyGameAuthenticity, ServerOptions.gameVerificationUrl != null);
    if (ServerOptions.jurisdiction == "UK") XT.SetBool(Vars.Jurisdiction_GameTitle, true);
    if (ServerOptions.jurisdiction == "PT") XT.SetBool(Vars.Jurisdiction_Clock, true);
    var jr = requirements.split(",");
    for (var i =
            0; i < jr.length; ++i)
        if (jr[i] == "AAP") XT.SetBool(Vars.HasAdvancedAutoplay, true);
        else if (jr[i].indexOf("SS") == 0) {
        var sval = jr[i].substr(2);
        var val = _number.otoi(sval) / 10;
        XT.SetBool(Vars.Jurisdiction_SpinLimit, true);
        XT.SetFloat(Vars.Jurisdiction_SpinLimit_Value, val)
    } else if (jr[i].indexOf("SR") == 0) {
        var sval = jr[i].substr(2);
        var val = _number.otoi(sval) / 10;
        XT.SetBool(Vars.Jurisdiction_ResultMinimumTime, true);
        XT.SetFloat(Vars.Jurisdiction_ResultMinimumTime_Value, val)
    } else if (jr[i].indexOf("ST") == 0) {
        var sval = jr[i].substr(2);
        var val = _number.otoi(sval) / 10;
        XT.SetBool(Vars.Jurisdiction_ResultMinimumTimeTurbo, true);
        XT.SetFloat(Vars.Jurisdiction_ResultMinimumTimeTurbo_Value, val)
    } else if (jr[i].indexOf("SB") == 0) {
        var sval = jr[i].substr(2);
        var val = _number.otoi(sval) / 10;
        XT.SetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins, true);
        XT.SetFloat(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins_Value, val);
        XT.SetFloat(Vars.SpinDuration, val)
    } else if (jr[i].indexOf("MAX" + ServerOptions.currency + "BET") == 0) {
        var name = "MAX" + ServerOptions.currency +
            "BET";
        var sval = jr[i].substr(name.length);
        var val = _number.otoi(sval);
        XT.SetInt(Vars.Jurisdiction_MaxBetCents, val)
    } else if (jr[i].indexOf("MAX" + ServerOptions.currency + "WIN") == 0) {
        var name = "MAX" + ServerOptions.currency + "WIN";
        var sval = jr[i].substr(name.length);
        var val = _number.otoi(sval);
        XT.SetInt(Vars.Jurisdiction_MaxWin, val)
    } else if (jr[i] == "CLK") XT.SetBool(Vars.Jurisdiction_Clock, true);
    else if (jr[i] == "CLS") XT.SetBool(Vars.Jurisdiction_Clock_Server, true);
    else if (jr[i] == "GT") XT.SetBool(Vars.Jurisdiction_GameTitle,
        true);
    else if (jr[i] == "NOAP") XT.SetBool(Vars.Jurisdiction_DisableAutoplay, true);
    else if (jr[i] == "MALL") XT.SetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit, true);
    else if (jr[i] == "LBLFS") XT.SetBool(Vars.Jurisdiction_LineByLineFreespin, true);
    else if (jr[i] == "LBLG") XT.SetBool(Vars.Jurisdiction_LineByLineGlobal, true);
    else if (jr[i] == "BALS") XT.SetBool(Vars.Jurisdiction_SplitBalance, true);
    else if (jr[i] == "PURL") XT.SetBool(Vars.Jurisdiction_PromotionURL, true);
    else if (jr[i] == "CREV") XT.SetBool(Vars.Jurisdiction_ClientRevision,
        true);
    else if (jr[i] == "GSYM") XT.SetBool(Vars.Jurisdiction_GameSymbol, true);
    else if (jr[i] == "FCBS") XT.SetBool(Vars.Jurisdiction_FinishCountersBeforeSpin, true);
    else if (jr[i] == "COCA") {
        ServerOptions.amountType = "CURRENCY";
        this.SetHasCoins(false)
    } else if (jr[i] == "CLMB") XT.SetBool(Vars.Jurisdiction_CLMBcurrency, true);
    else if (jr[i] == "PORC") XT.SetBool(Vars.Jurisdiction_TournamentOptOut, true);
    else if (jr[i] == "NOBF") XT.SetBool(Vars.Jurisdiction_DisableBuyFeature, true);
    else if (jr[i] == "NOI") XT.SetBool(Vars.GameHasIntro,
        false);
    else if (jr[i] == "NOST") XT.SetBool(Vars.DisableStopButton, true);
    else if (jr[i] == "NOFP") XT.SetBool(Vars.DisableFastPlay, true);
    else if (jr[i] == "NOMM") XT.SetBool(Vars.DisableNoMoneyMessageFromServer, true);
    else if (jr[i] == "DETXT") XT.SetBool(Vars.Jurisdiction_Text_DE, true);
    else if (jr[i] == "SHOXC") XT.SetBool(Vars.Jurisdiction_Show_X_Chance, true);
    else if (jr[i] == "NORP") window["UHT_REPLAY_DISABLED"] = true;
    else if (jr[i] == "AP_STFW") XT.SetBool(Vars.Jurisdiction_Autoplay_StopOnFeatureWin, true);
    else if (jr[i] ==
        "AP_NOSKP") {
        XT.SetBool(Vars.Jurisdiction_Autoplay_NoSkipScreens, true);
        XT.SetBool(Vars.Autoplay_SkipScreens, false)
    } else if (jr[i] == "SHOIG") XT.SetBool(Vars.ShowIncompleteGame, true);
    else if (jr[i] == "SHONP") XT.SetBool(Vars.ShowNetPosition, true);
    else if (jr[i] == "NOAB") XT.SetBool(Vars.Jurisdiction_DisableAnteBet, true);
    else if (jr[i] == "SISU") XT.SetBool(Vars.Jurisdiction_ShowSessionUptime, true);
    else if (jr[i] == "GEV") XT.SetBool(Vars.Jurisdiction_GameEngineVersion, true);
    else if (jr[i] == "NOSTW") XT.SetBool(Vars.Jurisdiction_NoSpinToWin,
        true);
    else if (jr[i] == "NOSWC") XT.SetBool(Vars.Jurisdiction_NoSmallWinCount, true);
    else if (jr[i] == "NOSS") XT.SetBool(Vars.Jurisdiction_DisableSuperSpin, true);
    else if (jr[i] == "SISUH") XT.SetBool(Vars.Jurisdiction_ShowHoursInSessionUptime, true);
    else if (jr[i] == "HODOR") XT.SetBool(Vars.Jurisdiction_DisableContinousSpin, true);
    else if (jr[i] == "WINUPTXT") XT.SetBool(Vars.Jurisdiction_WinUp_Text, true)
};
VideoSlotsConnectionXTLayer.prototype.InitReceived = function() {
    this.handlerGameInitReceived = true;
    if (this.CanTriggerInitReady()) this.TriggerInitReady()
};
var GLOBAL_TIME_RESPONSE_RECEIVED = -1;
VideoSlotsConnectionXTLayer.prototype.SpinResultReceived = function() {
    XT.TriggerEvent(Vars.Evt_FromServer_SpinResultReceived);
    GLOBAL_TIME_RESPONSE_RECEIVED = globalTracking.GetTimerValue("uht_spin", "time_response_received", "SpinTracker");
    globalTracking.StopTimerAndSend("uht_spin", "time_response_received", "SpinTracker")
};
VideoSlotsConnectionXTLayer.prototype.InitFirstScreenSymbols = function(reelSymbols) {
    XT.SetObject(Vars.FirstScreenSymbols, reelSymbols)
};
VideoSlotsConnectionXTLayer.prototype.SetNASymbolId = function(_naSymbolId) {
    XT.SetInt(Vars.NASymbolId, _naSymbolId)
};
VideoSlotsConnectionXTLayer.prototype.SetWildRandomLineMpConfig = function(cfgs) {
    XT.SetObject(Vars.WildRandomLineMpConfig, cfgs)
};
VideoSlotsConnectionXTLayer.prototype.SetWRLMResponse = function(response) {
    XT.SetObject(Vars.WRLMResponse, response)
};
VideoSlotsConnectionXTLayer.prototype.SetWRLMCurrentSets = function(css) {
    XT.SetObject(Vars.WRLMCurrentSets, css)
};
VideoSlotsConnectionXTLayer.prototype.SetRandomAwardsConfig = function(config) {
    XT.SetObject(Vars.RandomAwardsConfig, config)
};
VideoSlotsConnectionXTLayer.prototype.SetRandomAwardResponse = function(rar) {
    XT.SetObject(Vars.RandomAwardsResponse, rar)
};
VideoSlotsConnectionXTLayer.prototype.SetBetLevelSettings = function(bl) {
    XT.SetObject(Vars.BetLevelSettings, bl)
};
VideoSlotsConnectionXTLayer.prototype.SetFSPurchaseConfig = function(fspc) {
    XT.SetObject(Vars.FreeSpinsPurchaseConfig, fspc)
};
VideoSlotsConnectionXTLayer.prototype.SetFSPurchaseData = function(fspd) {
    XT.SetObject(Vars.FreeSpinsPurchaseData, fspd)
};
VideoSlotsConnectionXTLayer.prototype.SetRandomSymbolMultipliers = function(rsm) {
    XT.SetObject(Vars.RandomSymbolMultipliers, rsm)
};
VideoSlotsConnectionXTLayer.prototype.SetPossibleRandomSymbolMultipliers = function(prm) {
    XT.SetObject(Vars.PossibleRandomSymbolMultipliers, prm)
};
VideoSlotsConnectionXTLayer.prototype.SetFreeSpinsChainData = function(fcsd) {
    XT.SetObject(Vars.FreeSpinsChainData, fcsd)
};
VideoSlotsConnectionXTLayer.prototype.SetOpeningSymbolsData = function(osd) {
    XT.SetObject(Vars.OpeningSymbolsData, osd)
};
VideoSlotsConnectionXTLayer.prototype.SetRandomMysterySymbolsIds = function(rms) {
    XT.SetObject(Vars.RandomMysterySymbolId, rms)
};
VideoSlotsConnectionXTLayer.prototype.SetInitialMysterySymbolsIds = function(rmi) {
    XT.SetObject(Vars.InitialMysterySymbolId, rmi)
};
VideoSlotsConnectionXTLayer.prototype.SetInitialBGItemValues = function(bgItemValues) {
    XT.SetObject(Vars.InitBGItemValues, bgItemValues)
};
VideoSlotsConnectionXTLayer.prototype.SetInitialBGItemMasks = function(bgItemMasks) {
    XT.SetObject(Vars.InitBGItemMasks, bgItemMasks)
};
VideoSlotsConnectionXTLayer.prototype.SetSpinOneReelValues = function(Values) {
    XT.SetObject(Vars.SpinOneReelData, Values)
};
VideoSlotsConnectionXTLayer.prototype.SetPatternedMysterySymbols = function(pms) {
    XT.SetObject(Vars.PatternedMysterySymbols, pms)
};
VideoSlotsConnectionXTLayer.prototype.SetTumblingWin = function(value) {
    XT.SetDouble(Vars.TumblingWin, value)
};
VideoSlotsConnectionXTLayer.prototype.SetTumblingData = function(value) {
    XT.SetObject(Vars.TumblingData, value)
};
VideoSlotsConnectionXTLayer.prototype.SetRandomWildsData = function(randomWildsData, upSymbols) {
    XT.SetObject(Vars.RandomWildsData, randomWildsData);
    XT.SetObject(Vars.UpSymbols_RandomWilds, upSymbols);
    XT.TriggerEvent(Vars.Evt_Internal_RandomWildsDataSet)
};
VideoSlotsConnectionXTLayer.prototype.SetExpandingSymbolsData = function(expSymbolsData) {
    XT.SetObject(Vars.ExpandingSymbolsData, expSymbolsData);
    XT.TriggerEvent(Vars.Evt_Internal_ExpandingSymbolsDataSet)
};
VideoSlotsConnectionXTLayer.prototype.SetResultScreenSymbols = function(reelSymbols) {
    XT.SetObject(Vars.ResultScreenSymbols, reelSymbols)
};
VideoSlotsConnectionXTLayer.prototype.SetInitialResultScreenSymbols = function(reelSymbols) {
    XT.SetObject(Vars.InitialResultScreenSymbols, reelSymbols)
};
VideoSlotsConnectionXTLayer.prototype.SetSymbolsAbove = function(sa) {
    XT.SetObject(Vars.SymbolsAboveReels, sa)
};
VideoSlotsConnectionXTLayer.prototype.SetSymbolsBelow = function(sb) {
    XT.SetObject(Vars.SymbolsBelowReels, sb)
};
VideoSlotsConnectionXTLayer.prototype.SetNextReelsSymbolsList = function(n_rsl) {
    XT.SetObject(Vars.NextReelsSymbolsList, n_rsl)
};
VideoSlotsConnectionXTLayer.prototype.SetWinValue = function(value) {
    if (value >= 0) XT.SetDouble(Vars.WinReceived, value)
};
VideoSlotsConnectionXTLayer.prototype.SetExtraAwardWin = function(val) {
    XT.SetDouble(Vars.ExtraAwardWin, val)
};
VideoSlotsConnectionXTLayer.prototype.SetRespinCycleWin = function(val) {
    XT.SetDouble(Vars.RespinCycleWin, val)
};
VideoSlotsConnectionXTLayer.prototype.SetSpinCycleWinValue = function(value) {
    if (value >= 0) XT.SetDouble(Vars.SpinCycleWinReceived, value)
};
VideoSlotsConnectionXTLayer.prototype.SetLinesWinValue = function(value) {
    XT.SetDouble(Vars.TotalLinesWinReceived, value)
};
VideoSlotsConnectionXTLayer.prototype.SetHasCoins = function(allowCoins) {
    var hasCoins = XT.GetBool(Vars.HasCoins);
    XT.SetBool(Vars.HasCoins, !hasCoins);
    XT.SetBool(Vars.HasCoins, hasCoins);
    XT.SetBool(Vars.FromServer_AllowCoins, allowCoins)
};
VideoSlotsConnectionXTLayer.prototype.SetBets = function(betsFromServer, previousBet, defaultBet) {
    CoinManager.ComputeCoinValuesAndCurrentBet(betsFromServer, previousBet, defaultBet)
};
VideoSlotsConnectionXTLayer.prototype.SetExplicitMaxTotalBet = function(maxTotalBet) {
    if (maxTotalBet > 0) XT.SetDouble(Vars.ExplicitMaxTotalBetFromServer, maxTotalBet);
    else XT.SetDouble(Vars.ExplicitMaxTotalBetFromServer, 9007199254740991)
};
VideoSlotsConnectionXTLayer.prototype.SetBetLines = function(lines) {
    XT.SetInt(Vars.BetToTotalBetMultiplier, lines);
    XT.SetInt(Vars.Lines, XT.GetBool(Vars.GameHasWaysInsteadOfLines) ? XT.GetInt(Vars.TotalNumberOfLines) : lines)
};
VideoSlotsConnectionXTLayer.prototype.SetWinLines = function(winLines) {
    if (XT.GetBool(Vars.GameHasWaysInsteadOfLines) && !XT.GetBool(Vars.GameHasLinesWithBetMultiplier))
        for (var i = 0; i < winLines.length; i++) winLines[i].LineNumber = i;
    XT.SetObject(Vars.ReceivedWinLines, winLines)
};
VideoSlotsConnectionXTLayer.prototype.SetBalance = function(value, fromSpinResult) {
    XT.SetDouble(Vars.BalanceReceived, value);
    if (fromSpinResult) XT.TriggerEvent(Vars.Evt_FromServer_BalanceUpdatedFromResult);
    else if (!XT.GetBool(Vars.IgnoreServerBalanceRequest)) {
        XT.TriggerEvent(Vars.Evt_FromServer_BalanceUpdated);
        UHTInterfaceBOSS.PostMessage("post_updateBalance")
    }
};
VideoSlotsConnectionXTLayer.prototype.SetBonusBalance = function(value) {
    XT.SetDouble(Vars.BonusBalanceReceived, value)
};
VideoSlotsConnectionXTLayer.prototype.SetCanGambleSpinWin = function(val) {
    XT.SetBool(Vars.FromServer_CanGambleSpinWin, val)
};
VideoSlotsConnectionXTLayer.prototype.SetGambleResponse = function(vsGambleResp) {
    XT.SetObject(Vars.FromServer_GambleResult, vsGambleResp)
};
VideoSlotsConnectionXTLayer.prototype.SetGambleHistory = function(vsGambleHistory) {
    XT.SetObject(Vars.FromServer_GambleHistory, vsGambleHistory)
};
VideoSlotsConnectionXTLayer.prototype.SetInitialSoundState = function(isOn) {
    this.internalGlobalSoundIsOn = isOn
};
VideoSlotsConnectionXTLayer.prototype.SetSoundState = function(_gameSoundIsOn, _musicIsOn, _soundFXIsOn, _oldMusicIsOn, _oldSoundFXIsOn) {
    var s = new SoundState;
    s.gameSoundIsOn = _gameSoundIsOn;
    if (UHT_DEVICE_TYPE.MOBILE) {
        s.musicIsOn = s.gameSoundIsOn;
        s.soundFXIsOn = s.gameSoundIsOn;
        s.oldMusicIsOn = !s.gameSoundIsOn;
        s.oldSoundFXIsOn = !s.gameSoundIsOn
    } else {
        s.musicIsOn = _musicIsOn;
        s.soundFXIsOn = _soundFXIsOn;
        s.oldMusicIsOn = _oldMusicIsOn;
        s.oldSoundFXIsOn = _oldSoundFXIsOn
    }
    s.globalSoundIsOn = this.internalGlobalSoundIsOn;
    XT.SetObject(Vars.SoundState,
        s);
    XT.SetBool(Vars.MusicIsOn, s.musicIsOn);
    XT.TriggerEvent(Vars.Evt_Internal_SoundStateChanged)
};
VideoSlotsConnectionXTLayer.prototype.SetFreeSpinResponseReceived = function(_freeSpinResponse) {
    if (this.fsr == null) this.fsr = new FreeSpinsResponse;
    this.fsr.SetFreeSpinsResponse(_freeSpinResponse);
    XT.SetObject(Vars.ReceivedFreeSpinsResponse, this.fsr)
};
VideoSlotsConnectionXTLayer.prototype.SetTruncatedFSResponseReceived = function(_fsr) {
    var t_fsr = new FreeSpinsResponse;
    t_fsr.SetFreeSpinsResponse(_fsr);
    XT.SetObject(Vars.TruncatedFreeSpinsResponse, t_fsr)
};
VideoSlotsConnectionXTLayer.prototype.SetMysteryScatterSymbolIds = function(mssidList) {
    XT.SetObject(Vars.MysteryScatterSymbolIds, mssidList)
};
VideoSlotsConnectionXTLayer.prototype.SetStartFSBG = function(isMysteryScatter) {
    if (isMysteryScatter) this.SendGetMysteryScatter();
    XT.SetBool(Vars.FromServer_MustOpenFSBG, true)
};
VideoSlotsConnectionXTLayer.prototype.SendGetMysteryScatter = function() {
    this.vsc.SendGetMysteryScatter()
};
VideoSlotsConnectionXTLayer.prototype.SendFSBGInitDone = function() {
    XT.TriggerEvent(Vars.Evt_FromServer_InitFSBGPick)
};
VideoSlotsConnectionXTLayer.prototype.SendFSBGResponseReceived = function() {
    XT.TriggerEvent(Vars.Evt_FromServer_ResponseFSBGPick)
};
VideoSlotsConnectionXTLayer.prototype.OnShowResult = function() {
    this.vsc.OnShowResult()
};
VideoSlotsConnectionXTLayer.prototype.OnFreeSpinClosed = function() {
    this.vsc.OnFreeSpinsClosed();
    this.fsr = new FreeSpinsResponse;
    XT.SetObject(Vars.ReceivedFreeSpinsResponse, this.fsr)
};
VideoSlotsConnectionXTLayer.prototype.OnRequestInit = function() {
    console.log("OnRequestInit", ServerOptions);
    EventManager.AddHandler(GameEvents.evtConnectionReady, this.OnConnectionReady, this)
};
VideoSlotsConnectionXTLayer.prototype.OnRequestSpin = function() {
    this.vsc.SpinPressed(XT.GetInt(Vars.Lines), CoinManager.GetNextBet());
    XT.SetBool(Vars.CanAnimateValues, true);
    var bData = XT.GetObject(Vars.BonusData);
    if (bData != null) bData.justReceived = false
};
VideoSlotsConnectionXTLayer.prototype.OnRequestGambleOpen = function() {
    this.vsc.SendGambleOpen()
};
VideoSlotsConnectionXTLayer.prototype.OnRequestGambleClose = function() {
    XT.SetObject(Vars.FromServer_GambleHistory, null);
    this.vsc.SendGambleBack()
};
VideoSlotsConnectionXTLayer.prototype.OnGamblePick = function() {
    var choice;
    XT.SetBool(Vars.CanAnimateValues, true);
    switch (XT.GetInt(Vars.Gamble_Choice)) {
        case 0:
            choice = VsGamblingRequest.GamblingChoices.Red;
            break;
        case 1:
            choice = VsGamblingRequest.GamblingChoices.Black;
            break;
        case 2:
            choice = VsGamblingRequest.GamblingChoices.Clubs;
            break;
        case 3:
            choice = VsGamblingRequest.GamblingChoices.Spades;
            break;
        case 4:
            choice = VsGamblingRequest.GamblingChoices.Diamond;
            break;
        case 5:
            choice = VsGamblingRequest.GamblingChoices.Heart;
            break;
        case 6:
            choice = VsGamblingRequest.GamblingChoices.Dices;
            break;
        default:
            choice = VsGamblingRequest.GamblingChoices.None;
            break
    }
    this.vsc.SendGambleChoice(choice)
};
VideoSlotsConnectionXTLayer.prototype.OnBonusPick = function() {
    var i = XT.GetInt(Vars.BonusPickItemIndex);
    this.bonusConnection.SendItemPick(i);
    XT.SetBool(Vars.CanAnimateValues, true)
};
VideoSlotsConnectionXTLayer.prototype.OnSendBonusRespin = function() {
    this.bonusConnection.SendBonusRespin();
    XT.SetBool(Vars.CanAnimateValues, true)
};
VideoSlotsConnectionXTLayer.prototype.OnBonusCustomPick = function() {
    var i = XT.GetInt(Vars.BonusPickItemIndex);
    this.bonusConnection.SendCustomItemPick(i, -1);
    XT.SetBool(Vars.CanAnimateValues, true)
};
VideoSlotsConnectionXTLayer.prototype.OnBonusGameFinished = function() {
    this.bonusConnection.OnBonusGameFinished();
    if (XT.GetBool(Vars.BonusTriggersFSBG)) this.SetStartFSBG(XT.GetBool(Vars.BonusTriggeredFSBGIsMystery))
};
VideoSlotsConnectionXTLayer.prototype.SendBonusInitDone = function() {
    this.UpdateBonusVars();
    XT.TriggerEvent(FOXVars.Evt_FOX_AfterInitBonusReceived);
    XT.TriggerEvent(Vars.Evt_FromServer_BonusInitDone)
};
VideoSlotsConnectionXTLayer.prototype.SendBonusResponse = function() {
    this.UpdateBonusVars();
    XT.TriggerEvent(Vars.Evt_FromServer_BonusResponseReceived)
};
VideoSlotsConnectionXTLayer.prototype.UpdateBonusVars = function() {
    if (this.bonusData == null) this.bonusData = new BonusData;
    this.bonusData.justReceived = true;
    this.bonusData.GameID = this.bonusConnection.lastResponse.id;
    this.bonusData.GameType = this.bonusConnection.lastResponse.type;
    this.bonusData.WheelOfFortune = this.bonusConnection.lastResponse.wheelOfFortune;
    this.bonusData.Coef = this.bonusConnection.Coef();
    this.bonusData.GameOver = this.bonusConnection.GameOver();
    this.bonusData.Level = this.bonusConnection.Level();
    this.bonusData.Life = this.bonusConnection.Life();
    this.bonusData.RealWin = this.bonusConnection.RealWin();
    this.bonusData.WinPoints = this.bonusConnection.WinPoints();
    this.bonusData.PossibleWins = this.bonusConnection.PossibleWins();
    this.bonusData.PremultipliedWin = this.bonusConnection.lastResponse.PremultipliedWin;
    this.bonusData.MultipliedSymbolPositions = this.bonusConnection.MultipliedSymbolPositions();
    this.bonusData.RespinsTotalMultiplier = this.bonusConnection.lastResponse.RespinsTotalMultiplier;
    this.bonusData.ExtraRespinsWon =
        this.bonusConnection.lastResponse.ExtraRespinsWon;
    this.bonusData.ExtraRetriggersWon = this.bonusConnection.lastResponse.ExtraRetriggersWon;
    if (XT.GetBool(Vars.UpdateBonusPickDataDuringRespins) || (this.bonusConnection.lastResponse.currentBonusRespin == 0 || this.bonusData.MultipliedSymbolPositions != null) && this.bonusConnection.lastResponse.respinSymbols == null) {
        this.bonusData.ItemsMarkers = this.bonusConnection.ItemsMarkers();
        this.bonusData.ItemsStatus = this.bonusConnection.ItemsStatus();
        this.bonusData.ItemsWins =
            this.bonusConnection.ItemsWins();
        this.bonusData.WinsMask = this.bonusConnection.WinsMask()
    }
    this.bonusData.LifeWins = this.bonusConnection.LifeWins();
    this.bonusData.currentBonusRespin = this.bonusConnection.CurrentBonusRespin();
    this.bonusData.maxBonusRespins = this.bonusConnection.MaxBonusRespins();
    this.bonusData.respinSymbols = this.bonusConnection.RespinSymbols();
    if (this.bonusConnection.lastResponse.MultipliersTable.Markers != null) {
        this.bonusData.MultipliersMarkers = this.bonusConnection.MultipliersMarkers();
        this.bonusData.MultipliersStatus = this.bonusConnection.MultipliersStatus();
        this.bonusData.MultipliersWins = this.bonusConnection.MultipliersWins()
    }
    this.bonusData.MultiplierStep = this.bonusConnection.MultiplierStep();
    this.bonusData.numberOfLevels = this.bonusConnection.lastResponse.numberOfLevels;
    if (this.bonusConnection.lastResponse.BonusTable.BGItemValues != null) this.bonusData.BGItemValues = this.bonusConnection.lastResponse.BonusTable.BGItemValues;
    if (this.bonusConnection.lastResponse.BonusTable.BGItemMasks !=
        null) this.bonusData.BGItemMasks = this.bonusConnection.lastResponse.BonusTable.BGItemMasks;
    if (this.bonusConnection.lastResponse.map != null) this.bonusData.Map = this.bonusConnection.lastResponse.map;
    XT.SetObject(Vars.BonusData, this.bonusData);
    XT.SetBool(BGVars.BonusDataReceived, true)
};
VideoSlotsConnectionXTLayer.prototype.SetMustOpenBonus = function(mustOpen, mustOpenAnother) {
    XT.SetBool(Vars.MustOpenBonus, mustOpen);
    XT.SetBool(Vars.MustOpenAnotherBonus, mustOpenAnother)
};
VideoSlotsConnectionXTLayer.prototype.MustOpenFSOptions = function(fsOptions) {
    XT.SetObject(Vars.FreeSpinOptions, fsOptions);
    XT.SetBool(Vars.FromServer_MustOpenFSBG, true)
};
VideoSlotsConnectionXTLayer.prototype.FreeSpinOptionsResponseReceived = function(response) {
    if (this.fsr == null) this.fsr = new FreeSpinsResponse;
    this.fsr.SetFreeSpinsResponse(response.GetVsFreeSpin());
    XT.SetObject(Vars.ReceivedFreeSpinsResponse, this.fsr);
    XT.SetInt(Vars.StackedSymbolIndex, response.StackedSymbolIndex);
    XT.SetObject(Vars.FreeSpinOptions, response.FreeSpinsOptions);
    var reelSets = XT.GetObject(Vars.ReelSets);
    if (reelSets != null && response.ReelSetIndex >= 0) this.InitNextReelSymbols(reelSets[response.ReelSetIndex]);
    XT.TriggerEvent(FOXVars.Evt_FOX_AfterPickFSOptionReceived);
    XT.TriggerEvent(Vars.Evt_FromServer_ResponseFSBGPick)
};
VideoSlotsConnectionXTLayer.prototype.OnItemPickedFSBGPick = function() {
    XT.SetBool(Vars.CanAnimateValues, true);
    var pickedIndex = XT.GetInt(Vars.PickedItemIndexLocal_FSBGPick);
    var bonusHasFreeSpinOptions = this.bonusConnection.vsResponse != null && this.bonusConnection.vsResponse.HasFreeSpinOptions();
    if (this.vsc.HasFreeSpinOptions() || bonusHasFreeSpinOptions) this.vsc.FSOption_SendPick(pickedIndex);
    else this.vsc.FSBG_SendPick(pickedIndex)
};
VideoSlotsConnectionXTLayer.prototype.SetJackpotState = function(data) {
    var jackpotToEnable = -1;
    if (data != null && data.JackpotID > 0) jackpotToEnable = 0;
    else;
    XT.SetInt(Vars.CurrentlyDisplayedJackpot, jackpotToEnable)
};
VideoSlotsConnectionXTLayer.prototype.SetJackpotWon = function(jackpotId, jackpotOrder, amount) {
    XT.SetDouble(Vars.FromServer_JackpotAmountWon, amount);
    XT.SetInt(Vars.FromServer_JackpotWonID, jackpotId);
    XT.SetInt(Vars.FromServer_JackpotWonOrder, jackpotOrder);
    XT.SetBool(Vars.FromServer_IsJackpotWin, true);
    XT.SetBool(Vars.MustShowJackpotWon, true)
};
VideoSlotsConnectionXTLayer.prototype.SetJackpotsInfo = function(jpInfo) {
    var oldJP = XT.GetObject(Vars.FromServer_JackpotsInformation);
    if (oldJP != null) XT.SetObject(Vars.FromServer_LastValidJackpotsInformation, oldJP);
    else XT.SetObject(Vars.FromServer_LastValidJackpotsInformation, jpInfo);
    XT.SetObject(Vars.FromServer_JackpotsInformation, jpInfo)
};
VideoSlotsConnectionXTLayer.prototype.SetJackpotVisualization = function(jpv) {
    XT.SetObject(Vars.JackpotVisualization, jpv)
};
VideoSlotsConnectionXTLayer.prototype.SetGoldSymbol = function(gs) {
    XT.SetObject(Vars.GoldSymbol, gs)
};
VideoSlotsConnectionXTLayer.prototype.SetSymbolReplacementData = function(sr) {
    XT.SetObject(Vars.SymbolReplacementData, sr)
};
VideoSlotsConnectionXTLayer.prototype.SetPaytableInfo = function(paytableInfo) {
    XT.SetObject(Vars.PaytablePayoutData, paytableInfo);
    XT.TriggerEvent(Vars.Evt_Internal_PaytablePayoutUpdate)
};
VideoSlotsConnectionXTLayer.prototype.SetRespinData = function(_respinData) {
    if (_respinData != null && _respinData.TotalRespins != null) _respinData.IsDone = true;
    XT.SetObject(Vars.RespinData, _respinData)
};
VideoSlotsConnectionXTLayer.prototype.SetProgressiveFeatureConfig = function(_progressiveConfig) {
    XT.SetObject(Vars.ProgressiveFeatureConfig, _progressiveConfig)
};
VideoSlotsConnectionXTLayer.prototype.SetProgressiveFeatureData = function(_progressiveData) {
    XT.SetObject(Vars.ProgressiveFeatureData, _progressiveData)
};
VideoSlotsConnectionXTLayer.prototype.SetMoneySymbolConfig = function(_moneySymbolConfig) {
    XT.SetObject(Vars.MoneySymbolConfig, _moneySymbolConfig)
};
VideoSlotsConnectionXTLayer.prototype.SetMoneySymbolData = function(_moneySymbolData) {
    XT.SetObject(Vars.MoneySymbolData, _moneySymbolData)
};
VideoSlotsConnectionXTLayer.prototype.SetStickySymbolsData = function(_stickySymbolsData) {
    XT.SetObject(Vars.StickySymbolsData, _stickySymbolsData)
};
VideoSlotsConnectionXTLayer.prototype.SetMergingSymbolsData = function(_mergingSymbolsData) {
    XT.SetObject(Vars.MergingSymbolsData, _mergingSymbolsData)
};
VideoSlotsConnectionXTLayer.prototype.SetNudgedSymbolsData = function(_nudgedSymbolsData) {
    XT.SetObject(Vars.NudgedSymbols, _nudgedSymbolsData)
};
VideoSlotsConnectionXTLayer.prototype.Update = function() {
    if (this.isInCoolDown) {
        this.timeInCooldown += Time.deltaTime;
        if (this.timeInCooldown > 3) this.isInCoolDown = false
    }
    if (!this.isInCoolDown && this.needToSendSettingsToServer) {
        var settings = new GameSettings;
        this.UpdateSettings(false, settings);
        this.needToSendSettingsToServer = false;
        this.isInCoolDown = true;
        this.timeInCooldown = 0
    }
    if (this.mustTriggerDelayedGameLoadingFinished)
        if (Time.frameCount - this.delayedGameLoadingFinishedFrameCount > 5) {
            EventManager.Trigger(ApplicationEvents.evtGameLoadingFinished,
                this.gameSymbol);
            if (!ServerOptions.isReplay) Globals.InputBlocked = false;
            this.mustTriggerDelayedGameLoadingFinished = false
        }
};
VideoSlotsConnectionXTLayer.prototype.OnRequestToOpenCashier = function() {
    EventManager.Trigger(AdapterEvents.evtOpenCashier, null)
};
VideoSlotsConnectionXTLayer.prototype.OnRequestToCloseGame = function() {
    UHTInterfaceBOSS.PostMessage("gameQuit");
    EventManager.Trigger(AdapterEvents.evtCloseGame, null)
};
VideoSlotsConnectionXTLayer.prototype.OnRequestToReloadGame = function() {
    EventManager.Trigger(AdapterEvents.evtReload, null)
};
VideoSlotsConnectionXTLayer.prototype.SetGambleSettings = function(canGambleSpin, canGambleFreeSpin, canGambleBonus, gambleColorMultiplier, gambleSuitMultiplier) {
    XT.SetBool(Vars.CanGamble_Spin, canGambleSpin);
    XT.SetBool(Vars.CanGamble_FreeSpin, canGambleFreeSpin);
    XT.SetBool(Vars.CanGamble_Bonus, canGambleBonus);
    XT.SetDouble(Vars.Gamble_ColorMultiplier, gambleColorMultiplier);
    XT.SetDouble(Vars.Gamble_SuitMultiplier, gambleSuitMultiplier)
};
VideoSlotsConnectionXTLayer.prototype.SetReturnToPlayer = function(rtp) {
    XT.SetDouble(Vars.ReturnToPlayer, rtp)
};
VideoSlotsConnectionXTLayer.prototype.SetReturnToPlayerMin = function(rtp) {
    XT.SetDouble(Vars.ReturnToPlayerMin, rtp)
};
VideoSlotsConnectionXTLayer.prototype.SkipResultDisplayOnInit = function() {
    XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, true)
};
VideoSlotsConnectionXTLayer.prototype.CanTriggerInitReady = function() {
    return this.handlerGameInitReceived && this.settingsReceived && (this.resourcesLoaded || !ServerOptions.isOnline)
};
VideoSlotsConnectionXTLayer.prototype.TriggerInitReady = function() {
    XT.TriggerEvent(Vars.Evt_FromServer_InitReceived);
    this.mustTriggerDelayedGameLoadingFinished = true;
    this.delayedGameLoadingFinishedFrameCount = Time.frameCount
};
VideoSlotsConnectionXTLayer.prototype.UpdateBonusRoundsInfo = function(res) {
    if (res.FreeRoundEvents != null) XT.SetObject(Vars.BonusRoundsEvents, res.FreeRoundEvents);
    var evts = XT.GetObject(Vars.BonusRoundsEvents);
    if (res.FreeRound != null || evts != null && evts.length == 0) XT.SetObject(Vars.BonusRoundsData, res.FreeRound);
    XT.TriggerEvent(Vars.Evt_Internal_BonusRoundsInfoUpdated)
};
VideoSlotsConnectionXTLayer.prototype.UpdateBonusFSResponseValues = function(res) {
    var _vsFreeSpin = res.GetVsFreeSpin();
    if (_vsFreeSpin != null) this.SetFreeSpinResponseReceived(res.GetVsFreeSpin());
    this.SetWinValue(res.Win);
    this.vsc.UpdateBonusFSResponseValues(res)
};
VideoSlotsConnectionXTLayer.prototype.SetWildRandomMultipliers = function(wildRandomMultipliers) {
    XT.SetObject(Vars.WildRandomMultipliers, wildRandomMultipliers);
    XT.TriggerEvent(Vars.Evt_Internal_WildRandomMultipliersReceived)
};
VideoSlotsConnectionXTLayer.prototype.OnGambleV2Pick = function() {
    XT.SetBool(Vars.CanAnimateValues, true);
    this.vsc.SendGambleV2Choice(XT.GetInt(Vars.Gamble_Choice))
};
VideoSlotsConnectionXTLayer.prototype.SetGambleV2Response = function(gambleData) {
    XT.SetObject(Vars.GambleV2Data, gambleData);
    XT.TriggerEvent(FOXVars.Evt_FOX_AfterGambleReceived);
    XT.TriggerEvent(Vars.Evt_FromServer_GambleV2Response)
};
VideoSlotsConnectionXTLayer.prototype.SetMustOpenGambleV2 = function(mustOpen) {
    XT.SetBool(Vars.MustOpenGambleV2, mustOpen)
};
VideoSlotsConnectionXTLayer.prototype.MustPlayJackpot = function() {
    XT.SetObject(Vars.PlayJackpotData, null);
    XT.SetBool(Vars.MustPlayJackpot, true)
};
VideoSlotsConnectionXTLayer.prototype.OnRequestPlayJackpot = function() {
    this.vsc.SendPlayJackpotRequest()
};
VideoSlotsConnectionXTLayer.prototype.PlayJackpotResponse = function(data) {
    XT.SetObject(Vars.PlayJackpotData, data);
    XT.TriggerEvent(FOXVars.Evt_FOX_AfterPlayJackpotReceived);
    XT.TriggerEvent(Vars.Evt_FromServer_PlayJackpotResponse)
};
VideoSlotsConnectionXTLayer.prototype.SetServerTime = function(time) {
    XT.SetDouble(Vars.Jurisdiction_ServerTime, time)
};
goog.require("UHT.Engine");
ServerInterface.prototype = Object.create(Component.prototype);
ServerInterface.prototype.constructor = ServerInterface;

function ServerInterface() {
    Component.call(this);
    this.userName = "";
    this.userPass = "";
    this.domain = "";
    this.isExternal = false;
    this.xtLayer = null;
    this.configFile = null;
    this.counter = 0
}
ServerInterface.prototype.Awake = function() {
    if (UHT_LOCAL) ServerOptions.logLevel = LogLevel.Debug;
    this.ParseConfigFile()
};
ServerInterface.prototype.Start = function() {};
ServerInterface.prototype.Update = function() {
    if (this.counter < 4) this.counter++;
    if (this.counter == 2) {
        if (!UHT_LOCAL) ServerOptions.serverUrl = location.protocol + "//" + ServerInterface.GetDomain();
        else ServerOptions.serverUrl = "https://" + this.domain;
        if (UHT_LOCAL)
            if (_string.IsNullOrEmpty(this.userName) || _string.IsNullOrEmpty(this.userPass)) {
                console.error("The username and/or password are empty!");
                return
            }
        if (UHT_LOCAL && UHT_ONLINE) ServerHelpers.CookiesRequest(new EventHandler(this, this.OnCookieResponse));
        else EventManager.Trigger(ApplicationEvents.evtRequestInitApplication,
            null)
    }
};
ServerInterface.prototype.OnCookieResponse = function(param, statusCode) {
    console.info("Received response for sessionid request");
    ServerHelpers.LoginRequest(this.userName, this.userPass, new EventHandler(this, this.OnLoginResponse))
};
ServerInterface.prototype.OnLoginResponse = function(loginStr, statusCode) {
    if (loginStr.indexOf("log=1") != -1) {
        console.info("Login - Succes");
        EventManager.Trigger(ApplicationEvents.evtRequestInitApplication, null)
    } else console.error("Login - Fail")
};
ServerInterface.prototype.ParseConfigFile = function() {
    var lines = this.configFile.text.split("\n");
    if (this.configFile.text.indexOf("external") != -1) this.isExternal = true;
    if (lines.length < 6 || this.isExternal && lines.length < 8) console.error("There are missing parameters from the config file!");
    else {
        this.userName = lines[0];
        this.userPass = lines[1];
        this.domain = lines[2];
        ServerOptions.styleName = lines[3];
        ServerOptions.gameSymbol = lines[4];
        ServerOptions.language = lines[5];
        if (this.isExternal) {
            ServerOptions.gameServiceUri =
                lines[6];
            ServerOptions.tokenUrl = lines[7];
            ServerOptions.serverDomain = this.domain
        }
        if (this.configFile.text.indexOf("online") != -1) ServerOptions.isOnline = true;
        ServerInterface.domain = this.domain
    }
    ServerOptions.isOnline = UHT_ONLINE;
    if (UHT_GAME_CONFIG_SRC["replayMode"] == true) {
        ServerOptions.isOnline = false;
        ServerOptions.isReplay = true
    }
};
ServerInterface.domain = "";
ServerInterface.GetDomain = function() {
    return UHT_LOCAL ? ServerInterface.domain : location.host
};
goog.require("UHT.ArrangeableBase");
var V3ARCASamplerProperty = {
    None: 0,
    From: 1,
    To: 2
};
V3AnimatorRatioControllerArrangeable.prototype = Object.create(ArrangeableBase.prototype);
V3AnimatorRatioControllerArrangeable.prototype.constructor = V3AnimatorRatioControllerArrangeable;

function V3AnimatorRatioControllerArrangeable() {
    ArrangeableBase.call(this);
    this.landscapeV3ARC = null;
    this.portraitV3ARC = null;
    this.animators = null;
    this.samplers = null;
    this.samplerProperty = V3ARCASamplerProperty.None;
    this.targets = null;
    this.onlyUpdateTarget = false;
    this.ratioControllerChangedFrame = -1;
    this.ratioController = null;
    this.ratioPercent = -1;
    this.curIndex = -1;
    this.prevIndex = -1
}
V3AnimatorRatioControllerArrangeable.prototype.LateUpdate = function() {
    if (this.ratioController == null) return;
    if (this.ratioPercent != this.ratioController.ratioPercent || this.ratioControllerChangedFrame == Time.frameCount) {
        this.ratioPercent = this.ratioController.ratioPercent;
        this.UpdateAnimators()
    }
};
V3AnimatorRatioControllerArrangeable.prototype.OnSwitchToPortrait = function() {
    this.ratioController = this.portraitV3ARC;
    this.ratioControllerChangedFrame = Time.frameCount
};
V3AnimatorRatioControllerArrangeable.prototype.OnSwitchToLandscape = function() {
    this.ratioController = this.landscapeV3ARC;
    this.ratioControllerChangedFrame = Time.frameCount
};
V3AnimatorRatioControllerArrangeable.prototype.UpdateTarget = function(index, fast) {
    index = Number(index);
    if (this.curIndex == index) return;
    this.prevIndex = this.curIndex;
    this.curIndex = index;
    if (fast == undefined) fast = false;
    for (var i = 0; i < this.samplers.length; ++i) {
        if (this.samplerProperty == V3ARCASamplerProperty.From) this.samplers[i].from = this.targets[index];
        else if (this.samplerProperty == V3ARCASamplerProperty.To) this.samplers[i].to = this.targets[index];
        if (this.onlyUpdateTarget) continue;
        this.samplers[i].Sample(this.ratioPercent)
    }
    if (this.onlyUpdateTarget) return;
    if (fast)
        for (var i = 0; i < this.animators.length; ++i) this.animators[i].Sample(1);
    else
        for (var i = 0; i < this.animators.length; ++i) this.animators[i].Play()
};
V3AnimatorRatioControllerArrangeable.prototype.UpdateTargetFast = function(index) {
    this.UpdateTarget(Number(index), true)
};
V3AnimatorRatioControllerArrangeable.prototype.UpdateTargetPrevious = function() {
    if (this.prevIndex > -1) this.UpdateTarget(this.prevIndex)
};
V3AnimatorRatioControllerArrangeable.prototype.UpdateTargetPreviousFast = function() {
    if (this.prevIndex > -1) this.UpdateTarget(this.prevIndex, true)
};
V3AnimatorRatioControllerArrangeable.prototype.UpdateAnimators = function() {
    if (this.onlyUpdateTarget) return;
    for (var i = 0; i < this.samplers.length; ++i) this.samplers[i].Sample(this.ratioPercent);
    for (var i = 0; i < this.animators.length; ++i)
        if (!this.animators[i].IsPlaying()) this.animators[i].Sample(1)
};
goog.provide("UHT.Special_Symbol");
goog.require("UHT.Engine");
goog.require("UHT.CAT_Event");
Special_Symbol.prototype = Object.create(Component.prototype);
Special_Symbol.prototype.constructor = Special_Symbol;

function Special_Symbol() {
    Component.call(this);
    this.symbolId = 0;
    this.willHighlightOffAfterExciteWin = true;
    this.eventNormal = null;
    this.eventSpinStart = null;
    this.eventSpinLoop = null;
    this.eventSpinStop = null;
    this.eventHighlightOff = null;
    this.eventHighlightOn = null;
    this.eventExcited = null;
    this.eventWinExcited = null;
    this.eventWinning = null;
    this.eventSpinLoopExcited = null;
    this.eventFSHighlightOff = null;
    this.eventStart = null;
    this.eventStop = null;
    this.currentStateForInspector = Special_Symbol.State.Invalid;
    this.internalState =
        Special_Symbol.State.Invalid;
    this.lastQueuedState = Special_Symbol.State.Invalid;
    this.commands = [];
    this.stopEventSent = false;
    this.canProcessNextCommand = true
}
Special_Symbol.State = {
    Invalid: 0,
    Normal: 1,
    HighlightOn: 2,
    HighlightOff: 3,
    SpinStart: 4,
    SpinLoop: 5,
    SpinStop: 6,
    Excited: 7,
    WinExcited: 8,
    SpinLoopExcited: 9,
    Winning: 10,
    FSHighlightOff: 11
};
Special_Symbol.prototype.ChangeToState = function(newState) {
    this.commands.push(newState);
    this.lastQueuedState = newState;
    this.ProcessCommands()
};
Special_Symbol.prototype.Start = function() {
    this.eventNormal.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOn.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOff.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStart.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoop.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStop.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventExcited.UnregisterCallback(this.Callback_EventEnded,
        this);
    this.eventWinExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoopExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWinning.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventFSHighlightOff.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventNormal.RegisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOn.RegisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOff.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStart.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoop.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStop.RegisterCallback(this.Callback_EventEnded, this);
    this.eventExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWinExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoopExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWinning.RegisterCallback(this.Callback_EventEnded, this);
    this.eventFSHighlightOff.RegisterCallback(this.Callback_EventEnded,
        this)
};
Special_Symbol.prototype.ProcessCommands = function() {
    if (this.commands.length > 0)
        if (this.canProcessNextCommand) {
            var newState = this.commands[0];
            this.commands.splice(0, 1);
            this.canProcessNextCommand = false;
            switch (newState) {
                case Special_Symbol.State.Normal:
                    this.eventNormal.Start();
                    break;
                case Special_Symbol.State.HighlightOn:
                    this.eventHighlightOn.Start();
                    break;
                case Special_Symbol.State.HighlightOff:
                    this.eventHighlightOff.Start();
                    break;
                case Special_Symbol.State.SpinStart:
                    this.eventSpinStart.Start();
                    break;
                case Special_Symbol.State.SpinLoop:
                    this.eventSpinLoop.Start();
                    break;
                case Special_Symbol.State.SpinStop:
                    this.eventSpinStop.Start();
                    break;
                case Special_Symbol.State.Excited:
                    this.eventExcited.Start();
                    break;
                case Special_Symbol.State.WinExcited:
                    this.eventWinExcited.Start();
                    break;
                case Special_Symbol.State.Winning:
                    this.eventWinning.Start();
                    break;
                case Special_Symbol.State.SpinLoopExcited:
                    this.eventSpinLoopExcited.Start();
                    break;
                case Special_Symbol.State.FSHighlightOff:
                    this.eventFSHighlightOff.Start();
                    break;
                case Special_Symbol.State.Invalid:
                default:
                    this.canProcessNextCommand =
                        true;
                    break
            }
            this.internalState = newState;
            this.currentStateForInspector = this.internalState
        } else if (this.stopEventSent == false) this.StopAllRunningEvents()
};
Special_Symbol.prototype.Update = function() {
    this.ProcessCommands()
};
Special_Symbol.prototype.Callback_EventEnded = function(_type, data) {
    if (_type == CAT_Event.CallbackType.EndOfEvent) this.canProcessNextCommand = true
};
Special_Symbol.prototype.StopAllRunningEvents = function() {
    if (this.eventNormal.IsRunning()) this.eventNormal.Stop();
    if (this.eventHighlightOn.IsRunning()) this.eventHighlightOn.Stop();
    if (this.eventHighlightOff.IsRunning()) this.eventHighlightOff.Stop();
    if (this.eventSpinStart.IsRunning()) this.eventSpinStart.Stop();
    if (this.eventSpinLoop.IsRunning()) this.eventSpinLoop.Stop();
    if (this.eventSpinStop.IsRunning()) this.eventSpinStop.Stop();
    if (this.eventExcited.IsRunning()) this.eventExcited.Stop();
    if (this.eventWinExcited.IsRunning()) this.eventWinExcited.Stop();
    if (this.eventWinning.IsRunning()) this.eventWinning.Stop();
    if (this.eventSpinLoopExcited.IsRunning()) this.eventSpinLoopExcited.Stop();
    if (this.eventFSHighlightOff.IsRunning()) this.eventFSHighlightOff.Stop()
};
Special_Symbol.prototype.SpinStart = function() {
    this.ChangeToState(Special_Symbol.State.SpinStart)
};
Special_Symbol.prototype.SpinLoop = function() {
    this.ChangeToState(Special_Symbol.State.SpinLoop)
};
Special_Symbol.prototype.SpinStop = function() {
    this.ChangeToState(Special_Symbol.State.SpinStop)
};
Special_Symbol.prototype.SetHighlightOn = function() {
    this.ChangeToState(Special_Symbol.State.HighlightOn)
};
Special_Symbol.prototype.SetHighlightOff = function() {
    if (this.internalState != Special_Symbol.State.WinExcited && this.internalState != Special_Symbol.State.Winning || this.willHighlightOffAfterExciteWin)
        if (XT.GetBool(Vars.Logic_IsFreeSpin)) this.ChangeToState(Special_Symbol.State.FSHighlightOff);
        else this.ChangeToState(Special_Symbol.State.HighlightOff)
};
Special_Symbol.prototype.SetNormal = function() {
    this.ChangeToState(Special_Symbol.State.Normal)
};
Special_Symbol.prototype.SetExcited = function() {
    this.ChangeToState(Special_Symbol.State.Excited)
};
Special_Symbol.prototype.SetWinExcited = function() {
    this.ChangeToState(Special_Symbol.State.WinExcited)
};
Special_Symbol.prototype.SpinLoopExcited = function() {
    this.ChangeToState(Special_Symbol.State.SpinLoopExcited)
};
Special_Symbol.prototype.SetWinning = function() {
    this.ChangeToState(Special_Symbol.State.Winning)
};
Special_Symbol.prototype.EventStart = function() {
    this.eventStart.Start()
};
Special_Symbol.prototype.EventStop = function() {
    this.eventStop.Start()
};
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
goog.require("UHT.Special_Symbol");
Special_SymbolsManager.prototype = Object.create(XTLink.prototype);
Special_SymbolsManager.prototype.constructor = Special_SymbolsManager;

function Special_SymbolsManager() {
    XTLink.call(this);
    this.pool = null;
    this.symbols = [];
    this.symbolIdToIndexMap = [];
    this.pooledSymbols = [];
    this.disablePoolNextFrame = false;
    this.defaultBufferAmount = 10;
    this.currentInitSymbol = -1
}
Special_SymbolsManager.initializing = 0;
Special_SymbolsManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Init_SymbolManager, this.OnSymbolManagerInit, this)
};
Special_SymbolsManager.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnSymbolManagerInit, this)
};
Special_SymbolsManager.prototype.OnSymbolManagerInit = function() {
    SymbolsManager_CheckAndSendTrackingInit();
    Special_SymbolsManager.initializing++;
    this.currentInitSymbol = 0;
    this.BuildSymbolIdToIndexMap();
    this.pooledSymbols = [];
    this.pool.SetActive(true);
    if (LoaderProgress.SymbolsManagers_Total == -1) LoaderProgress.SymbolsManagers_Total = this.symbols.length;
    else LoaderProgress.SymbolsManagers_Total += this.symbols.length
};
Special_SymbolsManager.prototype.Update = function() {
    if (this.currentInitSymbol >= 0)
        if (this.currentInitSymbol < this.symbols.length) {
            var id = this.symbols[this.currentInitSymbol].symbolId;
            this.pooledSymbols[id] = [];
            for (var n = 0; n < this.defaultBufferAmount; n++) {
                var newObj = instantiate(this.symbols[this.currentInitSymbol].gameObject);
                newObj.SetActive(true);
                this.PoolSymbol(id, newObj.GetComponent(Special_Symbol))
            }
            this.currentInitSymbol++;
            LoaderProgress.SymbolsManagers_Current++
        } else if (this.currentInitSymbol == this.symbols.length) {
        this.disablePoolNextFrame =
            false;
        Special_SymbolsManager.initializing--;
        SymbolsManager_CheckAndSendTrackingEnd();
        this.currentInitSymbol++
    }
};
Special_SymbolsManager.prototype.BuildSymbolIdToIndexMap = function() {
    var highestSymbolId = -1;
    for (var i = 0; i < this.symbols.length; i++)
        if (this.symbols[i].symbolId > highestSymbolId) highestSymbolId = this.symbols[i].symbolId;
    this.symbolIdToIndexMap = new Array(highestSymbolId + 1);
    for (var j = 0; j < this.symbols.length; j++) this.symbolIdToIndexMap[this.symbols[j].symbolId] = j
};
Special_SymbolsManager.prototype.GetFromPool = function(id, parent) {
    if (this.pooledSymbols[id].length == 0) {
        console.log("Symbol pool capacity is too small! ID = " + id);
        this.pooledSymbols[id].push(instantiate(this.symbols[this.symbolIdToIndexMap[id]].gameObject).GetComponent(Special_Symbol));
        this.pooledSymbols[id][this.pooledSymbols[id].length - 1].gameObject.SetActive(true)
    }
    var pooledObject = this.pooledSymbols[id][0];
    this.pooledSymbols[id].splice(0, 1);
    pooledObject.gameObject.transform.SetParent(parent.transform,
        false);
    pooledObject.gameObject.transform.localPosition(UHTMath.Vector3.zero);
    pooledObject.gameObject.transform.localRotation(UHTMath.Quaternion.euler(UHTMath.Vector3.zero));
    pooledObject.gameObject.transform.localScale(UHTMath.Vector3.one);
    return pooledObject
};
Special_SymbolsManager.prototype.PoolSymbol = function(id, obj) {
    obj.gameObject.transform.SetParent(this.pool.transform, false);
    this.pooledSymbols[id].push(obj)
};
Special_SymbolsManager.prototype.GetSymbol = function(symbolId, parent) {
    return this.GetFromPool(symbolId, parent)
};
Special_SymbolsManager.prototype.RecycleSymbol = function(symbol) {
    this.PoolSymbol(symbol.symbolId, symbol)
};
Special_SymbolsManager.prototype.LateUpdate = function() {
    if (this.pool.activeSelf && this.currentInitSymbol > this.symbols.length) {
        if (!this.disablePoolNextFrame) {
            this.disablePoolNextFrame = true;
            return
        }
        this.pool.SetActive(false)
    }
};
goog.require("UHT.UHTStage");
StageInit.prototype = Object.create(UHTStage.prototype);
StageInit.prototype.constructor = StageInit;

function StageInit() {
    UHTStage.call(this);
    this.initShow = null;
    this.introShow = null;
    this.introHide = null;
    this.XTRoot = null;
    this.manualRespin = false;
    this.totalNumberOfLines = -1;
    this.linesForMinBet = -1;
    this.linesForMaxBet = -1;
    this.hasWaysInsteadOfLines = false;
    this.hasLinesWithBetMultiplier = false;
    this.hasAnteBet = false;
    this.paysBothWays = false;
    this.hasCustomGamble = false;
    this.hasIntro = false;
    this.triggerBonusBeforeResult = false;
    this.scatterIsWild = false;
    this.freeSpinsStartNeedsConfirmation = false;
    this.bonusWinIsSeparated =
        false;
    this.instantlyCollectBonusWin = false;
    this.opaqueInterface = true;
    this.hasReelAwareSymbolContent = false;
    this.truncateFSResponseDuringRespin = false;
    this.updateFSResponseOnBonusPick = true;
    this.partiallyUpdateSpinResponseOnBonusPick = false;
    this.allowBonusPickDuringBonusRespin = false;
    this.updateRespinDataOnBonusPick = false;
    this.noInitBonusGameTypes = [];
    this.noInitBonusGameIds = [];
    this.payingSymbolsDisplayServerID = false;
    this.canTriggerBigWinBeforeBonus = false;
    this.forcedGoToSpin = false;
    this.numberOfBetLevels =
        10;
    this.minimumJackpotBigWinDuration = 99999;
    this.defaultGameWindowOverride = null;
    this.showGamePaysAsWinTeaser = false;
    this.GUIDynamicMessagesDelay = .5;
    this.GUICustomFSLeftMessage = "default";
    this.GUICustomFSLeft_usesCATEvents = true;
    this.showExplicitResult = false;
    this.initReceived = false;
    this.introClosed = false;
    this.canGoToNextStage = false;
    this.fastPlayChangesBetweenSpins = false;
    this.bFastPlayRequestedValue = false;
    this.bFastPlayBeforeSpinValue = false;
    this.bFastPlayManuallySet = false;
    this.bSpinInProgress = false;
    this.waitForCustomDataInit =
        0;
    this.limitSpinButtonPositionByGameAnchors = false
}
StageInit.prototype.GetStageName = function() {
    return UHTStageName.Init
};
StageInit.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(Vars.GameHasIntro, this.hasIntro);
    XT.SetBool(Vars.GameHasCustomGamble, this.hasCustomGamble);
    XT.SetBool(Vars.ScatterSymbolIsWild, this.scatterIsWild);
    XT.SetBool(Vars.UpdateVSGameStateOnSpin, true);
    XT.SetBool(Vars.TruncateFSResponseDuringRespin, this.truncateFSResponseDuringRespin);
    XT.SetBool(Vars.UpdateFSResponseOnBonusPick, this.updateFSResponseOnBonusPick);
    XT.SetBool(Vars.PartiallyUpdateSpinResponseOnBonusPick, this.partiallyUpdateSpinResponseOnBonusPick);
    XT.SetBool(Vars.UpdateBonusPickDataDuringRespins, this.allowBonusPickDuringBonusRespin);
    XT.SetBool(Vars.UpdateRespinDataOnBonusPick, this.updateRespinDataOnBonusPick);
    XT.SetObject(Vars.NoInitBonusGameTypes, this.noInitBonusGameTypes);
    XT.SetObject(Vars.NoInitBonusGameIds, this.noInitBonusGameIds);
    XT.SetInt(Vars.TotalNumberOfLines, this.totalNumberOfLines);
    XT.SetBool(Vars.GameHasWaysInsteadOfLines, this.hasWaysInsteadOfLines);
    XT.SetBool(Vars.GameHasLinesWithBetMultiplier, this.hasLinesWithBetMultiplier);
    XT.SetInt(Vars.NumberOfBetLevels,
        this.numberOfBetLevels);
    XT.SetBool(Vars.TriggerBonusBeforeResult, this.triggerBonusBeforeResult);
    XT.SetBool(Vars.BonusWinIsSeparated, this.bonusWinIsSeparated);
    XT.SetBool(Vars.OpaqueInterface, this.opaqueInterface);
    XT.SetBool(Vars.HasReelAwareSymbolContent, this.hasReelAwareSymbolContent);
    XT.SetBool(Vars.HiddenMathematics, false);
    XT.SetBool(BGVars.BonusDataReceived, false);
    XT.SetBool(Vars.InstantlyCollectBonus, this.instantlyCollectBonusWin);
    XT.SetBool(Vars.HasAnteBet, this.hasAnteBet);
    XT.SetBool(InterfaceVars.PayingSymbolsDisplayServerID,
        this.payingSymbolsDisplayServerID);
    XT.SetBool(Vars.LinesPaysBothWays, this.paysBothWays);
    XT.SetObject(Vars.FreeSpinOptions, null);
    XT.SetBool(Vars.CanSpin, false);
    XT.SetBool(Vars.AllowFastStop, true);
    XT.SetBool(Vars.IsDifferentSpinType, false);
    XT.SetObject(Vars.DefaultGameWindowOverrideData, this.defaultGameWindowOverride);
    XT.SetBool(Vars.BrowserWarningShown, false);
    XT.SetBool(Vars.FSStartNeedsConfirmation, this.freeSpinsStartNeedsConfirmation);
    XT.SetBool(Vars.SpinNeedsConfirmation, false);
    XT.SetBool(Vars.SpinBlockingFeatureIsRunning,
        false);
    XT.SetFloat(Vars.MinimumJackpotBigWinDuration, this.minimumJackpotBigWinDuration);
    XT.SetBool(Vars.ManualRespin, this.manualRespin);
    XT.SetObject(Vars.FeaturePurchase, null);
    XT.SetBool(InterfaceVars.ShowGamePaysAsWinTeaser, this.showGamePaysAsWinTeaser);
    XT.SetBool(Vars.FastPlayChangesBetweenSpins, this.fastPlayChangesBetweenSpins);
    XT.SetDouble(InterfaceVars.GUIDynamicMessageDelay, this.GUIDynamicMessagesDelay);
    XT.SetBool(InterfaceVars.CustomFreeSpinsLeft_UsesCATEvents, this.GUICustomFSLeft_usesCATEvents);
    XT.SetString(InterfaceVars.CustomFreeSpinsLeftMessage, this.GUICustomFSLeftMessage);
    XT.SetBool(InterfaceVars.ShowExplicitResult, this.showExplicitResult);
    XT.SetBool(Vars.WinLimitReached, false);
    XT.SetBool(Vars.RespinInProgress, false);
    XT.SetBool(Vars.CanTriggerBigWinBeforeBonus, this.canTriggerBigWinBeforeBonus);
    XT.SetObject(Vars.ToServer_RequestExtraParams, null);
    XT.SetBool(InterfaceVars.LimitSpinButtonPositionByGameAnchors, this.limitSpinButtonPositionByGameAnchors)
};
StageInit.prototype.UHTInit = function() {
    XT.RegisterAndInit(this.XTRoot)
};
StageInit.prototype.OnCustomDataInitialized = function() {
    this.waitForCustomDataInit--
};
StageInit.prototype.UHTUpdate = function(isFirstFrame) {
    if (isFirstFrame) {
        XT.TriggerEvent(Vars.Evt_Internal_Init_SymbolManager);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_InitReceived, this.OnInitReceived, this);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_BalanceUpdated, this.OnBalanceUpdated, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_IntroClosePressed, this.IntroClosed, this);
        XT.TriggerEvent(Vars.Evt_ToServer_RequestInit);
        if (XT.GetBool(Vars.DisableIntroScreen)) XT.SetBool(Vars.GameHasIntro, false);
        XT.RegisterCallbackBool(Vars.FastPlay, this.OnFastPlayValueChanged, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnStartSpin, this, -999);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelManager_SpinEnded, this.OnSpinEnded, this, 999);
        XT.TriggerEvent(Vars.Evt_Internal_Init_CustomData);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_CustomDataIsInitialized, this.OnCustomDataInitialized, this)
    }
    if (this.initReceived && this.waitForCustomDataInit <= 0 && globalResourcesNeededList.length == 0 && !(VS_SymbolsManager.initializing +
            Special_SymbolsManager.initializing > 0)) {
        UHTEngine.HideLoader();
        this.PatchNudgeData();
        if (XT.GetBool(Vars.MustOpenBonus)) CoinManager.SetStrictBetMode(false);
        CoinManager.SetStrictBetMode(true);
        CoinManager.InitLastBets();
        XT.TriggerEvent(Vars.Evt_Internal_Init_SoundManager);
        XT.TriggerEvent(Vars.Evt_Internal_Init_ReelsManager);
        XT.TriggerEvent(Vars.Evt_Internal_GameInit);
        XT.TriggerEvent(Vars.Evt_Internal_GUIInit);
        var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
        if (fsr.IsFreeSpin && !fsr.IsFreeSpinsCollected) {
            XT.SetInt(Vars.MaxFreeSpinsDisplayed,
                fsr.MaxSpins);
            XT.SetInt(Vars.CurrentFreeSpinDisplayed, fsr.CurrentSpin);
            XT.SetInt(Vars.FreeSpinsLeftDisplayed, fsr.MaxSpins - fsr.CurrentSpin);
            XT.SetInt(Vars.FreeSpinsTotalMultiplierDisplayed, fsr.TotalMultiplier | 0)
        }
        if (!XT.GetBool(Vars.MustPlayJackpot)) XT.SetDouble(Vars.SpinCycleWinDisplayed, XT.GetDouble(Vars.SpinCycleWinReceived));
        UHTEngine.SignalCanStartPrefetchingUnusedAtlasses();
        if (!XT.GetBool(Vars.GameHasIntro) || XT.GetBool(Vars.GameHasIntro) && !XT.GetBool(Vars.ShouldDisplayIntro)) {
            if (this.ProcessStageToGo()) {
                this.initShow.RegisterCallback(this.OnIntroClosedOrSkipped,
                    this);
                this.initShow.Start();
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
        } else this.introShow.Start();
        this.canGoToNextStage = true;
        this.initReceived = false
    }
    if (this.canGoToNextStage) {
        if (!Globals.InputBlocked && (Input.GetKeyDown(KeyCode.Space, true) || Input.GetKeyDown(KeyCode.Return, true))) this.introClosed = true;
        if (this.introClosed)
            if (this.ProcessStageToGo()) {
                this.introHide.RegisterCallback(this.OnIntroClosedOrSkipped, this);
                this.introHide.Start();
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
    }
    return UHTAction.NoAction()
};
StageInit.prototype.UHTFinish = function() {
    XT.UnregisterCallbackEvent(this.OnInitReceived, this);
    XT.UnregisterCallbackEvent(this.OnBalanceUpdated, this);
    XT.UnregisterCallbackEvent(this.IntroClosed, this)
};
StageInit.prototype.OnBetToTotalBetMultiplierChanged = function(multiplier) {
    if (this.linesForMinBet != -1) XT.SetInt(Vars.LinesForMinBet, this.linesForMinBet);
    else XT.SetInt(Vars.LinesForMinBet, multiplier);
    if (this.linesForMaxBet != -1) XT.SetInt(Vars.LinesForMaxBet, XT.GetBool(Vars.HasAnteBet) ? this.linesForMaxBet : this.linesForMinBet);
    else XT.SetInt(Vars.LinesForMaxBet, multiplier)
};
StageInit.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackInt(Vars.BetToTotalBetMultiplier, this.OnBetToTotalBetMultiplierChanged, this)
};
StageInit.prototype.OnBalanceUpdated = function() {
    XT.SetDouble(Vars.BalanceDisplayed, XT.GetDouble(Vars.BalanceReceived));
    XT.SetDouble(Vars.BonusBalance, XT.GetDouble(Vars.BonusBalanceReceived))
};
StageInit.prototype.OnInitReceived = function() {
    this.initReceived = true
};
StageInit.prototype.IntroClosed = function() {
    this.introClosed = true
};
StageInit.prototype.ProcessStageToGo = function() {
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    XT.SetBool(Vars.Logic_IsFreeSpin, fsr.IsFreeSpin && !fsr.IsFreeSpinsCollected);
    var isBonus = XT.GetBool(Vars.MustOpenBonus) && !XT.GetBool(Vars.InstantlyCollectBonus);
    if (XT.GetBool(Vars.MustPlayJackpot)) {
        XT.TriggerEvent(Vars.Evt_Internal_StartVSLogicSounds);
        XT.SetObject(Vars.FromStageName, this.GetStageName());
        XT.SetObject(Vars.ToStageName, UHTStageName.Jackpot);
        return true
    }
    if (this.forcedGoToSpin) {
        XT.TriggerEvent(Vars.Evt_Internal_StartVSLogicSounds);
        XT.SetObject(Vars.FromStageName, this.GetStageName());
        XT.SetObject(Vars.ToStageName, UHTStageName.Spin);
        return true
    }
    if (isBonus) {
        if (XT.GetBool(Vars.TriggerBonusBeforeResult) && fsr.IsFreeSpin && !fsr.IsFreeSpinsCollected) {
            if (fsr.BonusGameData != null && fsr.BonusGameData.GameOver || fsr.IsFreeSpinsStart && fsr.MysteryScatter.length > 0) XT.SetBool(Vars.Internal_FSBGJustClosed, true);
            if (fsr.PickedOptionIndex >= 0) {
                XT.SetBool(Vars.MustResumeFreeSpinOptions, true);
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName,
                    UHTStageName.FSBG);
                return true
            }
        }
        if (!XT.GetBool(BGVars.BonusDataReceived)) return false;
        else XT.SetBool(BGVars.BonusDataReceived, false);
        XT.SetObject(Vars.FromStageName, this.GetStageName());
        XT.SetObject(Vars.ToStageName, UHTStageName.Bonus);
        return true
    }
    if (XT.GetBool(Vars.FromServer_MustOpenFSBG) || XT.GetObject(Vars.FreeSpinOptions) != null) {
        XT.SetBool(Vars.FromServer_MustOpenFSBG, false);
        XT.SetObject(Vars.FromStageName, this.GetStageName());
        XT.SetObject(Vars.ToStageName, UHTStageName.FSBG);
        return true
    }
    XT.TriggerEvent(Vars.Evt_Internal_StartVSLogicSounds);
    if (XT.GetBool(Vars.MustOpenGambleV2)) {
        XT.SetObject(Vars.FromStageName, this.GetStageName());
        XT.SetObject(Vars.ToStageName, UHTStageName.Gamble);
        return true
    }
    if (fsr.IsFreeSpin && !fsr.IsFreeSpinsCollected) {
        if (fsr.BonusGameData != null && fsr.BonusGameData.GameOver || fsr.IsFreeSpinsStart && fsr.MysteryScatter.length > 0) XT.SetBool(Vars.Internal_FSBGJustClosed, true);
        if (fsr.PickedOptionIndex >= 0) {
            XT.SetBool(Vars.MustResumeFreeSpinOptions, true);
            XT.SetObject(Vars.FromStageName, this.GetStageName());
            XT.SetObject(Vars.ToStageName,
                UHTStageName.FSBG);
            return true
        }
        XT.SetObject(Vars.FromStageName, this.GetStageName());
        XT.SetObject(Vars.ToStageName, UHTStageName.ResultFreeSpin);
        return true
    } else {
        XT.SetObject(Vars.FromStageName, this.GetStageName());
        XT.SetObject(Vars.ToStageName, UHTStageName.Result);
        return true
    }
};
StageInit.prototype.OnBrowserWarningShown = function() {
    XT.SetBool(Vars.BrowserWarningShown, true);
    XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
};
StageInit.prototype.OnIntroClosedOrSkipped = function(type, data) {
    if (type == CAT_Event.CallbackType.EndOfEvent) XT.TriggerEvent(Vars.Evt_CodeToData_IntroClosedOrSkipped)
};
StageInit.prototype.PatchNudgeData = function() {
    var nudgeData = XT.GetObject(Vars.NudgedSymbols);
    if (nudgeData != null) {
        var initialScreenSymbols = XT.GetObject(Vars.InitialResultScreenSymbols);
        for (var i = 0; i < nudgeData.length; i++) {
            initialScreenSymbols[nudgeData[i].reelID] = nudgeData[i].nudgedSymbolsIDs;
            initialScreenSymbols[nudgeData[i].reelID].reverse()
        }
        XT.SetObject(Vars.ReceivedWinLines, []);
        XT.SetObject(Vars.InitialResultScreenSymbols, initialScreenSymbols);
        XT.SetObject(Vars.NudgedSymbols, null)
    }
};
StageInit.prototype.OnFastPlayValueChanged = function(newVal) {
    if (this.bFastPlayManuallySet) {
        this.bFastPlayManuallySet = false;
        return
    }
    this.bFastPlayRequestedValue = newVal;
    if (XT.GetBool(Vars.FastPlayChangesBetweenSpins))
        if (this.bSpinInProgress)
            if (newVal != this.bFastPlayBeforeSpinValue) {
                this.bFastPlayManuallySet = true;
                XT.SetBool(Vars.FastPlay, this.bFastPlayBeforeSpinValue)
            }
};
StageInit.prototype.SaveFastPlayValue = function() {
    this.bFastPlayBeforeSpinValue = XT.GetBool(Vars.FastPlay)
};
StageInit.prototype.RestoreFastPlayValue = function() {
    if (XT.GetBool(Vars.FastPlayChangesBetweenSpins))
        if (this.bFastPlayRequestedValue != XT.GetBool(Vars.FastPlay)) {
            this.bFastPlayManuallySet = true;
            XT.SetBool(Vars.FastPlay, this.bFastPlayRequestedValue)
        }
};
StageInit.prototype.OnSpinEnded = function() {
    this.bSpinInProgress = false;
    this.RestoreFastPlayValue()
};
StageInit.prototype.OnStartSpin = function() {
    this.SaveFastPlayValue();
    this.bSpinInProgress = true
};
goog.require("UHT.XTLink");
var globalMustStopAutoplay = false;

function AdvancedAutoplaySettings() {
    this.stopOnAnyWin = false;
    this.stopIfFeature = false;
    this.stopIfSingleWinExceeds = false;
    this.singleWinValue = 0;
    this.stopIfCashIncreases = false;
    this.cashIncreasesValue = 0;
    this.stopIfCashDecreases = false;
    this.cashDecreasesValue = 0;
    this.initialBalance = 0
}

function AutoplayManager() {}
AutoplayManager.wasReset = false;
AutoplayManager.fastPlay = false;
AutoplayManager.autoplayContinuousSpin = false;
AutoplayManager.TestAdvancedStopConditions = function() {
    if (globalMustStopAutoplay) {
        XT.SetInt(Vars.AutoplaySpinsLeft, -1);
        globalMustStopAutoplay = false;
        XT.TriggerEvent(Vars.Evt_DataToCode_StopAutoplay);
        return
    }
    if (XT.GetInt(Vars.AutoplaySpinsLeft) < 0) return;
    var mustStop = false;
    var s = XT.GetObject(Vars.AdvancedAutoplaySettings);
    if (!mustStop && s.stopOnAnyWin)
        if (XT.GetDouble(Vars.SpinCycleWinReceived) > 0) mustStop = true;
    if (XT.GetBool(Vars.Jurisdiction_Autoplay_StopOnFeatureWin)) s.stopIfFeature = true;
    if (!mustStop &&
        s.stopIfFeature) {
        var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
        if (fsr.IsFreeSpin || XT.GetBool(Vars.FromServer_MustOpenFSBG) || XT.GetBool(Vars.MustOpenBonus)) mustStop = true
    }
    if (!mustStop && s.stopIfSingleWinExceeds)
        if (XT.GetDouble(Vars.SpinCycleWinReceived) > s.singleWinValue) mustStop = true;
    if (!mustStop && s.stopIfCashIncreases)
        if (XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived) > s.initialBalance + s.cashIncreasesValue) mustStop = true;
    if (!mustStop && s.stopIfCashDecreases)
        if (XT.GetDouble(Vars.BalanceReceived) +
            XT.GetDouble(Vars.BonusBalanceReceived) - CoinManager.GetNextTotalBet() < s.initialBalance - s.cashDecreasesValue) mustStop = true;
    if (mustStop) {
        XT.SetInt(Vars.AutoplaySpinsLeft, -1);
        XT.TriggerEvent(Vars.Evt_Internal_StoppedAutoplayByCondition)
    }
};
AutoplayManager.ResetSettings = function() {
    if (AutoplayManager.wasReset) return;
    AutoplayManager.wasReset = true;
    AutoplayManager.fastPlay = XT.GetBool(Vars.FastPlay);
    AutoplayManager.autoplayContinuousSpin = XT.GetBool(Vars.AutoplayContinuousSpin);
    XT.SetBool(Vars.FastPlay, false);
    XT.SetBool(Vars.AutoplayContinuousSpin, false)
};
AutoplayManager.RestoreSettings = function() {
    if (!AutoplayManager.wasReset) return;
    AutoplayManager.wasReset = false;
    XT.SetBool(Vars.FastPlay, AutoplayManager.fastPlay);
    XT.SetBool(Vars.AutoplayContinuousSpin, AutoplayManager.autoplayContinuousSpin)
};
goog.require("UHT.Engine");
var BonusRoundsController = {
    isFirstSession: true,
    lastRoundType: VsFreeRound.RoundType.Spins,
    HandleNextEvent: function(onlyTreatErrors, betChangeAllowed, showWindowAllowed) {
        var ret = new BonusRoundRetData;
        if (ServerOptions.isReplay) return ret;
        var data = XT.GetObject(Vars.BonusRoundsData);
        ret.isBonusRounds = data != null;
        if (XT.GetBool(Vars.UserChoseToPlayLater)) ret.isBonusRounds = false;
        if (ret.isBonusRounds && !onlyTreatErrors) {
            XT.SetInt(Vars.BonusRoundsLeftDisplayed, data.RoundsLeft);
            XT.SetDouble(Vars.BonusRoundsWinDisplayed,
                data.TotalWin)
        }
        var evts = XT.GetObject(Vars.BonusRoundsEvents);
        if (evts != null && evts.length > 0) {
            if (evts.length == 1 && ret.isBonusRounds) BonusRoundsController.lastRoundType = data.Type;
            var curEvt = evts[0];
            if (curEvt.Type == VsFreeRoundEvent.EventType.Start && !onlyTreatErrors) {
                var brd = XT.GetObject(Vars.BonusRoundsData);
                if (showWindowAllowed) {
                    XT.SetBool(Vars.BonusRoundCanBePlayedLater, curEvt.PlayLaterAvailable);
                    XT.SetDouble(Vars.BonusRoundEndDateTimestamp, curEvt.EndDateTimestamp);
                    if (curEvt.PromoLocalizedName.indexOf("#DDW#") !=
                        -1) XT.SetBool(Vars.BonusRoundWonFromDDW, true);
                    else XT.SetBool(Vars.BonusRoundWonFromDDW, false);
                    XT.SetString(Vars.BonusRoundPromoType, curEvt.PromoType);
                    XT.TriggerEvent(Vars.Evt_CodeToData_BonusRoundsStarted);
                    if (data.Type == VsFreeRound.RoundType.Spins) XT.TriggerEvent(Vars.Evt_CodeToData_GUI_BonusRoundsStarted);
                    else if (data.Type == VsFreeRound.RoundType.BonusBoost) XT.TriggerEvent(Vars.Evt_CodeToData_GUI_BoostBonusRoundsStarted);
                    else {
                        XT.TriggerEvent(Vars.Evt_CodeToData_GUI_TimedBonusRoundsStarted);
                        XT.SetInt(Vars.TimedBonusRoundsSeconds,
                            brd.RoundsLeft)
                    }
                    ret.messageIsOpened = true;
                    if (!BonusRoundsController.isFirstSession) {
                        XT.SetDouble(Vars.BonusRoundsWinDisplayed, 0);
                        brd.TotalWin = 0;
                        XT.SetObject(Vars.BonusRoundsData, brd)
                    }
                }
                if (betChangeAllowed) {
                    evts.splice(0, 1);
                    if (!XT.GetBool(Vars.UserChoseToPlayLater)) {
                        CoinManager.SetDesiredBet(curEvt.Bet);
                        BonusRoundsController.SetLines(curEvt.Lines);
                        XT.TriggerEvent(Vars.Evt_Internal_CoinValueChanged);
                        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup)
                    }
                }
            } else if (curEvt.Type == VsFreeRoundEvent.EventType.Finish &&
                !onlyTreatErrors) {
                if (showWindowAllowed) {
                    XT.SetInt(Vars.BonusRoundsLeftDisplayed, 0);
                    if (ret.isBonusRounds)
                        if (BonusRoundsController.lastRoundType == VsFreeRound.RoundType.Spins) {
                            XT.TriggerEvent(Vars.Evt_CodeToData_BonusRoundsFinished);
                            XT.TriggerEvent(Vars.Evt_CodeToData_GUI_BonusRoundsFinished);
                            ret.messageIsOpened = true;
                            BonusRoundsController.isFirstSession = false
                        } else if (BonusRoundsController.lastRoundType == VsFreeRound.RoundType.BonusBoost) {
                        XT.TriggerEvent(Vars.Evt_CodeToData_BonusRoundsFinished);
                        XT.TriggerEvent(Vars.Evt_CodeToData_GUI_BoostBonusRoundsFinished);
                        ret.messageIsOpened = true;
                        BonusRoundsController.isFirstSession = false
                    } else if (!XT.GetBool(Vars.TimedBonusRoundIsOngoing)) XT.TriggerEvent(Vars.Evt_DataToCode_BonusRoundsOnContinuePressed);
                    else {
                        if (!XT.GetBool(Vars.ShouldIgnoreNextFinishEventFromServer)) {
                            XT.TriggerEvent(Vars.Evt_CodeToData_BonusRoundsFinished);
                            XT.TriggerEvent(Vars.Evt_CodeToData_GUI_TimedBonusRoundsFinished)
                        }
                    } else if (XT.GetBool(Vars.TimedBonusRoundIsOngoing)) XT.TriggerEvent(Vars.Evt_DataToCode_BonusRoundsOnContinuePressed);
                    else if (!XT.GetBool(Vars.ShouldIgnoreNextFinishEventFromServer)) {
                        XT.TriggerEvent(Vars.Evt_CodeToData_BonusRoundsFinished);
                        XT.TriggerEvent(Vars.Evt_CodeToData_GUI_BonusRoundsFinished);
                        ret.messageIsOpened = true;
                        BonusRoundsController.isFirstSession = false
                    } else {
                        XT.SetBool(Vars.ShouldIgnoreNextFinishEventFromServer, false);
                        evts.splice(0, 1)
                    }
                }
                if (betChangeAllowed) {
                    evts.splice(0, 1);
                    ret.isBonusRounds = false;
                    CoinManager.SetDesiredBet(curEvt.Bet);
                    BonusRoundsController.SetLines(curEvt.Lines);
                    if (evts.length == 0) XT.SetObject(Vars.BonusRoundsData, null);
                    XT.TriggerEvent(Vars.Evt_Internal_CoinValueChanged);
                    XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup)
                }
            } else if (curEvt.Type ==
                VsFreeRoundEvent.EventType.Error) {
                if (showWindowAllowed)
                    if (ret.isBonusRounds)
                        if (BonusRoundsController.lastRoundType == VsFreeRound.RoundType.Spins) {
                            XT.SetInt(Vars.BonusRoundsLeftDisplayed, 0);
                            XT.TriggerEvent(Vars.Evt_CodeToData_BonusRoundsError);
                            XT.TriggerEvent(Vars.Evt_CodeToData_GUI_BonusRoundsError);
                            ret.messageIsOpened = true;
                            BonusRoundsController.isFirstSession = false
                        } else {
                            if (BonusRoundsController.lastRoundType == VsFreeRound.RoundType.BonusBoost) {
                                XT.SetInt(Vars.BonusRoundsLeftDisplayed, 0);
                                XT.TriggerEvent(Vars.Evt_CodeToData_BonusRoundsError);
                                XT.TriggerEvent(Vars.Evt_CodeToData_GUI_BoostBonusRoundsError);
                                ret.messageIsOpened = true;
                                BonusRoundsController.isFirstSession = false
                            }
                        }
                else if (!XT.GetBool(Vars.TimedBonusRoundIsOngoing) && !XT.GetBool(Vars.ShouldIgnoreNextFinishEventFromServer)) {
                    XT.SetInt(Vars.BonusRoundsLeftDisplayed, 0);
                    XT.TriggerEvent(Vars.Evt_CodeToData_BonusRoundsError);
                    XT.TriggerEvent(Vars.Evt_CodeToData_GUI_BonusRoundsError);
                    ret.messageIsOpened = true
                }
                if (betChangeAllowed) {
                    if (!XT.GetBool(Vars.TimedBonusRoundIsOngoing)) evts.splice(0,
                        1);
                    ret.isBonusRounds = false;
                    CoinManager.SetDesiredBet(curEvt.Bet);
                    BonusRoundsController.SetLines(curEvt.Lines)
                }
            }
        }
        return ret
    },
    SetLines: function(lines) {
        if (!XT.GetBool(Vars.HasAnteBet)) XT.SetInt(Vars.BetToTotalBetMultiplier, lines);
        else XT.SetInt(Vars.BetToTotalBetMultiplier, XT.GetBool(Vars.GameHasWaysInsteadOfLines) ? XT.GetInt(Vars.TotalNumberOfLines) : lines);
        XT.SetInt(Vars.Lines, XT.GetBool(Vars.GameHasWaysInsteadOfLines) ? XT.GetInt(Vars.TotalNumberOfLines) : lines)
    }
};

function BonusRoundRetData() {
    this.isBonusRounds = false;
    this.messageIsOpened = false
}
goog.require("UHT.Engine");
goog.require("UHT.UHTStage");
var StageResultFreeSpinVars = {
    ResultFS_VarsToUpdateWithWin: "ResultFS_VarsToUpdateWithWin",
    Evt_Internal_ResultFS_VarsToUpdateWithWinUpdated: "Evt_Internal_ResultFS_VarsToUpdateWithWinUpdated"
};
StageResultFreeSpin.prototype = Object.create(UHTStage.prototype);
StageResultFreeSpin.prototype.constructor = StageResultFreeSpin;

function StageResultFreeSpin() {
    UHTStage.call(this);
    this.transition = null;
    this.transitionFast = null;
    this.additionalFreeSpins = null;
    this.minimalResultDisplayAtFreeSpinsPrepare = false;
    this.bypassNoWinFSWindow = true;
    this.shouldClearMysteryScattersOnFSClose = true;
    this.mustSpin = false;
    this.changeToResult = false;
    this.changeToFSBG = false;
    this.freeSpinsEnded = false;
    this.fsr = null;
    this.prepareToOpenBonus = false;
    this.mustOpenBonus = false;
    this.mustOpenGamble = false;
    this.isJackpotWinOnScreen = false;
    this.isRespin = false;
    this.totalWinReceivedSoFarInFS =
        0;
    this.firstTimeInFSResult = true;
    this.fsStartConfirmed = true;
    this.shouldEnterFS = false;
    this.mustStartFSSounds = false;
    this.transitionWasStarted = false;
    this.varsToUpdateWhenWinIsUpdated = {}
}
StageResultFreeSpin.prototype.GetStageName = function() {
    return UHTStageName.ResultFreeSpin
};
StageResultFreeSpin.prototype.XTRegisterCallbacks = function() {};
StageResultFreeSpin.prototype.XTInitVariablesAndEvents = function() {
    XT.SetInt(Vars.FreeSpinsTotalMultiplierDisplayed, 0);
    XT.SetDouble(Vars.FreeSpinsWinDisplayed, 0);
    XT.SetInt(Vars.AdditionalFreeSpinsWon, 0);
    XT.SetDouble(Vars.FreeSpinsWinMultipliedDisplayed, 0);
    XT.SetDouble(Vars.FreeSpinsTotalWinDisplayed, 0);
    XT.SetDouble(Vars.FreeSpinsTotalWinMultipliedDisplayed, 0);
    XT.SetDouble(Vars.FreeSpinsConsolationPrize, 0);
    XT.SetBool(Vars.FromServer_MustOpenFSBG, false);
    XT.SetBool(Vars.Internal_FSBGJustClosed, false);
    XT.SetObject(StageResultFreeSpinVars.ResultFS_VarsToUpdateWithWin, this.varsToUpdateWhenWinIsUpdated);
    XT.SetBool(Vars.FreeSpinsEndedOverride, false)
};
StageResultFreeSpin.prototype.UHTInit = function() {};
StageResultFreeSpin.prototype.UHTUpdate = function(isFirstFrame) {
    if (isFirstFrame) {
        CoinManager.SetStrictBetMode(true);
        XT.SetInt(Vars.AdditionalFreeSpinsWon, 0);
        XT.SetBool(Vars.Logic_IsFreeSpin, true);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_Stop, this.OnPressedStop, this);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_BalanceUpdated, this.OnBalanceUpdated, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_FreeSpinsWindowWinCollectPressed, this.OnWinResultCollectPressed, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_FreeSpinsWindowLoseCollectPressed,
            this.OnLoseResultCollectPressed, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_LoopDone, this.OnResultDisplayerLoopDone, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_ConfirmFSStart, this.OnConfirmFSStart, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_BonusRoundsOnContinuePressed, this.OnBonusRoundsContinuePressed, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_Gamble_FreeSpinsResult, this.OnPressedGamble, this);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_GambleOpen,
            this.OnMustOpenGamble, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_CollectJackpotPressed, this.OnJackpotCollected, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_UpdateDisplayedWin, this.OnRequestToUpdateDisplayedWin, this);
        AutoplayManager.TestAdvancedStopConditions();
        var data = XT.GetObject(Vars.BonusRoundsData);
        if (data != null && data.Type == VsFreeRound.RoundType.Timed) BonusRoundsController.HandleNextEvent(false, false, true);
        this.fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
        this.prepareToOpenBonus =
            XT.GetBool(Vars.MustOpenBonus);
        var respinData = XT.GetObject(Vars.RespinData);
        this.isRespin = respinData != null && !respinData.IsDone;
        this.UpdateGambleButtonState();
        XT.SetDouble(Vars.FreeSpinsWinDisplayed, this.fsr.CurrentWin);
        this.varsToUpdateWhenWinIsUpdated[Vars.FreeSpinsWinMultipliedDisplayed] = this.fsr.CurrentWinMultiplied;
        XT.SetInt(Vars.FreeSpinsTotalMultiplierDisplayed, this.fsr.TotalMultiplier);
        if (this.fsr.IsFreeSpin && !this.fsr.IsLastFreeSpin) {
            XT.SetInt(Vars.AdditionalFreeSpinsWon, this.fsr.AdditionalSpins);
            XT.SetInt(Vars.MaxFreeSpinsDisplayed, this.fsr.MaxSpins)
        } else XT.SetInt(Vars.FreeSpinsLeftDisplayed, 0);
        if (this.fsr.IsFreeSpinsStart || XT.GetObject(Vars.FreeSpinOptions) != null && XT.GetBool(Vars.FromServer_MustOpenFSBG) || XT.GetBool(Vars.OpenFSBGForMysteryScatter)) {
            UHTInterfaceBOSS.PostMessage("freeSpinStarted");
            this.fsStartConfirmed = false;
            if (!this.prepareToOpenBonus && XT.GetBool(Vars.Internal_FSBGJustClosed)) {
                XT.SetBool(Vars.Internal_FSBGJustClosed, false);
                this.ReallyEnterFreeSpins()
            } else if (XT.GetBool(Vars.BonusTriggersFSBG)) VSGameStateManager.ChangeTo(VSGameState.FSBG);
            else if (XT.GetObject(Vars.FreeSpinsChainData) == null) {
                XT.SetDouble(Vars.WinDisplayed, 0);
                this.varsToUpdateWhenWinIsUpdated[Vars.WinDisplayed] = XT.GetDouble(Vars.WinReceived);
                XT.SetDouble(Vars.TotalLinesWinDisplayed, 0);
                this.varsToUpdateWhenWinIsUpdated[Vars.TotalLinesWinDisplayed] = XT.GetDouble(Vars.TotalLinesWinReceived);
                VSGameStateManager.ChangeTo(VSGameState.ResultFreeSpinsPrepare)
            }
            this.varsToUpdateWhenWinIsUpdated[Vars.BalanceDisplayed] = XT.GetDouble(Vars.BalanceReceived);
            this.varsToUpdateWhenWinIsUpdated[Vars.BonusBalance] =
                XT.GetDouble(Vars.BonusBalanceReceived);
            XT.SetBool(Vars.ResultDisplayerMinimalMode, this.minimalResultDisplayAtFreeSpinsPrepare)
        } else if (this.fsr.IsFreeSpin) {
            XT.SetDouble(Vars.FreeSpinsLastWinDisplayed, 0);
            if (this.fsr.IsLastFreeSpin && XT.GetObject(Vars.TumblingData) == null)
                if (this.firstTimeInFSResult) {
                    XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, true);
                    XT.SetDouble(Vars.FreeSpinsWinMultipliedDisplayed, this.fsr.CurrentWinMultiplied);
                    XT.SetDouble(Vars.SpinCycleWinDisplayed, XT.GetDouble(Vars.SpinCycleWinReceived))
                } else if (XT.GetDouble(Vars.TumblingWin) >
                0 || XT.GetBool(Vars.RespinInProgress)) this.varsToUpdateWhenWinIsUpdated[Vars.FreeSpinsLastWinDisplayed] = XT.GetDouble(Vars.WinReceived) * this.fsr.TotalMultiplier;
            else {
                if (XT.GetDouble(Vars.FreeSpinsConsolationPrize) > 0) this.totalWinReceivedSoFarInFS += XT.GetDouble(Vars.FreeSpinsConsolationPrize);
                var value = (this.fsr.CurrentWin - this.totalWinReceivedSoFarInFS) * this.fsr.TotalMultiplier;
                if (XT.GetBool(Vars.WinLimitReached)) value = this.fsr.CurrentWin - this.totalWinReceivedSoFarInFS * this.fsr.TotalMultiplier;
                this.varsToUpdateWhenWinIsUpdated[Vars.FreeSpinsLastWinDisplayed] =
                    value < 0 ? 0 : value
            } else {
                this.varsToUpdateWhenWinIsUpdated[Vars.FreeSpinsLastWinDisplayed] = XT.GetDouble(Vars.WinReceived) * this.fsr.TotalMultiplier;
                this.totalWinReceivedSoFarInFS = this.fsr.CurrentWin
            }
            XT.SetBool(Vars.ResultDisplayerMinimalMode, true);
            VSGameStateManager.ChangeTo(VSGameState.ResultFreeSpins);
            if (!this.transitionWasStarted) {
                AutoplayManager.ResetSettings();
                this.transitionWasStarted = true;
                if (this.transitionFast != null) this.transitionFast.Start()
            }
        }
        if (XT.GetDouble(Vars.FreeSpinsConsolationPrize) > 0) this.varsToUpdateWhenWinIsUpdated[Vars.SpinCycleWinDisplayed] =
            XT.GetDouble(Vars.SpinCycleWinReceived) - XT.GetDouble(Vars.FreeSpinsConsolationPrize);
        else this.varsToUpdateWhenWinIsUpdated[Vars.SpinCycleWinDisplayed] = XT.GetDouble(Vars.SpinCycleWinReceived);
        var scatterwin = (XT.GetDouble(Vars.WinReceived) - XT.GetDouble(Vars.TotalLinesWinReceived)) * this.fsr.TotalMultiplier;
        XT.SetDouble(Vars.MysteryScatterWinDisplayed, 0);
        this.varsToUpdateWhenWinIsUpdated[Vars.MysteryScatterWinDisplayed] = scatterwin;
        XT.SetDouble(Vars.TotalScattersWinDisplayed, 0);
        this.varsToUpdateWhenWinIsUpdated[Vars.TotalScattersWinDisplayed] =
            scatterwin;
        XT.TriggerEvent(StageResultFreeSpinVars.Evt_Internal_ResultFS_VarsToUpdateWithWinUpdated);
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_Prepare);
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop)
    } else {
        XT.SetBool(Vars.Internal_FSBGJustClosed, false);
        if (this.mustOpenBonus && !XT.GetBool(Vars.LastWinIsCounting))
            if (XT.GetBool(BGVars.BonusDataReceived)) {
                this.mustOpenBonus = false;
                XT.SetBool(BGVars.BonusDataReceived, false);
                XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                var fsr =
                    XT.GetObject(Vars.ReceivedFreeSpinsResponse);
                if (fsr != null) {
                    XT.SetInt(Vars.CurrentFreeSpinDisplayed, fsr.CurrentSpin);
                    XT.SetInt(Vars.FreeSpinsLeftDisplayed, fsr.MaxSpins - fsr.CurrentSpin)
                }
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.Bonus);
                return UHTAction.ChangeStage(UHTStageName.Transition)
            } else return UHTAction.NoAction();
        this.mustOpenGamble = XT.GetObject(Vars.GambleV2Data) != null && XT.GetBool(Vars.CanSpin) && !XT.GetBool(Vars.LastWinIsCounting);
        if (this.mustOpenGamble) {
            this.mustOpenGamble =
                false;
            XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
            XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, true);
            XT.SetDouble(Vars.Gamble_CurrentBalance, XT.GetDouble(Vars.FreeSpinsWinMultipliedDisplayed));
            XT.SetObject(Vars.FromStageName, this.GetStageName());
            XT.SetObject(Vars.ToStageName, UHTStageName.Gamble);
            return UHTAction.ChangeStage(UHTStageName.Transition)
        }
        if (this.changeToResult) {
            this.changeToResult = false;
            AutoplayManager.RestoreSettings();
            XT.SetObject(Vars.FromStageName,
                this.GetStageName());
            XT.SetObject(Vars.ToStageName, UHTStageName.Result);
            UHTInterfaceBOSS.PostMessage("freeSpinEnded");
            UHTInterfaceBOSS.PostMessage("gameRoundEnded");
            return UHTAction.ChangeStage(UHTStageName.Transition)
        }
        if (this.shouldEnterFS && XT.GetBool(Vars.WaitInResultForBigWin) == false && XT.GetBool(Vars.LastWinIsCounting) == false)
            if (!XT.GetBool(Vars.SpinBlockingFeatureIsRunning)) {
                this.shouldEnterFS = false;
                this.ReallyEnterFreeSpins()
            }
        if (this.freeSpinsEnded && XT.GetBool(Vars.WaitInResultForBigWin) == false &&
            XT.GetBool(Vars.LastWinIsCounting) == false) {
            this.freeSpinsEnded = false;
            if (XT.GetBool(Vars.OpenFSBGForMysteryScatter) && XT.GetBool(Vars.FromServer_MustOpenFSBG)) {
                XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                XT.SetBool(Vars.FromServer_MustOpenFSBG, false);
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.FSBG);
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
            XT.SetBool(Vars.SkipNextBigWin, true);
            var totalFreeSpins = this.fsr.TotalSpins;
            var fscd =
                XT.GetObject(Vars.FreeSpinsChainData);
            if (fscd != null && fscd.HasPreviousChainInformation()) {
                totalFreeSpins = 0;
                for (var i = 0; i < fscd.FSCSpinsTotal.length; i++) totalFreeSpins += fscd.FSCSpinsTotal[i]
            }
            XT.SetInt(Vars.TotalFreeSpinsChainDisplayed, totalFreeSpins);
            XT.SetInt(Vars.TotalFreeSpinsDisplayed, this.fsr.TotalSpins);
            XT.SetDouble(Vars.FreeSpinsTotalWinDisplayed, this.fsr.TotalWin);
            XT.SetInt(Vars.FreeSpinsTotalMultiplierDisplayed, this.fsr.TotalMultiplier);
            XT.SetDouble(Vars.FreeSpinsTotalWinMultipliedDisplayed,
                XT.GetDouble(Vars.SpinCycleWinReceived));
            if (XT.GetDouble(Vars.SpinCycleWinReceived) > 0) {
                XT.SetDouble(Vars.FSResultWindowTotalWinMultipliedDisplayed, 0);
                XT.SetDouble(Vars.FSResultWindowTotalWinMultipliedDisplayed, XT.GetDouble(Vars.SpinCycleWinReceived));
                XT.TriggerEvent(Vars.Evt_CodeToData_FreeSpinsShowWindowWin)
            } else if (!this.bypassNoWinFSWindow) XT.TriggerEvent(Vars.Evt_CodeToData_FreeSpinsShowWindowLose);
            else this.OnLoseResultCollectPressed();
            if (XT.GetBool(Vars.CanGamble_FreeSpin) == false) XT.TriggerEvent(Vars.Evt_ToServer_OnFreeSpinsClosed)
        }
        if (this.mustSpin &&
            XT.GetBool(Vars.WaitInResultForBigWin) == false && XT.GetBool(Vars.LastWinIsCounting) == false || this.changeToFSBG) {
            if (XT.GetBool(Vars.FSStartNeedsConfirmation))
                if (!this.fsStartConfirmed) return UHTAction.NoAction();
            if (this.mustStartFSSounds) {
                XT.TriggerEvent(Vars.Evt_Internal_SwitchToFSSounds);
                this.mustStartFSSounds = false
            }
            if (XT.GetBool(Vars.FromServer_MustOpenFSBG)) {
                this.changeToFSBG = false;
                XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                XT.SetBool(Vars.FromServer_MustOpenFSBG, false);
                XT.SetObject(Vars.FromStageName,
                    this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.FSBG);
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
            if (!XT.GetBool(Vars.WaitInResultForBigWin) && !XT.GetBool(Vars.SpinBlockingFeatureIsRunning)) {
                this.mustSpin = false;
                XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.Spin);
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
        }
    }
    return UHTAction.NoAction()
};
StageResultFreeSpin.prototype.UHTFinish = function() {
    this.firstTimeInFSResult = false;
    for (var i in this.varsToUpdateWhenWinIsUpdated)
        if (this.varsToUpdateWhenWinIsUpdated.hasOwnProperty(i)) delete this.varsToUpdateWhenWinIsUpdated[i];
    XT.UnregisterCallbackEvent(this.OnPressedStop, this);
    XT.UnregisterCallbackEvent(this.OnBalanceUpdated, this);
    XT.UnregisterCallbackEvent(this.OnWinResultCollectPressed, this);
    XT.UnregisterCallbackEvent(this.OnLoseResultCollectPressed, this);
    XT.UnregisterCallbackEvent(this.OnResultDisplayerLoopDone,
        this);
    XT.UnregisterCallbackEvent(this.OnConfirmFSStart, this);
    XT.UnregisterCallbackEvent(this.OnPressedGamble, this);
    XT.UnregisterCallbackEvent(this.OnMustOpenGamble, this);
    XT.UnregisterCallbackEvent(this.OnJackpotCollected, this);
    XT.UnregisterCallbackEvent(this.OnRequestToUpdateDisplayedWin, this);
    XT.UnregisterCallbackEvent(this.OnBonusRoundsContinuePressed, this)
};
StageResultFreeSpin.prototype.OnPressedStop = function() {
    XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin)
};
StageResultFreeSpin.prototype.ReadyForSpin = function(type, data) {
    if (type == CAT_Event.CallbackType.EndOfEvent) {
        if (!XT.GetBool(Vars.FromServer_MustOpenFSBG)) VSGameStateManager.ChangeTo(VSGameState.ResultFreeSpins);
        this.transition.cat.UnregisterCallback(this.transition.id, this.ReadyForSpin, this);
        this.additionalFreeSpins.cat.UnregisterCallback(this.additionalFreeSpins.id, this.ReadyForSpin, this)
    }
    this.mustSpin = true
};
StageResultFreeSpin.prototype.OnBalanceUpdated = function() {
    if (XT.GetBool(Vars.BalanceDisplayedIsAnimating) == false) {
        XT.SetDouble(Vars.BalanceDisplayed, XT.GetDouble(Vars.BalanceReceived));
        XT.SetDouble(Vars.BonusBalance, XT.GetDouble(Vars.BonusBalanceReceived))
    }
};
StageResultFreeSpin.prototype.OnPressedGamble = function() {
    this.freeSpinsEnded = false;
    this.fsr.IsFreeSpinsGambled = true;
    XT.SetBool(Vars.Logic_IsFreeSpin, false);
    XT.TriggerEvent(Vars.Evt_Internal_FreeSpinsEnded);
    if (XT.GetBool(Vars.WaitInResultForBigWin)) {
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        return
    }
    if (XT.GetBool(Vars.LastWinIsCounting)) XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    XT.TriggerEvent(Vars.Evt_ToServer_RequestGambleOpen)
};
StageResultFreeSpin.prototype.OnMustOpenGamble = function() {
    XT.TriggerEvent(Vars.Evt_CodeToData_FreeSpinsCloseWindowWin);
    this.mustOpenGamble = true
};
StageResultFreeSpin.prototype.UpdateGambleButtonState = function() {
    if (XT.GetBool(Vars.FromServer_CanGambleSpinWin) && !XT.GetBool(Vars.ForceDisableGambleSpinWin)) XT.TriggerEvent(Vars.Evt_Internal_EnableGambleButton);
    else XT.TriggerEvent(Vars.Evt_Internal_DisableGambleButton)
};
StageResultFreeSpin.prototype.IsJackpotWin = function() {
    if (XT.GetBool(Vars.FromServer_IsJackpotWin) && !this.isJackpotWinOnScreen)
        if (!(XT.GetBool(Vars.WaitInResultForBigWin) || XT.GetBool(Vars.LastWinIsCounting))) this.isJackpotWinOnScreen = true;
    return XT.GetBool(Vars.FromServer_IsJackpotWin)
};
StageResultFreeSpin.prototype.OnJackpotCollected = function() {
    if (XT.GetBool(Vars.WaitInResultForBigWin)) {
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        return
    }
    if (XT.GetBool(Vars.LastWinIsCounting)) XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    XT.SetBool(Vars.FromServer_IsJackpotWin, false);
    this.isJackpotWinOnScreen = false
};
StageResultFreeSpin.prototype.OnResultDisplayerLoopDone = function() {
    if (this.IsJackpotWin() || XT.GetBool(Vars.LastWinIsCounting) || XT.GetBool(ResultDisplayerVars.ResultDisplayer_DoExtraLoop)) {
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop);
        return
    }
    if (this.prepareToOpenBonus) {
        this.mustOpenBonus = true;
        return
    }
    if (this.fsr.IsLastFreeSpin) {
        if (this.IsAutoRespin()) {
            this.mustSpin = true;
            return
        }
        if (this.IsFSChainedSession()) return;
        if (XT.GetBool(Vars.FreeSpinsEndedOverride)) {
            XT.SetBool(Vars.FreeSpinsEndedOverride,
                false);
            this.mustSpin = true;
            return
        }
        if (XT.GetDouble(Vars.FreeSpinsConsolationPrize) > 0) {
            XT.SetDouble(Vars.SpinCycleWinDisplayed, XT.GetDouble(Vars.SpinCycleWinReceived));
            XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin)
        }
        this.freeSpinsEnded = true;
        this.transitionWasStarted = false;
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
        XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, true)
    } else if (this.fsr.IsFreeSpinsStart) this.shouldEnterFS = true;
    else if (XT.GetInt(Vars.AdditionalFreeSpinsWon) >
        0) {
        this.additionalFreeSpins.cat.RegisterCallback(this.additionalFreeSpins.id, this.ReadyForSpin, this);
        this.additionalFreeSpins.Start()
    } else this.mustSpin = true
};
StageResultFreeSpin.prototype.OnWinResultCollectPressed = function() {
    if (XT.GetBool(Vars.WaitInResultForBigWin)) {
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        return
    }
    if (XT.GetBool(Vars.LastWinIsCounting)) XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    XT.TriggerEvent(Vars.Evt_CodeToData_FreeSpinsCloseWindowWin);
    XT.TriggerEvent("PS_AnnounceResultShown");
    this.OnFreeSpinsClosed()
};
StageResultFreeSpin.prototype.OnLoseResultCollectPressed = function() {
    XT.TriggerEvent(Vars.Evt_CodeToData_FreeSpinsCloseWindowLose);
    this.OnFreeSpinsClosed()
};
StageResultFreeSpin.prototype.IsFSChainedSession = function() {
    var fscd = XT.GetObject(Vars.FreeSpinsChainData);
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fscd != null && fsr.MaxSpins > 0) {
        XT.SetInt(Vars.FreeSpinsTotalMultiplierDisplayed, fsr.TotalMultiplier);
        XT.SetInt(Vars.FreeSpinsLeftDisplayed, fsr.MaxSpins);
        this.mustStartFSSounds = true;
        XT.TriggerEvent(Vars.Evt_Internal_FreeSpinsStarted);
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        this.transitionWasStarted = true;
        this.transition.cat.RegisterCallback(this.transition.id,
            this.ReadyForSpin, this);
        this.transition.Start();
        return true
    }
    return false
};
StageResultFreeSpin.prototype.OnFreeSpinsClosed = function() {
    if (XT.GetBool(Vars.FromServer_MustOpenFSBG)) this.changeToFSBG = true;
    else this.changeToResult = true;
    this.freeSpinsEnded = false;
    if (this.shouldClearMysteryScattersOnFSClose) XT.SetObject(Vars.MysteryScatterSymbolIds, []);
    XT.SetBool(Vars.Logic_IsFreeSpin, false);
    if (XT.GetBool(Vars.CanGamble_FreeSpin)) XT.TriggerEvent(Vars.Evt_ToServer_OnFreeSpinsClosed);
    XT.TriggerEvent(Vars.Evt_Internal_FreeSpinsEnded)
};
StageResultFreeSpin.prototype.ReallyEnterFreeSpins = function() {
    this.mustStartFSSounds = true;
    XT.TriggerEvent(Vars.Evt_Internal_FreeSpinsStarted);
    XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    this.fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    XT.SetInt(Vars.CurrentFreeSpinDisplayed, 0);
    XT.SetDouble(Vars.FreeSpinsLastWinDisplayed, 0);
    this.totalWinReceivedSoFarInFS = 0;
    XT.SetInt(Vars.FreeSpinsLeftDisplayed, this.fsr.MaxSpins);
    AutoplayManager.ResetSettings();
    this.transitionWasStarted = true;
    this.transition.cat.RegisterCallback(this.transition.id,
        this.ReadyForSpin, this);
    this.transition.Start()
};
StageResultFreeSpin.prototype.OnConfirmFSStart = function() {
    this.fsStartConfirmed = true
};
StageResultFreeSpin.prototype.OnRequestToUpdateDisplayedWin = function() {
    for (var i in this.varsToUpdateWhenWinIsUpdated) XT.SetDouble(i, this.varsToUpdateWhenWinIsUpdated[i]);
    XT.TriggerEvent(Vars.Evt_Internal_UpdateDisplayedWinInUI);
    XT.UnregisterCallbackEvent(this.OnRequestToUpdateDisplayedWin, this)
};
StageResultFreeSpin.prototype.IsAutoRespin = function() {
    return this.isRespin && !XT.GetBool(Vars.ManualRespin)
};
StageResultFreeSpin.prototype.OnBonusRoundsContinuePressed = function() {
    var data = XT.GetObject(Vars.BonusRoundsData);
    if (data != null && data.Type != VsFreeRound.RoundType.Timed) return;
    XT.TriggerEvent(Vars.Evt_CodeToData_CloseOtherOpenedBonusRoundsWindows);
    XT.SetBool(Vars.CanSpin, true);
    this.OnBonusRoundsInfoUpdated()
};
StageResultFreeSpin.prototype.OnBonusRoundsInfoUpdated = function() {
    var brret = BonusRoundsController.HandleNextEvent(false, true, false);
    CoinManager.SetStrictBetMode(brret.isBonusRounds);
    brret = BonusRoundsController.HandleNextEvent(false, false, true);
    var isBonusRounds = brret.isBonusRounds;
    var bonusRoundsMessageWindowIsOpened = brret.messageIsOpened;
    var brd = XT.GetObject(Vars.BonusRoundsData);
    if (bonusRoundsMessageWindowIsOpened == false) CoinManager.SetStrictBetMode(isBonusRounds)
};
goog.require("UHT.Engine");
goog.require("UHT.UHTStage");
StageSpin.prototype = Object.create(UHTStage.prototype);
StageSpin.prototype.constructor = StageSpin;

function StageSpin() {
    UHTStage.call(this);
    this.cat = null;
    this.startEvent = null;
    this.spinEnded = false;
    this.isBonusRounds = false;
    this.onlySpinVisually = false;
    this.resumeSpinning = false;
    this.autoRespinsIsInfinite = false;
    this.rq = null;
    this.isRQEnded = false;
    this.shouldResetSpinCycleWinDisplayed = false
}
StageSpin.prototype.GetStageName = function() {
    return UHTStageName.Spin
};
StageSpin.prototype.XTRegisterCallbacks = function() {};
StageSpin.prototype.XTInitVariablesAndEvents = function() {
    XT.SetDouble(Vars.CurrentWinMultiplier, 1);
    XT.SetObject(Vars.SpinRoutineQueue, this.rq);
    XT.SetBool(Vars.SpinResultIsBigWin, false);
    XT.SetFloat(Vars.SpinDuration, 0)
};
StageSpin.prototype.UHTInit = function() {};
StageSpin.prototype.UHTUpdate = function(isFirstFrame) {
    if (isFirstFrame) {
        if (!XT.GetBool(Vars.IsDifferentSpinType)) XT.SetFloat(Vars.SpinDuration, 0);
        var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
        var respinData = XT.GetObject(Vars.RespinData);
        this.shouldResetSpinCycleWinDisplayed = (respinData == null || respinData.IsDone) && (!fsr.IsFreeSpin || fsr.IsLastFreeSpin);
        if (this.rq != null) {
            XT.TriggerEvent(Vars.Evt_Internal_InjectRQIBeforeSpinStart);
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnRQEnded,
                null, this));
            this.rq.StartRoutines()
        } else this.OnRQEnded(null);
        UHTEngine.RegisterUserInteraction()
    }
    if (this.isRQEnded) {
        this.isRQEnded = false;
        if (!XT.GetBool(Vars.Logic_IsFreeSpin))
            if (XT.GetBool(Vars.ContinuousSpin)) globalTracking.SendEvent("uht_spin", "started_turbo_spin_fastplay", XT.GetBool(Vars.FastPlay) ? 1 : 0, "SpinTracker");
            else globalTracking.SendEvent("uht_spin", "started_normal_spin_fastplay", XT.GetBool(Vars.FastPlay) ? 1 : 0, "SpinTracker");
        globalTracking.StartTimer("uht_spin", "time_response_received",
            "SpinTracker");
        var respinData = XT.GetObject(Vars.RespinData);
        if (!XT.GetBool(Vars.Logic_IsFreeSpin) && (respinData == null || respinData.IsDone)) UHTInterfaceBOSS.PostMessage("gameRoundStarted");
        UHTInterfaceBOSS.PostMessage("spinStarted");
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_Stop, this.OnPressedStop, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_StartAutoplay, this.OnStartAutoplay, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_StopAutoplay, this.OnStopAutoplay, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelManager_SpinEnded,
            this.OnSpinEnded, this);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_BalanceUpdatedFromResult, this.OnBalanceUpdated, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_BonusRoundsOnContinuePressed, this.OnBonusRoundsContinuePressed, this);
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        if (!this.onlySpinVisually) XT.TriggerEvent(Vars.Evt_ToServer_RequestSpin);
        XT.TriggerEvent(Vars.Evt_Internal_StopIdleSpinCounter);
        XT.TriggerEvent(Vars.Evt_Internal_SpinStarted);
        XT.SetBool(Vars.CanSpin, false);
        XT.SetBool(Vars.SkipNextBigWin,
            false);
        XT.SetInt(Vars.BigWinLevel, 0);
        XT.SetBool(Vars.SpinResultIsBigWin, false);
        XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, false);
        var brret = BonusRoundsController.HandleNextEvent(true, true, true);
        this.isBonusRounds = brret.isBonusRounds;
        var brd = XT.GetObject(Vars.BonusRoundsData);
        var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
        if (XT.GetBool(Vars.UpdateVSGameStateOnSpin)) {
            XT.SetDouble(Vars.CurrentWinMultiplier, 1);
            if (fsr.IsFreeSpin && !fsr.IsFreeSpinsCollected && !fsr.IsFreeSpinsGambled) {
                XT.SetDouble(Vars.CurrentWinMultiplier,
                    fsr.TotalMultiplier);
                VSGameStateManager.ChangeTo(VSGameState.SpinFreeSpins)
            } else if (XT.GetInt(Vars.AutoplaySpinsLeft) >= 0)
                if (this.autoRespinsIsInfinite) VSGameStateManager.ChangeTo(VSGameState.Spin);
                else if (this.isBonusRounds) VSGameStateManager.ChangeTo(VSGameState.SpinBonusRoundsAutoplay);
            else VSGameStateManager.ChangeTo(VSGameState.SpinAutoplay);
            else if (this.isBonusRounds) VSGameStateManager.ChangeTo(VSGameState.SpinBonusRounds);
            else if (this.onlySpinVisually || this.resumeSpinning) VSGameStateManager.ChangeTo(VSGameState.Result);
            else VSGameStateManager.ChangeTo(VSGameState.Spin)
        }
        if (this.cat != null) this.cat.StartEvent(this.startEvent.id)
    } else {
        var brret = BonusRoundsController.HandleNextEvent(true, true, true);
        this.isBonusRounds = brret.isBonusRounds;
        if (!Globals.InputBlocked)
            if ((Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.Return) || XT.GetBool(Vars.ContinuousSpin)) && XT.GetBool(Vars.AllowFastStop))
                if (!XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins) || XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins) &&
                    XT.GetFloat(Vars.SpinDuration) > XT.GetFloat(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins_Value))
                    if (!XT.GetBool(Vars.DisableStopButton)) XT.TriggerEvent(Vars.Evt_Internal_ReelManager_StopSpin);
        var delayForLastFRB = XT.GetObject(Vars.BonusRoundsData) != null && XT.GetObject(Vars.BonusRoundsData).RoundsLeft == 0 && GameConnection.I.requestState == RequestState.Collect;
        if (this.spinEnded && !delayForLastFRB) {
            this.spinEnded = false;
            if (!XT.GetBool(Vars.Logic_IsFreeSpin)) {
                var timer = GLOBAL_TIME_RESPONSE_RECEIVED;
                if (timer >
                    0)
                    if (XT.GetInt(Vars.AutoplaySpinsLeft) >= 0) globalTracking.SendEvent("uht_spin", "finished_autospin", timer, "SpinTracker")
            }
            UHTInterfaceBOSS.PostMessage("spinEnded");
            var fsr2 = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
            var respinData = XT.GetObject(Vars.RespinData);
            if (this.shouldResetSpinCycleWinDisplayed) XT.SetDouble(Vars.SpinCycleWinDisplayed, 0);
            var isEndOfSpinCycle = (respinData == null || respinData.IsDone) && (!fsr2.IsFreeSpin || fsr2.IsLastFreeSpin);
            if (isEndOfSpinCycle)
                if (!XT.GetBool(Vars.MustOpenBonus) && !XT.GetBool(Vars.FromServer_MustOpenFSBG) &&
                    XT.GetObject(Vars.GambleV2Data) == null) UHTInterfaceBOSS.PostMessage("gameRoundEnded");
            XT.TriggerEvent(Vars.Evt_Internal_SpinEnded);
            if (XT.GetBool(Vars.MustPlayJackpot)) {
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.Jackpot);
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
            if (XT.GetBool(Vars.TriggerBonusBeforeResult) && XT.GetBool(Vars.MustOpenBonus))
                if (XT.GetBool(BGVars.BonusDataReceived)) {
                    XT.SetBool(BGVars.BonusDataReceived, false);
                    XT.SetObject(Vars.FromStageName,
                        this.GetStageName());
                    XT.SetObject(Vars.ToStageName, UHTStageName.Bonus);
                    return UHTAction.ChangeStage(UHTStageName.Transition)
                } else return UHTAction.NoAction();
            if ((fsr2.IsFreeSpin || XT.GetBool(Vars.FromServer_MustOpenFSBG)) && (respinData == null || respinData.IsDone && fsr2.IsFreeSpinsStart || !fsr2.IsFreeSpinsStart)) {
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.ResultFreeSpin);
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
            XT.SetObject(Vars.FromStageName,
                this.GetStageName());
            XT.SetObject(Vars.ToStageName, UHTStageName.Result);
            return UHTAction.ChangeStage(UHTStageName.Transition)
        }
    }
    return UHTAction.NoAction()
};
StageSpin.prototype.UHTFinish = function() {
    XT.UnregisterCallbackEvent(this.OnSpinEnded, this);
    XT.UnregisterCallbackEvent(this.OnBalanceUpdated, this);
    XT.UnregisterCallbackEvent(this.OnPressedStop, this);
    XT.UnregisterCallbackEvent(this.OnStartAutoplay, this);
    XT.UnregisterCallbackEvent(this.OnStopAutoplay, this);
    XT.UnregisterCallbackEvent(this.OnBonusRoundsContinuePressed, this)
};
StageSpin.prototype.OnPressedStop = function() {
    if (XT.GetBool(Vars.AllowFastStop) && !XT.GetBool(Vars.DisableStopButton)) XT.TriggerEvent(Vars.Evt_Internal_ReelManager_StopSpin)
};
StageSpin.prototype.OnSpinEnded = function() {
    this.spinEnded = true
};
StageSpin.prototype.OnBalanceUpdated = function() {
    XT.SetDouble(Vars.BalanceDisplayed, XT.GetDouble(Vars.BalanceReceived));
    XT.SetDouble(Vars.BonusBalance, XT.GetDouble(Vars.BonusBalanceReceived))
};
StageSpin.prototype.OnStopAutoplay = function() {
    XT.SetInt(Vars.AutoplaySpinsLeft, -1);
    var brd = XT.GetObject(Vars.BonusRoundsData);
    if (this.isBonusRounds) VSGameStateManager.ChangeTo(VSGameState.SpinBonusRounds);
    else VSGameStateManager.ChangeTo(VSGameState.Spin)
};
StageSpin.prototype.OnBonusRoundsContinuePressed = function() {
    XT.TriggerEvent(Vars.Evt_ToServer_ReloadGame)
};
StageSpin.prototype.OnStartAutoplay = function() {
    XT.SetInt(Vars.AutoplaySpinsLeft, XT.GetInt(Vars.AutoplaySpinsRequested));
    XT.SetInt(Vars.AutoplaySpinsLeftDisplayed, XT.GetInt(Vars.AutoplaySpinsLeft))
};
StageSpin.prototype.OnRQEnded = function(unused) {
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr != null && !XT.GetBool(Vars.IsDifferentSpinType)) {
        XT.SetInt(Vars.CurrentFreeSpinDisplayed, fsr.CurrentSpin);
        XT.SetInt(Vars.FreeSpinsLeftDisplayed, fsr.MaxSpins - fsr.CurrentSpin)
    }
    this.isRQEnded = true
};
goog.require("UHT.Engine");
goog.require("UHT.UHTStage");
StageBonusSimpleWindow.prototype = Object.create(UHTStage.prototype);
StageBonusSimpleWindow.prototype.constructor = StageBonusSimpleWindow;

function StageBonusSimpleWindow() {
    UHTStage.call(this);
    this.showWindowWithNoWin = false;
    this.canGoToAnotherBonus = false;
    this.resetLevel = true;
    this.externalWinUpdate = false;
    this.treatAsFSBG = false;
    this.mustCloseBonus = false;
    this.stageToReturnTo = UHTStageName.No_Stage;
    this.realWin = 0;
    this.bonusInitReceived = false
}
StageBonusSimpleWindow.prototype.GetStageName = function() {
    return UHTStageName.Bonus
};
StageBonusSimpleWindow.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_BonusInitDone, this.UpdateBonusData, this)
};
StageBonusSimpleWindow.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.UpdateBonusData, this)
};
StageBonusSimpleWindow.prototype.UHTUpdate = function(isFirstFrame) {
    if (isFirstFrame) {
        CoinManager.SetStrictBetMode(true);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_BalanceUpdated, this.OnBalanceUpdated, this);
        XT.RegisterCallbackEvent(BGVars.Evt_DataToCode_BonusResultWindowCollect, this.OnBonusResultWindowCollect, this);
        XT.RegisterCallbackEvent(BGVars.Evt_DataToCode_BonusResultWindowClosed, this.OnBonusResultWindowClosed, this);
        VSGameStateManager.ChangeTo(VSGameState.Bonus);
        XT.SetDouble(Vars.BonusRealWinDisplayed,
            0);
        var bonusData = XT.GetObject(Vars.BonusData);
        bonusData.Level = 0;
        XT.TriggerEvent(Vars.Evt_Internal_StopVSLogicSounds);
        XT.TriggerEvent(Vars.Evt_Internal_StartBGLogicSounds);
        XT.SetBool(Vars.MustOpenBonus, false);
        this.mustCloseBonus = false;
        this.stageToReturnTo = UHTStageName.No_Stage;
        UHTInterfaceBOSS.PostMessage("bonusGameStarted")
    } else {
        if (this.bonusInitReceived)
            if (this.showWindowWithNoWin || this.realWin > 0) {
                if (!this.externalWinUpdate) {
                    XT.SetDouble(Vars.BonusRealWinDisplayed, this.realWin);
                    this.realWin = 0
                }
                XT.TriggerEvent(BGVars.Evt_CodeToData_BonusResultWindowShow);
                this.bonusInitReceived = false
            }
        if (this.mustCloseBonus) {
            var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
            this.stageToReturnTo = fsr.IsFreeSpin ? UHTStageName.ResultFreeSpin : UHTStageName.Result;
            if (!XT.GetObject(Vars.BonusData).GameOver && this.canGoToAnotherBonus) XT.SetBool(Vars.MustOpenBonus, true);
            if (this.stageToReturnTo == UHTStageName.Result) AutoplayManager.RestoreSettings();
            XT.SetObject(Vars.FromStageName, this.GetStageName());
            XT.SetObject(Vars.ToStageName, this.stageToReturnTo);
            UHTInterfaceBOSS.PostMessage("bonusGameEnded");
            if (!fsr.IsFreeSpin && !XT.GetBool(Vars.MustOpenBonus)) UHTInterfaceBOSS.PostMessage("gameRoundEnded");
            return UHTAction.ChangeStage(UHTStageName.Transition)
        }
    }
    return UHTAction.NoAction()
};
StageBonusSimpleWindow.prototype.UHTFinish = function() {
    XT.UnregisterCallbackEvent(this.OnBalanceUpdated, this);
    XT.UnregisterCallbackEvent(this.OnBonusResultWindowCollect, this);
    XT.UnregisterCallbackEvent(this.OnBonusResultWindowClosed, this);
    XT.TriggerEvent(Vars.Evt_Internal_StopBGLogicSounds);
    XT.TriggerEvent(Vars.Evt_Internal_StartVSLogicSounds)
};
StageBonusSimpleWindow.prototype.OnBonusResultWindowCollect = function() {
    if (XT.GetBool(Vars.WaitInResultForBigWin)) {
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        return
    }
    if (XT.GetBool(Vars.LastWinIsCounting)) XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    XT.TriggerEvent(BGVars.Evt_CodeToData_BonusResultWindowClose);
    XT.TriggerEvent(Vars.Evt_ToServer_BonusGameFinished)
};
StageBonusSimpleWindow.prototype.OnBonusResultWindowClosed = function() {
    if (this.treatAsFSBG) XT.SetBool(Vars.Internal_FSBGJustClosed, true);
    this.mustCloseBonus = true
};
StageBonusSimpleWindow.prototype.UpdateBonusData = function() {
    var bonusData = XT.GetObject(Vars.BonusData);
    if (this.resetLevel) bonusData.Level = 0;
    this.realWin = bonusData.RealWin;
    this.bonusInitReceived = true
};
StageBonusSimpleWindow.prototype.OnBalanceUpdated = function() {
    XT.SetDouble(Vars.BalanceDisplayed, XT.GetDouble(Vars.BalanceReceived));
    XT.SetDouble(Vars.BonusBalance, XT.GetDouble(Vars.BonusBalanceReceived))
};
StageBonusSimpleWindow.prototype.UpdateWinAmount = function() {
    XT.SetDouble(Vars.BonusRealWinDisplayed, this.realWin);
    this.realWin = 0
};
goog.require("UHT.Engine");
goog.require("UHT.UHTStage");

function TransitionHelperClass() {
    this.transitionCAT = null;
    this.fromStageName = UHTStageName.No_Stage;
    this.toStageName = UHTStageName.No_Stage;
    this.canWait = false
}
var StageTransitionVars = {
    StageTransition_WaitInTransition: "StageTransition_WaitInTransition",
    Evt_StageTransition_SetWaitInTransition: "Evt_StageTransition_SetWaitInTransition"
};
StageTransition.prototype = Object.create(UHTStage.prototype);
StageTransition.prototype.constructor = StageTransition;

function StageTransition() {
    UHTStage.call(this);
    this.transitions = [];
    this.toStageName = UHTStageName.No_Stage;
    this.fromStageName = UHTStageName.No_Stage;
    this.transitionCAT = null;
    this.transitionDone = false;
    this.transitionCanWait = false
}
StageTransition.prototype.GetStageName = function() {
    return UHTStageName.Transition
};
StageTransition.prototype.XTRegisterCallbacks = function() {};
StageTransition.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(StageTransitionVars.StageTransition_WaitInTransition, false)
};
StageTransition.prototype.UHTInit = function() {};
StageTransition.prototype.UHTUpdate = function(isFirstFrame) {
    var waitInTransition = XT.GetBool(StageTransitionVars.StageTransition_WaitInTransition);
    if (isFirstFrame) {
        this.fromStageName = XT.GetObject(Vars.FromStageName);
        this.toStageName = XT.GetObject(Vars.ToStageName);
        this.transitionCAT = this.GetCAT(this.fromStageName, this.toStageName);
        if (this.transitionCAT != null) {
            this.transitionCAT.RegisterCallback(0, this.TransitionToStageDone, this);
            this.transitionCAT.StartEvent(0)
        } else if (!(this.transitionCanWait && waitInTransition)) return UHTAction.ChangeStage(this.toStageName)
    } else if (!(this.transitionCanWait &&
            waitInTransition) && this.transitionDone) {
        this.transitionDone = false;
        return UHTAction.ChangeStage(this.toStageName)
    }
    return UHTAction.NoAction()
};
StageTransition.prototype.UHTFinish = function() {
    if (this.transitionCAT != null) this.transitionCAT.StartEvent(1)
};
StageTransition.prototype.TransitionToStageDone = function(type, data) {
    if (type == CAT_Event.CallbackType.EndOfEvent) this.transitionDone = true
};
StageTransition.prototype.GetCAT = function(_fromStage, _toStage) {
    for (var index = 0; index < this.transitions.length; index++)
        if (this.transitions[index].fromStageName == _fromStage && this.transitions[index].toStageName == _toStage) {
            this.transitionCanWait = this.transitions[index].canWait;
            return this.transitions[index].transitionCAT
        }
    this.transitionCanWait = false;
    return null
};
goog.require("UHT.XTLink");
BigWinWarningVM.prototype = Object.create(XTLink.prototype);
BigWinWarningVM.prototype.constructor = BigWinWarningVM;

function BigWinWarningVM() {
    XTLink.call(this);
    this.priorityBefore = 0;
    this.priorityAfter = 0;
    this.bigWinLevelsBase = null;
    this.bigWinLevelsFree = null;
    this.bigWinLevelsRespin = null;
    this.bigWinLevelsLastRespin = null;
    this.beforeSpinResult = null;
    this.afterSpinResult = null
}
BigWinWarningVM.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_SpinResultReceived, this.OnSpinResultBefore, this, this.priorityBefore);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_SpinResultReceived, this.OnSpinResultAfter, this, this.priorityAfter)
};
BigWinWarningVM.prototype.OnSpinResultBefore = function() {
    this.beforeSpinResult.Start()
};
BigWinWarningVM.prototype.OnSpinResultAfter = function() {
    var levels = XT.GetBool(Vars.Logic_IsFreeSpin) ? this.bigWinLevelsFree : this.bigWinLevelsBase;
    var respinData = XT.GetObject(Vars.RespinData);
    if (respinData != null) levels = respinData.IsDone ? this.bigWinLevelsLastRespin : this.bigWinLevelsRespin;
    var level = XT.GetInt(Vars.SpinResultWinLevel);
    var index = -1;
    for (var i = 0; i < levels.length; i++)
        if (level >= levels[i]) index = i;
    if (index > -1) this.afterSpinResult[index].Start()
};
goog.require("UHT.Engine");
RandomCATStarter.prototype = Object.create(Component.prototype);
RandomCATStarter.prototype.constructor = RandomCATStarter;

function RandomCATStarter() {
    Component.call(this);
    this.catList = null;
    this.alsoStopAnyRunningCAT = false;
    this.useWeights = false;
    this.weights = null;
    this.catIndices = null
}
RandomCATStarter.prototype.StartRandomCAT = function() {
    if (this.alsoStopAnyRunningCAT) this.StopAnyRunningCAT();
    if (this.catIndices == null) this.InitCatIndices();
    var randIdx = Random.Range(0, this.catIndices.length);
    this.catList[this.catIndices[randIdx]].Start()
};
RandomCATStarter.prototype.StopAnyRunningCAT = function() {
    for (var i = 0; i < this.catList.length; i++)
        if (this.catList[i].IsRunning()) this.catList[i].Stop()
};
RandomCATStarter.prototype.InitCatIndices = function() {
    this.catIndices = [];
    if (this.useWeights)
        for (var i = 0; i < this.weights.length; ++i)
            for (var j = 0; j < this.weights[i]; ++j) this.catIndices.push(i);
    else
        for (var i = 0; i < this.catList.length; ++i) this.catIndices.push(i)
};
goog.require("UHT.Engine");
SymbolsFader.prototype = Object.create(XTLink.prototype);
SymbolsFader.prototype.constructor = SymbolsFader;

function SymbolsFader() {
    XTLink.call(this);
    this.alphaValue = 1;
    this.includeLoopers = false;
    this.symbolPositions = [];
    this.oldAlphaValue = 1;
    this.rm = null;
    this.isAllowed = true
}
SymbolsFader.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinEnded, this.OnSpinEnded, this)
};
SymbolsFader.prototype.OnSpinStarted = function() {
    this.alphaValue = 1;
    this.Update();
    this.isAllowed = false
};
SymbolsFader.prototype.OnSpinEnded = function() {
    this.isAllowed = true
};
SymbolsFader.prototype.Start = function() {
    this.oldAlphaValue = this.alphaValue
};
SymbolsFader.prototype.Update = function() {
    if (this.rm == null) this.rm = XT.GetObject(Vars.ReelsManagerObject);
    if (Math.abs(this.alphaValue - this.oldAlphaValue) > .001) {
        this.oldAlphaValue = this.alphaValue;
        for (var i = 0; i < this.rm.reels.length; i++) {
            if (this.includeLoopers)
                for (var j = 0; j < this.rm.reels[i].symbolLoopHolders.length; j++)
                    if (this.rm.reels[i].symbolLoopHolders[j].currentSymbol != null) this.rm.reels[i].symbolLoopHolders[j].currentSymbol.GetComponent(UIPanel).alpha = this.alphaValue;
            if (this.isAllowed)
                for (var j =
                        0; j < this.rm.reels[i].symbolHolders.length; j++) {
                    var contained = false;
                    var containedIndex = j * this.rm.reels.length + i;
                    for (var index = 0; index < this.symbolPositions.length; index++)
                        if (this.symbolPositions[index] == containedIndex) {
                            contained = true;
                            break
                        }
                    if (contained || this.symbolPositions.length == 0) this.rm.reels[i].symbolHolders[j].currentSymbol.gameObject.GetComponent(UIPanel).alpha = this.alphaValue
                }
        }
    }
};
goog.require("UHT.Engine");
SymbolsStartCustomCATProxy.prototype = Object.create(Component.prototype);
SymbolsStartCustomCATProxy.prototype.constructor = SymbolsStartCustomCATProxy;

function SymbolsStartCustomCATProxy() {
    Component.call(this);
    this.cat = null
}
goog.require("UHT.Engine");
SymbolsStartCustomCAT.prototype = Object.create(Component.prototype);
SymbolsStartCustomCAT.prototype.constructor = SymbolsStartCustomCAT;

function SymbolsStartCustomCAT() {
    Component.call(this);
    this.catId = 0;
    this.symbolPositions = [];
    this.useProxy = false;
    this.rm = null
}
SymbolsStartCustomCAT.prototype.StartCustomCAT = function() {
    if (this.symbolPositions.length == 0) return;
    if (this.rm == null) this.rm = XT.GetObject(Vars.ReelsManagerObject);
    for (var i = 0; i < this.rm.reels.length; i++)
        for (var j = 0; j < this.rm.reels[i].symbolHolders.length; j++)
            if (_array.indexOf(j * this.rm.reels.length + i, this.symbolPositions) != -1) {
                var symbol = this.rm.reels[i].symbolHolders[j].currentSymbol;
                (this.useProxy ? symbol.GetComponentInChildren(SymbolsStartCustomCATProxy).cat : symbol.eventNormal.cat).StartEvent(this.catId)
            }
};
goog.require("UHT.Engine");
var ReelFXReelStopEvent = {
    ReelStopStarted: 0,
    ReelStopEnded: 1
};
ReelFX.prototype = Object.create(XTLink.prototype);
ReelFX.prototype.constructor = ReelFX;

function ReelFX() {
    XTLink.call(this);
    this.reelIndex = 0;
    this.reelStopEvent = ReelFXReelStopEvent.ReelStopStarted;
    this.reelExcited = null;
    this.reelStop = null;
    this.reelStopWin = null;
    this.fastPlayReelExcited = null;
    this.fastPlayReelStop = null;
    this.fastPlayReelStopWin = null;
    this.reelStoppedFast = null;
    this.reelsExcited = null;
    this.numberOfReels = 0
}
ReelFX.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ExcitedReel, this.ReelExcited, this);
    XT.RegisterCallbackObject(Vars.ReelInitialPositions, this.OnReelPositions, this);
    XT.RegisterCallbackObject(Vars.ResultScreenSymbols, this.OnResultScreenSymbols, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelManager_StopSpin, this.OnReelStoppedFast, this);
    if (this.reelStopEvent == ReelFXReelStopEvent.ReelStopEnded) XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelStopEnded, this.ReelStopEnded,
        this);
    else XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelStopStarted, this.ReelStopped, this)
};
ReelFX.prototype.XTInitVariablesAndEvents = function() {};
ReelFX.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.ReelExcited, this);
    XT.UnregisterCallbackEvent(this.ReelStopped, this);
    XT.UnregisterCallbackObject(this.OnReelPositions, this);
    XT.UnregisterCallbackObject(this.OnResultScreenSymbols, this);
    XT.UnregisterCallbackEvent(this.OnReelStoppedFast, this)
};
ReelFX.prototype.OnResultScreenSymbols = function(resultScreenSymbols) {
    this.reelsExcited = [];
    for (var reIndex = 0; reIndex < this.numberOfReels; reIndex++) this.reelsExcited.push(false)
};
ReelFX.prototype.OnReelPositions = function(reelPos) {
    this.numberOfReels = reelPos.length;
    this.reelsExcited = []
};
ReelFX.prototype.ReelExcited = function() {
    var excitedReelIndex = XT.GetInt(Vars.LastExcitedReelIndex);
    this.reelsExcited[excitedReelIndex] = true;
    if (excitedReelIndex == this.reelIndex)
        if (XT.GetBool(Vars.FastPlay) && this.fastPlayReelExcited.cat != null) this.fastPlayReelExcited.Start();
        else this.reelExcited.Start()
};
ReelFX.prototype.ReelStopped = function() {
    this.ReelStoppedInternal(XT.GetObject(Vars.LastStoppedReelIndices))
};
ReelFX.prototype.ReelStopEnded = function() {
    this.ReelStoppedInternal([XT.GetInt(Vars.LastStopEndedReelIndex)])
};
ReelFX.prototype.ReelStoppedInternal = function(reelsStopped) {
    var reelsStopOrder = XT.GetObject(Vars.ReelsStopOrder);
    for (var rsIndex = 0; rsIndex < reelsStopped.length; rsIndex++)
        if (_array.indexOf(this.reelIndex, reelsStopOrder) <= _array.indexOf(reelsStopped[rsIndex], reelsStopOrder)) {
            this.reelExcited.Stop();
            if (this.fastPlayReelExcited.cat != null) this.fastPlayReelExcited.Stop();
            if (this.reelIndex == reelsStopped[rsIndex]) {
                var fastPlay = XT.GetBool(Vars.FastPlay);
                var reelwin = XT.GetObject(Vars.ReelsWinInfo)[this.reelIndex];
                var win = this.reelsExcited[this.reelIndex] && reelwin;
                if (win && this.reelStopWin.cat != null)
                    if (fastPlay && this.fastPlayReelStopWin.cat != null) this.fastPlayReelStopWin.Start();
                    else this.reelStopWin.Start();
                else if (fastPlay && this.fastPlayReelExcited.cat != null) this.fastPlayReelStop.Start();
                else this.reelStop.Start()
            }
        }
};
ReelFX.prototype.OnReelStoppedFast = function() {
    if (this.reelsExcited[this.reelIndex] && this.reelStoppedFast != null) this.reelStoppedFast.Start()
};
goog.require("UHT.XTLink");
RQInjector.prototype = Object.create(XTLink.prototype);
RQInjector.prototype.constructor = RQInjector;

function RQInjector() {
    XTLink.call(this);
    this.rq = null;
    this.Event = "";
    this.priority = 0;
    this.useBeforeInject = false;
    this.beforeInject = null;
    this.cat = null;
    this.waitForSeconds = -1;
    this.waitForXTEvent = "";
    this.timeScaleID = "";
    this.canInject = false;
    this.items = []
}
RQInjector.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(this.Event, this.OnEvent, this, this.priority);
    if (!_string.IsNullOrEmpty(this.waitForXTEvent)) this.waitForXTEvent = "Evt_RQInjector_" + this.waitForXTEvent
};
RQInjector.prototype.OnEvent = function() {
    if (this.canInject && this.useBeforeInject) this.beforeInject.Start();
    if (this.canInject) {
        this.canInject = false;
        this.items.splice(0);
        if (this.cat != null) {
            var item = new RQITriggerCallback(this.StartCAT, null, this);
            this.rq.AddRoutineQueueItem(item);
            this.items.push(item)
        }
        if (this.waitForSeconds >= 0) {
            var item = new RQIWaitForSeconds(this.waitForSeconds, this.timeScaleID);
            this.rq.AddRoutineQueueItem(item);
            this.items.push(item)
        }
        if (!_string.IsNullOrEmpty(this.waitForXTEvent)) {
            var item =
                new RQIWaitForXTEvent(this.waitForXTEvent);
            this.rq.AddRoutineQueueItem(item);
            this.items.push(item)
        }
    }
};
RQInjector.prototype.StartCAT = function(param) {
    this.cat.Start()
};
RQInjector.prototype.InjectRQ = function() {
    this.canInject = true
};
RQInjector.prototype.CancelInjectRQ = function() {
    this.canInject = false
};
RQInjector.prototype.TriggerExpectedEvent = function() {
    XT.TriggerEvent(this.waitForXTEvent)
};
RQInjector.prototype.SetRoutineQueue = function(param) {
    this.rq = param
};
RQInjector.prototype.UninjectRQ = function() {
    this.canInject = false;
    var list = this.rq.rqiList;
    var startRQI = false;
    for (var i = 0; i < this.items.length; ++i) {
        var item = this.items[i];
        var index = list.indexOf(item);
        if (index < 0) continue;
        if (index == 0) {
            startRQI = true;
            item.RQIStop()
        }
        list.splice(index, 1)
    }
    if (startRQI && list.length > 0) list[0].RQIStart()
};
goog.require("UHT.XTLink");
SymbolsReplacementJK.prototype = Object.create(XTLink.prototype);
SymbolsReplacementJK.prototype.constructor = SymbolsReplacementJK;

function SymbolsReplacementJK() {
    XTLink.call(this);
    this.duration = 0;
    this.symbolDelay = 0;
    this.symbolDuration = 0;
    this.replacementStart = null;
    this.replacementActivator = null;
    this.injector = null;
    this.queue = null;
    this.trailSource = null;
    this.triggerID = 0;
    this.triggerCATStarter = null;
    this.triggerPositions = [];
    this.holders = null;
    this.replacements = [];
    this.descriptors = [];
    this.canReplace = false
}
SymbolsReplacementJK.reelsCount = 0;
SymbolsReplacementJK.Descriptor = function() {
    this.data = null;
    this.position = 0
};
SymbolsReplacementJK.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.ReelsManagerObject, this.OnReelsManager, this);
    XT.RegisterCallbackObject(Vars.OrderedSymbolHoldersList, this.OnSymbolHolders, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_SpinResultReceived, this.OnSpinResultReceived, this)
};
SymbolsReplacementJK.prototype.OnReelsManager = function(param) {
    SymbolsReplacementJK.reelsCount = param.reels.length
};
SymbolsReplacementJK.prototype.OnSymbolHolders = function(param) {
    this.holders = param;
    for (var i = 0; i < this.holders.length; ++i) {
        var desc = new SymbolsReplacementJK.Descriptor;
        desc.position = i;
        this.descriptors.push(desc)
    }
};
SymbolsReplacementJK.prototype.OnSpinStarted = function() {
    this.canReplace = true;
    XT.UnregisterCallbackEvent(this.OnSpinStarted, this, Vars.Evt_Internal_SpinStarted)
};
SymbolsReplacementJK.prototype.OnSpinResultReceived = function() {
    this.OnSymbolReplacement(XT.GetObject(Vars.SymbolReplacementData))
};
SymbolsReplacementJK.prototype.OnSymbolReplacement = function(param) {
    if (!this.canReplace) return;
    var response = XT.GetObject(FOXVars.FOX_Response);
    if (response == null) return;
    if (response[GameProtocolDictionary.symbolsBeforeExpanding] == undefined) return;
    var replacementData = param;
    if (replacementData == null) return;
    this.replacements.splice(0);
    this.triggerPositions.splice(0);
    var initScreen = _array.ConvertAll(response[GameProtocolDictionary.symbolsBeforeExpanding].split(","), _number.otoi);
    for (var i = 0; i < initScreen.length; ++i)
        if (initScreen[i] ==
            this.triggerID) this.triggerPositions.push(i);
    this.triggerPositions.sort(SymbolsReplacementJK.SortPositions);
    for (var i = 0; i < replacementData.length; ++i) {
        var data = replacementData[i];
        var replacement = this.FindReplacement(data);
        if (replacement == null) {
            replacement = new VsSymbolReplacement;
            replacement.FromSymbolId = data.FromSymbolId;
            replacement.ToSymbolId = data.ToSymbolId;
            this.replacements.push(replacement)
        }
        _array.AddRange(replacement.ReplacementPositions, data.ReplacementPositions)
    }
    this.replacements.sort(SymbolsReplacementJK.SortReplacements);
    this.injector.InjectRQ();
    this.queue.StopRoutines();
    for (var i = 0; i < this.replacements.length; ++i) {
        this.queue.AddRoutineQueueItem(new RQITriggerCallback(this.ReplacementStart, i, this));
        var totalSeconds = 0;
        var data = this.replacements[i];
        var positions = data.ReplacementPositions;
        positions.sort(SymbolsReplacementJK.SortPositions);
        for (var j = 0; j < positions.length; ++j) {
            var position = positions[j];
            var desc = this.descriptors[position];
            desc.data = data;
            this.queue.AddRoutineQueueItem(new RQITriggerCallback(this.TransformSymbol,
                desc, this));
            this.queue.AddRoutineQueueItem(new RQIWaitForSeconds(this.symbolDelay));
            totalSeconds += this.symbolDelay
        }
        var seconds = this.symbolDuration - this.symbolDelay;
        this.queue.AddRoutineQueueItem(new RQIWaitForSeconds(seconds));
        totalSeconds += seconds;
        seconds = this.duration - totalSeconds;
        if (seconds > 0) this.queue.AddRoutineQueueItem(new RQIWaitForSeconds(seconds))
    }
    this.queue.AddRoutineQueueItem(new RQITriggerCallback(this.ReplaceSymbols, null, this))
};
SymbolsReplacementJK.prototype.ReplacementStart = function(index) {
    this.replacementActivator.DeactivateAll();
    this.replacementActivator.Activate(this.replacements[index].FromSymbolId);
    this.replacementStart.Start();
    this.triggerCATStarter.symbolPositions.splice(0);
    this.triggerCATStarter.symbolPositions.push(this.triggerPositions[index]);
    this.triggerCATStarter.StartCustomCAT()
};
SymbolsReplacementJK.prototype.TransformSymbol = function(desc) {
    var data = desc.data;
    var holder = this.holders[desc.position];
    var symbol = holder.currentSymbol;
    var replacement = symbol.GetComponentInChildren(SymbolReplacementJK);
    replacement.UpdateTrail(this.trailSource, holder.transform);
    replacement.ReplaceSymbol(data.FromSymbolId, data.ToSymbolId)
};
SymbolsReplacementJK.prototype.ReplaceSymbols = function(param) {
    for (var i = 0; i < this.replacements.length; ++i) {
        var data = this.replacements[i];
        var positions = data.ReplacementPositions;
        var toSymbolId = data.ToSymbolId;
        for (var j = 0; j < positions.length; ++j) {
            var position = positions[j];
            var holder = this.holders[position];
            var symbol = holder.currentSymbol;
            var replacement = symbol.GetComponentInChildren(SymbolReplacementJK);
            replacement.ResetTrail();
            holder.ReplaceSymbol(toSymbolId);
            symbol = holder.currentSymbol;
            symbol.SpinStop();
            symbol.EventStop()
        }
    }
    this.injector.UninjectRQ()
};
SymbolsReplacementJK.prototype.FindReplacement = function(replacement) {
    for (var i = 0; i < this.replacements.length; ++i)
        if (this.replacements[i].FromSymbolId == replacement.FromSymbolId && this.replacements[i].ToSymbolId == replacement.ToSymbolId) return this.replacements[i];
    return null
};
SymbolsReplacementJK.SortReplacements = function(x, y) {
    return x.FromSymbolId - y.FromSymbolId
};
SymbolsReplacementJK.SortPositions = function(x, y) {
    var reelsCount = SymbolsReplacementJK.reelsCount;
    var ret = x % reelsCount - y % reelsCount;
    if (ret == 0) ret = x - y;
    return ret
};
goog.require("UHT.Engine");
goog.provide("UHT.StickyReel");
StickyReel.prototype = Object.create(XTLink.prototype);
StickyReel.prototype.constructor = StickyReel;

function StickyReel() {
    XTLink.call(this);
    this.reelIndex = -1;
    this.fakeSymbolHolders = [];
    this.showStickyReel = null;
    this.hideStickyReel = null;
    this.rm = null;
    this.stickySymbolsData = null;
    this.screenSymbols = null
}
StickyReel.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.SpinStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinEnded, this.SpinEnded, this)
};
StickyReel.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGameInit, this);
    XT.UnregisterCallbackEvent(this.SpinStarted, this);
    XT.UnregisterCallbackEvent(this.SpinEnded, this)
};
StickyReel.prototype.OnGameInit = function() {
    this.rm = XT.GetObject(Vars.ReelsManagerObject)
};
StickyReel.prototype.SpinStarted = function() {
    this.stickySymbolsData = XT.GetObject(Vars.StickySymbolsData);
    if (this.stickySymbolsData == null) return;
    var reelIsSticky = false;
    for (var i = 0; i < this.stickySymbolsData.length; i++) {
        var stickyReelIndex = this.stickySymbolsData[i].currentPosition % this.rm.reels.length;
        if (this.stickySymbolsData[i].IsSticky() && stickyReelIndex == this.reelIndex) {
            var symbolHolderIndex = Math.floor(this.stickySymbolsData[i].currentPosition / this.rm.reels.length);
            this.ReplaceSymbol(this.fakeSymbolHolders[symbolHolderIndex],
                this.GetStickySymbolId(this.stickySymbolsData[i]));
            this.fakeSymbolHolders[symbolHolderIndex].currentSymbol.SetNormal();
            reelIsSticky = true
        }
    }
    if (reelIsSticky) this.showStickyReel.Start()
};
StickyReel.prototype.SpinEnded = function() {
    this.stickySymbolsData = XT.GetObject(Vars.StickySymbolsData);
    if (this.stickySymbolsData == null) return;
    var reelWasSticky = false;
    for (var i = 0; i < this.stickySymbolsData.length; i++) {
        var stickyReelIndex = this.stickySymbolsData[i].currentPosition % this.rm.reels.length;
        if (this.stickySymbolsData[i].WillDisappear() && stickyReelIndex == this.reelIndex) {
            var symbolHolderIndex = Math.floor(this.stickySymbolsData[i].currentPosition / this.rm.reels.length);
            this.rm.reels[this.reelIndex].symbolHolders[symbolHolderIndex].ReplaceSymbol(this.GetStickySymbolId(this.stickySymbolsData[i]),
                false);
            this.rm.reels[this.reelIndex].symbolHolders[symbolHolderIndex].currentSymbol.SetNormal();
            this.rm.symbolsManager.RecycleSymbol(this.fakeSymbolHolders[symbolHolderIndex].currentSymbol, false);
            this.fakeSymbolHolders[symbolHolderIndex].currentSymbol = null;
            reelWasSticky = true
        }
    }
    if (reelWasSticky) this.hideStickyReel.Start()
};
StickyReel.prototype.ReplaceSymbol = function(holder, symbolIndex) {
    if (holder.currentSymbol != null) this.rm.symbolsManager.RecycleSymbol(holder.currentSymbol, false);
    holder.currentSymbol = this.rm.symbolsManager.GetSymbol(symbolIndex, holder.gameObject, false);
    holder.currentSymbol.SetNormal()
};
StickyReel.prototype.GetStickySymbolId = function(_data) {
    var stickySymbolId = -1;
    var screenSymbols = XT.GetObject(Vars.ResultScreenSymbols);
    var pos = Math.floor(_data.currentPosition / this.rm.reels.length);
    stickySymbolId = screenSymbols[this.reelIndex][this.rm.reels[this.reelIndex].symbolHolders.length - (pos + 1)];
    return stickySymbolId
};
goog.require("UHT.Engine");
var PanelDepthLogicAction = {
    NoAction: 0,
    HighlightOn: 1,
    HighlightOff: 2
};
PanelDepthLogic.prototype = Object.create(Component.prototype);
PanelDepthLogic.prototype.constructor = PanelDepthLogic;

function PanelDepthLogic() {
    Component.call(this);
    this.depthOrderHighlightOff = null;
    this.depthOrderHighlightOn = null;
    this.depthLoopers = 0;
    this.updateDepthInLoopers = false;
    this.symbolTransform = null;
    this.panels = null;
    this.catHolders = null;
    this.catLoopers = null;
    this.onEnable = PanelDepthLogicAction.NoAction;
    this.findPanelsInHolder = false;
    this.panelsHolder = null;
    this.considerInitialDepth = false;
    this.initialDepths = null;
    this.mustDoOnEnableAction = false;
    this.panelsUpdated = false;
    this.reel = new PanelDepthLogic.Reel
}
PanelDepthLogic.emptyHolders = [];
PanelDepthLogic.Reel = function() {
    this.reelIndex = 0;
    this.symbolHolders = null;
    this.symbolLoopHolders = null
};
PanelDepthLogic.prototype.Awake = function() {
    if (this.symbolTransform == null) this.symbolTransform = this.gameObject.transform;
    var list = [];
    if (this.panels != null) list = list.concat(this.panels);
    if (this.findPanelsInHolder) list = list.concat(this.panelsHolder.GetComponentsInChildren(UIPanel, true));
    var panel = this.gameObject.GetComponent(UIPanel);
    if (panel != null && list.indexOf(panel) < 0) list.push(panel);
    this.panels = list;
    if (this.considerInitialDepth) {
        this.initialDepths = [];
        for (var i = 0; i < this.panels.length; ++i) this.initialDepths.push(this.panels[i].depth)
    }
};
PanelDepthLogic.prototype.OnEnable = function() {
    if (this.onEnable != PanelDepthLogicAction.NoAction) this.mustDoOnEnableAction = true
};
PanelDepthLogic.prototype.Update = function() {
    if (this.mustDoOnEnableAction) {
        this.panelsUpdated = false;
        if (this.onEnable == PanelDepthLogicAction.HighlightOn) this.SetPanelHighlightOn();
        else if (this.onEnable == PanelDepthLogicAction.HighlightOff) this.SetPanelHighlightOff();
        if (this.panelsUpdated) this.mustDoOnEnableAction = false
    }
};
PanelDepthLogic.prototype.SetPanelHighlightOn = function() {
    var myReel = this.FindMyReel();
    if (myReel == null) return;
    for (var i = 0; i < myReel.symbolHolders.length; i++)
        if (this.symbolTransform.parent.gameObject == myReel.symbolHolders[i].gameObject) this.UpdatePanels(this.depthOrderHighlightOn[i] + myReel.reelIndex);
    this.UpdateDepthInLoopers(myReel)
};
PanelDepthLogic.prototype.SetPanelHighlightOff = function() {
    var myReel = this.FindMyReel();
    if (myReel == null) return;
    for (var i = 0; i < myReel.symbolHolders.length; i++)
        if (this.symbolTransform.parent.gameObject == myReel.symbolHolders[i].gameObject) this.UpdatePanels(this.depthOrderHighlightOff[i] + myReel.reelIndex);
    this.UpdateDepthInLoopers(myReel)
};
PanelDepthLogic.prototype.SetPanelDefault = function() {
    this.UpdatePanels(1)
};
PanelDepthLogic.prototype.UpdateDepthInLoopers = function(myReel) {
    if (!this.updateDepthInLoopers) return;
    for (var i = 0; i < myReel.symbolLoopHolders.length; i++)
        if (this.symbolTransform.parent.gameObject == myReel.symbolLoopHolders[i].gameObject) this.UpdatePanels(this.depthLoopers + myReel.reelIndex, true)
};
PanelDepthLogic.prototype.UpdatePanels = function(depth, isLooper) {
    if (this.panels != null)
        for (var i = 0; i < this.panels.length; ++i) this.panels[i].depth = this.GetDepth(this.panels[i], depth);
    if (isLooper == undefined) isLooper = false;
    var cat = isLooper ? this.catLoopers : this.catHolders;
    if (cat != null) cat.Start();
    this.panelsUpdated = true
};
PanelDepthLogic.prototype.FindMyReel = function() {
    if (this.symbolTransform.parent == null) return null;
    var reel = this.reel;
    var reelTransform = this.symbolTransform.parent.parent;
    var vsReel = reelTransform.GetComponent(VS_Reel);
    if (vsReel != null) {
        reel.reelIndex = vsReel.reelIndex;
        reel.symbolHolders = vsReel.symbolHolders;
        reel.symbolLoopHolders = vsReel.symbolLoopHolders;
        return reel
    }
    var stickyReel = reelTransform.GetComponent(StickyReel);
    if (stickyReel != null) {
        reel.reelIndex = stickyReel.reelIndex;
        reel.symbolHolders = stickyReel.fakeSymbolHolders;
        reel.symbolLoopHolders = PanelDepthLogic.emptyHolders;
        return reel
    }
    return null
};
PanelDepthLogic.prototype.GetDepth = function(panel, depth) {
    if (this.considerInitialDepth) return this.initialDepths[this.panels.indexOf(panel)] + depth;
    return depth
};
goog.require("UHT.XTLink");
SymbolReplacementJK.prototype = Object.create(XTLink.prototype);
SymbolReplacementJK.prototype.constructor = SymbolReplacementJK;

function SymbolReplacementJK() {
    XTLink.call(this);
    this.replacement = null;
    this.activatorFrom = null;
    this.activatorTo = null;
    this.trailP = null;
    this.trailR = null;
    this.trailS = null;
    this.trailFrom = null;
    this.trailTo = null
}
SymbolReplacementJK.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(InterfaceVars.Evt_Internal_BlackBandsUpdated, this.OnGameSizeChanged, this)
};
SymbolReplacementJK.prototype.OnGameSizeChanged = function() {
    if (this.trailFrom != null && this.trailTo != null) this.UpdateTrail(this.trailFrom, this.trailTo)
};
SymbolReplacementJK.prototype.UpdateActivators = function(from, to) {
    this.activatorFrom.DeactivateAll();
    this.activatorFrom.Activate(from);
    this.activatorTo.DeactivateAll();
    this.activatorTo.Activate(to)
};
SymbolReplacementJK.prototype.ReplaceSymbol = function(from, to) {
    this.UpdateActivators(from, to);
    this.replacement.Start()
};
SymbolReplacementJK.prototype.UpdateTrail = function(from, to) {
    this.trailFrom = from;
    this.trailTo = to;
    var p0 = from.position();
    var p1 = to.position();
    this.trailP.position(UHTMath.Vector3.lerp(p0, p1, .5));
    this.trailR.localRotation(UHTMath.Quaternion.euler(this.GetEulerAngles(p0, p1)));
    this.trailS.localScale(this.GetScale(p0, p1))
};
SymbolReplacementJK.prototype.ResetTrail = function() {
    this.trailFrom = null;
    this.trailTo = null
};
SymbolReplacementJK.prototype.GetScale = function(from, to) {
    var ret = UHTMath.Vector3.distance(this.transform.inverseTransformPoint(from), this.transform.inverseTransformPoint(to));
    return new UHTMath.Vector3(ret, 1, 1)
};
SymbolReplacementJK.prototype.GetEulerAngles = function(from, to) {
    var xDiff = to.x - from.x;
    var yDiff = to.y - from.y;
    var ret = Math.atan2(yDiff, xDiff) * 180 / UHTMath.PI;
    return new UHTMath.Vector3(0, 0, ret)
};
goog.require("UHT.Engine");
ScatterPossibleWinJK.prototype = Object.create(Component.prototype);
ScatterPossibleWinJK.prototype.constructor = ScatterPossibleWinJK;

function ScatterPossibleWinJK() {
    Component.call(this);
    this.possibleWin = null;
    this.possibleWinReelIndicesXTVar = ""
}
ScatterPossibleWinJK.prototype.AnimatePossibleWin = function() {
    var reelIndices = XT.GetObject(this.possibleWinReelIndicesXTVar);
    if (reelIndices.indexOf(this.GetReelIndex()) > -1) this.possibleWin.Start()
};
ScatterPossibleWinJK.prototype.GetReelIndex = function() {
    var reels = XT.GetObject(Vars.ReelsManagerObject).reels;
    for (var i = 0; i < reels.length; ++i)
        if (reels[i].GetComponentsInChildren(ScatterPossibleWinJK, true).indexOf(this) > -1) return i;
    return -1
};
goog.require("UHT.XTLink");
SymbolMultiplierJK.prototype = Object.create(XTLink.prototype);
SymbolMultiplierJK.prototype.constructor = SymbolMultiplierJK;

function SymbolMultiplierJK() {
    XTLink.call(this);
    this.multiplierValue = null;
    this.revealMultiplier = null;
    this.highlight = null;
    this.unhighlight = null;
    this.highlightScatter = null;
    this.unhighlightScatter = null
}
SymbolMultiplierJK.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.RevealMultiplier, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StartDisplayWinLine, this.Highlight, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StopDisplayWinLine, this.Unhighlight, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowAllLinesWin, this.Highlight, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_HideAllLinesWin, this.Unhighlight, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowScattersWin,
        this.HighlightScatter, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_HideScattersWin, this.UnhighlightScatter, this)
};
SymbolMultiplierJK.prototype.RevealMultiplier = function() {
    var multiplier = this.GetMultiplier(this.GetPosition());
    var index = this.multiplierValue.indexOf(multiplier);
    if (index > -1) this.revealMultiplier[index].Start()
};
SymbolMultiplierJK.prototype.Highlight = function() {
    if (this.gameObject.activeInHierarchy) this.highlight.Start()
};
SymbolMultiplierJK.prototype.Unhighlight = function() {
    if (this.gameObject.activeInHierarchy) this.unhighlight.Start()
};
SymbolMultiplierJK.prototype.HighlightScatter = function() {
    if (this.gameObject.activeInHierarchy) this.highlightScatter.Start()
};
SymbolMultiplierJK.prototype.UnhighlightScatter = function() {
    if (this.gameObject.activeInHierarchy) this.unhighlightScatter.Start()
};
SymbolMultiplierJK.prototype.GetPosition = function() {
    var holders = XT.GetObject(Vars.OrderedSymbolHoldersList);
    if (holders != null)
        for (var i = 0; i < holders.length; ++i)
            if (holders[i].GetComponentsInChildren(SymbolMultiplierJK, true).indexOf(this) > -1) return i;
    return -1
};
SymbolMultiplierJK.prototype.GetMultiplier = function(position) {
    var multipliers = XT.GetObject(Vars.RandomSymbolMultipliers);
    if (multipliers != null)
        for (var i = 0; i < multipliers.length; ++i)
            if (multipliers[i].symbolPositions.indexOf(position) > -1) return multipliers[i].multiplierValue;
    return -1
};
goog.require("UHT.Engine");
SymbolLoopingEnhancementBySpeed.prototype = Object.create(Component.prototype);
SymbolLoopingEnhancementBySpeed.prototype.constructor = SymbolLoopingEnhancementBySpeed;

function SymbolLoopingEnhancementBySpeed() {
    Component.call(this);
    this.enhanceAlpha = true;
    this.enhanceScale = true;
    this.blurredComponents = null;
    this.maxAlpha = .7;
    this.maxSpeed = 2;
    this.minSpeed = .3;
    this.minScale = .8;
    this.maxScale = 1.2;
    this.firstBlurAlphaFactor = 2;
    this.symbolHolder = null
}
SymbolLoopingEnhancementBySpeed.prototype.OnEnable = function() {
    if (this.gameObject.transform.parent != null) this.symbolHolder = this.gameObject.transform.parent.gameObject.GetComponent(VS_ReelSymbolHolder);
    this.Update()
};
SymbolLoopingEnhancementBySpeed.prototype.OnDisable = function() {
    this.symbolHolder = null
};
SymbolLoopingEnhancementBySpeed.prototype.Update = function() {
    if (this.symbolHolder == null) return;
    var speedScale = (this.symbolHolder.speed - this.minSpeed) / (this.maxSpeed - this.minSpeed);
    if (speedScale < 0) speedScale = 0;
    var widgets = [];
    var i;
    widgets = widgets.concat(this.blurredComponents[0].gameObject.GetComponentsInChildren(UISprite, true));
    widgets = widgets.concat(this.blurredComponents[0].gameObject.GetComponentsInChildren(UILabel, true));
    for (i = 0; i < widgets.length; i++) widgets[i].color.a = UHTMath.clamp(0, (1 - speedScale) *
        this.firstBlurAlphaFactor, 1);
    for (i = 1; i < this.blurredComponents.length; i++) {
        if (this.enhanceAlpha) {
            widgets = [];
            widgets = widgets.concat(this.blurredComponents[i].gameObject.GetComponentsInChildren(UISprite, true));
            widgets = widgets.concat(this.blurredComponents[i].gameObject.GetComponentsInChildren(UILabel, true));
            for (var j = 0; j < widgets.length; j++) widgets[j].color.a = UHTMath.clamp(0, speedScale / i * this.maxAlpha, 1)
        }
        if (this.enhanceScale) this.blurredComponents[this.blurredComponents.length - i].localScale(1, this.minScale +
            speedScale / i * (this.maxScale - this.minScale), 1)
    }
};
goog.require("UHT.Engine");
AdditionalFreeSpins.prototype = Object.create(XTLink.prototype);
AdditionalFreeSpins.prototype.constructor = AdditionalFreeSpins;

function AdditionalFreeSpins() {
    XTLink.call(this);
    this.showAdditionalFreeSpins = null;
    this.showSymbolFX = null;
    this.duration = 1;
    this.symbolFXDelay = null;
    this.RQBeforeSpinStartPriority = 0;
    this.numberOfReels = 0;
    this.showValue = null;
    this.valueDuration = null
}
AdditionalFreeSpins.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.ReelInitialPositions, this.OnReelPositions, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_InjectRQIBeforeSpinStart, this.AddRqiForAdditionalFreeSpins, this, this.RQBeforeSpinStartPriority)
};
AdditionalFreeSpins.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.AddRqiForAdditionalFreeSpins, this)
};
AdditionalFreeSpins.prototype.OnReelPositions = function(reelPos) {
    this.numberOfReels = reelPos.length
};
AdditionalFreeSpins.prototype.AddRqiForAdditionalFreeSpins = function() {
    var additionalFS = XT.GetInt(Vars.AdditionalFreeSpinsWon);
    if (XT.GetBool(Vars.Logic_IsFreeSpin) && additionalFS > 0) {
        var rq = XT.GetObject(Vars.SpinRoutineQueue);
        rq.AddRoutineQueueItem(new RQITriggerCallback(this.StartCATLink, this.showAdditionalFreeSpins, this));
        if (this.showSymbolFX.length > 0) {
            var scatterPositions = this.GetScattersThatNeedToBeAnimated();
            for (var i = 0; i < scatterPositions.length; ++i) {
                rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.symbolFXDelay[i]));
                rq.AddRoutineQueueItem(new RQITriggerCallback(this.StartCATLink, this.showSymbolFX[scatterPositions[i]], this))
            }
        }
        if (this.showValue.length > 0) {
            var valueIdx = additionalFS - 1;
            rq.AddRoutineQueueItem(new RQITriggerCallback(this.StartCATLink, this.showValue[valueIdx], this));
            rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.valueDuration[valueIdx]))
        }
        rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.duration))
    }
};
AdditionalFreeSpins.prototype.IncreaseFreeSpinsLeftDisplayed = function() {
    XT.SetInt(Vars.FreeSpinsLeftDisplayed, XT.GetInt(Vars.FreeSpinsLeftDisplayed) + 1)
};
AdditionalFreeSpins.prototype.StartCATLink = function(link) {
    if (link != null) link.Start()
};
AdditionalFreeSpins.prototype.GetScattersThatNeedToBeAnimated = function() {
    var upSymbols = XT.GetObject(Vars.UpSymbols_RandomWilds);
    var list = upSymbols != null ? this.FindInitialSymbolsWithID(1) : this.FindSymbolsWithID(1);
    var positionsByReels = [];
    for (var i = 0; i < this.numberOfReels; ++i) positionsByReels[i] = [];
    for (var i = 0; i < list.length; i++) positionsByReels[list[i] % this.numberOfReels].push(list[i]);
    var scatterPositions = [];
    for (var i = 0; i < positionsByReels.length; ++i)
        for (var j = 0; j < positionsByReels[i].length; ++j) scatterPositions.push(positionsByReels[i][j]);
    return scatterPositions
};
AdditionalFreeSpins.prototype.FindSymbolsWithID = function(id) {
    var ret = [];
    var curOrderedHoldersList = XT.GetObject(Vars.OrderedSymbolHoldersList);
    for (var i = 0; i < curOrderedHoldersList.length; i++)
        if (curOrderedHoldersList[i].currentSymbol.symbolId == id) ret.push(i);
    return ret
};
AdditionalFreeSpins.prototype.FindInitialSymbolsWithID = function(id) {
    var ret = [];
    var initialResultSymbols = XT.GetObject(Vars.InitialResultScreenSymbols);
    for (var i = 0; i < initialResultSymbols.length; i++)
        for (var j = 0; j < initialResultSymbols[i].length; j++)
            if (id == initialResultSymbols[i][j]) ret.push(i + (initialResultSymbols[i].length - 1 - j) * initialResultSymbols.length);
    return ret
};
AdditionalFreeSpins.prototype.IncreaseAdditionalFreeSpinsWonDisplayed = function() {
    XT.SetInt(Vars.AdditionalFreeSpinsWonDisplayed, XT.GetInt(Vars.AdditionalFreeSpinsWonDisplayed) + 1)
};
AdditionalFreeSpins.prototype.ResetAdditionalFreeSpinsWonDisplayed = function() {
    XT.SetInt(Vars.AdditionalFreeSpinsWonDisplayed, 1)
};
goog.require("UHT.XTLink");
PerLineWinDisplayer.prototype = Object.create(XTLink.prototype);
PerLineWinDisplayer.prototype.constructor = PerLineWinDisplayer;

function PerLineWinDisplayer() {
    XTLink.call(this);
    this.StartCAT = null;
    this.StopCAT = null
}
PerLineWinDisplayer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_UpdateCurrentDisplayedWinLineIndex, this.OnUpdateWinLineIndex, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StartDisplayWinLine, this.OnStartDisplayWinLine, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StopDisplayWinLine, this.OnStopDisplayWinLine, this)
};
PerLineWinDisplayer.prototype.OnUpdateWinLineIndex = function() {
    var index = XT.GetInt(Vars.CurrentDisplayedWinLineIndex);
    var curWinLines = XT.GetObject(Vars.ReceivedWinLines);
    XT.SetDouble(Vars.CurrentDisplayedWinLineWin, curWinLines[index].WinAmount * XT.GetDouble(Vars.CurrentWinMultiplier));
    var curOrderedHoldersList = XT.GetObject(Vars.OrderedSymbolHoldersList);
    var winPositions = curWinLines[index].WinPositions;
    this.gameObject.transform.position(curOrderedHoldersList[winPositions[winPositions.length - 1]].gameObject.transform.position())
};
PerLineWinDisplayer.prototype.OnStartDisplayWinLine = function() {
    this.StartCAT.cat.StartEvent(this.StartCAT.id)
};
PerLineWinDisplayer.prototype.OnStopDisplayWinLine = function() {
    if (!this.StopCAT.cat.IsEventRunning(this.StopCAT.id)) this.StopCAT.cat.StartEvent(this.StopCAT.id)
};
goog.require("UHT.VS_Symbol");
VS_SymbolScatterWild.prototype = Object.create(VS_Symbol.prototype);
VS_SymbolScatterWild.prototype.constructor = VS_SymbolScatterWild;

function VS_SymbolScatterWild() {
    VS_Symbol.call(this);
    this.eventWildNormal = null;
    this.eventWildSpinStart = null;
    this.eventWildSpinLoop = null;
    this.eventWildSpinStop = null;
    this.eventWildHighlightOff = null;
    this.eventWildFSHighlightOff = null;
    this.eventWildHighlightOn = null;
    this.eventWildExcited = null;
    this.eventWildWinExcited = null;
    this.eventWildWinning = null;
    this.eventSetAsScatter = null;
    this.eventSetAsWild = null;
    this.eventResetToScatter = null;
    this.eventWildSpinLoopExcited = null;
    this.isScatter = true
}
VS_SymbolScatterWild.prototype.Start = function() {
    VS_Symbol.prototype.Start.call(this);
    this.eventWildNormal.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinStart.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinLoop.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinStop.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildHighlightOff.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildFSHighlightOff.UnregisterCallback(this.Callback_EventEnded,
        this);
    this.eventWildHighlightOn.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildWinExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildWinning.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSetAsScatter.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSetAsWild.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinLoopExcited.UnregisterCallback(this.Callback_EventEnded,
        this);
    this.eventWildNormal.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinStart.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinLoop.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinStop.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildHighlightOff.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildFSHighlightOff.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildHighlightOn.RegisterCallback(this.Callback_EventEnded,
        this);
    this.eventWildExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildWinExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildWinning.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSetAsScatter.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSetAsWild.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinLoopExcited.RegisterCallback(this.Callback_EventEnded, this)
};
VS_SymbolScatterWild.prototype.ProcessCommands = function() {
    if (this.commands.length > 0)
        if (this.canProcessNextCommand) {
            var newState = this.commands[0];
            this.commands.splice(0, 1);
            this.canProcessNextCommand = false;
            switch (newState) {
                case VS_Symbol.State.Normal:
                    if (this.isScatter) this.eventNormal.Start();
                    else this.eventWildNormal.Start();
                    break;
                case VS_Symbol.State.HighlightOn:
                    if (this.isScatter) this.eventHighlightOn.Start();
                    else this.eventWildHighlightOn.Start();
                    break;
                case VS_Symbol.State.HighlightOff:
                    if (this.isScatter) this.eventHighlightOff.Start();
                    else this.eventWildHighlightOff.Start();
                    break;
                case VS_Symbol.State.SpinStart:
                    if (this.isScatter) this.eventSpinStart.Start();
                    else this.eventWildSpinStart.Start();
                    break;
                case VS_Symbol.State.SpinLoop:
                    if (this.isScatter) this.eventSpinLoop.Start();
                    else this.eventWildSpinLoop.Start();
                    break;
                case VS_Symbol.State.SpinStop:
                    if (this.isScatter) this.eventSpinStop.Start();
                    else this.eventWildSpinStop.Start();
                    break;
                case VS_Symbol.State.Excited:
                    if (this.isScatter) this.eventExcited.Start();
                    else this.eventWildExcited.Start();
                    break;
                case VS_Symbol.State.WinExcited:
                    if (this.isScatter) this.eventWinExcited.Start();
                    else this.eventWildWinExcited.Start();
                    break;
                case VS_Symbol.State.Winning:
                    if (this.isScatter) this.eventWinning.Start();
                    else this.eventWildWinning.Start();
                    break;
                case VS_Symbol.State.SpinLoopExcited:
                    if (this.isScatter) this.eventSpinLoopExcited.Start();
                    else this.eventWildSpinLoopExcited.Start();
                    break;
                case VS_Symbol.State.FSHighlightOff:
                    if (this.isScatter) this.eventFSHighlightOff.Start();
                    else this.eventWildFSHighlightOff.Start();
                    break;
                case VS_Symbol.State.Invalid:
                default:
                    this.canProcessNextCommand = true;
                    break
            }
            this.internalState = newState;
            this.currentStateForInspector = this.internalState
        } else if (this.stopEventSent == false) this.StopAllRunningEvents()
};
VS_SymbolScatterWild.prototype.StopAllRunningEvents = function() {
    VS_Symbol.prototype.StopAllRunningEvents.call(this);
    if (this.eventWildNormal.IsRunning()) this.eventWildNormal.Stop();
    if (this.eventWildSpinStart.IsRunning()) this.eventWildSpinStart.Stop();
    if (this.eventWildSpinLoop.IsRunning()) this.eventWildSpinLoop.Stop();
    if (this.eventWildSpinStop.IsRunning()) this.eventWildSpinStop.Stop();
    if (this.eventWildHighlightOff.IsRunning()) this.eventWildHighlightOff.Stop();
    if (this.eventWildHighlightOn.IsRunning()) this.eventWildHighlightOn.Stop();
    if (this.eventWildExcited.IsRunning()) this.eventWildExcited.Stop();
    if (this.eventWildWinExcited.IsRunning()) this.eventWildWinExcited.Stop();
    if (this.eventWildWinning.IsRunning()) this.eventWildWinning.Stop();
    if (this.eventSetAsScatter.IsRunning()) this.eventSetAsScatter.Stop();
    if (this.eventSetAsWild.IsRunning()) this.eventSetAsWild.Stop();
    if (this.eventWildSpinLoopExcited.IsRunning()) this.eventWildSpinLoopExcited.Stop();
    if (this.eventWildFSHighlightOff.IsRunning()) this.eventWildFSHighlightOff.Stop()
};
VS_SymbolScatterWild.prototype.SetAsWild = function() {
    this.eventSetAsWild.Start();
    this.isScatter = false
};
VS_SymbolScatterWild.prototype.SetAsScatter = function() {
    this.eventSetAsScatter.Start();
    this.isScatter = true
};
VS_SymbolScatterWild.prototype.IsScatter = function() {
    return this.isScatter
};
VS_SymbolScatterWild.prototype.ResetToScatter = function() {
    this.eventResetToScatter.Start();
    this.isScatter = true
};
goog.require("UHT.VS_ReelsManager");
goog.provide("UHT.ResultDisplayer");
var ResultDisplayerVars = {
    ResultDisplayerObject: "ResultDisplayerObject",
    ResultDisplayer_DoExtraLoop: "ResultDisplayer_DoExtraLoop",
    ResultDisplayer_SkipDelayBeforeEndOfDisplayLoop: "ResultDisplayer_SkipDelayBeforeEndOfDisplayLoop"
};
ResultDisplayer.prototype = Object.create(XTLink.prototype);
ResultDisplayer.prototype.constructor = ResultDisplayer;

function ResultDisplayer() {
    XTLink.call(this);
    ResultDisplayer.PlaySpinEndedBigWinSound = {
        whenEnteringResult: 0,
        whenExpandingIsDone: 1,
        whenLinesWillShow: 2
    };
    this.rq = null;
    this.showAllLinesVisual = true;
    this.showEachLineVisual = true;
    this.showSymbolSquaresOnLineVisual = false;
    this.expandSymbolsOneByOne = true;
    this.singleLineShowDuration = .5;
    this.allLinesShowDuration = 1;
    this.scatterDuration = .5;
    this.bonusDuration = .5;
    this.transitionDuration = .1;
    this.noWinDisplayDuration = .5;
    this.scatterWildChangeDuration = .2;
    this.wildBecomesScatterWhenScatterPays =
        false;
    this.mysteryScatterDuration = .5;
    this.applyDelayOnSymbols = false;
    this.delayIsAppliedPerReel = false;
    this.singleLineSymbolDelay = .2;
    this.allLinesSymbolDelay = .15;
    this.singleLineLastSymbolDelay = 1;
    this.allLinesLastSymbolDelay = 1;
    this.numberOfReels = 5;
    this.expandingSymbolDuration = 1;
    this.bigWinWaitsAllLinesLoops = 0;
    this.playSpinEndedBWCondition = 0;
    this.eachLine_WldOverridesDominatingSymbolWinSound = false;
    this.allLines_WildOverridesDominatingSymbolWinSound = false;
    this.allLines_PlaySymbolWinSoundOnlyOnce = false;
    this.resetSymbolsVisualState = VS_Symbol.State.Normal;
    this.showFSWonBeforeResult = false;
    this.showFSWonBeforeResultDuration = 2;
    this.showBonusWonBeforeResult = false;
    this.showBonusWonBeforeResultDuration = 2;
    this.treatMoneySymbolsAsBonusSymbols = true;
    this.treatMarkedPositionsAsBonusSymbols = false;
    this.considerSymbolSubstitutes = false;
    this.symbolWinSoundPlayedOnce = false;
    this.mustStart = false;
    this.isMinimalMode = false;
    this.isStarted = false;
    this.mustAnimateScatters = false;
    this.scatterPositions = null;
    this.animateScattersLoop =
        true;
    this.mustAnimateScattersWin = false;
    this.scatterWinPositions = null;
    this.mustAnimateBonuses = false;
    this.bonusPositions = null;
    this.animateBonusesLoop = false;
    this.mustSetScattersAsWilds = false;
    this.scatterAsWildPositions = null;
    this.mysteryScatterID = [];
    this.mustAnimateMysteryScatters = false;
    this.mysteryScatterPositions = null;
    this.iMysteryScatterIDtoShow = -1;
    this.curWinLines = null;
    this.calculator = null;
    this.mustExpandSymbols = false;
    this.expandingSymbolsData = null;
    this.upSymbols = null;
    this.curOrderedHoldersList = null;
    this.resultTime = 3;
    ResultDisplayer.ScatterWildState = {
        SCATTER: 0,
        WILD: 1
    };
    this.currentScatterWildState = ResultDisplayer.ScatterWildState.SCATTER;
    this.scattersWildConvertedThisSpin = false;
    this.useScatterWildStates = false
}
ResultDisplayer.isJackpotWin = false;
ResultDisplayer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_Prepare, this.OnPrepare, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop, this.OnDoLoop, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup, this.OnDoCleanup, this)
};
ResultDisplayer.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.RQManagerObject, this.rq);
    XT.SetBool(Vars.CanSpinAfterResultMinimumTime, false);
    XT.SetBool(Vars.ShowSymbolSquaresOnLineVisual, this.showSymbolSquaresOnLineVisual);
    XT.SetBool(ResultDisplayerVars.ResultDisplayer_DoExtraLoop, false);
    XT.SetBool(ResultDisplayerVars.ResultDisplayer_SkipDelayBeforeEndOfDisplayLoop, false);
    XT.SetObject(ResultDisplayerVars.ResultDisplayerObject, this);
    XT.SetBool(Vars.ResultDisplayer_CanAnimateScatters,
        true);
    XT.SetBool(Vars.ResultDisplayer_CanAnimateBonuses, true);
    XT.SetBool(Vars.ForceResultMinimalMode, false);
    XT.SetDouble(Vars.CurrentDisplayedWinLineWin, 0)
};
ResultDisplayer.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnPrepare, this);
    XT.UnregisterCallbackEvent(this.OnDoLoop, this);
    XT.UnregisterCallbackEvent(this.OnDoCleanup, this)
};
ResultDisplayer.prototype.Update = function() {
    if (this.mustStart) {
        this.mustStart = false;
        this.rq.StopRoutines();
        if (this.playSpinEndedBWCondition == ResultDisplayer.PlaySpinEndedBigWinSound.whenEnteringResult && XT.GetBool(Vars.SpinResultIsBigWin)) this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_PlaySpinEndedBWSound));
        XT.TriggerEvent(Vars.Evt_Internal_InjectRQIOnResultDisplayerLoopStarts);
        if (XT.GetBool(Vars.FromServer_IsJackpotWin) && XT.GetBool(Vars.MustShowJackpotWon)) {
            ResultDisplayer.isJackpotWin =
                true;
            XT.SetBool(Vars.MustShowJackpotWon, false);
            XT.TriggerEvent(Vars.Evt_Internal_InjectRQIForMysteryJackpotWin)
        }
        if (XT.GetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion)) {
            this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_UpdateDisplayedWin));
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SignalTheUserCanSpin, true, this));
            this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.noWinDisplayDuration))
        } else {
            XT.TriggerEvent(Vars.Evt_Internal_InjectRQIAfterBonusAnimate);
            if (this.mustAnimateScatters && this.showFSWonBeforeResult && !XT.GetBool(Vars.WinLimitReached)) {
                if (!this.animateScattersLoop) this.mustAnimateScatters = false;
                if (XT.GetBool(Vars.ScatterSymbolIsWild) && this.mustSetScattersAsWilds)
                    if (!this.useScatterWildStates || this.currentScatterWildState == ResultDisplayer.ScatterWildState.WILD) {
                        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnSetScatterWildAsScatter, this.scatterPositions, this));
                        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.scatterWildChangeDuration));
                        if (this.useScatterWildStates) this.currentScatterWildState = ResultDisplayer.ScatterWildState.SCATTER
                    }
                if (this.mustAnimateScattersWin) this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowScattersWin));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnAnimateListOfSymbols, this.scatterPositions, this));
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowFSWonBeforeResult));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.showFSWonBeforeResultDuration));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation, null, this));
                if (this.mustAnimateScattersWin) this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideScattersWin))
            }
            if (this.mustAnimateBonuses && this.showBonusWonBeforeResult) {
                if (!this.animateBonusesLoop) this.mustAnimateBonuses = false;
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnAnimateListOfSymbols, this.bonusPositions, this));
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowBonusWonBeforeResult));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.showBonusWonBeforeResultDuration));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation, null, this))
            }
            if (this.mustExpandSymbols) {
                for (var xdIndex = 0; xdIndex < this.expandingSymbolsData.length; xdIndex++) {
                    this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnShowExpandingSymbol, this.expandingSymbolsData[xdIndex].ExpandingSymbolId, this));
                    if (this.expandSymbolsOneByOne) this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.expandingSymbolDuration))
                }
                if (!this.expandSymbolsOneByOne &&
                    XT.GetBool(Vars.ExpandableDelayNeededAtTheEnd)) this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.expandingSymbolDuration));
                this.mustExpandSymbols = false
            }
            if (this.playSpinEndedBWCondition == ResultDisplayer.PlaySpinEndedBigWinSound.whenExpandingIsDone && XT.GetBool(Vars.SpinResultIsBigWin)) this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_PlaySpinEndedBWSound));
            if (!XT.GetBool(Vars.SpinResultIsBigWin) || this.bigWinWaitsAllLinesLoops == 0) {
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_UpdateDisplayedWin));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SignalTheUserCanSpin, true, this));
                XT.TriggerEvent(Vars.Evt_Internal_InjectRQIBeforeLinesShow);
                if (this.playSpinEndedBWCondition == ResultDisplayer.PlaySpinEndedBigWinSound.whenLinesWillShow && XT.GetBool(Vars.SpinResultIsBigWin)) this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_PlaySpinEndedBWSound));
                if (this.curWinLines.length > 0) this.QueueDisplayAllLines();
                this.QueueDisplayJackpot();
                this.QueueDisplayPayingSymbols()
            }
            if (this.bigWinWaitsAllLinesLoops >
                0 && XT.GetBool(Vars.SpinResultIsBigWin)) {
                XT.TriggerEvent(Vars.Evt_Internal_InjectRQIBeforeLinesShow);
                if (this.playSpinEndedBWCondition == ResultDisplayer.PlaySpinEndedBigWinSound.whenLinesWillShow && XT.GetBool(Vars.SpinResultIsBigWin)) this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_PlaySpinEndedBWSound));
                for (var i = 0; i < this.bigWinWaitsAllLinesLoops; i++)
                    if (this.curWinLines.length > 0) this.QueueDisplayAllLines();
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_UpdateDisplayedWin));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SignalTheUserCanSpin, true, this))
            }
            var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
            var forceLBL = false;
            if (XT.GetBool(Vars.Jurisdiction_LineByLineFreespin))
                if (fsr.IsFreeSpin && !fsr.IsFreeSpinsStart) forceLBL = true;
            if (XT.GetBool(Vars.Jurisdiction_LineByLineGlobal)) forceLBL = true;
            if (!(this.isMinimalMode || XT.GetBool(Vars.ForceResultMinimalMode)) || forceLBL) {
                this.rq.AddRoutineQueueItem(new RQIMarker(RQIMarker.MarkerType.StartLineByLine));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.transitionDuration));
                if (this.curWinLines.length > 1 || XT.GetBool(InterfaceVars.ShowExplicitResult)) this.QueueDisplayLinesOneByOne();
                this.rq.AddRoutineQueueItem(new RQIMarker(RQIMarker.MarkerType.EndLineByLine));
                for (var i = 0; i < this.curWinLines.length; i++) {
                    this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideLine, this.curWinLines[i].LineNumber, this));
                    this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideLineWin, i, this))
                }
            }
            XT.TriggerEvent(Vars.Evt_Internal_InjectRQIAfterLinesShow);
            if (this.mustAnimateScattersWin) {
                if (XT.GetBool(Vars.ScatterSymbolIsWild) &&
                    this.wildBecomesScatterWhenScatterPays && this.mustSetScattersAsWilds)
                    if (!this.useScatterWildStates || this.currentScatterWildState == ResultDisplayer.ScatterWildState.WILD) {
                        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnSetScatterWildAsScatter, this.scatterAsWildPositions, this));
                        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.scatterWildChangeDuration));
                        if (this.useScatterWildStates) this.currentScatterWildState = ResultDisplayer.ScatterWildState.SCATTER
                    }
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowScattersWin));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation, null, this));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnAnimateListOfSymbols, this.scatterWinPositions, this));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SymbolWinPlaySound, 1, this));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.scatterDuration));
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideScattersWin))
            }
            if (this.mustAnimateScatters && !this.showFSWonBeforeResult) {
                if (!this.animateScattersLoop) this.mustAnimateScatters =
                    false;
                if (XT.GetBool(Vars.ScatterSymbolIsWild) && this.mustSetScattersAsWilds)
                    if (!this.useScatterWildStates || this.currentScatterWildState == ResultDisplayer.ScatterWildState.WILD) {
                        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnSetScatterWildAsScatter, this.scatterPositions, this));
                        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.scatterWildChangeDuration));
                        if (this.useScatterWildStates) this.currentScatterWildState = ResultDisplayer.ScatterWildState.SCATTER
                    }
                if (this.mustAnimateScattersWin) this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowScattersWin));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnAnimateListOfSymbols, this.scatterPositions, this));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SymbolWinPlaySound, 1, this));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.scatterDuration));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation, null, this));
                if (this.mustAnimateScattersWin) this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideScattersWin))
            }
            if (XT.GetObject(Vars.ReceivedFreeSpinsResponse).IsFreeSpin &&
                this.mustAnimateMysteryScatters) {
                this.mustAnimateMysteryScatters = false;
                for (var i = 0; i < this.mysteryScatterPositions.length; i++)
                    if (this.mysteryScatterPositions[i].length > 0) {
                        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnSetMysteryScatterIDtoShow, this.mysteryScatterID[i], this));
                        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnSetMysteryScatters, this.mysteryScatterPositions[i], this));
                        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowMysteryScatterWin));
                        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnAnimateListOfSymbols,
                            this.mysteryScatterPositions[i], this));
                        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.mysteryScatterDuration));
                        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideMysteryScatterWin))
                    }
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation, null, this))
            }
            if (this.mustAnimateBonuses && !this.showBonusWonBeforeResult) {
                if (!this.animateBonusesLoop) this.mustAnimateBonuses = false;
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnAnimateListOfSymbols,
                    this.bonusPositions, this));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SymbolWinPlaySound, 0, this));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.bonusDuration));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation, null, this))
            }
            if (XT.GetBool(Vars.TruncateFSResponseDuringRespin)) {
                var truncated_fsr = XT.GetObject(Vars.TruncatedFreeSpinsResponse);
                var normal_fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
                if (truncated_fsr.IsFreeSpin && !normal_fsr.IsFreeSpin) this.mustAnimateScatters =
                    false
            }
            if (this.HasWorkToDo() == false && !XT.GetBool(ResultDisplayerVars.ResultDisplayer_SkipDelayBeforeEndOfDisplayLoop)) this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.noWinDisplayDuration));
            XT.TriggerEvent(Vars.Evt_Internal_InjectRQIBeforeEndOfDisplayLoop)
        }
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnDisplayLoopEnded, null, this));
        this.rq.StartRoutines()
    }
    this.resultTime += Time.deltaTime;
    if (XT.GetBool(Vars.CanSpinAfterResultMinimumTime)) {
        XT.SetBool(Vars.CanSpinAfterResultMinimumTime,
            false);
        this.SignalTheUserCanSpin(true)
    }
};
ResultDisplayer.prototype.InternalSetCurWinLines = function(_newWinLines) {
    this.curWinLines = _newWinLines
};
ResultDisplayer.prototype.InternalSetWinLinesMinimalMode = function(_bSet) {
    this.isMinimalMode = _bSet
};
ResultDisplayer.prototype.OnPrepare = function() {
    this.curWinLines = XT.GetObject(Vars.ReceivedWinLines);
    this.isMinimalMode = XT.GetBool(Vars.ResultDisplayerMinimalMode);
    this.curOrderedHoldersList = XT.GetObject(Vars.OrderedSymbolHoldersList);
    this.calculator = XT.GetObject(Vars.SpinExciterObject);
    this.upSymbols = XT.GetObject(Vars.UpSymbols_RandomWilds);
    this.ComputeScatters();
    this.ComputeBonuses();
    if (XT.GetBool(Vars.ScatterSymbolIsWild)) this.ComputeScattersSetAsWilds();
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr.IsFreeSpin && !fsr.IsFreeSpinsStart && XT.GetDouble(Vars.MysteryScatterWinDisplayed) > 0) this.ComputeMysteryScatters();
    for (var i = 0; i < this.curOrderedHoldersList.length; i++)
        if (this.HasWorkToDo() && !XT.GetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion)) this.curOrderedHoldersList[i].currentSymbol.SetHighlightOff();
        else this.curOrderedHoldersList[i].currentSymbol.SetNormal();
    this.expandingSymbolsData = XT.GetObject(Vars.ExpandingSymbolsData);
    this.mustExpandSymbols = this.expandingSymbolsData !=
        null;
    console.log("ResultDisplayer - started (winlines: " + this.curWinLines.length + ", this.mustAnimateScatters = " + String(this.mustAnimateScatters) + ", this.mustAnimateBonuses = " + String(this.mustAnimateBonuses) + ")");
    this.isStarted = true;
    if (XT.GetObject(Vars.FromStageName) != UHTStageName.Init) this.resultTime = 0;
    if (this.useScatterWildStates) {
        this.currentScatterWildState = ResultDisplayer.ScatterWildState.SCATTER;
        this.scattersWildConvertedThisSpin = false
    }
};
ResultDisplayer.prototype.OnDoLoop = function() {
    if (this.isStarted) this.mustStart = true
};
ResultDisplayer.prototype.OnDoCleanup = function() {
    if (this.isStarted) {
        this.isStarted = false;
        this.mustStart = false;
        this.rq.StopRoutines();
        for (var i = 0; i < this.curWinLines.length; i++) {
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideLine, this.curWinLines[i].LineNumber, this));
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideLineWin, i, this))
        }
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideAllLinesWin));
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideScattersWin));
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnResetAllSymbolsVisual, null, this));
        this.rq.StartRoutines()
    }
    this.symbolWinSoundPlayedOnce = false;
    ResultDisplayer.isJackpotWin = false
};
ResultDisplayer.prototype.QueueDisplayAllLines = function() {
    if (XT.GetBool(Vars.ScatterSymbolIsWild) && this.mustSetScattersAsWilds)
        if (!this.useScatterWildStates || this.currentScatterWildState == ResultDisplayer.ScatterWildState.SCATTER && !this.scattersWildConvertedThisSpin) {
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnSetScatterWildAsWild, this.scatterAsWildPositions, this));
            this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.scatterWildChangeDuration));
            if (this.useScatterWildStates) {
                this.currentScatterWildState =
                    ResultDisplayer.ScatterWildState.WILD;
                this.scattersWildConvertedThisSpin = true
            }
        }
    if (XT.GetDouble(Vars.TotalLinesWinReceived) > 0) this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowAllLinesWin));
    if (this.showAllLinesVisual)
        for (var i = 0; i < this.curWinLines.length; i++) {
            var id = this.curWinLines[i].LineNumber;
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnShowLine, id, this))
        }
    var mustPlaySymbolsWinSound = true;
    if (!(this.symbolWinSoundPlayedOnce && this.allLines_PlaySymbolWinSoundOnlyOnce))
        for (var i =
                0; i < this.curWinLines.length; i++)
            if (this.allLines_WildOverridesDominatingSymbolWinSound && this.calculator.BetLinesFromServer(this.curWinLines[i].LineNumber).containsWild) {
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SymbolWinPlaySound, 2, this));
                this.symbolWinSoundPlayedOnce = true;
                mustPlaySymbolsWinSound = false;
                break
            }
    if (mustPlaySymbolsWinSound) this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SymbolWinPlaySound, -1, this));
    if (this.applyDelayOnSymbols) this.QueueAllLinesDelayed(null);
    else {
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnShowAllSymbolAnimation,
            null, this));
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_InjectRQIWhileShowingAllLines));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.allLinesShowDuration))
    }
    if (this.showAllLinesVisual)
        for (var i = 0; i < this.curWinLines.length; i++) {
            var id = this.curWinLines[i].LineNumber;
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideLine, id, this))
        }
    this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation, null, this));
    if (XT.GetDouble(Vars.TotalLinesWinReceived) >
        0) this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideAllLinesWin));
    this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.transitionDuration))
};
ResultDisplayer.prototype.QueueDisplayLinesOneByOne = function() {
    for (var i = 0; i < this.curWinLines.length; i++) {
        var id = this.curWinLines[i].LineNumber;
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnShowLineWin, i, this));
        if (this.showEachLineVisual) this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnShowLine, id, this));
        if (this.eachLine_WldOverridesDominatingSymbolWinSound && this.calculator.BetLinesFromServer(id).containsWild) this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SymbolWinPlaySound,
            2, this));
        else this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SymbolWinPlaySound, this.calculator.BetLinesFromServer(id).dominatingSymbol, this));
        if (this.applyDelayOnSymbols) this.QueueSingleLineDelayed(id);
        else {
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnShowSymbolAnimation, this.curWinLines[i].WinPositions, this));
            this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.singleLineShowDuration))
        }
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideLine, id, this));
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation,
            id, this));
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideLineWin, i, this));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.transitionDuration))
    }
};
ResultDisplayer.prototype.QueueSingleLineDelayed = function(lineId) {
    var isWinning = _array.create(this.curOrderedHoldersList.length, false);
    for (var i = 0; i < this.curWinLines.length; i++)
        if (this.curWinLines[i].LineNumber == lineId) {
            var winPositions = this.curWinLines[i].WinPositions;
            for (var j = 0; j < winPositions.length; ++j) isWinning[winPositions[j]] = true
        }
    for (var i = 0; i < this.numberOfReels; i++) {
        var j = i;
        while (j < this.curOrderedHoldersList.length) {
            if (isWinning[j]) {
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.HighlightSymbol,
                    j, this));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.singleLineSymbolDelay))
            } else this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.UnHighlightSymbol, j, this));
            j = j + this.numberOfReels
        }
    }
    this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.singleLineLastSymbolDelay - this.singleLineSymbolDelay))
};
ResultDisplayer.prototype.QueueAllLinesDelayed = function(unused) {
    var isWinning = _array.create(this.curOrderedHoldersList.length, false);
    for (var i = 0; i < this.curWinLines.length; i++) {
        var winPositions = this.curWinLines[i].WinPositions;
        for (var j = 0; j < winPositions.length; j++) isWinning[winPositions[j]] = true
    }
    for (var i = 0; i < this.numberOfReels; i++) {
        var j = i;
        while (j < this.curOrderedHoldersList.length) {
            if (isWinning[j]) {
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.HighlightSymbol, j, this));
                if (!this.delayIsAppliedPerReel) this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.allLinesSymbolDelay))
            } else this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.UnHighlightSymbol,
                j, this));
            j = j + this.numberOfReels
        }
        if (this.delayIsAppliedPerReel) this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.allLinesSymbolDelay))
    }
    this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.allLinesLastSymbolDelay - this.allLinesSymbolDelay))
};
ResultDisplayer.prototype.HighlightSymbol = function(id) {
    this.curOrderedHoldersList[id].currentSymbol.SetHighlightOn()
};
ResultDisplayer.prototype.UnHighlightSymbol = function(id) {
    this.curOrderedHoldersList[id].currentSymbol.SetHighlightOff()
};
ResultDisplayer.prototype.OnDisplayLoopEnded = function(unused) {
    XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_LoopDone)
};
ResultDisplayer.prototype.OnShowExpandingSymbol = function(param) {
    XT.SetInt(Vars.CurrentAnimatingExpandingSymbolID, _number.otoi(param));
    XT.TriggerEvent(Vars.Evt_Internal_ShowExpandingSymbol)
};
ResultDisplayer.prototype.OnShowLineWin = function(param) {
    XT.SetInt(Vars.CurrentDisplayedWinLineIndex, param);
    XT.TriggerEvent(Vars.Evt_Internal_UpdateCurrentDisplayedWinLineIndex);
    if (XT.GetDouble(Vars.CurrentDisplayedWinLineWin) > 0) XT.TriggerEvent(Vars.Evt_Internal_StartDisplayWinLine)
};
ResultDisplayer.prototype.OnHideLineWin = function(param) {
    if (XT.GetDouble(Vars.CurrentDisplayedWinLineWin) > 0) XT.TriggerEvent(Vars.Evt_Internal_StopDisplayWinLine)
};
ResultDisplayer.prototype.OnShowLine = function(param) {
    XT.SetInt(Vars.CurrentDisplayedWinLineId, param);
    XT.TriggerEvent(Vars.Evt_Internal_ShowWinLine)
};
ResultDisplayer.prototype.OnHideLine = function(param) {
    XT.SetInt(Vars.CurrentDisplayedWinLineId, param);
    XT.TriggerEvent(Vars.Evt_Internal_HideWinLine)
};
ResultDisplayer.prototype.OnShowAllSymbolAnimation = function(unused) {
    var isWinning = _array.create(this.curOrderedHoldersList.length, false);
    for (var i = 0; i < this.curWinLines.length; i++) {
        var winPositions = this.curWinLines[i].WinPositions;
        for (var j = 0; j < winPositions.length; j++) isWinning[winPositions[j]] = true
    }
    for (var i = 0; i < this.curOrderedHoldersList.length; i++)
        if (isWinning[i]) this.curOrderedHoldersList[i].currentSymbol.SetHighlightOn();
        else this.curOrderedHoldersList[i].currentSymbol.SetHighlightOff()
};
ResultDisplayer.prototype.OnHideAllSymbolAnimation = function(unused) {
    for (var i = 0; i < this.curOrderedHoldersList.length; i++) this.curOrderedHoldersList[i].currentSymbol.SetHighlightOff()
};
ResultDisplayer.prototype.OnResetAllSymbolsVisual = function(unused) {
    for (var i = 0; i < this.curOrderedHoldersList.length; i++) {
        if (XT.GetBool(Vars.ScatterSymbolIsWild) && this.curOrderedHoldersList[i].currentSymbol.symbolId == 1)
            if (!this.useScatterWildStates) this.curOrderedHoldersList[i].currentSymbol.SetAsScatter();
        if (this.resetSymbolsVisualState == VS_Symbol.State.Normal) this.curOrderedHoldersList[i].currentSymbol.SetNormal();
        else this.curOrderedHoldersList[i].currentSymbol.ChangeToState(this.resetSymbolsVisualState)
    }
};
ResultDisplayer.prototype.OnShowSymbolAnimation = function(linePositions) {
    for (var i = 0; i < this.curOrderedHoldersList.length; i++)
        if (linePositions.indexOf(i) != -1) this.curOrderedHoldersList[i].currentSymbol.SetHighlightOn();
        else this.curOrderedHoldersList[i].currentSymbol.SetHighlightOff()
};
ResultDisplayer.prototype.OnAnimateListOfSymbols = function(list) {
    for (var i = 0; i < list.length; i++) this.curOrderedHoldersList[list[i]].currentSymbol.SetHighlightOn()
};
ResultDisplayer.prototype.SymbolWinPlaySound = function(param) {
    var winSymbolID = param;
    XT.SetInt(Vars.ResultSymbolWinID, winSymbolID);
    XT.TriggerEvent(Vars.Evt_Internal_ResultSymbolWinPlaySound)
};
ResultDisplayer.prototype.FindSymbolsWithID = function(id) {
    var ret = [];
    for (var i = 0; i < this.curOrderedHoldersList.length; i++)
        if (this.considerSymbolSubstitutes) {
            if (this.calculator.IsSameID(id, this.curOrderedHoldersList[i].currentSymbol.symbolId)) ret.push(i)
        } else if (this.curOrderedHoldersList[i].currentSymbol.symbolId == id) ret.push(i);
    return ret
};
ResultDisplayer.prototype.FindInitialSymbolsWithID = function(id) {
    var ret = [];
    var initialResultSymbols = XT.GetObject(Vars.InitialResultScreenSymbols);
    for (var i = 0; i < initialResultSymbols.length; i++)
        for (var j = 0; j < initialResultSymbols[i].length; j++)
            if (this.considerSymbolSubstitutes) {
                if (this.calculator.IsSameID(id, initialResultSymbols[i][j])) ret.push(i + (initialResultSymbols[i].length - 1 - j) * initialResultSymbols.length)
            } else if (id == initialResultSymbols[i][j]) ret.push(i + (initialResultSymbols[i].length - 1 - j) * initialResultSymbols.length);
    return ret
};
ResultDisplayer.prototype.ComputeScatters = function() {
    var list = this.upSymbols != null ? this.FindInitialSymbolsWithID(1) : this.FindSymbolsWithID(1);
    var scatters = this.calculator.GetScattersThatNeedToBeAnimated();
    this.scatterPositions = [];
    for (var i = 0; i < list.length; i++)
        if (scatters[list[i]]) this.scatterPositions.push(list[i]);
    this.mustAnimateScatters = this.scatterPositions.length > 0;
    if (this.mustAnimateScatters) this.isMinimalMode = true;
    this.scatterWinPositions = null;
    this.mustAnimateScattersWin = false;
    switch (this.calculator.ScatterPaysMoney) {
        case ScatterSymbolPayType.Everywhere:
            this.scatterWinPositions =
                this.upSymbols != null ? this.FindInitialSymbolsWithID(1) : this.FindSymbolsWithID(1);
            var scatterWin = XT.GetDouble(Vars.WinReceived) - XT.GetDouble(Vars.TotalLinesWinReceived);
            this.mustAnimateScattersWin = this.scatterWinPositions.length >= this.calculator.ScatterPaysMoneyMinCombo && scatterWin > 0;
            break;
        case ScatterSymbolPayType.OnActivePayline:
            console.warn("scatter pays on active payline...");
            break;
        case ScatterSymbolPayType.OnActivePaylineLeftToRight:
            console.warn("scatter pays on active payline from left to right...");
            break;
        case ScatterSymbolPayType.OnAdjacentReelsBothWays:
            this.scatterWinPositions = this.FindSymbolsWithID(1);
            var positions = [];
            var iR = 0;
            var j = 0;
            for (iR = 0; iR < this.numberOfReels; iR++)
                if (this.calculator.SymbolAppearencesOnReel(1, iR) == 0) break;
            if (iR >= this.calculator.ScatterPaysMoneyMinCombo) {
                for (j = 0; j < this.scatterWinPositions.length; j++)
                    if (this.curOrderedHoldersList[this.scatterWinPositions[j]].parentReel.reelIndex < iR) positions.push(this.scatterWinPositions[j]);
                this.mustAnimateScattersWin = true
            }
            for (iR = 0; iR <
                this.numberOfReels; iR++)
                if (this.calculator.SymbolAppearencesOnReel(1, this.numberOfReels - iR - 1) == 0) break;
            if (iR >= this.calculator.ScatterPaysMoneyMinCombo) {
                for (j = 0; j < this.scatterWinPositions.length; j++)
                    if (this.curOrderedHoldersList[this.scatterWinPositions[j]].parentReel.reelIndex > this.numberOfReels - iR - 1) positions.push(this.scatterWinPositions[j]);
                this.mustAnimateScattersWin = true
            }
            this.scatterWinPositions = positions;
            break;
        default:
            break
    }
    var payingSymbolsScatterIdx = XT.GetInt(PayingSymbolVars.PayingSymbolsScatterIndex);
    if (payingSymbolsScatterIdx > -1) {
        this.mustAnimateScattersWin = true;
        this.scatterWinPositions = XT.GetObject(PayingSymbolVars.PayingSymbols)[payingSymbolsScatterIdx].positions
    }
    if (!XT.GetBool(Vars.ResultDisplayer_CanAnimateScatters)) {
        this.mustAnimateScatters = false;
        this.mustAnimateScattersWin = false
    }
};
ResultDisplayer.prototype.ComputeBonuses = function() {
    var list = this.FindSymbolsWithID(0);
    var bonuses = this.calculator.GetBonusesThatNeedToBeAnimated();
    this.bonusPositions = [];
    for (var i = 0; i < list.length; i++)
        if (bonuses[list[i]]) this.bonusPositions.push(list[i]);
    if (this.bonusPositions.length == 0) {
        var msData = XT.GetObject(Vars.MoneySymbolData);
        var j;
        if (this.treatMoneySymbolsAsBonusSymbols && msData != null && msData.currentValues != null)
            for (j = 0; j < msData.currentValues.length; j++) {
                if (msData.currentValues[j] > 0) this.bonusPositions.push(j)
            } else {
                var markedPositions =
                    XT.GetObject(Vars.MarkedSymbolPositions);
                if (this.treatMarkedPositionsAsBonusSymbols && markedPositions != null)
                    for (j = 0; j < markedPositions.length; j++) this.bonusPositions.push(markedPositions[j])
            }
    }
    var bonusFlag = XT.GetBool(Vars.MustOpenBonus);
    this.mustAnimateBonuses = this.bonusPositions.length > 0 && bonusFlag;
    if (!XT.GetBool(Vars.ResultDisplayer_CanAnimateBonuses)) this.mustAnimateBonuses = false
};
ResultDisplayer.prototype.ComputeScattersSetAsWilds = function() {
    var isWinning = _array.create(this.curOrderedHoldersList.length, false);
    this.scatterAsWildPositions = [];
    for (var i = 0; i < this.curWinLines.length; i++) {
        var winPositions = this.curWinLines[i].WinPositions;
        for (var j = 0; j < winPositions.length; ++j) isWinning[winPositions[j]] = true
    }
    for (var i = 0; i < this.curOrderedHoldersList.length; i++)
        if (isWinning[i] && this.curOrderedHoldersList[i].currentSymbol.symbolId == 1) this.scatterAsWildPositions.push(i);
    this.mustSetScattersAsWilds =
        this.scatterAsWildPositions.length > 0
};
ResultDisplayer.prototype.OnSetScatterWildAsScatter = function(list) {
    for (var i = 0; i < list.length; i++) this.curOrderedHoldersList[list[i]].currentSymbol.SetAsScatter()
};
ResultDisplayer.prototype.OnSetScatterWildAsWild = function(list) {
    for (var i = 0; i < list.length; i++) this.curOrderedHoldersList[list[i]].currentSymbol.SetAsWild()
};
ResultDisplayer.prototype.HasWorkToDo = function() {
    return this.curWinLines.length > 0 || (this.mustAnimateScatters || XT.GetObject(Vars.ReceivedFreeSpinsResponse).IsFreeSpin && this.mustAnimateMysteryScatters) || this.mustAnimateBonuses || this.mustAnimateScattersWin
};
ResultDisplayer.prototype.SignalTheUserCanSpin = function(param) {
    var canSpin = param;
    if (canSpin) {
        var applyResultMinimumTime = XT.GetBool(Vars.Jurisdiction_ResultMinimumTime) || XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins);
        if (XT.GetBool(Vars.ContinuousSpin) && XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeTurbo)) applyResultMinimumTime = true;
        if (applyResultMinimumTime && !XT.GetObject(Vars.ReceivedFreeSpinsResponse).IsFreeSpin) {
            var resultMinimumTime = 0;
            if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTime)) resultMinimumTime =
                XT.GetFloat(Vars.Jurisdiction_ResultMinimumTime_Value);
            if (XT.GetBool(Vars.ContinuousSpin) && XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeTurbo)) resultMinimumTime = XT.GetFloat(Vars.Jurisdiction_ResultMinimumTimeTurbo_Value);
            if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins))
                if (XT.GetFloat(Vars.SpinDuration) < XT.GetFloat(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins_Value)) resultMinimumTime = this.resultTime + 1;
            if (this.resultTime < resultMinimumTime) {
                canSpin = false;
                XT.SetBool(Vars.CanSpinAfterResultMinimumTime,
                    true)
            }
        }
    }
    if (XT.GetObject(Vars.NudgedSymbols) != null) canSpin = false;
    XT.SetBool(Vars.CanSpin, canSpin)
};
ResultDisplayer.prototype.OnSetMysteryScatterIDtoShow = function(_id) {
    this.iMysteryScatterIDtoShow = _number.otoi(_id)
};
ResultDisplayer.prototype.OnSetMysteryScatters = function(list) {
    for (var i = 0; i < list.length; ++i) this.curOrderedHoldersList[list[i]].ReplaceSymbol(this.iMysteryScatterIDtoShow);
    if (XT.GetBool(Vars.ScatterSymbolIsWild)) this.ComputeScattersSetAsWilds()
};
ResultDisplayer.prototype.ComputeMysteryScatters = function() {
    this.mysteryScatterPositions = [];
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    this.mustAnimateMysteryScatters = false;
    if (fsr.MysteryScatter.length > 0) {
        this.mysteryScatterID = fsr.MysteryScatter;
        for (var i = 0; i < this.mysteryScatterID.length; i++) {
            this.mysteryScatterPositions.push([]);
            var mysteryScatters = this.FindSymbolsWithID(this.mysteryScatterID[i]);
            if (mysteryScatters.length >= this.calculator.MysteryScatterMinCombo) {
                var reels = XT.GetObject(Vars.ReelsManagerObject).reels;
                this.mustAnimateMysteryScatters = true;
                for (var i = 0; i < mysteryScatters.length; ++i) {
                    var reelIdx = mysteryScatters[i] % reels.length;
                    for (var j = 0; j < reels[reelIdx].symbolHolders.length; ++j) this.mysteryScatterPositions[i].push(reelIdx + j * reels.length)
                }
            }
        }
    }
};
ResultDisplayer.prototype.QueueDisplayJackpot = function() {
    if (!ResultDisplayer.isJackpotWin) return;
    var allLinesWinShown = this.curWinLines.length > 0 && XT.GetDouble(Vars.TotalLinesWinReceived) > 0;
    if (!allLinesWinShown) {
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowAllLinesWin));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.singleLineShowDuration));
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideAllLinesWin));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.transitionDuration))
    }
    this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowJackpotWin));
    this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.singleLineShowDuration));
    this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideJackpotWin));
    this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.transitionDuration))
};
ResultDisplayer.prototype.QueueDisplayPayingSymbols = function() {
    var payingSymbols = XT.GetObject(PayingSymbolVars.PayingSymbols);
    if (payingSymbols.length == 0 || XT.GetBool(PayingSymbolVars.PayingSymbolIsScatter)) return;
    var allLinesWinShown = this.curWinLines.length > 0 && XT.GetDouble(Vars.TotalLinesWinReceived) > 0;
    if (!allLinesWinShown && !ResultDisplayer.isJackpotWin) {
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowAllLinesWin));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.singleLineShowDuration));
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideAllLinesWin));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.transitionDuration))
    }
    var scatterIdx = XT.GetInt(PayingSymbolVars.PayingSymbolsScatterIndex);
    for (var i = 0; i < payingSymbols.length; ++i) {
        if (i == scatterIdx) continue;
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SetCurrentDisplayedPayingSymbolIndex, i, this));
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(PayingSymbolVars.Evt_Internal_ShowPayingSymbol));
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnAnimateListOfSymbols,
            payingSymbols[i].positions, this));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.singleLineShowDuration));
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(PayingSymbolVars.Evt_Internal_HidePayingSymbol));
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation, null, this));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.transitionDuration))
    }
};
ResultDisplayer.prototype.SetCurrentDisplayedPayingSymbolIndex = function(param) {
    XT.SetInt(PayingSymbolVars.CurrentDisplayedPayingSymbolIndex, param)
};
goog.require("UHT.UHTStage");
goog.require("UHT.ResultDisplayer");
StageResult.prototype = Object.create(UHTStage.prototype);
StageResult.prototype.constructor = StageResult;

function StageResult() {
    UHTStage.call(this);
    this.cat = null;
    this.startEvent = null;
    this.bMustBehaveLikeResultFreeSpinsFRB = false;
    this.mustSpin = false;
    this.mustShowGamble = false;
    this.prepareToOpenBonus = false;
    this.mustOpenBonus = false;
    this.prepareToOpenFSBG = false;
    this.mustOpenFSBG = false;
    this.isJackpotWinOnScreen = false;
    this.isBonusRounds = false;
    this.bonusRoundsMessageWindowIsOpened = false;
    this.isRespin = false;
    this.canAutoSpinAfterResultMinimumTime = false;
    this.spinBlockersCounter = 0;
    this.autoplayRequested = false;
    this.mustStartAutoplayAfterConfirmSpinStart =
        false
}
StageResult.prototype.GetStageName = function() {
    return UHTStageName.Result
};
StageResult.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_BlockSpin, this.OnBlockSpin, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_UnblockSpin, this.OnUnblockSpin, this)
};
StageResult.prototype.XTInitVariablesAndEvents = function() {
    XT.SetInt(Vars.AutoplaySpinsLeft, -1);
    XT.SetInt(Vars.AutoplaySpinsRequested, 0);
    XT.SetInt(Vars.AutoplaySpinsLeftDisplayed, 0);
    XT.SetBool(Vars.WaitInResultForBigWin, false);
    XT.SetInt(Vars.VAWBWCounters, 0);
    XT.SetBool(Vars.LastWinIsCounting, false);
    XT.SetBool(Vars.BalanceIsCounting, false);
    XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, false);
    XT.SetBool(Vars.ForceDisableGambleSpinWin, false);
    XT.SetBool(Vars.CanUpdateBalanceDisplayed,
        true)
};
StageResult.prototype.UHTInit = function() {};
StageResult.AllowSkipMoneyCheckOnContinuousSpin = false;
StageResult.SkipMoneyCheckOnSpin = false;
StageResult.prototype.UHTUpdate = function(isFirstFrame) {
    window["RC_CheckShowWindow"]();
    if (isFirstFrame) {
        window["RC1API"]["ReinstateRC"]();
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_Spin, this.OnPressedSpin, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_Stop, this.OnPressedStop, this);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_BalanceUpdated, this.OnBalanceUpdated, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_LoopDone, this.OnResultDisplayerLoopDone, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_Gamble,
            this.OnPressedGamble, this);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_GambleOpen, this.OnMustOpenGamble, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_StartAutoplay, this.OnStartAutoplay, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_StopAutoplay, this.OnStopAutoplay, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_CollectJackpotPressed, this.OnJackpotCollected, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_BonusRoundsOnContinuePressed, this.OnBonusRoundsContinuePressed, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_BonusRoundsInfoUpdated,
            this.OnBonusRoundsInfoUpdated, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinValueChanged, this.OnCoinValueChanged, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_UpdateDisplayedWin, this.OnRequestToUpdateDisplayedWin, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_ConfirmSpinStart, this.OnConfirmStartSpin, this);
        XT.SetDouble(Vars.WinDisplayed, 0);
        XT.SetDouble(Vars.TotalLinesWinDisplayed, 0);
        XT.SetDouble(Vars.TotalScattersWinDisplayed, 0);
        XT.SetInt(Vars.Lines, XT.GetInt(Vars.TotalNumberOfLines));
        AutoplayManager.TestAdvancedStopConditions();
        if (!this.bMustBehaveLikeResultFreeSpinsFRB) {
            var brret = BonusRoundsController.HandleNextEvent(false, false, true);
            this.isBonusRounds = brret.isBonusRounds;
            this.bonusRoundsMessageWindowIsOpened = brret.messageIsOpened
        }
        var brd = XT.GetObject(Vars.BonusRoundsData);
        var respinData = XT.GetObject(Vars.RespinData);
        this.isRespin = respinData != null && !respinData.IsDone;
        if (this.bonusRoundsMessageWindowIsOpened == false) CoinManager.SetStrictBetMode(this.isBonusRounds);
        if (XT.GetBool(Vars.InstantlyCollectBonus) &&
            XT.GetBool(Vars.MustOpenBonus)) XT.TriggerEvent(Vars.Evt_ToServer_BonusGameFinished);
        this.prepareToOpenBonus = XT.GetBool(Vars.MustOpenBonus) && !XT.GetBool(Vars.InstantlyCollectBonus);
        this.prepareToOpenFSBG = XT.GetBool(Vars.FromServer_MustOpenFSBG);
        if (XT.GetInt(Vars.AutoplaySpinsLeft) > 0 || this.IsAutoRespin()) XT.SetBool(Vars.ForceDisableGambleSpinWin, true);
        this.UpdateGambleButtonState();
        var autoplaySpinsLeft = XT.GetInt(Vars.AutoplaySpinsLeft);
        var displayResultMinimal = false;
        var normalResult = true;
        if (autoplaySpinsLeft >=
            0 && !this.IsAutoRespin()) {
            autoplaySpinsLeft--;
            if (XT.GetBool(Vars.InstantAutoplay) && autoplaySpinsLeft == -1) autoplaySpinsLeft = 0;
            if (autoplaySpinsLeft == -1) displayResultMinimal = false;
            else {
                if (this.isBonusRounds) VSGameStateManager.ChangeTo(VSGameState.ResultBonusRoundsAutoplay);
                else VSGameStateManager.ChangeTo(VSGameState.ResultAutoplay);
                displayResultMinimal = true;
                normalResult = false
            }
            if (!this.prepareToOpenBonus && !this.prepareToOpenFSBG) XT.SetInt(Vars.AutoplaySpinsLeft, autoplaySpinsLeft)
        }
        if (normalResult)
            if (this.prepareToOpenBonus) VSGameStateManager.ChangeTo(VSGameState.ResultPrepareForBonus);
            else if (this.isBonusRounds && brd != null) VSGameStateManager.ChangeTo(VSGameState.ResultBonusRounds);
        else if (this.prepareToOpenFSBG) VSGameStateManager.ChangeTo(VSGameState.FSBG);
        else VSGameStateManager.ChangeTo(VSGameState.Result);
        displayResultMinimal = displayResultMinimal || this.IsAutoRespin() || this.prepareToOpenBonus || this.prepareToOpenFSBG;
        XT.SetBool(Vars.ResultDisplayerMinimalMode, displayResultMinimal);
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_Prepare);
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop);
        if (this.cat != null) this.cat.StartEvent(this.startEvent.id);
        this.canAutoSpinAfterResultMinimumTime = false;
        this.autoplayRequested = false;
        this.mustStartAutoplayAfterConfirmSpinStart = false;
        XT.TriggerEvent(TournamentPointsVars.ShowTournamentPointsNotification)
    } else {
        if (this.mustOpenBonus && !XT.GetBool(Vars.LastWinIsCounting)) {
            XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
            if (XT.GetBool(Vars.WaitInResultForBigWin) == false)
                if (XT.GetBool(BGVars.BonusDataReceived)) {
                    this.mustOpenBonus = false;
                    XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                    XT.SetBool(BGVars.BonusDataReceived, false);
                    XT.SetObject(Vars.FromStageName, this.GetStageName());
                    XT.SetObject(Vars.ToStageName, UHTStageName.Bonus);
                    window["RC1API"]["PauseRC"]();
                    return UHTAction.ChangeStage(UHTStageName.Transition)
                } else return UHTAction.NoAction()
        }
        if (this.mustOpenFSBG && !XT.GetBool(Vars.LastWinIsCounting)) {
            XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
            if (XT.GetBool(Vars.WaitInResultForBigWin) == false) {
                XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                this.mustOpenFSBG =
                    false;
                XT.SetBool(Vars.FromServer_MustOpenFSBG, false);
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.FSBG);
                return UHTAction.ChangeStage(UHTStageName.Transition)
            } else return UHTAction.NoAction()
        }
        if (!XT.GetBool(Vars.LastWinIsCounting)) XT.TriggerEvent(Vars.ShowPendingNotifications);
        if (!Globals.InputBlocked) {
            if (XT.GetBool(Vars.ContinuousSpin) && StageResult.AllowSkipMoneyCheckOnContinuousSpin) StageResult.SkipMoneyCheckOnSpin = true;
            if (Input.GetKeyDown(KeyCode.Space) ||
                Input.GetKeyDown(KeyCode.Return) || XT.GetBool(Vars.ContinuousSpin) || (Input.GetKey(KeyCode.Space) || Input.GetKey(KeyCode.Return) || XT.GetBool(Vars.ForceContinuousSpin)) && !XT.GetBool(Vars.Jurisdiction_DisableAutoplay))
                if (!ServerOptions.isReplay && this.CanSpin()) this.mustSpin = true;
            StageResult.SkipMoneyCheckOnSpin = false
        }
        if (this.mustSpin) {
            this.mustSpin = false;
            if (XT.GetBool(Vars.WaitInResultForBigWin) || XT.GetBool(Vars.SpinBlockingFeatureIsRunning)) XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
            else if (!this.IsJackpotWin()) {
                XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                XT.SetInt(Vars.AutoplaySpinsLeftDisplayed, XT.GetInt(Vars.AutoplaySpinsLeft));
                XT.SetBool(Vars.ForceDisableGambleSpinWin, true);
                this.UpdateGambleButtonState();
                XT.SetBool(Vars.ForceDisableGambleSpinWin, false);
                XT.TriggerEvent(Vars.Evt_Internal_SpinRequested);
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.Spin);
                window["RC1API"]["PauseRC"]();
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
        }
        if (this.mustShowGamble) {
            this.mustShowGamble = false;
            if (XT.GetBool(Vars.WaitInResultForBigWin)) XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
            else if (!this.IsJackpotWin()) {
                XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, true);
                XT.SetDouble(Vars.Gamble_CurrentBalance, XT.GetDouble(Vars.WinReceived));
                XT.SetBool(Vars.ForceDisableGambleSpinWin, true);
                this.UpdateGambleButtonState();
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.Gamble);
                window["RC1API"]["PauseRC"]();
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
        }
        if (this.canAutoSpinAfterResultMinimumTime &&
            XT.GetBool(Vars.CanSpin)) this.OnResultDisplayerLoopDone()
    }
    return UHTAction.NoAction()
};
StageResult.prototype.UHTFinish = function() {
    XT.UnregisterCallbackEvent(this.OnPressedSpin, this);
    XT.UnregisterCallbackEvent(this.OnPressedStop, this);
    XT.UnregisterCallbackEvent(this.OnBalanceUpdated, this);
    XT.UnregisterCallbackEvent(this.OnResultDisplayerLoopDone, this);
    XT.UnregisterCallbackEvent(this.OnPressedGamble, this);
    XT.UnregisterCallbackEvent(this.OnMustOpenGamble, this);
    XT.UnregisterCallbackEvent(this.OnStartAutoplay, this);
    XT.UnregisterCallbackEvent(this.OnStopAutoplay, this);
    XT.UnregisterCallbackEvent(this.OnJackpotCollected,
        this);
    XT.UnregisterCallbackEvent(this.OnBonusRoundsContinuePressed, this);
    XT.UnregisterCallbackEvent(this.OnBonusRoundsInfoUpdated, this);
    XT.UnregisterCallbackEvent(this.OnCoinValueChanged, this);
    XT.UnregisterCallbackEvent(this.OnRequestToUpdateDisplayedWin, this);
    XT.UnregisterCallbackEvent(this.OnConfirmStartSpin, this)
};
StageResult.prototype.OnPressedStop = function() {
    XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin)
};
StageResult.prototype.UpdateGambleButtonState = function() {
    if (XT.GetBool(Vars.FromServer_CanGambleSpinWin) && !XT.GetBool(Vars.ForceDisableGambleSpinWin)) XT.TriggerEvent(Vars.Evt_Internal_EnableGambleButton);
    else XT.TriggerEvent(Vars.Evt_Internal_DisableGambleButton)
};
StageResult.prototype.OnPressedSpin = function() {
    if (this.CanSpin()) this.mustSpin = true
};
StageResult.prototype.OnPressedGamble = function() {
    XT.TriggerEvent(Vars.Evt_ToServer_RequestGambleOpen)
};
StageResult.prototype.OnMustOpenGamble = function() {
    this.mustShowGamble = true
};
StageResult.prototype.OnBalanceUpdated = function() {
    if (XT.GetBool(Vars.BalanceDisplayedIsAnimating) == false) {
        XT.SetDouble(Vars.BalanceDisplayed, XT.GetDouble(Vars.BalanceReceived));
        XT.SetDouble(Vars.BonusBalance, XT.GetDouble(Vars.BonusBalanceReceived))
    }
};
StageResult.prototype.CanSpin = function() {
    if (this.spinBlockersCounter > 0) return false;
    if (!XT.GetBool(Vars.WaitInResultForBigWin)) {
        if (XT.GetBool(Vars.Jurisdiction_FinishCountersBeforeSpin))
            if ((XT.GetBool(Vars.LastWinIsCounting) || XT.GetBool(Vars.BalanceIsCounting)) && XT.GetInt(Vars.AutoplaySpinsLeft) < 0) {
                XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
                return false
            }
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin)
    }
    if (window["SystemMessageManager"]["IsMessageOpen"]()) return false;
    if (XT.GetBool(Vars.CanSpin) ==
        false) return false;
    if (this.bonusRoundsMessageWindowIsOpened) return false;
    if (this.prepareToOpenBonus) return false;
    if (this.prepareToOpenFSBG) return false;
    if (this.isBonusRounds) return true;
    if (this.isRespin)
        if (this.IsAutoRespin()) return false;
        else return true;
    if (!ServerOptions.isReplay)
        if (!StageResult.SkipMoneyCheckOnSpin && window["UHT_STILLCHECKMONEYONSPIN"] != undefined)
            if (CoinManager.GetNextTotalBet() > XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived) && !XT.GetBool(Vars.Logic_IsFreeSpin)) {
                XT.TriggerEvent(Vars.Evt_CodeToData_NotEnoughMoneyForSpin);
                XT.SetDouble(Vars.AlternativeWager, -1);
                UHTInterfaceBOSS.PostMessage("balanceTooLow");
                return false
            }
    XT.SetDouble(Vars.AlternativeWager, -1);
    if (XT.GetBool(Vars.SpinNeedsConfirmation)) {
        if (this.autoplayRequested) this.mustStartAutoplayAfterConfirmSpinStart = true;
        XT.TriggerEvent(Vars.Evt_CodeToData_ShowSpinConfirmationWindow);
        return false
    }
    return true
};
var BT_AUTOPLAY_FirstSent = false;
StageResult.prototype.OnStartAutoplay = function() {
    this.autoplayRequested = true;
    if (this.CanSpin() == false) {
        this.autoplayRequested = false;
        return
    }
    if (!BT_AUTOPLAY_FirstSent) {
        var timer = globalTracking.GetTimerValue("uht_behaviour", "Session_timer", "BehaviourTracker");
        globalTracking.SendEvent("uht_behaviour", "AUTOPLAY_started_once", timer, "BehaviourTracker");
        BT_AUTOPLAY_FirstSent = true
    }
    XT.SetInt(Vars.AutoplaySpinsLeft, XT.GetInt(Vars.AutoplaySpinsRequested) - 1);
    XT.SetInt(Vars.AutoplaySpinsLeftDisplayed, XT.GetInt(Vars.AutoplaySpinsLeft));
    this.mustSpin = true
};
StageResult.prototype.OnStopAutoplay = function() {
    XT.SetInt(Vars.AutoplaySpinsLeft, -1);
    XT.SetBool(Vars.ForceDisableGambleSpinWin, false);
    this.UpdateGambleButtonState();
    var brd = XT.GetObject(Vars.BonusRoundsData);
    if (this.isBonusRounds) VSGameStateManager.ChangeTo(VSGameState.ResultBonusRounds);
    else VSGameStateManager.ChangeTo(VSGameState.Result)
};
StageResult.prototype.IsJackpotWin = function() {
    if (XT.GetBool(Vars.FromServer_IsJackpotWin) && !this.isJackpotWinOnScreen)
        if (!(XT.GetBool(Vars.WaitInResultForBigWin) || XT.GetBool(Vars.LastWinIsCounting))) this.isJackpotWinOnScreen = true;
    return XT.GetBool(Vars.FromServer_IsJackpotWin)
};
StageResult.prototype.OnJackpotCollected = function() {
    if (XT.GetBool(Vars.WaitInResultForBigWin)) {
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        return
    }
    if (XT.GetBool(Vars.LastWinIsCounting)) XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    XT.SetBool(Vars.FromServer_IsJackpotWin, false);
    this.isJackpotWinOnScreen = false
};
StageResult.prototype.OnResultDisplayerLoopDone = function() {
    if (this.IsJackpotWin()) {
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop);
        return
    }
    if (this.prepareToOpenBonus) {
        this.mustOpenBonus = true;
        return
    }
    if (this.prepareToOpenFSBG) {
        this.mustOpenFSBG = true;
        return
    }
    if (this.IsAutoRespin())
        if (XT.GetBool(Vars.WaitInResultForBigWin) || XT.GetBool(Vars.LastWinIsCounting)) XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop);
        else {
            this.mustSpin = true;
            return
        }
    var autoplaySpinsLeft = XT.GetInt(Vars.AutoplaySpinsLeft);
    if (autoplaySpinsLeft >= 0)
        if (XT.GetBool(Vars.WaitInResultForBigWin) || XT.GetBool(Vars.LastWinIsCounting)) XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop);
        else if (this.CanSpin()) this.mustSpin = true;
    else {
        this.canAutoSpinAfterResultMinimumTime = XT.GetBool(Vars.CanSpinAfterResultMinimumTime);
        if (!this.canAutoSpinAfterResultMinimumTime) {
            XT.SetInt(Vars.AutoplaySpinsLeft, -1);
            var brd = XT.GetObject(Vars.BonusRoundsData);
            if (this.isBonusRounds) VSGameStateManager.ChangeTo(VSGameState.ResultBonusRounds);
            else VSGameStateManager.ChangeTo(VSGameState.Result)
        }
    } else {
        if (!XT.GetBool(Vars.WaitInResultForBigWin) &&
            !XT.GetBool(Vars.LastWinIsCounting)) XT.TriggerEvent(Vars.Evt_Internal_StartIdleSpinCounter);
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop)
    }
};
StageResult.prototype.OnBonusRoundsContinuePressed = function() {
    XT.TriggerEvent(Vars.Evt_CodeToData_CloseOtherOpenedBonusRoundsWindows);
    XT.SetBool(Vars.CanSpin, true);
    var brret = BonusRoundsController.HandleNextEvent(false, true, false);
    CoinManager.SetStrictBetMode(brret.isBonusRounds);
    this.OnBonusRoundsInfoUpdated()
};
StageResult.prototype.OnBonusRoundsInfoUpdated = function() {
    if (this.bMustBehaveLikeResultFreeSpinsFRB) return;
    var brret = BonusRoundsController.HandleNextEvent(false, false, true);
    this.isBonusRounds = brret.isBonusRounds;
    this.bonusRoundsMessageWindowIsOpened = brret.messageIsOpened;
    var autoplaySpinsLeft = XT.GetInt(Vars.AutoplaySpinsLeft);
    if (autoplaySpinsLeft >= 0) VSGameStateManager.ChangeTo(this.isBonusRounds ? VSGameState.ResultBonusRoundsAutoplay : VSGameState.ResultAutoplay);
    else VSGameStateManager.ChangeTo(this.isBonusRounds ?
        VSGameState.ResultBonusRounds : VSGameState.Result);
    if (this.bonusRoundsMessageWindowIsOpened == false) CoinManager.SetStrictBetMode(this.isBonusRounds)
};
StageResult.prototype.OnCoinValueChanged = function() {
    if (XT.GetBool(Vars.CanSpin) == false) return;
    if (this.bonusRoundsMessageWindowIsOpened) return;
    if (this.prepareToOpenBonus) return;
    if (this.prepareToOpenFSBG) return;
    if (this.isBonusRounds) return;
    XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup)
};
StageResult.prototype.OnRequestToUpdateDisplayedWin = function() {
    XT.SetDouble(Vars.WinDisplayed, XT.GetDouble(Vars.WinReceived));
    XT.SetDouble(Vars.TotalLinesWinDisplayed, XT.GetDouble(Vars.TotalLinesWinReceived));
    XT.SetDouble(Vars.TotalScattersWinDisplayed, XT.GetDouble(Vars.WinReceived) - XT.GetDouble(Vars.TotalLinesWinReceived));
    if (XT.GetBool(Vars.CanUpdateBalanceDisplayed)) XT.SetDouble(Vars.BalanceDisplayed, XT.GetDouble(Vars.BalanceReceived));
    XT.SetDouble(Vars.BonusBalance, XT.GetDouble(Vars.BonusBalanceReceived));
    if (XT.GetBool(Vars.BonusWinIsSeparated))
        if (this.prepareToOpenBonus) XT.SetDouble(Vars.SpinCycleWinDisplayed, XT.GetDouble(Vars.WinReceived));
        else {
            var bonusData = XT.GetObject(Vars.BonusData);
            if (bonusData != null && bonusData.justReceived || this.prepareToOpenFSBG) XT.SetBool(Vars.CanAnimateValues, false);
            XT.SetDouble(Vars.SpinCycleWinDisplayed, XT.GetDouble(Vars.SpinCycleWinReceived))
        }
    else if (ResultDisplayer.isJackpotWin) {
        var canAnimate = XT.GetBool(Vars.CanAnimateValues);
        var cycleWin = XT.GetDouble(Vars.SpinCycleWinReceived);
        var jackpotWin = XT.GetDouble(Vars.FromServer_JackpotAmountWon);
        XT.SetBool(Vars.CanAnimateValues, false);
        XT.SetDouble(Vars.SpinCycleWinDisplayed, jackpotWin);
        XT.SetBool(Vars.CanAnimateValues, canAnimate);
        XT.SetDouble(Vars.SpinCycleWinDisplayed, jackpotWin + cycleWin)
    } else XT.SetDouble(Vars.SpinCycleWinDisplayed, XT.GetDouble(Vars.SpinCycleWinReceived));
    XT.TriggerEvent(Vars.Evt_Internal_UpdateDisplayedWinInUI);
    XT.UnregisterCallbackEvent(this.OnRequestToUpdateDisplayedWin, this)
};
StageResult.prototype.OnConfirmStartSpin = function() {
    XT.SetBool(Vars.SpinNeedsConfirmation, false);
    if (this.mustStartAutoplayAfterConfirmSpinStart) {
        XT.SetInt(Vars.AutoplaySpinsLeft, XT.GetInt(Vars.AutoplaySpinsRequested) - 1);
        XT.SetInt(Vars.AutoplaySpinsLeftDisplayed, XT.GetInt(Vars.AutoplaySpinsLeft))
    }
    this.OnPressedSpin()
};
StageResult.prototype.OnBlockSpin = function() {
    this.spinBlockersCounter++
};
StageResult.prototype.OnUnblockSpin = function() {
    this.spinBlockersCounter--
};
StageResult.prototype.IsAutoRespin = function() {
    return this.isRespin && !XT.GetBool(Vars.ManualRespin)
};
goog.require("UHT.FOXLink");
var WinLimitVars = {
    WinLimit_TotalBetMultiplier: "WinLimit_TotalBetMultiplier",
    WinLimit_TotalAmount: "WinLimit_TotalAmount",
    WinLimit_UncappedWinLines: "WinLimit_UncappedWinLines"
};
WinLimitFOX.prototype = Object.create(FOXLink.prototype);
WinLimitFOX.prototype.constructor = WinLimitFOX;

function WinLimitFOX() {
    FOXLink.call(this);
    this.defaultWinLimit = "tbm";
    this.winLimitsValues = {};
    this.isCollect = false;
    this.isBonusCollect = false;
    this.isSpin = false;
    this.cycleWin = 0;
    this.prevCycleWin = 0;
    this.cycleWinBeforeRespins = 0;
    this.cycleWinBeforeFreeSpins = 0;
    this.bonusWinsInFreeSpins = 0;
    this.bFreeSpinEndsWithRespin = false;
    this.bRemoveBGTAtBonusRespin = false;
    this.forceBonusCollectOnCapDuringBonus = false
}
WinLimitFOX.prototype.XTRegisterCallbacks = function() {
    FOXLink.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this)
};
WinLimitFOX.prototype.XTInitVariablesAndEvents = function() {
    XT.SetInt(WinLimitVars.WinLimit_TotalBetMultiplier, 0);
    XT.SetDouble(WinLimitVars.WinLimit_TotalAmount, 0);
    XT.SetObject(WinLimitVars.WinLimit_UncappedWinLines, null)
};
WinLimitFOX.prototype.HandleInitResponse = function(dict) {
    var key = "wl_i";
    if (dict[key] == undefined) return;
    var splitTypes = dict[key].split(";");
    if (splitTypes.length == 0) return;
    for (var i = 0; i < splitTypes.length; i++) {
        var split = splitTypes[i].split("~");
        if (split.length < 2) return;
        this.winLimitsValues[split[0]] = _number.otoi(split[1])
    }
    var totalBetMultiplier = this.winLimitsValues[this.defaultWinLimit] != undefined ? this.winLimitsValues[this.defaultWinLimit] : 0;
    XT.SetInt(WinLimitVars.WinLimit_TotalBetMultiplier, totalBetMultiplier);
    this.HandleSpinResponse(dict);
    this.HandleBonusRespinResponse(dict)
};
WinLimitFOX.prototype.HandleSpinResponse = function(dict) {
    if (this.CapValuesIfNeeded(dict)) {
        if (this.isCollect && dict[GameProtocolDictionary.freeSpinCurrentNumber] != undefined) {
            var currentFS = _number.otoi(dict[GameProtocolDictionary.freeSpinCurrentNumber]);
            currentFS--;
            if (currentFS == 0) {
                delete dict[GameProtocolDictionary.freeSpinCurrentNumber];
                delete dict[GameProtocolDictionary.freeSpinMaxNumber];
                delete dict[GameProtocolDictionary.freeSpinTotalNumber]
            } else if (dict[GameProtocolDictionary.freeSpinTotalNumber] == undefined) dict[GameProtocolDictionary.freeSpinTotalNumber] =
                currentFS.toString();
            if (dict[GameProtocolDictionary.mysteryScatterGame] != undefined) delete dict[GameProtocolDictionary.mysteryScatterGame];
            if (this.WeHaveFSChainData(dict)) delete dict[GameProtocolDictionary.freeSpinMaxNumber]
        }
        if (dict["rs_p"] != undefined && dict["rs_t"] == undefined) {
            var respinsPlayed = dict["rs_p"];
            delete dict["rs_p"];
            dict["rs_t"] = respinsPlayed;
            if (this.bRemoveBGTAtBonusRespin) {
                if (dict[GameProtocolDictionary.BonusGame.gameOver] != undefined) dict[GameProtocolDictionary.BonusGame.gameOver] = "1";
                if (respinsPlayed == "0")
                    if (dict["bgt"] != undefined) delete dict["bgt"]
            }
        }
        if (this.bFreeSpinEndsWithRespin)
            if (dict[GameProtocolDictionary.freeSpinCurrentNumber] != undefined) {
                if (dict["rs_t"] == undefined) dict["rs_t"] = "1";
                if (dict["prg"] != undefined) dict["prg"] = "0,0"
            }
        if ((this.isCollect || this.isSpin) && (dict[GameProtocolDictionary.BonusGame.bonusGameExists] != undefined || dict[GameProtocolDictionary.BonusGame.level] != undefined || dict[GameProtocolDictionary.BonusGame.currentBonusRespin] != undefined || dict[GameProtocolDictionary.BonusGame.status] !=
                undefined || dict["wof_status"] != undefined)) {
            delete dict[GameProtocolDictionary.BonusGame.bonusGameExists];
            delete dict[GameProtocolDictionary.BonusGame.level];
            delete dict[GameProtocolDictionary.BonusGame.currentBonusRespin];
            delete dict[GameProtocolDictionary.BonusGame.status];
            delete dict["wof_status"]
        }
    }
};
WinLimitFOX.prototype.HandleBonusRespinResponse = function(dict) {
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (this.CapValuesIfNeeded(dict))
        if (this.isBonusCollect) {
            dict[GameProtocolDictionary.BonusGame.gameOver] = "1";
            if (dict[GameProtocolDictionary.BonusGame.extraRetriggersWon] != undefined) delete dict[GameProtocolDictionary.BonusGame.extraRetriggersWon];
            if (dict[GameProtocolDictionary.BonusGame.currentBonusRespin] != undefined && dict[GameProtocolDictionary.BonusGame.maxBonusRespins] != undefined) dict[GameProtocolDictionary.BonusGame.currentBonusRespin] =
                dict[GameProtocolDictionary.BonusGame.maxBonusRespins];
            if (fsr != null && fsr.IsFreeSpin) fsr.TotalSpins = fsr.CurrentSpin - 1
        } else {
            if (this.isCollect)
                if (fsr != null && fsr.IsFreeSpin) fsr.TotalSpins = fsr.CurrentSpin - 1
        }
    else if (fsr != null && fsr.IsFreeSpin)
        if (dict[GameProtocolDictionary.BonusGame.gameOver] != undefined && dict[GameProtocolDictionary.BonusGame.gameOver] == "1") this.bonusWinsInFreeSpins += GameProtocolCommonParser.ParseDouble(dict, GameProtocolDictionary.BonusGame.realWin)
};
WinLimitFOX.prototype.HandlePickBonusResponse = function(dict) {
    this.prevCycleWin = this.cycleWin;
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (this.CapValuesIfNeeded(dict)) {
        if (this.isCollect)
            if (dict[GameProtocolDictionary.freeSpinCurrentNumber] != undefined) {
                var currentFS = _number.otoi(dict[GameProtocolDictionary.freeSpinCurrentNumber]);
                currentFS--;
                if (dict[GameProtocolDictionary.freeSpinTotalNumber] == undefined) dict[GameProtocolDictionary.freeSpinTotalNumber] = currentFS.toString()
            } else if (fsr.IsFreeSpin) fsr.TotalSpins =
            fsr.CurrentSpin - 1
    } else if (fsr != null && fsr.IsFreeSpin)
        if (dict[GameProtocolDictionary.BonusGame.gameOver] != undefined && dict[GameProtocolDictionary.BonusGame.gameOver] == "1") this.bonusWinsInFreeSpins += GameProtocolCommonParser.ParseDouble(dict, GameProtocolDictionary.BonusGame.realWin)
};
WinLimitFOX.prototype.SwitchTotalBetMultiplier = function(key) {
    if (this.winLimitsValues[key] != undefined) XT.SetInt(WinLimitVars.WinLimit_TotalBetMultiplier, this.winLimitsValues[key])
};
WinLimitFOX.prototype.HandlePickFSOptionResponse = function(dict) {
    this.CapValuesIfNeeded(dict)
};
WinLimitFOX.prototype.CapValuesIfNeeded = function(dict) {
    if (dict[GameProtocolDictionary.spinCycleWin] != undefined) this.cycleWin = _number.otod(dict[GameProtocolDictionary.spinCycleWin]);
    var key = "rs_p";
    if (dict[key] != undefined) {
        var numPlayed = _number.otoi(dict[key]);
        if (numPlayed == 0) this.cycleWinBeforeRespins = this.prevCycleWin
    }
    if (dict[GameProtocolDictionary.freeSpinCurrentWin] != undefined) {
        var fsWin = _number.otod(dict[GameProtocolDictionary.freeSpinCurrentWin]);
        if (fsWin == 0) this.cycleWinBeforeFreeSpins = this.cycleWin
    }
    key =
        "wl_ta";
    if (dict[key] == undefined) {
        XT.SetDouble(WinLimitVars.WinLimit_TotalAmount, 0);
        XT.SetObject(WinLimitVars.WinLimit_UncappedWinLines, null);
        XT.SetBool(Vars.WinLimitReached, false);
        return false
    }
    XT.SetBool(Vars.WinLimitReached, true);
    var limitTotal = _number.otod(dict[key]);
    var limitCurrent = String(limitTotal - this.prevCycleWin);
    var limitRespins = String(limitTotal - this.cycleWinBeforeRespins);
    var limitFreeSpins = limitTotal - this.cycleWinBeforeFreeSpins;
    var limitBonusWin = limitTotal - this.prevCycleWin;
    var forceBonusCollect =
        false;
    if (dict[GameProtocolDictionary.winAmountShort] != undefined) dict[GameProtocolDictionary.winAmountShort] = limitCurrent;
    if (dict[GameProtocolDictionary.TumblingWin] != undefined) dict[GameProtocolDictionary.TumblingWin] = limitRespins;
    if (dict[GameProtocolDictionary.freeSpinTotalWin] != undefined) {
        var fsWinTotal = _number.otod(dict[GameProtocolDictionary.freeSpinTotalWin]);
        if (fsWinTotal > limitFreeSpins) fsWinTotal = limitFreeSpins;
        dict[GameProtocolDictionary.freeSpinTotalWin] = String(fsWinTotal)
    }
    if (dict[GameProtocolDictionary.freeSpinCurrentWin] !=
        undefined) dict[GameProtocolDictionary.freeSpinCurrentWin] = (limitFreeSpins - this.bonusWinsInFreeSpins).toString();
    if (dict[GameProtocolDictionary.freeSpinTotalWinMultiplied] != undefined) {
        var fsResTotal = _number.otod(dict[GameProtocolDictionary.freeSpinTotalWinMultiplied]);
        if (fsResTotal > limitFreeSpins) fsResTotal = limitFreeSpins;
        dict[GameProtocolDictionary.freeSpinTotalWinMultiplied] = String(fsResTotal)
    }
    if (dict[GameProtocolDictionary.BonusGame.realWin] != undefined) {
        var bonusWin = _number.otod(dict[GameProtocolDictionary.BonusGame.realWin]);
        if (bonusWin > limitBonusWin) bonusWin = limitBonusWin;
        dict[GameProtocolDictionary.BonusGame.realWin] = bonusWin.toString();
        if (this.forceBonusCollectOnCapDuringBonus) forceBonusCollect = true
    }
    if (dict["bpw"] != undefined) {
        var bonusWin = _number.otod(dict["bpw"]);
        if (bonusWin > limitBonusWin) bonusWin = limitBonusWin;
        if (this.forceBonusCollectOnCapDuringBonus) {
            forceBonusCollect = true;
            dict["bpw"] = "0";
            dict[GameProtocolDictionary.BonusGame.realWin] = bonusWin.toString()
        } else dict["bpw"] = bonusWin.toString()
    }
    XT.SetDouble(WinLimitVars.WinLimit_TotalAmount,
        limitTotal);
    XT.SetObject(WinLimitVars.WinLimit_UncappedWinLines, VSProtocolParser.ParseWinLines(dict));
    var i = 0;
    while (dict[GameProtocolDictionary.winLines(i)] != undefined) delete dict[GameProtocolDictionary.winLines(i++)];
    var action = "";
    if (dict[GameProtocolDictionary.Actions.action] != undefined) action = dict[GameProtocolDictionary.Actions.action];
    var nextAction = "";
    if (dict[GameProtocolDictionary.NextActions.nextAction] != undefined) nextAction = dict[GameProtocolDictionary.NextActions.nextAction];
    this.isCollect =
        action == GameProtocolDictionary.Actions.doCollect || nextAction == GameProtocolDictionary.NextActions.Collect;
    this.isBonusCollect = action == GameProtocolDictionary.Actions.doCollectBonus || nextAction == GameProtocolDictionary.NextActions.CollectBonus;
    this.isSpin = nextAction == GameProtocolDictionary.NextActions.Spin;
    if (forceBonusCollect) {
        this.isBonusCollect = true;
        this.isCollect = false;
        this.isSpin = false
    }
    if (dict[GameProtocolDictionary.Tumbling] != undefined) delete dict[GameProtocolDictionary.Tumbling];
    return true
};
WinLimitFOX.prototype.OnSpinStarted = function() {
    var respinData = XT.GetObject(Vars.RespinData);
    var isNewCycle = !XT.GetBool(Vars.Logic_IsFreeSpin) && (respinData == null || respinData.IsDone);
    if (isNewCycle) {
        this.prevCycleWin = 0;
        this.bonusWinsInFreeSpins = 0
    } else this.prevCycleWin = this.cycleWin
};
WinLimitFOX.prototype.WeHaveFSChainData = function(dict) {
    return dict[GameProtocolDictionary.FreeSpinsChain.spins] != undefined || dict[GameProtocolDictionary.FreeSpinsChain.multipliers] != undefined || dict[GameProtocolDictionary.FreeSpinsChain.sessionsWonSymbolsCount] != undefined || dict[GameProtocolDictionary.FreeSpinsChain.sessionsWonThisSpin] != undefined || dict[GameProtocolDictionary.FreeSpinsChain.spinsTotal] != undefined || dict[GameProtocolDictionary.FreeSpinsChain.multipliersTotal] != undefined || dict[GameProtocolDictionary.FreeSpinsChain.winsTotal] !=
        undefined || dict[GameProtocolDictionary.FreeSpinsChain.multipliedWinTotal] != undefined
};
goog.require("UHT.FOXLink");
var WinMultiplierVars = {
    WinMultipliers: "WinMultipliers"
};
WinMultiplierFOX.prototype = Object.create(FOXLink.prototype);
WinMultiplierFOX.prototype.constructor = WinMultiplierFOX;

function WinMultiplierFOX() {
    FOXLink.call(this)
}
WinMultiplierFOX.Keys = {
    types: "wmt",
    values: "wmv",
    indices: "wnd",
    total: "gwm"
};
WinMultiplierFOX.Multiplier = function(type, value, index) {
    this.type = type;
    this.value = value;
    this.index = index
};
WinMultiplierFOX.Multiplier.Types = {
    weightedBin: "wb"
};
WinMultiplierFOX.Multiplier.Type = {
    Undefined: 0,
    WeightedBin: 1
};
WinMultiplierFOX.Multiplier.ConvertType = function(type) {
    if (type == WinMultiplierFOX.Multiplier.Types.weightedBin) return WinMultiplierFOX.Multiplier.Type.WeightedBin;
    return WinMultiplierFOX.Multiplier.Type.Undefined
};
WinMultiplierFOX.prototype.XTInitVariablesAndEvents = function() {
    FOXLink.prototype.XTInitVariablesAndEvents.call(this);
    XT.SetObject(WinMultiplierVars.WinMultipliers, null)
};
WinMultiplierFOX.prototype.HandleInitResponse = function(param) {
    this.HandleResponse(param)
};
WinMultiplierFOX.prototype.HandleSpinResponse = function(param) {
    this.HandleResponse(param)
};
WinMultiplierFOX.prototype.HandleResponse = function(dict) {
    var Keys = WinMultiplierFOX.Keys;
    var Multiplier = WinMultiplierFOX.Multiplier;
    var types = null;
    if (dict[Keys.types] != undefined) types = _array.ConvertAll(dict[Keys.types].split(";"), Multiplier.ConvertType);
    var values = null;
    if (dict[Keys.values] != undefined) values = _array.ConvertAll(dict[Keys.values].split(";"), _number.otoi);
    var indices = null;
    if (dict[Keys.indices] != undefined) indices = _array.ConvertAll(dict[Keys.indices].split(";"), _number.otoi);
    var multipliers =
        null;
    if (types != null && values != null && indices != null) {
        multipliers = [];
        for (var i = 0; i < types.length; ++i) multipliers.push(new Multiplier(types[i], values[i], indices[i]))
    }
    var total = 1;
    if (dict[Keys.total] != undefined) total = _number.otoi(dict[Keys.total]);
    XT.SetInt(InterfaceVars.ExtraWinMultiplier, total);
    XT.SetObject(WinMultiplierVars.WinMultipliers, multipliers)
};
goog.require("UHT.XTLink");
goog.require("UHT.SoundManager");
goog.require("UHT.AudioClassesUtils");
var VSSoundLogicVars = {
    VSSoundLogicObject: "VSSoundLogicObject"
};
VS_SoundLogic.prototype = Object.create(XTLink.prototype);
VS_SoundLogic.prototype.constructor = VS_SoundLogic;

function VS_SoundLogic() {
    XTLink.call(this);
    this.rq = null;
    this.playSpecialSymbolSoundsInOrder = false;
    this.startFSSoundsOnSpecificEvent = false;
    this.clipMusic = null;
    this.clipsReelSpin = null;
    this.reelsStartingSounds = null;
    this.reelsStartingAll = null;
    this.reelsStoppingSounds = null;
    this.reelsStoppingAll = null;
    this.clipSpinWin = null;
    this.clipSpinNoWin = null;
    this.clipShowWinLine = null;
    this.clipsSymbolWin = null;
    this.clipsSymbolWinOverride = null;
    this.reelStopDelay = 0;
    this.reelsStopAllDelay = 0;
    this.reelsFastStopAllDelay = 0;
    this.clipFSWonBeforeResult = null;
    this.clipBonusWonBeforeResult = null;
    this.reelMustStop = [];
    this.reelsMustStopAll = null;
    this.sndManager = null;
    this.numberOfReels = 0;
    this.reelIndex = 0;
    this.reelIndices = null;
    this.reelsExcited = null;
    this.resultSymbols = null;
    this.isInactive = true;
    this.allReelsStopped = false;
    this.fastStop = false;
    this.oldClipReelSpinIndex = -1;
    this.reelsStoppedWithSpecialSymbol = null;
    this.canPlaySpinEndedBWSound = true;
    this.stillPossibleWinComboBonus = null;
    this.stillPossibleWinComboScatter = null;
    this.stillPossibleWinComboWild =
        null;
    this.stillPossibleWinComboPerSymbol = null
}
VS_SoundLogic.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSoundLogicSpinStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinEnded, this.OnVSSoundLogicSpinEnded, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PlaySpinEndedBWSound, this.OnVSSoundLogicSpinEndedBWSound, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelStopStarted, this.OnSoundLogicReelStopReceived, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelStarted, this.OnSoundLogicReelHasStarted,
        this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultSymbolWinPlaySound, this.OnSoundLogicShowWinLine, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_FreeSpinsEnded, this.OnSoundLogicStartFreeSpins, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StartVSLogicSounds, this.OnVSLogicStartSounds, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StopVSLogicSounds, this.OnVSLogicStopSounds, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ExcitedReel, this.OnSoundLogicReelHasExcited, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelManager_StopSpin,
        this.OnStopSpin, this);
    XT.RegisterCallbackObject(Vars.SoundManagerObject, this.OnSoundManagerChanged, this);
    XT.RegisterCallbackObject(Vars.ReelInitialPositions, this.OnSoundLogicReelPositions, this);
    XT.RegisterCallbackObject(Vars.ResultScreenSymbols, this.OnSoundLogicResultSymbolsReceived, this);
    XT.RegisterCallbackObject(Vars.SymbolsManagerObject, this.OnSymbolsManagerObject, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelStopEnded, this.OnSoundLogicReelStopEnded, this);
    XT.RegisterCallbackBool(Vars.MusicIsOn,
        this.OnMusicStateChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowFSWonBeforeResult, this.OnPlayFSWonBeforeResult, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowBonusWonBeforeResult, this.OnPlayBonusWonBeforeResult, this);
    if (this.startFSSoundsOnSpecificEvent) XT.RegisterCallbackEvent(Vars.Evt_Internal_SwitchToFSSounds, this.OnSoundLogicStartFreeSpins, this);
    else XT.RegisterCallbackEvent(Vars.Evt_Internal_FreeSpinsStarted, this.OnSoundLogicStartFreeSpins, this)
};
VS_SoundLogic.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(Vars.Logic_IsFreeSpin, false);
    XT.SetBool(Vars.CanPlayReelStopSounds, true);
    XT.SetBool(Vars.VSSoundLogic_IgnoreFastStop, false);
    XT.SetObject(VSSoundLogicVars.VSSoundLogicObject, this)
};
VS_SoundLogic.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnSoundLogicSpinStarted, this);
    XT.UnregisterCallbackEvent(this.OnVSSoundLogicSpinEnded, this);
    XT.UnregisterCallbackEvent(this.OnVSSoundLogicSpinEndedBWSound, this);
    XT.UnregisterCallbackEvent(this.OnSoundLogicReelStopReceived, this);
    XT.UnregisterCallbackEvent(this.OnSoundLogicReelHasStarted, this);
    XT.UnregisterCallbackEvent(this.OnSoundLogicShowWinLine, this);
    XT.UnregisterCallbackEvent(this.OnSoundLogicStartFreeSpins, this);
    XT.UnregisterCallbackEvent(this.OnVSLogicStartSounds,
        this);
    XT.UnregisterCallbackEvent(this.OnVSLogicStopSounds, this);
    XT.UnregisterCallbackEvent(this.OnSoundLogicReelHasExcited, this);
    XT.UnregisterCallbackObject(this.OnSoundManagerChanged, this);
    XT.UnregisterCallbackObject(this.OnSoundLogicReelPositions, this);
    XT.UnregisterCallbackObject(this.OnSoundLogicResultSymbolsReceived, this);
    XT.UnregisterCallbackObject(this.OnSymbolsManagerObject, this);
    XT.UnregisterCallbackEvent(this.OnSoundLogicReelStopEnded, this);
    XT.UnregisterCallbackBool(this.OnMusicStateChanged,
        this)
};
VS_SoundLogic.prototype.OnSoundManagerChanged = function(mgr) {
    this.sndManager = mgr
};
VS_SoundLogic.prototype.OnSymbolsManagerObject = function(mgr) {
    var symbolsManager = mgr;
    var biggestSymbolId = 0;
    for (var i = 0; i < symbolsManager.symbols.length; i++)
        if (biggestSymbolId < symbolsManager.symbols[i].symbolId) biggestSymbolId = symbolsManager.symbols[i].symbolId;
    this.reelsStoppedWithSpecialSymbol = _array.create(biggestSymbolId + 1, 0)
};
VS_SoundLogic.prototype.OnMusicStateChanged = function(unused) {
    this.UpdateSounds()
};
VS_SoundLogic.prototype.UpdateSounds = function() {
    if (this.isInactive) return;
    for (var crsIndex = 0; crsIndex < this.clipsReelSpin.length; crsIndex++)
        if (this.clipsReelSpin[crsIndex].IsPlaying()) {
            var args = {
                handle: this.clipsReelSpin[crsIndex].handler
            };
            this.sndManager.StopLoopingSound(args);
            this.clipsReelSpin[crsIndex].handler = args.handle;
            this.clipsReelSpin[crsIndex].handler = this.sndManager.PlayLooping(this.clipsReelSpin[crsIndex].GetClip())
        }
    for (var ermIndex = 0; ermIndex < this.numberOfReels; ermIndex++)
        if (this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.IsPlaying()) {
            var args = {
                handle: this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.handler
            };
            this.sndManager.StopLoopingSound(args);
            this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.handler = args.handle;
            this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.handler = this.sndManager.PlayLooping(this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.GetClip())
        }
    this.UpdateBackgroundMusic()
};
VS_SoundLogic.prototype.OnSoundLogicReelPositions = function(reelPos) {
    this.numberOfReels = reelPos.length;
    this.reelsExcited = []
};
VS_SoundLogic.prototype.OnSoundLogicResultSymbolsReceived = function(resultScreenSymbols) {
    this.resultSymbols = resultScreenSymbols;
    this.reelsExcited = [];
    for (var reIndex = 0; reIndex < this.numberOfReels; reIndex++) this.reelsExcited.push(false);
    this.allReelsStopped = false
};
VS_SoundLogic.prototype.OnSoundLogicSpinStarted = function() {
    this.fastStop = false;
    for (var crsIndex = 0; crsIndex < this.clipsReelSpin.length; crsIndex++)
        if (this.clipsReelSpin[crsIndex].IsPlaying()) {
            var args = {
                handle: this.clipsReelSpin[crsIndex].handler
            };
            this.sndManager.StopLoopingSound(args);
            this.clipsReelSpin[crsIndex].handler = args.handle
        }
    var randomClipReelSpinIndex = Random.Range(0, this.clipsReelSpin.length);
    while (this.clipsReelSpin.length > 1 && randomClipReelSpinIndex == this.oldClipReelSpinIndex) randomClipReelSpinIndex =
        Random.Range(0, this.clipsReelSpin.length);
    this.clipsReelSpin[randomClipReelSpinIndex].handler = this.sndManager.PlayLooping(this.clipsReelSpin[randomClipReelSpinIndex].GetClip());
    this.oldClipReelSpinIndex = randomClipReelSpinIndex;
    for (var i = 0; i < this.reelsStoppedWithSpecialSymbol.length; i++) this.reelsStoppedWithSpecialSymbol[i] = 0
};
VS_SoundLogic.prototype.OnStopSpin = function() {
    if (!XT.GetBool(Vars.VSSoundLogic_IgnoreFastStop)) this.fastStop = true
};
VS_SoundLogic.prototype.OnVSSoundLogicSpinEnded = function() {
    for (var crsIndex = 0; crsIndex < this.clipsReelSpin.length; crsIndex++)
        if (this.clipsReelSpin[crsIndex].IsPlaying()) {
            var args = {
                handle: this.clipsReelSpin[crsIndex].handler
            };
            this.sndManager.StopLoopingSound(args);
            this.clipsReelSpin[crsIndex].handler = args.handle
        }
    var winReceived = XT.GetDouble(Vars.WinReceived);
    if (winReceived > 0) {
        var coinCounter = XT.GetObject(Vars.CoinCounterObject);
        if (winReceived >= CoinManager.GetLastTotalBet() * coinCounter.BigWinSteps[0]) this.sndManager.PlaySimple(this.GetSpinWinClip())
    } else this.sndManager.PlaySimple(this.clipSpinNoWin.GetClip())
};
VS_SoundLogic.prototype.OnVSSoundLogicSpinEnded = function() {
    for (var crsIndex = 0; crsIndex < this.clipsReelSpin.length; crsIndex++)
        if (this.clipsReelSpin[crsIndex].IsPlaying()) {
            var args = {
                handle: this.clipsReelSpin[crsIndex].handler
            };
            this.sndManager.StopLoopingSound(args);
            this.clipsReelSpin[crsIndex].handler = args.handle
        }
    var winReceived = XT.GetDouble(Vars.WinReceived);
    if (winReceived <= 0) this.sndManager.PlaySimple(this.clipSpinNoWin.GetClip());
    this.canPlaySpinEndedBWSound = true
};
VS_SoundLogic.prototype.OnVSSoundLogicSpinEndedBWSound = function() {
    if (this.canPlaySpinEndedBWSound) {
        this.canPlaySpinEndedBWSound = false;
        this.sndManager.PlaySimple(this.GetSpinWinClip())
    }
};
VS_SoundLogic.prototype.OnSoundLogicReelHasStarted = function() {
    this.reelIndices = XT.GetObject(Vars.LastStartedReelIndices);
    this.reelIndex = this.reelIndices[this.reelIndices.length - 1];
    if (this.reelIndices.length == this.numberOfReels) this.sndManager.PlaySimple(this.reelsStartingAll.GetClip());
    else this.sndManager.PlaySimple(this.reelsStartingSounds[this.reelIndex].clipsReelStart.GetClip())
};
VS_SoundLogic.prototype.OnSoundLogicReelHasExcited = function() {
    var _reelIndex = XT.GetInt(Vars.LastExcitedReelIndex);
    this.reelsExcited[_reelIndex] = true
};
VS_SoundLogic.prototype.PlayReelStopSoundQueued = function(param) {
    if (!XT.GetBool(Vars.CanPlayReelStopSounds)) return;
    this.sndManager.PlaySimple(param)
};
VS_SoundLogic.prototype.OnSoundLogicReelStopReceived = function() {
    this.reelIndices = XT.GetObject(Vars.LastStoppedReelIndices);
    this.reelIndex = this.reelIndices[this.reelIndices.length - 1];
    this.stillPossibleWinComboBonus = XT.GetObject(Vars.StillPossibleWinComboBonus);
    this.stillPossibleWinComboScatter = XT.GetObject(Vars.StillPossibleWinComboScatter);
    this.stillPossibleWinComboWild = XT.GetObject(Vars.StillPossibleWinComboWild);
    this.stillPossibleWinComboPerSymbol = XT.GetObject(Vars.StillPossibleWinComboPerSymbol);
    var i;
    var rsIndex;
    var sIdx;
    var hasSpecialSymbol = false;
    this.rq.StopRoutines();
    var reelStopOrder = XT.GetObject(Vars.ReelsStopOrder);
    if (this.reelIndex == reelStopOrder[this.numberOfReels - 1]) this.allReelsStopped = true;
    if (this.fastStop) {
        for (var currentReelIndex = this.reelIndices[0]; currentReelIndex <= this.reelIndex; currentReelIndex++)
            for (i = 0; i < this.reelsStoppingSounds[currentReelIndex].reelStopWithSpecialSymbol.length; i++) {
                sIdx = this.reelsStoppingSounds[currentReelIndex].reelStopWithSpecialSymbol[i].specialSymbolId;
                if (sIdx == 0 && !this.stillPossibleWinComboBonus[currentReelIndex]) continue;
                if (sIdx == 1 && !this.stillPossibleWinComboScatter[currentReelIndex]) continue;
                if (sIdx == 2 && !this.stillPossibleWinComboWild[currentReelIndex]) continue;
                if (sIdx > 2 && !this.stillPossibleWinComboPerSymbol[currentReelIndex][sIdx]) continue;
                var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
                if (XT.GetInt(Vars.AdditionalFreeSpinsWon) > 0 || fsr.IsFreeSpinsStart || XT.GetBool(Vars.FromServer_MustOpenFSBG))
                    for (rsIndex = 0; rsIndex < this.resultSymbols[currentReelIndex].length; rsIndex++)
                        if (sIdx ==
                            this.resultSymbols[currentReelIndex][rsIndex]) {
                            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.PlayReelStopSoundQueued, this.reelsStoppingSounds[currentReelIndex].reelStopWithSpecialSymbol[i].GetClip(), this));
                            this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(.1));
                            hasSpecialSymbol = true;
                            break
                        }
            }
        if (hasSpecialSymbol) this.rq.StartRoutines();
        else this.PlayReelsStopAllSound(this.reelsStoppingAll.GetClip());
        return
    }
    if (this.playSpecialSymbolSoundsInOrder) {
        var clipToPlay = null;
        for (sIdx = 0; sIdx < this.reelsStoppedWithSpecialSymbol.length; sIdx++) {
            if (sIdx ==
                0 && !this.stillPossibleWinComboBonus[this.reelIndex]) continue;
            if (sIdx == 1 && !this.stillPossibleWinComboScatter[this.reelIndex]) continue;
            if (sIdx == 2 && !this.stillPossibleWinComboWild[this.reelIndex]) continue;
            if (sIdx > 2 && !this.stillPossibleWinComboPerSymbol[this.reelIndex][sIdx]) continue;
            var goToNextSIdx = false;
            for (rsIndex = 0; rsIndex < this.resultSymbols[this.reelIndex].length; rsIndex++) {
                if (this.resultSymbols[this.reelIndex][rsIndex] == sIdx)
                    for (i = 0; i < this.reelsStoppingSounds[this.reelsStoppedWithSpecialSymbol[sIdx]].reelStopWithSpecialSymbol.length; i++)
                        if (this.reelsStoppingSounds[this.reelsStoppedWithSpecialSymbol[sIdx]].reelStopWithSpecialSymbol[i].specialSymbolId ==
                            sIdx) {
                            if (clipToPlay == null)
                                if (this.reelsExcited[this.reelIndex]) clipToPlay = this.reelsStoppingSounds[this.reelsStoppedWithSpecialSymbol[sIdx]].reelStopWithSpecialSymbol[i].GetExcitedClip();
                                else clipToPlay = this.reelsStoppingSounds[this.reelsStoppedWithSpecialSymbol[sIdx]].reelStopWithSpecialSymbol[i].GetClip();
                            this.reelsStoppedWithSpecialSymbol[sIdx]++;
                            goToNextSIdx = true;
                            break
                        }
                if (goToNextSIdx) break
            }
            if (clipToPlay != null) {
                this.PlayReelStopSound(clipToPlay);
                return
            }
        }
    } else
        for (i = 0; i < this.reelsStoppingSounds[this.reelIndex].reelStopWithSpecialSymbol.length; i++) {
            sIdx =
                this.reelsStoppingSounds[this.reelIndex].reelStopWithSpecialSymbol[i].specialSymbolId;
            if (sIdx == 0 && !this.stillPossibleWinComboBonus[this.reelIndex]) continue;
            if (sIdx == 1 && !this.stillPossibleWinComboScatter[this.reelIndex]) continue;
            if (sIdx == 2 && !this.stillPossibleWinComboWild[this.reelIndex]) continue;
            if (sIdx > 2 && !this.stillPossibleWinComboPerSymbol[this.reelIndex][sIdx]) continue;
            for (rsIndex = 0; rsIndex < this.resultSymbols[this.reelIndex].length; rsIndex++)
                if (sIdx == this.resultSymbols[this.reelIndex][rsIndex]) {
                    if (this.reelsExcited[this.reelIndex]) this.PlayReelStopSound(this.reelsStoppingSounds[this.reelIndex].reelStopWithSpecialSymbol[i].GetExcitedClip());
                    else this.PlayReelStopSound(this.reelsStoppingSounds[this.reelIndex].reelStopWithSpecialSymbol[i].GetClip());
                    return
                }
        }
    if (this.reelsExcited[this.reelIndex]) {
        var reelwin = XT.GetObject(Vars.ReelsWinInfo)[this.reelIndex];
        if (reelwin) this.PlayReelStopSound(this.reelsStoppingSounds[this.reelIndex].reelStopExcitedWin.GetClip());
        else this.PlayReelStopSound(this.reelsStoppingSounds[this.reelIndex].reelStopExcitedLose.GetClip());
        return
    }
    this.PlayReelStopSound(this.reelsStoppingSounds[this.reelIndex].reelStopDefault.GetClip())
};
VS_SoundLogic.prototype.OnSoundLogicReelStopEnded = function() {
    this.reelIndex = XT.GetInt(Vars.LastStopEndedReelIndex);
    var reelStopOrder = XT.GetObject(Vars.ReelsStopOrder);
    var nextReelToStop = -1;
    var reelStopIndex = 0;
    for (var i = 0; i < this.numberOfReels; i++)
        if (reelStopOrder[i] == this.reelIndex) {
            reelStopIndex = i;
            if (i < this.numberOfReels - 1) nextReelToStop = i + 1
        }
    for (var ermIndex = reelStopIndex; ermIndex >= 0; ermIndex--)
        if (this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.IsPlaying()) {
            var args = {
                handle: this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.handler
            };
            this.sndManager.StopLoopingSound(args);
            this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.handler = args.handle
        }
    if (this.allReelsStopped) return;
    if (nextReelToStop != -1)
        if (this.reelsExcited[reelStopOrder[nextReelToStop]]) {
            this.sndManager.PlaySimple(this.reelsStartingSounds[nextReelToStop].clipsReelStartExcited.GetClip());
            this.reelsStartingSounds[nextReelToStop].clipsReelMusicExcited.handler = this.sndManager.PlayLooping(this.reelsStartingSounds[nextReelToStop].clipsReelMusicExcited.GetClip())
        }
};
VS_SoundLogic.prototype.OnPlayFSWonBeforeResult = function() {
    if (!XT.GetBool(Vars.LastWinIsCounting)) this.sndManager.PlaySimple(this.clipFSWonBeforeResult)
};
VS_SoundLogic.prototype.OnPlayBonusWonBeforeResult = function() {
    if (!XT.GetBool(Vars.LastWinIsCounting)) this.sndManager.PlaySimple(this.clipBonusWonBeforeResult)
};
VS_SoundLogic.prototype.OnSoundLogicShowWinLine = function() {
    var resultSymbolWinID = XT.GetInt(Vars.ResultSymbolWinID);
    if (resultSymbolWinID == -1 || this.clipsSymbolWin.length <= resultSymbolWinID || this.clipsSymbolWin[resultSymbolWinID].GetClip() == null) this.sndManager.PlaySimple(this.clipShowWinLine.GetClip());
    else this.sndManager.PlaySimple(this.clipsSymbolWin[resultSymbolWinID].GetClip())
};
VS_SoundLogic.prototype.OnSoundLogicStartFreeSpins = function() {
    this.UpdateSounds()
};
VS_SoundLogic.prototype.OnVSLogicStartSounds = function() {
    this.isInactive = false;
    this.UpdateSounds()
};
VS_SoundLogic.prototype.OnVSLogicStopSounds = function() {
    if (this.clipMusic.IsPlaying()) {
        var args = {
            handle: this.clipMusic.handler
        };
        this.sndManager.StopMusic(args);
        this.clipMusic.handler = args.handle
    }
    this.isInactive = true
};
VS_SoundLogic.prototype.UpdateBackgroundMusic = function() {
    if (this.clipMusic.IsPlaying()) {
        var args = {
            handle: this.clipMusic.handler
        };
        this.sndManager.StopMusic(args);
        this.clipMusic.handler = args.handle
    }
    this.clipMusic.handler = this.sndManager.PlayMusic(this.clipMusic.GetClip())
};
VS_SoundLogic.prototype.PlayReelStopSound = function(clip) {
    if (!XT.GetBool(Vars.CanPlayReelStopSounds)) return;
    if (this.reelStopDelay <= 0) this.sndManager.PlaySimple(clip);
    else {
        var clipDelay = new AudioClipDelay;
        clipDelay.CountToPlayClip(clip, this.reelStopDelay);
        this.reelMustStop.push(clipDelay)
    }
};
VS_SoundLogic.prototype.PlayReelsStopAllSound = function(clip) {
    if (!XT.GetBool(Vars.CanPlayReelStopSounds)) return;
    if (!this.fastStop && this.reelsStopAllDelay <= 0 || this.fastStop && this.reelsFastStopAllDelay <= 0) this.sndManager.PlaySimple(clip);
    else {
        this.reelsMustStopAll = new AudioClipDelay;
        this.reelsMustStopAll.CountToPlayClip(clip, this.fastStop ? this.reelsFastStopAllDelay : this.reelsStopAllDelay)
    }
};
VS_SoundLogic.prototype.Update = function() {
    for (var i = 0; i < this.reelMustStop.length; i++)
        if (this.reelMustStop[i].MustPlay()) {
            this.sndManager.PlaySimple(this.reelMustStop[i].GetClip());
            this.reelMustStop[i].Reset();
            this.reelMustStop.splice(i, 1)
        }
    if (this.reelsMustStopAll != null && this.reelsMustStopAll.MustPlay()) {
        this.sndManager.PlaySimple(this.reelsMustStopAll.GetClip());
        this.reelsMustStopAll.Reset();
        this.reelsMustStopAll = null
    }
};
VS_SoundLogic.prototype.GetSpinWinClip = function() {
    var winLines = XT.GetObject(Vars.ReceivedWinLines);
    var symbols = XT.GetObject(Vars.OrderedSymbolList);
    var winSymbolsIds = [];
    for (var i = 0; i < winLines.length; ++i) {
        var positions = winLines[i].WinPositions;
        for (var j = 0; j < positions.length; ++j)
            if (winSymbolsIds.indexOf(symbols[positions[j]].symbolId) == -1) winSymbolsIds.push(symbols[positions[j]].symbolId)
    }
    for (var i = 0; i < this.clipsSymbolWinOverride.length; ++i) {
        var clip = this.clipsSymbolWinOverride[i].GetClip();
        if (clip !=
            null && winSymbolsIds.indexOf(i) != -1) return clip
    }
    return this.clipSpinWin.GetClip()
};
goog.require("UHT.XTLink");
goog.require("UHT.SoundManager");
goog.require("UHT.AudioClassesUtils");
TRexManager.prototype = Object.create(XTLink.prototype);
TRexManager.prototype.constructor = TRexManager;

function TRexManager() {
    XTLink.call(this);
    this.crossFadeDuration = 1;
    this.clips = [];
    this.muteInFreeSpins = false;
    this.musicClips = [];
    this.clipsPlayingState = null;
    this.isDisabled = true;
    this.cantPlayInFS = false;
    this.sndManager = null;
    this.musicLogic = null;
    this.musicSource = null
}
TRexManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StartVSLogicSounds, this.OnVSLogicStartSounds, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StopVSLogicSounds, this.OnVSLogicStopSounds, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.Init, this);
    if (this.muteInFreeSpins) {
        XT.RegisterCallbackEvent(Vars.Evt_Internal_FreeSpinsStarted, this.FreeSpinsStarted, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_FreeSpinsEnded, this.FreeSpinsEnded, this)
    }
    XT.RegisterCallbackObject(Vars.SoundManagerObject,
        this.OnSoundManagerChanged, this);
    XT.RegisterCallbackObject(Vars.MusicLogicObject, this.OnMusicLogicObject, this)
};
TRexManager.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.TRexManagerObject, this)
};
TRexManager.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnVSLogicStartSounds, this);
    XT.UnregisterCallbackEvent(this.OnVSLogicStopSounds, this);
    XT.UnregisterCallbackEvent(this.Init, this);
    if (this.muteInFreeSpins) {
        XT.UnregisterCallbackEvent(this.FreeSpinsStarted, this);
        XT.UnregisterCallbackEvent(this.FreeSpinsEnded, this)
    }
    XT.UnregisterCallbackObject(this.OnSoundManagerChanged, this)
};
TRexManager.prototype.Init = function() {
    this.musicClips = [];
    this.clipsPlayingState = [];
    for (var i = 0; i < this.clips.length; i++) {
        this.musicClips.push(null);
        this.clipsPlayingState.push(false);
        if (this.musicLogic != null) this.musicClips[i] = this.musicLogic.GetMusicClipByAudioClip(this.clips[i].GetClip());
        if (this.musicClips[i] == null) this.musicClips[i] = this.sndManager.GetMusicClipByAudioClip(this.clips[i].GetClip());
        this.musicClips[i].volumeFadeInDuration = this.crossFadeDuration;
        this.musicClips[i].volumeFadeOutDuration =
            this.crossFadeDuration
    }
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    this.cantPlayInFS = this.muteInFreeSpins && (fsr.IsFreeSpin || fsr.IsLastFreeSpin)
};
TRexManager.prototype.FreeSpinsStarted = function() {
    this.cantPlayInFS = this.muteInFreeSpins && XT.GetObject(Vars.ReceivedFreeSpinsResponse).IsFreeSpin;
    for (var clipIndex = 0; clipIndex < this.musicClips.length; clipIndex++)
        if (this.musicClips[clipIndex].isPlaying) this.sndManager.MuteMusicClip(this.musicClips[clipIndex], true)
};
TRexManager.prototype.FreeSpinsEnded = function() {
    this.cantPlayInFS = this.muteInFreeSpins && XT.GetObject(Vars.ReceivedFreeSpinsResponse).IsFreeSpin;
    for (var clipIndex = 0; clipIndex < this.musicClips.length; clipIndex++)
        if (this.musicClips[clipIndex].isPlaying && this.clipsPlayingState[clipIndex]) this.sndManager.UnmuteMusicClip(this.musicClips[clipIndex], true)
};
TRexManager.prototype.StartPlayingClip = function(clipIndex) {
    if (!this.musicClips[clipIndex].isPlaying) {
        this.sndManager.PlayMusicClip(this.musicClips[clipIndex], true);
        this.sndManager.MuteMusicClip(this.musicClips[clipIndex], false)
    } else console.log("clip " + this.clips[clipIndex].GetClip().name + " is already playing.")
};
TRexManager.prototype.StartClip = function(clipIndex) {
    if (!this.musicClips[clipIndex].isPlaying) {
        console.log("You can't start an audio clip (" + this.musicClips[clipIndex].clip.name + ") that is not yet playing.");
        return
    }
    this.clipsPlayingState[clipIndex] = true;
    if (!this.cantPlayInFS && !this.isDisabled) this.sndManager.UnmuteMusicClip(this.musicClips[clipIndex], true)
};
TRexManager.prototype.StopClip = function(clipIndex) {
    this.clipsPlayingState[clipIndex] = false;
    if (!this.isDisabled) this.sndManager.MuteMusicClip(this.musicClips[clipIndex], true)
};
TRexManager.prototype.OnVSLogicStartSounds = function() {
    this.isDisabled = false;
    for (var clipIndex = 0; clipIndex < this.musicClips.length; clipIndex++) {
        if (!this.musicClips[clipIndex].isPlaying || this.cantPlayInFS) continue;
        if (this.clipsPlayingState[clipIndex]) this.sndManager.UnmuteMusicClip(this.musicClips[clipIndex], true)
    }
};
TRexManager.prototype.OnVSLogicStopSounds = function() {
    this.isDisabled = true;
    for (var clipIndex = 0; clipIndex < this.musicClips.length; clipIndex++) {
        if (!this.musicClips[clipIndex].isPlaying) continue;
        this.sndManager.MuteMusicClip(this.musicClips[clipIndex], true)
    }
};
TRexManager.prototype.OnSoundManagerChanged = function(mgr) {
    this.sndManager = mgr
};
TRexManager.prototype.OnMusicLogicObject = function(mLogic) {
    this.musicLogic = mLogic
};
goog.require("UHT.XTLink");
TRexController.prototype = Object.create(XTLink.prototype);
TRexController.prototype.constructor = TRexController;

function TRexController() {
    XTLink.call(this);
    TRexController.TRexLevel = {
        Idle: 0,
        Spin: 1,
        Win: 2,
        BigWin: 3
    };
    this.toIdleTimer = 10;
    this.toSpinTimer = 15;
    this.toWinTimer = 20;
    this.tm = null;
    this.currentLevel = TRexController.TRexLevel.Idle;
    this.currentTimerTarget = 0;
    this.currentTimer = 0
}
TRexController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.Init, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.GoToSpinLevel, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinEnded, this.GoToWinLevel, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ClearBigWin, this.GoToBigWinLevel, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StartVSLogicSounds, this.StartIdleMusic, this)
};
TRexController.prototype.XTInitVariablesAndEvents = function() {};
TRexController.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.Init, this);
    XT.UnregisterCallbackEvent(this.GoToSpinLevel, this);
    XT.UnregisterCallbackEvent(this.GoToWinLevel, this);
    XT.UnregisterCallbackEvent(this.GoToBigWinLevel, this);
    XT.UnregisterCallbackEvent(this.StartIdleMusic, this)
};
TRexController.prototype.Init = function() {
    this.tm = XT.GetObject(Vars.TRexManagerObject);
    this.currentState = TRexController.TRexLevel.Idle
};
TRexController.prototype.StartIdleMusic = function() {
    for (var clipIndex = 0; clipIndex < this.tm.clips.length; clipIndex++) this.tm.StartPlayingClip(clipIndex);
    if (this.currentState == TRexController.TRexLevel.Idle) this.tm.StartClip(0)
};
TRexController.prototype.GoToIdleMusic = function() {
    this.tm.StartClip(0);
    this.tm.StopClip(this.currentLevel);
    this.currentLevel = TRexController.TRexLevel.Idle;
    this.currentTimer = 0
};
TRexController.prototype.GoToSpinLevel = function() {
    if (this.currentLevel == TRexController.TRexLevel.Spin) {
        this.currentTimer = 0;
        return
    }
    if (this.currentLevel != TRexController.TRexLevel.Idle) return;
    this.currentTimerTarget = this.toIdleTimer;
    this.GoUpALevel()
};
TRexController.prototype.GoToWinLevel = function() {
    var betToCheck = 0;
    if (XT.GetBool(Vars.Jurisdiction_NoSmallWinCount)) betToCheck = CoinManager.GetLastTotalBet();
    if (this.currentLevel == TRexController.TRexLevel.Win && XT.GetDouble(Vars.WinReceived) > 0) {
        this.currentTimer = 0;
        return
    }
    if (this.currentLevel != TRexController.TRexLevel.Spin || XT.GetDouble(Vars.WinReceived) <= betToCheck) return;
    this.currentTimerTarget = this.toSpinTimer;
    this.GoUpALevel()
};
TRexController.prototype.GoToBigWinLevel = function() {
    this.currentTimerTarget = this.toWinTimer;
    if (this.currentLevel != TRexController.TRexLevel.BigWin) {
        this.tm.StopClip(this.currentLevel);
        this.currentLevel = TRexController.TRexLevel.BigWin;
        this.tm.StartClip(this.currentLevel)
    }
};
TRexController.prototype.GoUpALevel = function() {
    this.currentTimer = 0;
    this.tm.StopClip(this.currentLevel);
    this.tm.StartClip(++this.currentLevel)
};
TRexController.prototype.GoDownALevel = function() {
    this.currentTimer = 0;
    this.tm.StopClip(this.currentLevel);
    this.tm.StartClip(--this.currentLevel)
};
TRexController.prototype.Update = function() {
    if (this.currentLevel != TRexController.TRexLevel.Idle) {
        if (this.currentTimerTarget - this.currentTimer <= 1E-4) {
            this.GoDownALevel();
            switch (this.currentLevel) {
                case TRexController.TRexLevel.Win:
                    this.currentTimerTarget = this.toSpinTimer;
                    break;
                case TRexController.TRexLevel.Spin:
                    this.currentTimerTarget = this.toIdleTimer;
                    break;
                default:
                    break
            }
            return
        }
        this.currentTimer += Time.deltaTime
    }
};
goog.require("UHT.Engine");
SmallWinsMusic.prototype = Object.create(XTLink.prototype);
SmallWinsMusic.prototype.constructor = SmallWinsMusic;

function SmallWinsMusic() {
    XTLink.call(this);
    this.swCATintervals = null;
    this.swStartCATs = null;
    this.swStopCATs = null;
    this.isEnabled = true;
    this.currentWinInterval = -1;
    this.totalWinReceivedSoFarInFS = 0
}
SmallWinsMusic.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinCounterStop, this.CoinCounterStop, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinCounterStart, this.CoinCounterStart, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
};
SmallWinsMusic.prototype.XTInitVariablesAndEvents = function() {};
SmallWinsMusic.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.CoinCounterStop, this);
    XT.UnregisterCallbackEvent(this.CoinCounterStart, this)
};
SmallWinsMusic.prototype.OnGameInit = function() {
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr.IsFreeSpin) this.totalWinReceivedSoFarInFS = fsr.CurrentWin
};
SmallWinsMusic.prototype.CoinCounterStart = function() {
    if (XT.GetBool(Vars.SpinResultIsBigWin) || !this.isEnabled) {
        this.currentWinInterval = -1;
        return
    }
    this.currentWinInterval = this.GetCurrentInterval();
    if (this.currentWinInterval >= 0) this.swStartCATs[this.currentWinInterval].Start()
};
SmallWinsMusic.prototype.CoinCounterStop = function() {
    if (this.currentWinInterval >= 0) this.swStopCATs[this.currentWinInterval].Start();
    this.currentWinInterval = -1
};
SmallWinsMusic.prototype.GetCurrentInterval = function() {
    var totalWin = 0;
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr.IsFreeSpin)
        if (fsr.IsLastFreeSpin) {
            totalWin = (fsr.CurrentWin - this.totalWinReceivedSoFarInFS) * fsr.TotalMultiplier;
            this.totalWinReceivedSoFarInFS = 0
        } else {
            totalWin = XT.GetDouble(Vars.WinReceived) * fsr.TotalMultiplier;
            this.totalWinReceivedSoFarInFS = fsr.CurrentWin
        }
    else if (!XT.GetBool(Vars.MustOpenBonus)) totalWin = XT.GetDouble(Vars.WinReceived);
    var timesTotalBet = totalWin * 1E3 / CoinManager.GetLastTotalBet() /
        1E3;
    if (XT.GetBool(Vars.Jurisdiction_NoSmallWinCount))
        if (timesTotalBet <= 1) return -1;
    for (var i = this.swCATintervals.length - 1; i >= 0; i--)
        if (this.swCATintervals[i] < timesTotalBet) return i;
    return -1
};
SmallWinsMusic.prototype.EnableSWMusic = function() {
    this.isEnabled = true
};
SmallWinsMusic.prototype.DisableSWMusic = function() {
    this.isEnabled = false
};
goog.require("UHT.XTLink");
InterfaceStateChanger.prototype = Object.create(XTLink.prototype);
InterfaceStateChanger.prototype.constructor = InterfaceStateChanger;

function InterfaceStateChanger() {
    XTLink.call(this);
    this.gameStates = null;
    this.currentState = VSGameState.Invalid;
    this.shouldStickToCurrentState = false
}
InterfaceStateChanger.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ChangeVSGameState, this.OnVSGameStateChanged, this, 10)
};
InterfaceStateChanger.prototype.OnVSGameStateChanged = function() {
    if (this.shouldStickToCurrentState && VSGameStateManager.GetState() != this.currentState) VSGameStateManager.ChangeTo(this.currentState)
};
InterfaceStateChanger.prototype.LockToState = function(stateIdx) {
    this.currentState = this.gameStates[_number.otoi(stateIdx)];
    VSGameStateManager.ChangeTo(this.currentState);
    this.shouldStickToCurrentState = true
};
InterfaceStateChanger.prototype.UnlockAndChangeToState = function(stateIdx) {
    this.shouldStickToCurrentState = false;
    this.currentState = this.gameStates[_number.otoi(stateIdx)];
    VSGameStateManager.ChangeTo(this.currentState)
};
goog.require("UHT.FOXLink");
InitialSymbolsPatcherJK.prototype = Object.create(FOXLink.prototype);
InitialSymbolsPatcherJK.prototype.constructor = InitialSymbolsPatcherJK;

function InitialSymbolsPatcherJK() {
    FOXLink.call(this);
    this.resultID = null;
    this.randomID = null
}
InitialSymbolsPatcherJK.prototype.HandleSpinResponse = function(dict) {
    if (dict[GameProtocolDictionary.winSymbols] == undefined || dict[GameProtocolDictionary.symbolsBeforeExpanding] == undefined) return;
    var resultSymbols = _array.ConvertAll(dict[GameProtocolDictionary.winSymbols].split(","), _number.otoi);
    var initialSymbols = _array.ConvertAll(dict[GameProtocolDictionary.symbolsBeforeExpanding].split(","), _number.otoi);
    for (var i = 0; i < resultSymbols.length; ++i) {
        var symbolID = resultSymbols[i];
        if (this.resultID.indexOf(symbolID) >
            -1) initialSymbols[i] = symbolID
    }
    if (dict[GameProtocolDictionary.randomWildsData] != undefined) {
        var randomWilds = dict[GameProtocolDictionary.randomWildsData].split(";");
        for (var i = 0; i < randomWilds.length; i++) {
            var split = randomWilds[i].split("~");
            if (split.length < 2) continue;
            var symbolID = _number.otoi(split[0]);
            if (this.randomID.indexOf(symbolID) < 0) continue;
            var positions = _array.ConvertAll(split[1].split(","), _number.otoi);
            for (var j = 0; j < positions.length; j++) initialSymbols[positions[j]] = symbolID
        }
    }
    dict[GameProtocolDictionary.symbolsBeforeExpanding] =
        initialSymbols.join(",")
};
goog.require("UHT.FOXLink");
ScattersPossibleWinJK.prototype = Object.create(FOXLink.prototype);
ScattersPossibleWinJK.prototype.constructor = ScattersPossibleWinJK;

function ScattersPossibleWinJK() {
    FOXLink.call(this);
    this.scatterID = 0;
    this.scatterMinCombo = 0;
    this.animationInjector = null;
    this.eventAnimationEnded = "";
    this.possibleWinReelIndicesXTVar = "";
    this.reelsCount = 0;
    this.endedCount = 0;
    this.reelIndices = [];
    this.possibleWinReelIndices = [];
    this.symbolPositions = [];
    this.possibleWinSymbolPositions = []
}
ScattersPossibleWinJK.prototype.XTRegisterCallbacks = function() {
    FOXLink.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackObject(Vars.ReelsManagerObject, this.OnReelsManager, this);
    XT.RegisterCallbackEvent(this.eventAnimationEnded, this.OnAnimationEnded, this)
};
ScattersPossibleWinJK.prototype.XTInitVariablesAndEvents = function() {
    FOXLink.prototype.XTInitVariablesAndEvents.call(this);
    XT.SetObject(this.possibleWinReelIndicesXTVar, this.possibleWinReelIndices)
};
ScattersPossibleWinJK.prototype.OnReelsManager = function(param) {
    this.reelsCount = param.reels.length
};
ScattersPossibleWinJK.prototype.HandleSpinResponse = function(dict) {
    this.endedCount = 0;
    this.reelIndices.splice(0);
    this.possibleWinReelIndices.splice(0);
    this.symbolPositions.splice(0);
    this.possibleWinSymbolPositions.splice(0);
    if (dict[GameProtocolDictionary.symbolsBeforeExpanding] == undefined) return;
    var symbols = _array.ConvertAll(dict[GameProtocolDictionary.symbolsBeforeExpanding].split(","), _number.otoi);
    for (var i = 0; i < symbols.length; ++i) {
        if (symbols[i] != this.scatterID) continue;
        var reelIdx = i % this.reelsCount;
        this.reelIndices.push(reelIdx);
        this.symbolPositions.push(i)
    }
    if (this.reelIndices.length == 0) return;
    var stopOrder = XT.GetObject(Vars.ReelsStopOrder);
    var minCombo = this.scatterMinCombo;
    for (var i = 0; i < stopOrder.length; ++i) {
        var reelIdx = stopOrder[i];
        if (this.reelIndices.indexOf(reelIdx) > -1 && --minCombo + reelIdx < this.reelsCount) this.possibleWinReelIndices.push(reelIdx)
    }
    if (this.possibleWinReelIndices.length == 0) return;
    for (var i = 0; i < this.symbolPositions.length; ++i) {
        var position = this.symbolPositions[i];
        var reelIdx =
            position % this.reelsCount;
        if (this.possibleWinReelIndices.indexOf(reelIdx) > -1) this.possibleWinSymbolPositions.push(position)
    }
    this.animationInjector.InjectRQ()
};
ScattersPossibleWinJK.prototype.OnAnimationEnded = function() {
    if (++this.endedCount == this.possibleWinSymbolPositions.length) this.animationInjector.UninjectRQ()
};
goog.provide("UHT.FeatureIDProvider");
goog.require("UHT.XTLink");
FeatureIDProvider.prototype = Object.create(XTLink.prototype);
FeatureIDProvider.prototype.constructor = FeatureIDProvider;

function FeatureIDProvider() {
    XTLink.call(this);
    this.featureID = -1
}
goog.require("UHT.FeatureIDProvider");
FeatureIDProviderParameter.prototype = Object.create(FeatureIDProvider.prototype);
FeatureIDProviderParameter.prototype.constructor = FeatureIDProviderParameter;

function FeatureIDProviderParameter() {
    FeatureIDProvider.call(this);
    this.parameter = "";
    this.values = null;
    this.ids = null;
    this.useDefaultID = false;
    this.defaultID = 0;
    this.useIncludedResponses = false;
    this.includedResponses = null
}
FeatureIDProviderParameter.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(FOXVars.FOX_Response, this.OnResponse, this)
};
FeatureIDProviderParameter.prototype.OnResponse = function(param) {
    if (this.useIncludedResponses && this.includedResponses.indexOf(GameConnection.I.requestState) < 0) return;
    var dict = param;
    this.featureID = -1;
    if (dict[this.parameter] != undefined && this.values != null) {
        var idx = this.values.indexOf(dict[this.parameter]);
        if (idx > -1) this.featureID = this.ids[idx]
    }
    if (this.useDefaultID && this.featureID < 0) this.featureID = this.defaultID
};
goog.require("UHT.XTLink");
JurisdictionGameTitle.prototype = Object.create(XTLink.prototype);
JurisdictionGameTitle.prototype.constructor = JurisdictionGameTitle;

function JurisdictionGameTitle() {
    XTLink.call(this);
    this.miniFontSize = 50;
    this.miniTopOffset = 158;
    this.miniRightOffset = 20;
    this.miniScale = .69;
    this.copyFontStylesFromClockDesktop = true;
    this.copyFontStylesFromClockMobile = true;
    this.copyFontStylesFromClockMini = true;
    this.isPatched = false
}
JurisdictionGameTitle.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.Jurisdiction_GameTitle, this.OnJurisdictionGameTitleChanged, this)
};
JurisdictionGameTitle.prototype.OnJurisdictionGameTitleChanged = function(isGT) {
    this.gameObject.SetActive(isGT);
    GUIArranger.I.logoObjectAnchor.gameObject.SetActive(!isGT);
    var labels = this.gameObject.GetComponentsInChildren(UILabel, true);
    if (labels.length > 0) XT.SetString(Vars.GameTitle, labels[0].text);
    if (!isGT || this.isPatched) return;
    if (Globals.isMini) {
        this.PatchForMini();
        if (this.copyFontStylesFromClockMini) this.CopyFontStylesFromClock()
    } else if (Globals.isMobile) {
        this.PatchForMobile();
        if (this.copyFontStylesFromClockMobile) this.CopyFontStylesFromClock()
    }
    if (this.copyFontStylesFromClockDesktop &&
        !Globals.isMobile) this.CopyFontStylesFromClock();
    this.isPatched = true
};
JurisdictionGameTitle.prototype.PatchForMini = function() {
    var anchors = this.gameObject.GetComponentsInChildren(ScreenAnchor, true);
    if (anchors.length == 0) return;
    var labels = this.gameObject.GetComponentsInChildren(UILabel, true);
    for (var i = 0; i < labels.length; i++) {
        labels[i].fontSize = this.miniFontSize;
        var tmpColor = labels[i].color;
        labels[i].color = tmpColor;
        labels[0].init()
    }
    for (var i = 0; i < anchors.length; i++) {
        anchors[i].anchorTop = true;
        anchors[i].topOffset = this.miniTopOffset;
        anchors[i].rightOffset = anchors[i].rightOffset *
            (1 / this.miniScale) + this.miniRightOffset;
        anchors[i].transform.localScale(new UHTMath.Vector3(this.miniScale * labels[i].resize, this.miniScale * labels[i].resize, anchors[i].transform.localScale().z))
    }
};
JurisdictionGameTitle.prototype.CopyFontStylesFromClock = function() {
    var clockParent = globalRuntime.sceneRoots[1].transform.GetComponentsInChildren(ClockDisplayer, true)[0];
    var clockLabel = clockParent.gameObject.GetComponentsInChildren(UILabel, true)[0];
    var labels = this.gameObject.GetComponentsInChildren(UILabel, true);
    for (var i = 0; i < labels.length; i++) {
        labels[i].color = clockLabel.color;
        labels[i].effectStyle = clockLabel.effectStyle;
        labels[i].effectColor = clockLabel.effectColor;
        var computedEffectDistanceX = clockLabel.effectWidth *
            (labels[i].fontSize / clockLabel.fontSize);
        var computedEffectDistanceY = clockLabel.effectHeight * (labels[i].fontSize / clockLabel.fontSize);
        labels[i].effectWidth = computedEffectDistanceX;
        labels[i].effectHeight = computedEffectDistanceY;
        labels[i].init()
    }
    if (labels.length > 0)
        for (var i = 0; i < GUIArranger.I.gameTitles.length; ++i) {
            GUIArranger.I.gameTitles[i].SetColor(labels[0].color);
            GUIArranger.I.gameTitles[i].effectStyle = labels[0].effectStyle;
            GUIArranger.I.gameTitles[i].effectColor = labels[0].effectColor;
            GUIArranger.I.gameTitles[i].effectWidth =
                labels[0].effectWidth;
            GUIArranger.I.gameTitles[i].effectHeight = labels[0].effectHeight
        }
};
JurisdictionGameTitle.prototype.PatchForMobile = function() {
    var labels = this.gameObject.GetComponentsInChildren(UILabel, true);
    if (labels.length == 0) return;
    var arrangeables = this.gameObject.GetComponentsInChildren(ArrangeableActive, true);
    if (arrangeables.length > 0) {
        for (var i = 0; i < arrangeables.length; ++i)
            if (arrangeables[i].activeInPortrait) {
                arrangeables[i].activeInPortrait = false;
                arrangeables[i].gameObject.SetActive(false)
            }
        return
    }
    var isActive = true;
    switch (LayoutManager.layoutMode) {
        case LayoutManager.Mode.Portrait:
        case LayoutManager.Mode.PortraitIPad:
        case LayoutManager.Mode.PortraitIPhone:
            isActive =
                false;
            break
    }
    for (var i = 0; i < labels.length; ++i) {
        var arrangeable = labels[i].gameObject.AddComponent("ArrangeableActive");
        arrangeable.useOnMobile = true;
        arrangeable.activeInLandscape = true;
        arrangeable.activeInPortrait = false;
        labels[i].gameObject.SetActive(isActive)
    }
};
goog.require("UHT.Engine");
BigWin.prototype = Object.create(XTLink.prototype);
BigWin.prototype.constructor = BigWin;

function BigWin() {
    XTLink.call(this);
    this.catContainter = null;
    this.hideLevelsIndividually = false;
    this.skipJackpotWin = false;
    this.showOnlyJackpotWin = false;
    this.nextLevelToShow = -1;
    this.isAnyLevelActive = false
}
BigWin.CatEvents = {
    hide: 0,
    lvl_1: 1,
    lvl_2: 2,
    lvl_3: 3,
    lvl_4: 4,
    lvl_5: 5,
    jackpot: 6,
    counter: 7,
    hide_lvl_1: 8,
    hide_lvl_2: 9,
    hide_lvl_3: 10,
    hide_lvl_4: 11,
    hide_lvl_5: 12
};
BigWin.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackInt(Vars.BigWinLevel, this.OnShowBigWinLevel, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ShowBigWin, this.OnShowBigWin, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ClearBigWin, this.OnClearBigWin, this)
};
BigWin.prototype.OnDestroy = function() {
    XT.UnregisterCallbackInt(this.OnShowBigWinLevel, this);
    XT.UnregisterCallbackEvent(this.OnShowBigWin, this);
    XT.UnregisterCallbackEvent(this.OnClearBigWin, this)
};
BigWin.prototype.OnShowBigWinLevel = function(lvl) {
    this.nextLevelToShow = lvl
};
var GA_BW_SENDONESKIP = false;
BigWin.prototype.OnShowBigWin = function() {
    var isJackpotWin = XT.GetBool(Vars.FromServer_IsJackpotWin);
    if (this.skipJackpotWin && isJackpotWin || this.showOnlyJackpotWin && !isJackpotWin) return;
    this.isAnyLevelActive = true;
    this.catContainter.StartEvent(this.nextLevelToShow);
    if (this.nextLevelToShow > 0 && this.nextLevelToShow < 6) {
        globalTracking.SendEvent("uht_behaviour_BigWin", "GotLevel_" + this.nextLevelToShow.toString(), this.nextLevelToShow, "BehaviourTracker");
        GA_BW_SENDONESKIP = true
    }
};
BigWin.prototype.OnClearBigWin = function() {
    if (!this.isAnyLevelActive) return;
    if (this.hideLevelsIndividually) this.catContainter.StartEvent(this.nextLevelToShow + 7);
    else this.catContainter.StartEvent(BigWin.CatEvents.hide);
    this.isAnyLevelActive = false
};
goog.require("UHT.Engine");
BigWinSkipper.prototype = Object.create(XTLink.prototype);
BigWinSkipper.prototype.constructor = BigWinSkipper;

function BigWinSkipper() {
    XTLink.call(this)
}
BigWinSkipper.timeOfFirstClick = -1;
BigWinSkipper.prototype.OnClick = function() {
    if (UHT_DEVICE_TYPE.MOBILE)
        if (BigWinSkipper.timeOfFirstClick > 0) {
            if (Time.time - BigWinSkipper.timeOfFirstClick > 4) {
                BigWinSkipper.timeOfFirstClick = Time.time;
                return
            }
        } else {
            BigWinSkipper.timeOfFirstClick = Time.time;
            return
        }
    BigWinSkipper.timeOfFirstClick = -1;
    if (XT.GetBool(Vars.WaitInResultForBigWin)) XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin)
};
goog.provide("UHT.PaytableSymbolPayout_Ways");
goog.require("UHT.XTLink");
PaytableSymbolPayout_Ways.prototype = Object.create(XTLink.prototype);
PaytableSymbolPayout_Ways.prototype.constructor = PaytableSymbolPayout_Ways;

function PaytableSymbolPayout_Ways() {
    XTLink.call(this);
    this.symbolIndex = 0;
    this.isDisplayingCoins = false;
    this.isMultipliedByTotalBet = false;
    this.showOnlyValue = false;
    this.isDisplayingRange = false;
    this.ignoreRightUpperRange = false;
    this.updatedUpperRange = false;
    this.rangeDelimiter = " - ";
    this.valueDelimiter = "  ";
    this.rightUpperRangeReplacer = "+";
    this.customPayoutData = null;
    this.formatOptions = null
}
PaytableSymbolPayout_Ways.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
};
PaytableSymbolPayout_Ways.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGameInit, this);
    XT.UnregisterCallbackEvent(this.UpdateSymbolPayoutInformation, this);
    XT.UnregisterCallbackBool(this.OnHasCoinsChanged, this)
};
PaytableSymbolPayout_Ways.prototype.OnGameInit = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_BetChanged, this.UpdateSymbolPayoutInformation, this);
    XT.RegisterCallbackBool(Vars.HasCoins, this.OnHasCoinsChanged, this);
    this.UpdateSymbolPayoutInformation()
};
PaytableSymbolPayout_Ways.prototype.OnHasCoinsChanged = function(param) {
    this.UpdateSymbolPayoutInformation()
};
PaytableSymbolPayout_Ways.prototype.UpdateSymbolPayoutInformation = function() {
    var payoutData = XT.GetObject(Vars.PaytablePayoutData);
    if (payoutData == null) return;
    this.gameObject.GetComponent(UILabel).text = this.GetProcessedText(this.customPayoutData.length == 0 ? payoutData[this.symbolIndex] : this.customPayoutData)
};
PaytableSymbolPayout_Ways.prototype.GetProcessedText = function(symbolPayoutData) {
    var symbolPayoutText = "";
    var multiplier = this.isMultipliedByTotalBet ? CoinManager.GetNextTotalBet() : CoinManager.GetNextBet();
    if (this.isDisplayingRange) {
        this.updatedUpperRange = false;
        var rangeUpperLimits = [];
        var rangeLowerLimits = [];
        var currentRangeUpperLimit = symbolPayoutData.length - 1;
        var currentRangeLowerLimit = symbolPayoutData.length - 1;
        rangeUpperLimits.push(currentRangeUpperLimit);
        for (var payoutLineIndex = symbolPayoutData.length -
                1; payoutLineIndex >= 0; payoutLineIndex--)
            if (symbolPayoutData[currentRangeUpperLimit] != symbolPayoutData[payoutLineIndex]) {
                currentRangeUpperLimit = payoutLineIndex;
                rangeUpperLimits.push(currentRangeUpperLimit)
            }
        for (var i = 0; i < rangeUpperLimits.length; i++) {
            for (var _payoutLineIndex = rangeUpperLimits[i]; _payoutLineIndex >= 0; _payoutLineIndex--)
                if (symbolPayoutData[rangeUpperLimits[i]] == symbolPayoutData[_payoutLineIndex]) currentRangeLowerLimit = _payoutLineIndex;
                else break;
            rangeLowerLimits.push(currentRangeLowerLimit)
        }
        for (var idx =
                0; idx < rangeUpperLimits.length; idx++) {
            if (symbolPayoutData[rangeUpperLimits[idx]] <= 0) continue;
            var realValueStr = "";
            if (this.isDisplayingCoins && XT.GetBool(Vars.HasCoins)) realValueStr = CoinManager.ConvertMoneyToCoins(symbolPayoutData[rangeUpperLimits[idx]] * multiplier).toString();
            else realValueStr = LocaleManager.FormatValue(symbolPayoutData[rangeUpperLimits[idx]] * multiplier, this.formatOptions);
            if (rangeUpperLimits[idx] == rangeLowerLimits[idx]) symbolPayoutText += (this.showOnlyValue ? "" : (symbolPayoutText == "" ? "" :
                "\n") + (rangeUpperLimits[idx] + 1) + this.valueDelimiter) + realValueStr;
            else if (this.ignoreRightUpperRange && !this.updatedUpperRange) {
                this.updatedUpperRange = true;
                symbolPayoutText += (this.showOnlyValue ? "" : (symbolPayoutText == "" ? "" : "\n") + (rangeLowerLimits[idx] + 1) + this.rightUpperRangeReplacer + this.valueDelimiter) + realValueStr
            } else symbolPayoutText += (this.showOnlyValue ? "" : (symbolPayoutText == "" ? "" : "\n") + (rangeLowerLimits[idx] + 1) + this.rangeDelimiter + (rangeUpperLimits[idx] + 1) + this.valueDelimiter) + realValueStr
        }
    } else
        for (var payoutLineIndex =
                symbolPayoutData.length - 1; payoutLineIndex >= 0; payoutLineIndex--)
            if (symbolPayoutData[payoutLineIndex] > 0) {
                var realValueStr = "";
                if (this.isDisplayingCoins && XT.GetBool(Vars.HasCoins)) realValueStr = CoinManager.ConvertMoneyToCoins(symbolPayoutData[payoutLineIndex] * multiplier).toString();
                else realValueStr = LocaleManager.FormatValue(symbolPayoutData[payoutLineIndex] * multiplier, this.formatOptions);
                symbolPayoutText += (this.showOnlyValue ? "" : (symbolPayoutText == "" ? "" : "\n") + (payoutLineIndex + 1) + " - ") + realValueStr
            } return symbolPayoutText
};
goog.require("UHT.PaytableSymbolPayout_Ways");
PaytableSymbolPayout.prototype = Object.create(PaytableSymbolPayout_Ways.prototype);
PaytableSymbolPayout.prototype.constructor = PaytableSymbolPayout;

function PaytableSymbolPayout() {
    PaytableSymbolPayout_Ways.call(this)
}
PaytableSymbolPayout.prototype.UpdateSymbolPayoutInformation = function() {
    if (this.customPayoutData == null) {
        this.isDisplayingCoins = true;
        this.showOnlyValue = false;
        this.customPayoutData = [];
        this.formatOptions = new FormatOptions
    }
    PaytableSymbolPayout_Ways.prototype.UpdateSymbolPayoutInformation.call(this)
};
goog.require("UHT.XTLink");
RTPInfoSelector.prototype = Object.create(XTLink.prototype);
RTPInfoSelector.prototype.constructor = RTPInfoSelector;

function RTPInfoSelector() {
    XTLink.call(this);
    this.List1RTP = [];
    this.List2RTP = []
}
RTPInfoSelector.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
};
RTPInfoSelector.prototype.OnGameInit = function() {
    var showList1 = false;
    var showList2 = false;
    if (XT.GetDouble(Vars.ReturnToPlayer) >= 0)
        if (XT.GetDouble(Vars.ReturnToPlayerMin) >= 0) showList2 = true;
        else showList1 = true;
    var i = 0;
    for (i = 0; i < this.List1RTP.length; i++) this.List1RTP[i].SetActive(showList1);
    for (i = 0; i < this.List2RTP.length; i++) this.List2RTP[i].SetActive(showList2)
};
goog.require("UHT.FOXLink");
JurisdictionShowXChance.prototype = Object.create(FOXLink.prototype);
JurisdictionShowXChance.prototype.constructor = JurisdictionShowXChance;

function JurisdictionShowXChance() {
    FOXLink.call(this);
    this.chanceLabel = null
}
JurisdictionShowXChance.prototype.HandleInitResponse = function(dict) {
    if (!XT.GetBool(Vars.Jurisdiction_Show_X_Chance)) return;
    var gameInfo = null;
    if (dict["gameInfo"]) gameInfo = JSON5.parse(dict["gameInfo"]);
    var chanceInfoIsValid = false;
    if (gameInfo != null && gameInfo["props"] != null)
        if (gameInfo["props"]["max_rnd_win"] != null && gameInfo["props"]["max_rnd_hr"] != null) {
            var formatOptions = new FormatOptions;
            formatOptions.hasDecimals = false;
            formatOptions.hasCurrency = false;
            var maxRoundWin = LocaleManager.FormatValue(gameInfo["props"]["max_rnd_win"],
                formatOptions);
            var maxRoundHitRate = LocaleManager.FormatValue(gameInfo["props"]["max_rnd_hr"], formatOptions);
            this.chanceLabel.text = this.chanceLabel.text.replace("{0}", maxRoundWin + "X");
            this.chanceLabel.text = this.chanceLabel.text.replace("{1}", maxRoundHitRate);
            this.chanceLabel.gameObject.SetActive(true);
            var root = globalRuntime.sceneRoots[1];
            if (!Globals.isMobile) {
                var paytableArrangers = root.GetComponentsInChildren(window["PaytableArranger"], true);
                for (var i = 0; i < paytableArrangers.length; i++) {
                    var bkgSprite =
                        paytableArrangers[i].panelUnder.GetComponentsInChildren(UISprite, true)[0];
                    if (bkgSprite != null) {
                        bkgSprite.transform.localPosition(new UHTMath.Vector3(bkgSprite.transform.localPosition().x, -39, bkgSprite.transform.localPosition().z));
                        bkgSprite.transform.localScale(new UHTMath.Vector3(bkgSprite.transform.localScale().x, 1.097, bkgSprite.transform.localScale().z))
                    }
                }
            }
            chanceInfoIsValid = true
        }
    if (!chanceInfoIsValid) XT.SetBool(Vars.Jurisdiction_Show_X_Chance, false)
};
goog.require("UHT.BonusGameMultiplePicks");
goog.require("UHT.PickableItemBase");
goog.require("UHT.StickyReel");
goog.require("UHT.VSGameStateManager");
goog.require("UHT.VS_SpinExciter");
goog.require("UHT.Engine");
AGCCController.prototype = Object.create(Component.prototype);
AGCCController.prototype.constructor = AGCCController;

function AGCCController() {
    Component.call(this);
    this.image = null;
    this.shouldShow = false
}
AGCCController.prototype.Update = function() {
    if (UHT_GAME_CONFIG != null) {
        this.shouldShow = UHT_GAME_CONFIG["jurisdictionMsg"] == "imageAGCC";
        this.image.SetActive(this.shouldShow)
    }
    if (this.shouldShow) {
        var myCamera = Globals.GetCameraForObject(this.image);
        if (myCamera != null) {
            var posOnScreen = new UHTMath.Vector3(0, 0, 0);
            posOnScreen.y = UHTScreen.height;
            var posOnWorld = myCamera.ScreenToWorldPoint(posOnScreen);
            var pos = this.image.transform.position();
            this.image.transform.position(pos.x, posOnWorld.y + .05, pos.z)
        }
        if (UHTScreen.width >=
            UHTScreen.height * 1.4) this.image.transform.localScale(2.1, 2.1, 2.1);
        else if (UHTScreen.width >= UHTScreen.height) this.image.transform.localScale(1.7, 1.7, 1.7);
        else if (UHTScreen.width < UHTScreen.height) this.image.transform.localScale(1.05, 1.05, 1.05);
        var clientLoader = globalRuntime.sceneRoots[0].GetComponentsInChildren(ClientLoader)[0];
        clientLoader.transform.localScale(.6, .6, .6);
        clientLoader.transform.localPosition(0, 30, 0)
    }
};
goog.require("UHT.Engine");
AnimatedScaledBar.prototype = Object.create(Component.prototype);
AnimatedScaledBar.prototype.constructor = AnimatedScaledBar;

function AnimatedScaledBar() {
    Component.call(this);
    this.target = null;
    this.clip = null
}
AnimatedScaledBar.prototype.Scale = function(scale) {
    var animationState = this.target.GetAnimationState(this.clip.name);
    animationState.enabled = true;
    animationState.weight = 1;
    animationState.time = scale * animationState.length;
    this.target.Sample();
    animationState.enabled = false
};
goog.require("UHT.Engine");
ClientLoader.prototype = Object.create(Component.prototype);
ClientLoader.prototype.constructor = ClientLoader;
var UHT_LOADER_DEBUG = false;

function ClientLoader() {
    Component.call(this);
    this.scaledBar = null;
    this.minTimeForLoader = 0;
    this.percentLabel = null;
    this.shouldHide = -1;
    this.timeSpentInLoader = 0;
    this.curScale = 0;
    this.maxDeltaScale = .01;
    this.animatedBars = null;
    this.tryToHide = false
}
ClientLoader.progressPercent = 0;
ClientLoader.prototype.Start = function() {
    UHTEngine.StartDownloadingMainGame(this, "UNUSED", "OnRequestToHideLoader");
    this.scaledBar.transform.localScale(0, 1, 1);
    for (var i = 0; i < this.animatedBars.length; ++i) this.animatedBars[i].Scale(0);
    this.percentLabel.gameObject.SetActive(false);
    UHTEngine.HideFirstLoader()
};
ClientLoader.prototype.OnRequestToHideLoader = function() {
    this.tryToHide = true
};

function padLeft(nr, n, str) {
    return Array(n - String(nr).length + 1).join(str || "0") + nr
}
ClientLoader.prototype.Update = function() {
    this.timeSpentInLoader += Time.deltaTime;
    if (this.timeSpentInLoader < this.minTimeForLoader) return;
    this.percentLabel.gameObject.SetActive(true);
    LoaderProgress.Download_Total = UHT_GAME_SIZE;
    if (LoaderProgress.Download_AlreadyDownloaded == -1) {
        LoaderProgress.Download_Weight *= 1 - (LoaderProgress.Download_Current + 1) / (LoaderProgress.Download_Total + 1);
        LoaderProgress.GameAndSound_Download_Weight *= 1 - (LoaderProgress.Download_Current + 1) / (LoaderProgress.Download_Total + 1);
        LoaderProgress.Download_AlreadyDownloaded =
            LoaderProgress.Download_Current
    }
    if (LoaderProgress.Download_SoundAlreadyDownloaded == -1) {
        LoaderProgress.Sound_Download_Weight *= 1 - (LoaderProgress.Sound_Download_Current + 1) / (LoaderProgress.Sound_Download_Total + 1);
        LoaderProgress.Download_SoundAlreadyDownloaded = LoaderProgress.Sound_Download_Current
    }
    if (globalResourcesNeededList.length != 0 || UHTEngine.WaitingForSounds()) this.shouldHide = -1;
    else if (this.tryToHide && this.shouldHide < 0) this.shouldHide = 5;
    if (this.shouldHide != 0) {
        var DL_Total = 0;
        var DL_Loaded = 0;
        for (var j =
                0; j < globalResourcesNeededInfo.length; j++) {
            if (globalResourcesNeededInfo[j].baseTexture.source.downloadSizeTotal == undefined) {
                if (globalResourcesNeededInfo[j].valid) DL_Loaded++;
                DL_Total++;
                continue
            }
            var loaded = globalResourcesNeededInfo[j].baseTexture.source.downloadSizeLoaded;
            var total = globalResourcesNeededInfo[j].baseTexture.source.downloadSizeTotal;
            DL_Loaded += loaded;
            if (total == -1) DL_Total = -1;
            else if (DL_Total != -1) DL_Total += total
        }
        if (DL_Total > 0) {
            LoaderProgress.Blocking_Current = DL_Loaded;
            LoaderProgress.Blocking_Total =
                DL_Total
        }
        if (this.tryToHide)
            if (LoaderProgress.Blocking_Total == -1 && globalResourcesNeededInfo.length == 0) {
                LoaderProgress.Blocking_Current = 1;
                LoaderProgress.Blocking_Total = 1
            }
        if (LoaderProgress.InitConnection_Visual < LoaderProgress.InitConnection_Current) LoaderProgress.InitConnection_Visual += .2;
        LoaderProgress.Sound_Download_Weight = 0;
        LoaderProgress.Download_Weight = LoaderProgress.GameAndSound_Download_Weight;
        var Total_Weight = LoaderProgress.Download_Weight + (window["UHT_ForceClickForSounds"] != undefined ? 0 : UHT_DEVICE_TYPE.DESKTOP ?
            LoaderProgress.Sound_Download_Weight : 0) + LoaderProgress.Import_Weight + LoaderProgress.Import_Textures_Weight + LoaderProgress.InitConnection_Weight + LoaderProgress.Localize_Weight + LoaderProgress.Blocking_Weight + LoaderProgress.SymbolsManagers_Weight + .02;
        var realScale = 0;
        realScale += ((LoaderProgress.Download_Current - LoaderProgress.Download_AlreadyDownloaded + 1) / (LoaderProgress.Download_Total - LoaderProgress.Download_AlreadyDownloaded + 1) * (1 - LoaderProgress.Download_Retried_LockedPercent) + LoaderProgress.Download_Retried_LockedPercent) *
            (LoaderProgress.Download_Weight / Total_Weight);
        if (UHT_DEVICE_TYPE.DESKTOP && LoaderProgress.Sound_Download_Total != -1) realScale += (LoaderProgress.Sound_Download_Current - LoaderProgress.Download_SoundAlreadyDownloaded + 1) / (LoaderProgress.Sound_Download_Total - LoaderProgress.Download_SoundAlreadyDownloaded + 1) * (LoaderProgress.Sound_Download_Weight / Total_Weight);
        if (LoaderProgress.Import_Total != -1) realScale += LoaderProgress.Import_Current / LoaderProgress.Import_Total * (LoaderProgress.Import_Weight / Total_Weight);
        if (LoaderProgress.Import_Textures_Total != -1) {
            var texturesProgress = LoaderProgress.Import_Textures_Current / LoaderProgress.Import_Textures_Total;
            texturesProgress = UHTMath.clamp(texturesProgress, 0, 1);
            realScale += texturesProgress * (LoaderProgress.Import_Textures_Weight / Total_Weight)
        }
        realScale += LoaderProgress.InitConnection_Visual / LoaderProgress.InitConnection_Total * (LoaderProgress.InitConnection_Weight / Total_Weight);
        realScale += LoaderProgress.Localize_Current / LoaderProgress.Localize_Total * (LoaderProgress.Localize_Weight /
            Total_Weight);
        if (LoaderProgress.Blocking_Total != -1) realScale += LoaderProgress.Blocking_Current / LoaderProgress.Blocking_Total * (LoaderProgress.Blocking_Weight / Total_Weight);
        if (LoaderProgress.SymbolsManagers_Total != -1) realScale += LoaderProgress.SymbolsManagers_Current / LoaderProgress.SymbolsManagers_Total * (LoaderProgress.SymbolsManagers_Weight / Total_Weight);
        var delta = realScale - this.curScale;
        if (delta < 0) delta = 0;
        if (delta > this.maxDeltaScale * (2.5 / delta) * realScale) delta = this.maxDeltaScale * (2.5 / delta) * realScale;
        this.curScale += delta;
        if (UHT_LOADER_DEBUG) UHT_DEBUG_TEXT = "\nLP:   " + Number(realScale).toFixed(2) + "      " + Number(this.curScale).toFixed(2) + "      " + "\n  IC " + padLeft(LoaderProgress.Import_Current, 6, " ") + "/" + padLeft(LoaderProgress.Import_Total, 6, " ") + "\n  IT " + padLeft(LoaderProgress.Import_Textures_Current, 6, " ") + "/" + padLeft(LoaderProgress.Import_Textures_Total, 6, " ") + "\n       CC " + padLeft(LoaderProgress.InitConnection_Current, 1, " ") + "  CV " + Number(LoaderProgress.InitConnection_Visual).toFixed(2) +
            "  CT " + padLeft(LoaderProgress.InitConnection_Total, 1, " ") + "\n       LC " + padLeft(LoaderProgress.Localize_Current, 1, " ") + "/" + padLeft(LoaderProgress.Localize_Total, 1, " ") + "\n       BLOCK " + padLeft(LoaderProgress.Blocking_Current, 10, " ") + "  BT " + padLeft(LoaderProgress.Blocking_Total, 10, " ") + "\n       SM " + padLeft(LoaderProgress.SymbolsManagers_Current, 3, " ") + "/" + padLeft(LoaderProgress.SymbolsManagers_Total, 3, " ") + "\n       DL " + padLeft(LoaderProgress.Download_Current, 8, " ") + "/" + padLeft(LoaderProgress.Download_Total,
                8, " ")
    }
    if (this.shouldHide == 0) {
        this.gameObject.SetActive(false);
        UHTEngine.SignalLoaderIsHidden();
        LoadingStep = 4;
        globalTracking.StartTimer("uht_loading", "_CLOSED_at_PLAYING", "LoadingTracker");
        globalTracking.StopTimerAndSend("uht_loading", "_3_game_opening_and_connecting", "LoadingTracker");
        var timer = globalTracking.GetTimerValue("uht_loading", "_3_game_opening_and_connecting", "LoadingTracker");
        globalTracking.SendEvent("uht_loading", "_3_game_opening_and_connecting", timer, "LoadingTracker");
        globalTracking.StopTimerAndSend("uht_loading",
            "_4_loading_total_time", "LoadingTracker");
        var timer_all = globalTracking.GetTimerValue("uht_loading", "_4_loading_total_time", "LoadingTracker");
        globalTracking.SendEvent("uht_loading", "_4_loading_total_time", timer_all, "LoadingTracker");
        globalTracking.SendEvent("uht_behaviour", "Session_started", Renderer.IsWebGL ? 1 : 0, "BehaviourTracker");
        globalTracking.StartTimer("uht_behaviour", "Session_timer", "BehaviourTracker");
        UHTInterfaceBOSS.PostMessage("gameLoadingEnded");
        window["RC2API"]["PostMessage"]("gameLoaded");
        window["RC_timer"] = (new Date).getTime();
        window["RC_sessionTimer"] = window["RC_timer"];
        if (UHT_GAME_CONFIG["rcSettings"] != null)
            if (UHT_GAME_CONFIG["rcSettings"]["elapsed"] != undefined) window["RC_sessionTimer"] -= UHT_GAME_CONFIG["rcSettings"]["elapsed"] * 6E4
    } else if (this.shouldHide > 0) {
        this.shouldHide--;
        if (this.curScale + this.shouldHide * .004 < 1) this.curScale += .004
    }
    this.curScale = UHTMath.clamp(this.curScale, 0, 1);
    var adjustedScale = this.curScale < .5 ? .5 - 2 * (.5 - this.curScale) * (.5 - this.curScale) : 2 * (this.curScale - .5) *
        (this.curScale - .5) + .5;
    this.scaledBar.transform.localScale(adjustedScale, 1, 1);
    for (var i = 0; i < this.animatedBars.length; ++i) this.animatedBars[i].Scale(adjustedScale);
    var clampedScale = UHTMath.clamp(adjustedScale, .01, 1);
    this.percentLabel.text = Math.round(clampedScale * 100).toString() + "%";
    if (ClientLoader.progressPercent != clampedScale) UHTInterfaceBOSS.OnLoadingPercentChanged(ClientLoader.progressPercent);
    ClientLoader.progressPercent = clampedScale
};
goog.require("UHT.Engine");
ClientLoaderAnimation.prototype = Object.create(Component.prototype);
ClientLoaderAnimation.prototype.constructor = ClientLoaderAnimation;

function ClientLoaderAnimation() {
    Component.call(this);
    this.framePrefix = "";
    this.dt = .1;
    this.digits = 2;
    this.sprite = null;
    this.oframe = -1;
    this.frame = 0;
    this.animTime = 0
}
ClientLoaderAnimation.prototype.AddDigits = function(s) {
    while (s.length < this.digits) s = "0" + s;
    return s
};
ClientLoaderAnimation.prototype.SetFrame = function() {
    this.sprite.color.a = 1
};
ClientLoaderAnimation.prototype.Update = function() {
    if (UHTScreen.height < 600) this.frame = 32;
    else this.frame = 33;
    this.SetFrame()
};
goog.require("UHT.Engine");
ClientCustomContentTGCE.prototype = Object.create(Component.prototype);
ClientCustomContentTGCE.prototype.constructor = ClientCustomContentTGCE;

function ClientCustomContentTGCE() {
    Component.call(this);
    this.start = null;
    this.animate = null;
    this.landscape = null;
    this.portrait = null;
    this.framesAnimator = null;
    this.framesAnimationTime = 0;
    this.progressSampler = null;
    this.progressSamplers = null;
    this.progressAnimator = null;
    this.progressAnimators = null;
    this.progressAnimationTime = 0;
    this.progressThreshold = 0;
    this.totalDistance = 0;
    this.minimalDistance = 0;
    this.targetProgress = 0;
    this.screenWidth = 0;
    this.screenHeight = 0
}
ClientCustomContentTGCE.prototype.Start = function() {
    this.totalDistance = UHTMath.Vector3.distance(this.progressSampler.manualFrom, this.progressSampler.manualTo);
    this.minimalDistance = this.totalDistance * this.progressThreshold;
    this.framesAnimator.animationTime = this.framesAnimationTime;
    this.progressAnimator.animationTime = this.progressAnimationTime;
    for (var i = 0; i < this.progressAnimators.length; ++i) this.progressAnimators[i].animationTime = this.progressAnimationTime;
    this.start.Start()
};
ClientCustomContentTGCE.prototype.LateUpdate = function() {
    this.UpdateLayout();
    this.UpdateProgress()
};
ClientCustomContentTGCE.prototype.UpdateLayout = function() {
    if (this.screenWidth == UHTScreen.width && this.screenHeight == UHTScreen.height) return;
    this.screenWidth = UHTScreen.width;
    this.screenHeight = UHTScreen.height;
    (this.screenWidth >= this.screenHeight ? this.landscape : this.portrait).Start()
};
ClientCustomContentTGCE.prototype.UpdateProgress = function() {
    var clampedProgress = Math.round(ClientLoader.progressPercent * 100 / (this.progressThreshold * 100)) * this.progressThreshold;
    if (clampedProgress < this.targetProgress || Math.abs(clampedProgress - this.targetProgress) < UHTMath.numberError) return;
    this.targetProgress = clampedProgress;
    this.progressSampler.Sample(this.targetProgress);
    for (var i = 0; i < this.progressSamplers.length; ++i) this.progressSamplers[i].Sample(this.targetProgress);
    var distance = UHTMath.Vector3.distance(this.progressAnimator.target.transform.localPosition(),
        this.progressSampler.target.transform.localPosition());
    var speed = distance / this.minimalDistance;
    this.framesAnimator.animationTime = this.framesAnimationTime / speed;
    this.animate.Start()
};
goog.require("UHT.Engine");
OrientationChanger.prototype = Object.create(Component.prototype);
OrientationChanger.prototype.constructor = OrientationChanger;

function OrientationChanger() {
    Component.call(this);
    this.toLandscape = null;
    this.toPortrait = null;
    this.screenWidth = 0;
    this.screenHeight = 0
}
OrientationChanger.prototype.LateUpdate = function() {
    if (this.screenWidth == UHTScreen.width && this.screenHeight == UHTScreen.height) return;
    this.screenWidth = UHTScreen.width;
    this.screenHeight = UHTScreen.height;
    (this.screenWidth >= this.screenHeight ? this.toLandscape : this.toPortrait).Start()
};
goog.require("UHT.Engine");
FullscreenVisual.prototype = Object.create(Component.prototype);
FullscreenVisual.prototype.constructor = FullscreenVisual;

function FullscreenVisual() {
    Component.call(this);
    this.catShow = null;
    this.catHide = null;
    this.mustShow = false;
    this.isShown = false;
    UHTEventBroker.AddHandler(UHTEventBroker.Type.Game, new UHTEventBroker.Handler(this, this.OnGameEvent))
}
FullscreenVisual.prototype.OnGameEvent = function(param) {
    var args = JSON.parse(param);
    switch (args["common"]) {
        case "EVT_FULLSCREEN_OVERLAY_SHOWN":
            this.mustShow = true;
            break;
        case "EVT_FULLSCREEN_OVERLAY_HIDDEN":
            this.mustShow = false;
            break
    }
};
FullscreenVisual.prototype.Update = function() {
    if (this.mustShow != this.isShown) {
        if (this.catShow.IsRunning()) this.catShow.Stop();
        if (this.catHide.IsRunning()) this.catHide.Stop();
        (this.mustShow ? this.catShow : this.catHide).Start();
        this.isShown = this.mustShow
    }
};
goog.require("UHT.Engine");
LoaderScaler.prototype = Object.create(Component.prototype);
LoaderScaler.prototype.constructor = LoaderScaler;

function LoaderScaler() {
    Component.call(this);
    this.curWidth = -1;
    this.curHeight = -1;
    this.background = null
}
LoaderScaler.prototype.Update = function() {
    if (UHTScreen.width != this.curWidth || UHTScreen.height != this.curHeight) {
        this.curWidth = UHTScreen.width;
        this.curHeight = UHTScreen.height;
        if (this.curWidth >= this.curHeight) {
            console.log("-- Loader - Landscape!");
            this.gameObject.transform.localScale(1.5, 1.5, 1.5);
            if (this.background != null) this.background.transform.localScale(1, 1, 1)
        } else if (this.curWidth < this.curHeight) {
            console.log("-- Loader - Portrait!");
            this.gameObject.transform.localScale(1.6, 1.6, 1.6);
            if (this.background !=
                null) this.background.transform.localScale(1, 2, 1)
        }
    }
};
goog.require("UHT.Engine");
SpriteSizeProxy.prototype = Object.create(Component.prototype);
SpriteSizeProxy.prototype.constructor = SpriteSizeProxy;

function SpriteSizeProxy() {
    Component.call(this);
    this.sprite = null;
    this.width = -1;
    this.height = -1;
    this.curWidth = -1;
    this.curHeight = -1;
    this.useUpdate = true
}
SpriteSizeProxy.prototype.Update = function() {
    if (this.useUpdate) {
        if (this.width != this.curWidth) {
            this.sprite.width = this.width;
            this.curWidth = this.width
        }
        if (this.height != this.curHeight) {
            this.sprite.height = this.height;
            this.curHeight = this.height
        }
    }
};
SpriteSizeProxy.prototype.SetHeight = function(height) {
    this.sprite.height = height
};
SpriteSizeProxy.prototype.SetWidth = function(width) {
    this.sprite.width = width
};
goog.require("UHT.Engine");
var BetwayAPI = {};
BetwayAPI.ReceiveMessage = function(event) {
    if (!(event instanceof Object)) return;
    if (event["data"] != undefined && event["data"] != null && typeof event["data"] == "string" && event["data"].indexOf("{") != -1) {
        var msg = null;
        try {
            msg = JSON.parse(event["data"])
        } catch (e) {
            console.warn("unknown message:" + event["data"]);
            return
        }
        if (msg.Type == "REQUEST")
            if (msg.Name == "PAUSE_GAMEPLAY") {
                window["globalMustStopAutoplay"] = true;
                XT.SetBool(Vars.ForceContinuousSpin, false);
                BetwayAPI.PostMessage("PAUSE_GAMEPLAY", msg.Id)
            } else if (msg.Name ==
            "RESUME_GAMEPLAY") BetwayAPI.PostMessage("RESUME_GAMEPLAY", msg.Id, 1E3, "Resuming gameplay is not supported");
        else BetwayAPI.PostMessage(msg.Name, msg.Id, 1E3, "Message is not supported")
    }
};

function new_uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0,
            v = c == "x" ? r : r & 3 | 8;
        return v.toString(16)
    })
}
BetwayAPI.PostMessage = function(name, responseGUID, errorCode, errorDescription, body) {
    var msg = {
        Name: name,
        Body: body || null,
        Type: responseGUID != undefined ? "RESPONSE" : "REQUEST",
        Origin: "embeddedgame",
        SenderId: window.name,
        Id: responseGUID != undefined ? responseGUID : new_uuidv4()
    };
    if (errorCode != undefined) msg.Error = {
        ErrorCode: errorCode,
        Description: errorDescription
    };
    var args = JSON.stringify(msg);
    window.parent.postMessage(args, "*")
};
BetwayAPI.UHTInterfaceBOSS_PostMessage_Override = function(message) {
    if (message == "gameLoadingEnded") BetwayAPI.PostMessage("BRIDGE_API_READY");
    else if (message == "gameRoundStarted") BetwayAPI.PostMessage("BUSY");
    else if (message == "gameRoundEnded") BetwayAPI.PostMessage("IDLE");
    else if (message == "openCashier") BetwayAPI.PostMessage("LAUNCH_BANKING");
    else if (message == "gameQuit") BetwayAPI.PostMessage("CLOSE_GAME")
};
BetwayAPI.LobbyGameButtonOverride = function(gameData) {
    BetwayAPI.PostMessage("launch_game", undefined, undefined, undefined, {
        game_id: "pragmatic_" + gameData.symbol
    })
};
BetwayAPI.Init = function() {
    if (UHT_GAME_CONFIG_SRC["integrationType"] != "BETWAY") return;
    window.addEventListener("message", BetwayAPI.ReceiveMessage, false);
    UHTInterfaceBOSS.PostMessage = BetwayAPI.UHTInterfaceBOSS_PostMessage_Override;
    LobbyGameButton.prototype.StartGame = BetwayAPI.LobbyGameButtonOverride;
    UHTInterfaceBOSS.HandleGameHistory = function() {
        BetwayAPI.PostMessage("LAUNCH_GAME_HISTORY");
        return true
    };
    UHTInterfaceBOSS.UserInteraction = function() {
        BetwayAPI.PostMessage("PLAYER_ACTIVITY")
    }
};
BetwayAPI.Init();
goog.require("UHT.Engine");
goog.require("UHT.EventManager");
goog.require("UHT.VSGameStateManager");
var BVAPI = {};
BVAPI.isMobile = false;
BVAPI.BVFrame = null;
BVAPI.BVWindow = null;
BVAPI.canvas = null;
BVAPI.isFirstUpdate = true;
BVAPI.isXTInit = false;
BVAPI.isResultShown = false;
BVAPI.spinCycleWin = 0;
BVAPI.gameReady = false;
BVAPI.overlayReady = false;
BVAPI.postGameReady = false;
BVAPI.postGameActive = false;
BVAPI.postGameIdle = false;
BVAPI.stopGame = false;
BVAPI.restartGame = false;
BVAPI.isGamePaused = false;
BVAPI.isGameIdle = false;
BVAPI.ReceiveMessage = function(event) {
    if (!(event instanceof Object)) return;
    var msg = String(event["data"]);
    if (msg == "restartGame") BVAPI.restartGame = true;
    else if (msg == "stopGame") BVAPI.stopGame = true;
    else if (msg == "overlayReady" || msg == "rcFrameLoaded") BVAPI.overlayReady = BVAPI.postGameReady = true
};
BVAPI.VSGameStates = [VSGameState.Result, VSGameState.ResultBonusRounds];
BVAPI.VSGameStatesAutoplay = [VSGameState.ResultAutoplay, VSGameState.ResultBonusRoundsAutoplay];
BVAPI.PauseGame = function(pause) {
    if (pause == BVAPI.isGamePaused) return;
    BVAPI.isGamePaused = pause;
    Globals.GamePaused = pause;
    if (!SystemMessageManager.IsMessageOpen()) UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
        common: pause ? "EVT_MESSAGE_OPENED" : "EVT_MESSAGE_CLOSED",
        args: null
    }));
    SystemMessageManager.SetHiddenMode(pause);
    if (BVAPI.canvas == null) BVAPI.canvas = document.getElementsByTagName("canvas")[0];
    if (BVAPI.canvas != null) BVAPI.canvas.classList[pause ? "add" : "remove"]("paused");
    if (pause) {
        XT.SetInt(Vars.AutoplaySpinsLeft, -1);
        var idx = BVAPI.VSGameStatesAutoplay.indexOf(VSGameStateManager.GetState());
        if (idx > -1) VSGameStateManager.ChangeTo(BVAPI.VSGameStates[idx])
    }
    if (BVAPI.isMobile) BVAPI.OnUHTResize()
};
BVAPI.PostMessage = function(message) {
    if (BVAPI.BVWindow != null && BVAPI.BVWindow.postMessage instanceof Function) BVAPI.BVWindow.postMessage(message, "*")
};
BVAPI.UHTInterfaceBOSS_PostMessage = null;
BVAPI.UHTInterfaceBOSS_PostMessage_Override = function(message) {
    if (message == "gameRoundStarted") BVAPI.postGameActive = true;
    else if (message == "gameRoundEnded") BVAPI.postGameIdle = true;
    if (UHTInterfaceBOSS.enabled) BVAPI.UHTInterfaceBOSS_PostMessage(message)
};
BVAPI.OnFOXInitReceived = function() {
    var params = XT.GetObject(FOXVars.FOX_Response) || {};
    BVAPI.postGameIdle = params["na"] == "s" && params["fs"] == undefined && params["fs_total"] == undefined && params["rs"] == undefined;
    BVAPI.postGameActive = !BVAPI.postGameIdle
};
BVAPI.OnXTGameInit = function() {
    BVAPI.gameReady = true
};
BVAPI.OnXTUpdateDisplayedWinInUI = function() {
    var win = XT.GetDouble(Vars.SpinCycleWinReceived);
    if (win <= 0 || win == BVAPI.spinCycleWin) BVAPI.isResultShown = true;
    BVAPI.spinCycleWin = win
};
BVAPI.OnXTLastWinIsCountingChanged = function(isCounting) {
    var win = XT.GetDouble(Vars.SpinCycleWinReceived);
    if (win > 0 && !isCounting) BVAPI.isResultShown = true
};
BVAPI.OnUHTBeforeUpdate = function() {
    if (BVAPI.isXTInit && BVAPI.overlayReady && BVAPI.gameReady) {
        if (BVAPI.stopGame) {
            BVAPI.stopGame = false;
            BVAPI.PauseGame(true);
            if (BVAPI.isGameIdle) BVAPI.PostMessage("gameIdle")
        }
        if (BVAPI.restartGame) {
            BVAPI.restartGame = false;
            BVAPI.PauseGame(false)
        }
    }
};
BVAPI.OnUHTUpdate = function() {
    if (BVAPI.isFirstUpdate) {
        BVAPI.isFirstUpdate = false;
        if (BVAPI.isMobile) BVAPI.OnUHTResize()
    }
    if (!BVAPI.isXTInit && XT.RegisterAndInitDone) {
        BVAPI.isXTInit = true;
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_InitReceived, BVAPI.OnFOXInitReceived, BVAPI);
        XT.RegisterCallbackBool(Vars.LastWinIsCounting, BVAPI.OnXTLastWinIsCountingChanged, BVAPI);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_UpdateDisplayedWinInUI, BVAPI.OnXTUpdateDisplayedWinInUI, BVAPI);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit,
            BVAPI.OnXTGameInit, BVAPI)
    }
    if (BVAPI.isXTInit && BVAPI.overlayReady && BVAPI.gameReady) {
        if (BVAPI.postGameReady) {
            BVAPI.postGameReady = false;
            BVAPI.PostMessage("gameReady")
        }
        if (BVAPI.postGameIdle && BVAPI.isResultShown) {
            BVAPI.isGameIdle = true;
            BVAPI.postGameIdle = BVAPI.isResultShown = false;
            BVAPI.PostMessage("gameIdle")
        }
        if (BVAPI.postGameActive) {
            BVAPI.isGameIdle = false;
            BVAPI.postGameActive = false;
            BVAPI.PostMessage("gameActive")
        }
    }
};
BVAPI.OnUHTResize = function() {
    var styles = [];
    styles.push(["width:", BVAPI.isGamePaused ? window.innerWidth : 0, "px"].join(""));
    styles.push(["height:", BVAPI.isGamePaused ? window.innerHeight : 0, "px"].join(""));
    BVAPI.BVFrame.setAttribute("style", styles.join(";"))
};
BVAPI.Init = function() {
    if (UHT_GAME_CONFIG_SRC["externalOverlay_BV"] == null) return;
    BVAPI.isMobile = UHT_DEVICE_TYPE.MOBILE;
    if (BVAPI.isMobile) {
        var frame = document.createElement("iframe");
        frame.name = "BVFrame";
        frame.className = "rciframe_visible";
        frame.setAttribute("frameborder", "0");
        frame.setAttribute("allowtransparency", "true");
        document.body.appendChild(frame);
        BVAPI.BVWindow = window.open(UHT_GAME_CONFIG_SRC["externalOverlay_BV"], frame.name);
        BVAPI.BVFrame = frame;
        BVAPI.OnUHTResize();
        EventManager.AddHandler("EVT_UHT_RESIZE",
            BVAPI.OnUHTResize, BVAPI)
    } else {
        BVAPI.BVWindow = window.parent;
        BVAPI.overlayReady = BVAPI.postGameReady = true
    }
    window.addEventListener("message", BVAPI.ReceiveMessage, false);
    EventManager.AddHandler("EVT_UHT_BEFOREUPDATE", BVAPI.OnUHTBeforeUpdate, BVAPI);
    EventManager.AddHandler("EVT_UHT_UPDATE", BVAPI.OnUHTUpdate, BVAPI);
    BVAPI.UHTInterfaceBOSS_PostMessage = UHTInterfaceBOSS.PostMessage;
    UHTInterfaceBOSS.PostMessage = BVAPI.UHTInterfaceBOSS_PostMessage_Override
};
BVAPI.Init();
var CustomMsgManager = {};
CustomMsgManager.HistoryHandler = function() {
    if (UHT_GAME_CONFIG["openHistoryInTab"]) window.open(UHT_GAME_CONFIG["HISTORY"]);
    else(new GameHistoryWindow).Open()
};
CustomMsgManager.OpenHandler = function(url) {
    window.open(url)
};
CustomMsgManager.AjaxHandler = function(param) {
    var request = new ServerRequest;
    request.Url = param.url;
    if (param.wait) request.Handler = new EventHandler(null, CustomMsgManager.OnAjaxResponse);
    RequestManager.AddRequest(request, true)
};
CustomMsgManager.OnAjaxResponse = function(response, statusCode) {
    if (statusCode == 200) SystemMessageManager.CloseMessage()
};
CustomMsgManager.SendLogout = function() {
    var xhr = new XMLHttpRequest;
    xhr.open("POST", UHT_GAME_CONFIG["LOGOUT"], true);
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4)
            if (xhr.responseText == "OK") SystemMessageManager.CloseGame();
            else setTimeout(function() {
                CustomMsgManager.SendLogout()
            }, 2E3)
    };
    xhr.send()
};
CustomMsgManager.NotifyHandler = function(message) {
    if (window.top != window) UHTInterfaceBOSS.PostMessageRec(window.parent, message);
    SystemMessageManager.CloseMessage()
};
CustomMsgManager.HandleResponse = function(response, params) {
    var messages = params["custom_msg"];
    if (messages == undefined) {
        var args;
        try {
            args = JSON.parse(response)
        } catch (e) {
            args = {}
        }
        messages = args["custom_msg"];
        if (messages == undefined) return
    }
    try {
        messages = decodeURIComponent(atob(String(messages)).split("").map(function(c) {
            return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2)
        }).join(""))
    } catch (e) {}
    try {
        messages = JSON.parse(String(messages))
    } catch (e) {}
    if (!(messages instanceof Array)) return;
    var isI11 = !UHT_CONFIG.MINI_MODE;
    for (var i = 0; i < messages.length; ++i) {
        var message = messages[i];
        message.id = "msg" + UID.Generate();
        var classNames = ["sys-msg", "custom"];
        if (message["title"] == undefined) {
            message["title"] = isI11 ? SystemMessageManager.LocalizedText("WindowTitle") : "";
            classNames.push("no-title")
        }
        message["title"] = SystemMessageManager.ProcessText(message["title"]);
        message.className = classNames.join(" ");
        message["text"] = SystemMessageManager.ProcessText(String(message["text"]));
        if (!isI11 && message["nonIntrusive"] != true) message["text"] =
            message["text"].replace(/\n/g, "<br>");
        var options = message["options"];
        if (options == undefined)
            if (message["nonIntrusive"] == true) options = [];
            else options = [{
                label: SystemMessageManager.LocalizedText("BtContinuePlaying"),
                action: "continue"
            }];
        for (var j = 0; j < options.length; ++j) {
            var option = options[j];
            var handlers;
            var action = option["action"];
            if (action == "quit") handlers = [SystemMessageManager.CloseGame];
            if (action == "continue") handlers = [SystemMessageManager.CloseMessage];
            if (action == "logout") handlers = [CustomMsgManager.SendLogout];
            if (action == "history")
                if (UHT_GAME_CONFIG["HISTORY"] == null) action = "link";
                else handlers = [SystemMessageManager.CloseMessage, CustomMsgManager.HistoryHandler];
            if (action == "link") {
                var linkType = option["linkType"];
                var url = option["url"];
                if (linkType == "redirect") handlers = [SystemMessageManager.GetBtnClickHandler([SystemMessageManager.Reload], url)];
                if (linkType == "open") handlers = [SystemMessageManager.GetBtnClickHandler([CustomMsgManager.OpenHandler], url)];
                if (linkType == "openAndCloseMessage") handlers = [SystemMessageManager.GetBtnClickHandler([CustomMsgManager.OpenHandler,
                    SystemMessageManager.CloseMessage
                ], url)];
                if (linkType == "ajax") handlers = [SystemMessageManager.GetBtnClickHandler([CustomMsgManager.AjaxHandler, SystemMessageManager.CloseMessage], {
                    url: url,
                    wait: false
                })];
                if (linkType == "ajaxResponse") handlers = [SystemMessageManager.GetBtnClickHandler([CustomMsgManager.AjaxHandler], {
                    url: url,
                    wait: true
                })];
                if (linkType == "ajaxClose") handlers = [SystemMessageManager.GetBtnClickHandler([CustomMsgManager.AjaxHandler, SystemMessageManager.CloseGame], {
                    url: url,
                    wait: true
                })];
                if (linkType ==
                    "notify") handlers = [SystemMessageManager.GetBtnClickHandler([CustomMsgManager.NotifyHandler], url)]
            }
            var label = SystemMessageManager.ProcessText(option["label"]);
            if (label == undefined || label == "undefined")
                if (action == "quit") label = SystemMessageManager.LocalizedText("BtCLOSE");
                else if (action == "continue") label = SystemMessageManager.LocalizedText("BtContinuePlaying");
            else if (action == "history") label = SystemMessageManager.LocalizedText("BtRCHistory");
            else label = SystemMessageManager.LocalizedText("BtOK");
            option.id =
                "";
            option.label = label;
            option.handlers = handlers
        }
        message.buttons = options;
        delete message["options"];
        message.equals = function() {
            return false
        }
    }
    SystemMessageManager.canShowMessage = false;
    for (var i = messages.length - 1; i >= 0; --i) SystemMessageManager.ShowMessage(messages[i].id, false, messages[i].text, null, messages[i]);
    SystemMessageManager.canShowMessage = true;
    SystemMessageManager.InternalShowMessage()
};
var RC1API = {};
RC1API.enabled = false;
RC1API.ReceiveMessage = function(event) {
    if (typeof event != "object") return;
    if (event["data"] != undefined)
        if (event["data"] != null)
            if (typeof event["data"] == "string")
                if (event["data"].indexOf("{") != -1) {
                    var msg = null;
                    try {
                        msg = JSON.parse(event["data"])
                    } catch (e) {
                        console.warn("unknown message:" + event["data"]);
                        return
                    }
                    if (msg.type == "Tilt") {
                        window["globalMustStopAutoplay"] = true;
                        XT.SetBool(Vars.ForceContinuousSpin, false)
                    }
                }
};
RC1API.PauseRC = function() {
    if (RC1API.enabled) window.postMessage(JSON.stringify({
        "type": "status",
        "payload": {
            "freeSpins": "true"
        }
    }), "*")
};
RC1API.ReinstateRC = function() {
    if (RC1API.enabled) window.postMessage(JSON.stringify({
        "type": "status",
        "payload": {
            "freeSpins": "false"
        }
    }), "*")
};
RC1API.Init = function() {
    window.addEventListener("message", RC1API.ReceiveMessage, false);
    if (UHT_GAME_CONFIG["rcSettings"] == null) return;
    RC1API.enabled = UHT_GAME_CONFIG["rcSettings"]["rctype"] == "RC1"
};
RC1API.Init();
var RC2API = {};
RC2API.enabled = false;
RC2API.rciframe = null;
RC2API.rciwindow = null;
RC2API.isGamePaused = false;
RC2API.ReceiveMessage = function(event) {
    if (!RC2API.enabled) return;
    if (typeof event != "object" || typeof event["data"] != "object") return;
    var method = event.data["method"];
    var params = event.data["params"];
    switch (method) {
        case "operatorLoaded":
            break;
        case "confirmHandshake":
            if (typeof params == "object") RC2API.PostMessage(String(params["success"]));
            break;
        case "pauseGame":
            if (typeof params == "object") {
                var return_data = params["return_data"] instanceof Array ? params["return_data"] : [];
                var callbackArgs = {};
                if (return_data.indexOf("session_id") >
                    -1) callbackArgs["session_id"] = UHT_GAME_CONFIG["rcSettings"]["session_id"];
                if (return_data.indexOf("game_name") > -1) callbackArgs["game_name"] = UHT_GAME_CONFIG["rcSettings"]["game_name"];
                if (return_data.indexOf("user_id") > -1) callbackArgs["user_id"] = UHT_GAME_CONFIG["rcSettings"]["user_id"];
                if (!RC2API.isGamePaused) {
                    if (!SystemMessageManager.IsMessageOpen()) UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
                        common: "EVT_MESSAGE_OPENED",
                        args: null
                    }));
                    SystemMessageManager.SetHiddenMode(true);
                    RC2API.isGamePaused =
                        true;
                    RC2API.rciframe.className = "rciframe_visible"
                }
                RC2API.PostMessage(String(params["callback"]), callbackArgs)
            }
            break;
        case "resumeGame":
            if (RC2API.isGamePaused) {
                RC2API.isGamePaused = false;
                RC2API.rciframe.className = "rciframe_hidden";
                if (!SystemMessageManager.IsMessageOpen()) UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
                    common: "EVT_MESSAGE_CLOSED",
                    args: null
                }));
                SystemMessageManager.SetHiddenMode(false)
            }
            break;
        case "navigateTo":
            if (typeof params == "object" && typeof params["url"] == "string") location.href =
                params["url"];
            break
    }
};
RC2API.PostMessage = function(method, params) {
    if (RC2API.rciwindow != null) RC2API.rciwindow.postMessage({
        method: method,
        params: params
    }, "*")
};
RC2API.HandleResize = function() {
    var styles = [];
    styles.push(["width:", window.innerWidth, "px"].join(""));
    styles.push(["height:", window.innerHeight, "px"].join(""));
    RC2API.rciframe.setAttribute("style", styles.join(";"))
};
RC2API.Init = function() {
    if (UHT_GAME_CONFIG["rcSettings"] == null) return;
    RC2API.enabled = UHT_GAME_CONFIG["rcSettings"]["rctype"] == "RC2";
    if (RC2API.enabled) {
        var frame = document.createElement("iframe");
        frame.name = "rciframe";
        frame.className = "rciframe_hidden";
        frame.setAttribute("frameborder", "0");
        frame.setAttribute("allowtransparency", "true");
        document.body.appendChild(frame);
        RC2API.rciwindow = window.open(UHT_GAME_CONFIG["rcSettings"]["rciframeurl"], frame.name);
        RC2API.rciframe = frame;
        RC2API.HandleResize();
        window.addEventListener("message",
            RC2API.ReceiveMessage, false);
        window.addEventListener("resize", RC2API.HandleResize, false)
    }
};
RC2API.Init();
goog.provide("UHT.SystemMessageHelpers");
var SystemMessageType = {
    NoMoney: "NoMoney",
    NoMoneyBlocking: "NoMoneyBlocking",
    Frozen: "Frozen",
    Reload: "Reload",
    Disabled: "Disabled",
    Techbreak: "Techbreak",
    GameAvailableOnlyAtRealMode: "GameAvailableOnlyAtRealMode",
    ProgressiveJackpotGamesAvailableOnlyAtRealMode: "ProgressiveJackpotGamesAvailableOnlyAtRealMode",
    SaveSettingError: "SaveSettingError",
    LostConnect: "LostConnect",
    PleaseLogin: "PleaseLogin",
    UseGoogleChrome: "UseGoogleChrome",
    UseSafari: "UseSafari",
    Timeout: "Timeout",
    ClientRegulation: "ClientRegulation",
    Regulation: "Regulation"
};
var SystemMessageFrozenError = {
    t0: "UNKNOWN",
    t1: "COULD_NOT_RESTORE_WITH_FRB",
    t2: "INVALID_SESSION",
    t3: "RETRY_REQUEST_ERROR",
    t4: "POSTPONED_WIN_ERROR",
    t5: "GAME_CONFIGURATION_ERROR",
    t6: "EXTERNAL_SERVICE_ERROR",
    t7: "SERVER_OBJECT_NOT_FOUND",
    t8: "EXPIRED_SESSION"
};
var SystemMessageFrozenInfo = {
    t100: "PLAYER_FROZEN",
    t101: "PLAYER_LIMIT_REACHED",
    t102: "DISABLED_GAME",
    t103: "RTP_CHANGED"
};

function SystemMessageData(type, text, args) {
    this.type = type;
    this.text = text;
    this.args = args;
    this.id = ""
}
SystemMessageData.prototype.equals = function(data) {
    return this.type == data.type && this.text == data.text && this.args == data.args
};
var RCContinueURL;
var RCCloseURL;
var RCHistoryURL;
var RCContinueURL_Type;
var RCCloseURL_Type;

function SystemMessageSettings(type) {
    switch (type) {
        case SystemMessageType.NoMoney:
            return {
                id: "NoMoney",
                buttons: [{
                    id: "BtOK",
                    handlers: [SystemMessageManager.CloseMessage]
                }]
            };
        case SystemMessageType.NoMoneyBlocking:
            return {
                id: "NoMoney",
                buttons: []
            };
        case SystemMessageType.Frozen:
        case SystemMessageType.Disabled:
            return {
                id: "Frozen",
                buttons: UHT_DEVICE_TYPE.DESKTOP && !checkIsRequired("MBD") ? [] : [{
                    id: "BtCLOSE",
                    handlers: [SystemMessageManager.CloseGame]
                }]
            };
        case SystemMessageType.Reload:
            return {
                id: "ServerError",
                buttons: UHT_DEVICE_TYPE.DESKTOP &&
                    !checkIsRequired("MBD") ? [] : [{
                        id: "BtCLOSE",
                        handlers: [SystemMessageManager.CloseGame]
                    }]
            };
        case SystemMessageType.Techbreak:
            return {
                id: "Techbreak",
                buttons: UHT_DEVICE_TYPE.DESKTOP && !checkIsRequired("MBD") ? [] : [{
                    id: "BtCLOSE",
                    handlers: [SystemMessageManager.CloseGame]
                }]
            };
        case SystemMessageType.GameAvailableOnlyAtRealMode:
            return {
                id: "GameAvailableOnlyAtRealMode",
                buttons: UHT_DEVICE_TYPE.DESKTOP && !checkIsRequired("MBD") ? [] : [{
                    id: "BtCLOSE",
                    handlers: [SystemMessageManager.CloseGame]
                }]
            };
        case SystemMessageType.ProgressiveJackpotGamesAvailableOnlyAtRealMode:
            return {
                id: "ProgressiveJackpotGamesAvailableOnlyAtRealMode",
                title: "ProgressiveJackpotGames",
                buttons: UHT_DEVICE_TYPE.DESKTOP && !checkIsRequired("MBD") ? [] : [{
                    id: "BtCLOSE",
                    handlers: [SystemMessageManager.CloseGame]
                }]
            };
        case SystemMessageType.SaveSettingError:
            return {
                id: "SaveSettingError",
                buttons: UHT_DEVICE_TYPE.DESKTOP && !checkIsRequired("MBD") ? [] : [{
                    id: "BtCLOSE",
                    handlers: [SystemMessageManager.CloseGame]
                }]
            };
        case SystemMessageType.LostConnect:
            return {
                id: "LostConnect",
                buttons: UHT_DEVICE_TYPE.DESKTOP && !checkIsRequired("MBD") ? [] : [{
                    id: "BtCLOSE",
                    handlers: [SystemMessageManager.CloseGame]
                }]
            };
        case SystemMessageType.PleaseLogin:
            return {
                id: "PleaseLogin",
                buttons: UHT_DEVICE_TYPE.DESKTOP && !checkIsRequired("MBD") ? [] : [{
                    id: "BtCLOSE",
                    handlers: [SystemMessageManager.CloseGame]
                }]
            };
        case SystemMessageType.UseGoogleChrome:
            return {
                id: "UseGoogleChrome",
                title: "UnsupportedBrowserTitle",
                buttons: [{
                    id: "BtOK",
                    handlers: [SystemMessageManager.CloseMessage]
                }]
            };
        case SystemMessageType.UseSafari:
            return {
                id: "UseSafari",
                title: "UnsupportedBrowserTitle",
                buttons: [{
                    id: "BtOK",
                    handlers: [SystemMessageManager.CloseMessage]
                }]
            };
        case SystemMessageType.Timeout:
            return {
                id: "Timeout",
                buttons: Globals.isMobile ? [{
                    id: "BtCLOSE",
                    handlers: [SystemMessageManager.CloseGame]
                }] : []
            };
        case SystemMessageType.ClientRegulation:
            var rc_buttons = [];
            var i;
            var continue_found = false;
            if (UHT_GAME_CONFIG["rcSettings"]["buttons"] != undefined)
                for (i = 0; i < UHT_GAME_CONFIG["rcSettings"]["buttons"].length; i++)
                    if (UHT_GAME_CONFIG["rcSettings"]["buttons"][i].action == "continue") {
                        continue_found = true;
                        RCContinueURL = UHT_GAME_CONFIG["rcSettings"]["buttons"][i].url;
                        RCContinueURL_Type =
                            UHT_GAME_CONFIG["rcSettings"]["buttons"][i]["rcContinueType"];
                        rc_buttons.push({
                            id: "BtContinuePlaying",
                            handlers: [SystemMessageManager.RCContinue]
                        })
                    }
            if (!continue_found) rc_buttons.push({
                id: "BtContinuePlaying",
                handlers: [SystemMessageManager.RCCloseMessage]
            });
            if (UHT_GAME_CONFIG["rcSettings"]["buttons"] != undefined)
                for (i = 0; i < UHT_GAME_CONFIG["rcSettings"]["buttons"].length; i++)
                    if (UHT_GAME_CONFIG["rcSettings"]["buttons"][i].action == "history") {
                        var url = UHT_GAME_CONFIG["rcSettings"]["buttons"][i].url;
                        if (url !=
                            "") RCHistoryURL = url;
                        rc_buttons.push({
                            id: "BtRCHistory",
                            handlers: [SystemMessageManager.RCHistory]
                        })
                    }
            if (UHT_GAME_CONFIG["rcSettings"]["buttons"] != undefined)
                for (i = 0; i < UHT_GAME_CONFIG["rcSettings"]["buttons"].length; i++)
                    if (UHT_GAME_CONFIG["rcSettings"]["buttons"][i].action == "exit") {
                        RCCloseURL = UHT_GAME_CONFIG["rcSettings"]["buttons"][i].url;
                        RCCloseURL_Type = UHT_GAME_CONFIG["rcSettings"]["buttons"][i]["rcCloseType"];
                        rc_buttons.push({
                            id: "BtCLOSE",
                            handlers: [SystemMessageManager.RCClose]
                        })
                    }
            return {
                id: "ClientRegulation",
                buttons: rc_buttons
            };
        case SystemMessageType.Regulation:
            var rc_rbuttons = [{
                id: "BtContinuePlaying",
                handlers: [SystemMessageManager.RegulationContinuePressed]
            }, {
                id: "BtRCHistory",
                handlers: [SystemMessageManager.RCHistory]
            }, {
                id: "BtStopPlaying",
                handlers: [SystemMessageManager.RegulationStopPressed]
            }];
            return {
                id: "Regulation",
                buttons: rc_rbuttons
            }
    }
    return null
}
var ScaleHelper = {};
ScaleHelper.ScaleContent = function() {
    var scaleRootHeight = 999;
    var zoom = 1;
    if (window.innerWidth > window.innerHeight) zoom = window.innerHeight / scaleRootHeight;
    else zoom = window.innerWidth / scaleRootHeight;
    var styles = ["-moz-transform: scale(VAL)", "-webkit-transform: scale(VAL)", "-ms-transform: scale(VAL)", "-o-transform: scale(VAL)", "transform: scale(VAL)"];
    if (UHT_DEVICE_TYPE.DESKTOP) zoom = zoom > 1 ? 1 : zoom;
    for (var i = 0; i < styles.length; ++i) styles[i] = styles[i].replace("VAL", zoom);
    styles.push("width:" + window.innerWidth /
        zoom + "px");
    styles.push("margin-top:" + (window.innerHeight - scaleRootHeight * zoom) / 2 + "px");
    document.getElementById("ScaleRoot").setAttribute("style", styles.join(";"))
};
ScaleHelper.Init = function() {
    ScaleHelper.ScaleContent();
    window.addEventListener("resize", ScaleHelper.ScaleContent, false)
};
ScaleHelper.Init();
goog.require("UHT.SystemMessageHelpers");
goog.require("UHT.Tracking");
var SystemMessageManager = {};
SystemMessageManager.OS = {
    iOS: "iOS",
    Android: "Android"
};
SystemMessageManager.os = null;
SystemMessageManager.root = null;
SystemMessageManager.scaleRoot = null;
SystemMessageManager.defaultTexts = null;
SystemMessageManager.localizedTexts = null;
SystemMessageManager.initialized = false;
SystemMessageManager.showMessageTimeout = null;
SystemMessageManager.messagesToShow = [];
SystemMessageManager.shownMessages = [];
SystemMessageManager.browserWarningShownCallback = null;
SystemMessageManager.regulationType = null;
SystemMessageManager.isHiddenMode = false;
SystemMessageManager.msgOpenWasTriggered = false;
SystemMessageManager.fontName = "Tahoma";
SystemMessageManager.msgFontLoaded = {};
SystemMessageManager.canShowMessage = true;
SystemMessageManager.handleNoMoney = true;
SystemMessageManager.OnLoad = function() {
    var mng = SystemMessageManager;
    UHTEventBroker.AddHandler(UHTEventBroker.Type.Wrapper, new UHTEventBroker.Handler(mng, mng.HandleWrapperEvent));
    mng.LoadLocalizedMessages()
};
SystemMessageManager.CheckUserAgent = function(browserWarningShown, callback, object) {
    if (window.navigator.userAgent == "Mozilla/5.0 (iPhone; CPU iPhone OS 9_3 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13E230") return;
    SystemMessageManager.browserWarningShownCallback = new UHTEventBroker.Handler(object, callback);
    var parser = new UAParser2;
    var browser = parser.getBrowser();
    var os = parser.getOS();
    if (os.name == SystemMessageManager.OS.Android) {
        SystemMessageManager.os = SystemMessageManager.OS.Android;
        if (browser.name != "Chrome") SystemMessageManager.ShowMessage(SystemMessageType.UseGoogleChrome)
    } else if (os.name == SystemMessageManager.OS.iOS) {
        SystemMessageManager.os = SystemMessageManager.OS.iOS;
        if (!browserWarningShown)
            if (browser.name != "Mobile Safari") SystemMessageManager.ShowMessage(SystemMessageType.UseSafari)
    }
};
SystemMessageManager.LoadLocalizedMessages = function() {
    var allMsg = JSON.parse(String(UHT_SYSTEM_MESSAGES).replace(/\n/g, "<br>"));
    var defaultLocale = "en";
    var locale = UHT_CONFIG.LANGUAGE;
    if (allMsg[locale] != undefined) {
        SystemMessageManager.locale = locale;
        SystemMessageManager.localizedTexts = SystemMessageManager.Merge(allMsg[defaultLocale], allMsg[locale]);
        console.log("Localized messages found for locale " + locale)
    } else {
        SystemMessageManager.locale = defaultLocale;
        SystemMessageManager.localizedTexts = allMsg[defaultLocale];
        console.warn("Localized messages not found, locale " + locale)
    }
    SystemMessageManager.initialized = true;
    UHT_SYSTEM_MESSAGES = null;
    var deferredLoading = document.getElementById("DeferredLoadingText");
    if (deferredLoading != null) deferredLoading.innerHTML = SystemMessageManager.LocalizedText("DeferredLoading")
};
SystemMessageManager.Merge = function(src, override) {
    var result = {};
    for (var key in src) result[key] = src[key];
    for (var key in override) result[key] = override[key];
    return result
};
SystemMessageManager.HandleWrapperEvent = function(json) {
    var params = JSON.parse(json);
    var msg = params["common"];
    var args = params["args"];
    switch (msg) {
        case "EVT_HTTP_RESPONSE":
            SystemMessageManager.HandleHttpResponse(args);
            return;
        case "EVT_SHOW_MESSAGE":
            SystemMessageManager.HandleShowMessage(args);
            return
    }
};
SystemMessageManager.HandleHttpResponse = function(args) {
    var mng = SystemMessageManager;
    var mt = SystemMessageType;
    var httpCode = Number(args["httpCode"]);
    if (httpCode != 200) return;
    var data = args["data"];
    if (data == undefined) return;
    if (data.indexOf("unlogged") != -1) {
        mng.ShowMessage(mt.PleaseLogin, true);
        return
    }
    var variables = {};
    var pairs = String(data).split("&");
    for (var i = 0; i < pairs.length; ++i) {
        var pair = pairs[i].split("=");
        variables[pair[0]] = pair[1] || ""
    }
    if (mng.handleNoMoney && variables["nomoney"] != undefined && Number(variables["nomoney"]) ==
        1) {
        UHTInterfaceBOSS.PostMessage("balanceTooLow");
        if (!XT.GetBool(Vars.DisableNoMoneyMessageFromServer)) mng.ShowMessage(variables["error_type"] == "i" ? mt.NoMoney : mt.NoMoneyBlocking)
    } else if (variables["frozen"] != undefined) {
        var decodeError = SystemMessageFrozenError["t" + variables["msg_code"]] || "";
        var decodeInfo = SystemMessageFrozenInfo["t" + variables["msg_code"]] || "";
        var outStr = "BAD_CODE_" + variables["msg_code"] + "_" + variables["frozen"];
        if (decodeError != "") outStr = "ERROR_" + decodeError;
        if (decodeInfo != "") outStr =
            "INFO_" + decodeInfo;
        globalTracking.SendEvent("uht_server_errors", "Frozen_" + outStr, loaderIsVisible ? 1 : 0, "ServerErrorsTracker");
        mng.ShowMessage(mt.Frozen, true, variables["frozen"])
    } else if (variables["reload"] != undefined) mng.ShowMessage(mt.Reload, true, variables["reload"], variables["link"]);
    else if (variables["disabled"] != undefined) mng.ShowMessage(mt.Disabled, true, variables["disabled"]);
    else if (variables["techbreak"] == 2) mng.ShowMessage(mt.Techbreak, true);
    else if (variables["msg_code"] != undefined) {
        var code =
            Number(variables["msg_code"]);
        if (code == 1) mng.ShowMessage(mt.GameAvailableOnlyAtRealMode, true);
        else if (code == 2) mng.ShowMessage(mt.ProgressiveJackpotGamesAvailableOnlyAtRealMode, true)
    } else if (variables["regulation"] != undefined) {
        mng.regulationType = variables["regulation"];
        mng.ShowMessage(mt.Regulation, false, variables["msg"])
    }
    CustomMsgManager.HandleResponse(data, variables)
};
SystemMessageManager.HandleShowMessage = function(args) {
    var msgType = args["message"] || "";
    switch (msgType) {
        case "ALERT_CANT_SAVE_SETTINGS":
            globalTracking.SendEvent("uht_server_errors", SystemMessageType.SaveSettingError, loaderIsVisible ? 1 : 0, "ServerErrorsTracker");
            break;
        case "ALERT_CONNECTION_LOST":
            SystemMessageManager.ShowMessage(SystemMessageType.LostConnect, true);
            break
    }
};
var TimeoutWindowShown = false;
SystemMessageManager.ShowMessage = function(type, unlogged, text, args, customMsg) {
    if (TimeoutWindowShown) return;
    if (type != SystemMessageType.SaveSettingError && type != SystemMessageType.UseGoogleChrome && type != SystemMessageType.UseSafari) UHTInterfaceBOSS.OnSystemMessage(type);
    var isCustom = customMsg != undefined;
    if (!isCustom && type != SystemMessageType.Frozen) globalTracking.SendEvent("uht_server_errors", type, loaderIsVisible ? 1 : 0, "ServerErrorsTracker");
    if (unlogged == true) UHTEventBroker.Trigger(UHTEventBroker.Type.Adapter,
        JSON.stringify({
            common: "UNLOGGED",
            type: "html5"
        }));
    var mng = SystemMessageManager;
    if (type != undefined) {
        var data = isCustom ? customMsg : new SystemMessageData(type, text || null, args);
        if (!mng.MessageExists(data)) mng.messagesToShow.push(data)
    }
    if (!mng.initialized) {
        mng.showMessageTimeout = setTimeout(mng.ShowMessage, 200);
        return
    }
    if (mng.showMessageTimeout != null) {
        clearTimeout(mng.showMessageTimeout);
        mng.showMessageTimeout = null
    }
    if (mng.root == null) mng.InitRootElements();
    if (mng.messagesToShow.length == 0) return;
    for (var i = 0; i <
        mng.messagesToShow.length; ++i) {
        var options = isCustom ? customMsg : SystemMessageSettings(mng.messagesToShow[i].type);
        if (options == null) continue;
        var isI11 = !UHT_CONFIG.MINI_MODE;
        if (isI11 && !isCustom) {
            for (var j = 0; j < options.buttons.length; ++j) options.buttons[j].label = mng.LocalizedText(options.buttons[j].id);
            mng.messagesToShow[i].buttons = options.buttons;
            mng.messagesToShow[i].title = mng.LocalizedText(options.title || "WindowTitle");
            mng.messagesToShow[i].text = mng.messagesToShow[i].text != null ? mng.ProcessText(mng.messagesToShow[i].text) :
                mng.LocalizedText(options.id)
        }
        mng.messagesToShow[i].id = options.id;
        mng.scaleRoot.appendChild(mng.CreateMessage(mng.messagesToShow[i], options, isCustom))
    }
    if (!SystemMessageManager.isHiddenMode) mng.shownMessages = mng.shownMessages.concat(mng.messagesToShow);
    mng.messagesToShow = [];
    mng.InternalShowMessage()
};
SystemMessageManager.InternalShowMessage = function() {
    var mng = SystemMessageManager;
    if (mng.root == null) mng.InitRootElements();
    var rootStyle = "sys-msg-root-hidden";
    var msg = null;
    if (!XT.RegisterAndInitDone) {
        setTimeout(mng.InternalShowMessage, 100);
        return
    }
    if (mng.canShowMessage && mng.shownMessages.length > 0 && !mng.isHiddenMode) {
        msg = mng.shownMessages[mng.shownMessages.length - 1];
        var topMsgId = msg.id;
        if (msg["nonIntrusive"] == true) {
            mng.TriggerMessageClosed();
            XT.SetObject(CustomNotificationVars.CustomNotification, msg);
            XT.TriggerEvent(CustomNotificationVars.Evt_Internal_ShowNonIntrusiveNotification)
        } else {
            var isI11 = !UHT_CONFIG.MINI_MODE;
            if (isI11) {
                XT.SetObject(CustomNotificationVars.CustomNotification, msg);
                XT.TriggerEvent(CustomNotificationVars.Evt_Internal_ShowIntrusiveNotification)
            } else {
                if (!mng.msgFontLoaded[topMsgId]) {
                    setTimeout(mng.InternalShowMessage, 100);
                    return
                }
                rootStyle = ["sys-msg-root-visible", topMsgId].join(" ")
            }
            if (!mng.msgOpenWasTriggered) {
                UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
                    common: "EVT_MESSAGE_OPENED",
                    args: null
                }));
                mng.msgOpenWasTriggered = true
            }
            if (topMsgId == "UseSafari") mng.BrowserWarningShown()
        }
    }
    mng.root.className = rootStyle;
    if (msg != null && (msg.isCustom || Globals.isMini)) msg.element.style.top = (563 - msg.element.clientHeight) * .5 + "px"
};
SystemMessageManager.SetHiddenMode = function(hidden) {
    SystemMessageManager.isHiddenMode = hidden;
    SystemMessageManager.InternalShowMessage()
};
SystemMessageManager.IsMessageOpen = function() {
    var mng = SystemMessageManager;
    var messageShown = mng.shownMessages.length > 0;
    if (messageShown)
        if (mng.shownMessages[mng.shownMessages.length - 1]["nonIntrusive"] == true) messageShown = false;
    return messageShown || SystemMessageManager.messagesToShow.length > 0 || RC2API.isGamePaused
};
SystemMessageManager.RCContinue = function() {
    if (RCContinueURL_Type == "notify") {
        var xhr = new XMLHttpRequest;
        xhr.open("GET", RCContinueURL, true);
        xhr.send(null);
        SystemMessageManager.RCCloseMessage()
    } else location.href = RCContinueURL
};
SystemMessageManager.RCClose = function() {
    if (RCCloseURL != undefined)
        if (RCCloseURL_Type == "notify") {
            var xhr = new XMLHttpRequest;
            xhr.open("GET", RCCloseURL, true);
            xhr.send(null);
            UHTEventBroker.Trigger(UHTEventBroker.Type.Adapter, JSON.stringify({
                common: "EVT_CLOSE_GAME",
                args: null
            }))
        } else location.href = RCCloseURL;
    else UHTEventBroker.Trigger(UHTEventBroker.Type.Adapter, JSON.stringify({
        common: "EVT_CLOSE_GAME",
        args: null
    }))
};
SystemMessageManager.RCHistory = function() {
    if (UHTInterfaceBOSS.HandleGameHistory()) return;
    var oGH = ServerOptions.gameHistory;
    if (RCHistoryURL != undefined) ServerOptions.gameHistory = RCHistoryURL;
    if (UHT_GAME_CONFIG_SRC["externalHistoryUrl"] != undefined) ServerOptions.gameHistory = UHT_GAME_CONFIG_SRC["externalHistoryUrl"];
    if (UHT_GAME_CONFIG_SRC["openHistoryInWindow"]) window.location.assign(ServerOptions.gameHistory);
    else if (UHT_GAME_CONFIG["openHistoryInTab"]) window.open(ServerOptions.gameHistory);
    else(new GameHistoryWindow).Open();
    ServerOptions.gameHistory = oGH
};
SystemMessageManager.RCCloseMessage = function() {
    SystemMessageManager.CloseMessage();
    RC_timer = (new Date).getTime();
    RC_WindowShown = false
};
SystemMessageManager.CloseMessage = function() {
    var mng = SystemMessageManager;
    mng.scaleRoot.removeChild(mng.scaleRoot.lastChild);
    var msg = mng.shownMessages.pop();
    if (msg["nonIntrusive"] == true) XT.TriggerEvent(CustomNotificationVars.Evt_Internal_HideNonIntrusiveNotification);
    else XT.TriggerEvent(CustomNotificationVars.Evt_Internal_HideIntrusiveNotification);
    mng.InternalShowMessage();
    if (mng.shownMessages.length < 1) setTimeout(mng.TriggerMessageClosed, 1)
};
SystemMessageManager.TriggerMessageClosed = function() {
    UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
        common: "EVT_MESSAGE_CLOSED",
        args: null
    }));
    SystemMessageManager.msgOpenWasTriggered = false
};
SystemMessageManager.MessageExists = function(data) {
    var msgs = SystemMessageManager.shownMessages;
    for (var i = 0; i < msgs.length; ++i)
        if (msgs[i].equals(data)) return true;
    msgs = SystemMessageManager.messagesToShow;
    for (var j = 0; j < msgs.length; ++j)
        if (msgs[j].equals(data)) return true;
    return false
};
SystemMessageManager.CreateMessage = function(data, options, isCustom) {
    var mng = SystemMessageManager;
    var allTexts = [];
    var title = document.createElement("p");
    title.className = "sys-msg-title";
    title.innerHTML = isCustom ? mng.ProcessText(options.title) : mng.LocalizedText(options.title || "WindowTitle");
    allTexts.push(title.innerHTML);
    var text = document.createElement("table");
    text.className = "sys-msg-text";
    var txt = data.text != null ? mng.ProcessText(data.text) : mng.LocalizedText(options.id);
    text.innerHTML = ["<tbody><tr><td>",
        txt, "</td></tr></tbody>"
    ].join("");
    allTexts.push(txt);
    var buttons = document.createElement("p");
    buttons.className = "sys-msg-buttons";
    for (var i = 0; i < options.buttons.length; ++i) {
        var btn = document.createElement("a");
        btn.className = ["sys-msg-button", options.buttons[i].id].join(" ");
        btn.innerHTML = isCustom ? mng.ProcessText(options.buttons[i].label) : mng.LocalizedText(options.buttons[i].id);
        allTexts.push(btn.innerHTML);
        mng.SetBtnHandlers(btn, options.buttons[i].handlers, data.args);
        buttons.appendChild(btn)
    }
    var msg =
        document.createElement("div");
    msg.id = options.id;
    msg.className = isCustom ? options.className : "sys-msg";
    msg.appendChild(title);
    msg.appendChild(text);
    msg.appendChild(buttons);
    if (SystemMessageManager.msgFontLoaded[options.id] != true) {
        mng.msgFontLoaded[options.id] = false;
        FontLoader.LoadFont(mng.fontName, null, {
            force: true,
            text: allTexts.join("")
        });
        FontLoader.AddHandler(mng.fontName, function() {
            mng.msgFontLoaded[options.id] = true
        }, mng)
    }
    data.element = msg;
    data.isCustom = isCustom;
    return msg
};
SystemMessageManager.InitRootElements = function() {
    var mng = SystemMessageManager;
    if (mng.root != null) return;
    mng.root = document.createElement("div");
    mng.root.className = "sys-msg-root-hidden";
    mng.root.id = "SysMsgRoot_" + mng.locale;
    mng.scaleRoot = document.createElement("div");
    mng.scaleRoot.className = "sys-msg-scale-root";
    mng.root.appendChild(mng.scaleRoot);
    document.body.appendChild(mng.root);
    mng.HandleResize();
    window.addEventListener("resize", mng.HandleResize, false);
    if (mng.os == mng.OS.iOS) mng.root.addEventListener("touchmove",
        mng.HandleTouchMove, false)
};
SystemMessageManager.HandleTouchMove = function(evt) {
    evt.returnValue = false;
    evt.cancelBubble = true;
    if (evt.preventDefault) {
        evt.preventDefault();
        evt.stopPropagation()
    }
    return false
};
SystemMessageManager.SetBtnHandlers = function(btn, clickHandlers, clickArgs) {
    var mng = SystemMessageManager;
    btn.addEventListener("click", mng.GetBtnClickHandler(clickHandlers, clickArgs), false);
    btn.addEventListener("touchstart", mng.AddBtnActiveStyle, false);
    btn.addEventListener("touchend", mng.RemoveBtnActiveStyle, false);
    btn.addEventListener("touchcancel", mng.RemoveBtnActiveStyle, false);
    btn.addEventListener("touchleave", mng.RemoveBtnActiveStyle, false);
    btn.addEventListener("mousedown", mng.AddBtnActiveStyle,
        false);
    btn.addEventListener("mouseup", mng.RemoveBtnActiveStyle, false);
    btn.addEventListener("mouseout", mng.RemoveBtnActiveStyle, false);
    btn.addEventListener("mouseleave", mng.RemoveBtnActiveStyle, false)
};
SystemMessageManager.AddBtnActiveStyle = function() {
    var target = this || null;
    if (target == null) return;
    if (/\bactive\b/.test(target.className)) return;
    target.className = [target.className, "active"].join(" ")
};
SystemMessageManager.RemoveBtnActiveStyle = function() {
    var target = this || null;
    if (target == null) return;
    if (!/\bactive\b/.test(target.className)) return;
    target.className = String(target.className).replace(/\bactive\b/g, "").replace(/^\s/g, "").replace(/\s$/g, "").replace(/\s\s/g, " ")
};
SystemMessageManager.GetBtnClickHandler = function(handlers, args) {
    return function() {
        for (var i = 0; i < handlers.length; ++i) handlers[i](args)
    }
};
SystemMessageManager.HandleResize = function() {
    var scaleRootHeight = 567;
    var zoom = 1;
    if (window.innerWidth > window.innerHeight) zoom = window.innerHeight / scaleRootHeight;
    else zoom = window.innerWidth / scaleRootHeight;
    var styles = ["-moz-transform: scale(VAL)", "-webkit-transform: scale(VAL)", "-ms-transform: scale(VAL)", "-o-transform: scale(VAL)", "transform: scale(VAL)"];
    if (UHT_DEVICE_TYPE.DESKTOP) zoom = zoom > 1 ? 1 : zoom;
    if (Globals.isMini) {
        var messageContainer = document.getElementsByClassName("sys-msg-title")[0];
        var textWidth =
            900;
        if (messageContainer != null && messageContainer.offsetWidth != null) textWidth = messageContainer.offsetWidth;
        if (textWidth * zoom > window.innerWidth) zoom = window.innerWidth / textWidth
    }
    for (var i = 0; i < styles.length; ++i) styles[i] = styles[i].replace("VAL", zoom);
    styles.push("width:" + window.innerWidth / zoom + "px");
    styles.push("margin-top:" + (window.innerHeight - scaleRootHeight * zoom) / 2 + "px");
    SystemMessageManager.scaleRoot.setAttribute("style", styles.join(";"))
};
SystemMessageManager.ProcessText = function(text) {
    text = decodeURIComponent(text).replace(/\+/g, " ");
    var isI11 = !UHT_CONFIG.MINI_MODE;
    if (isI11) text = text.replace(/<br/ig, "\n<br").replace(/<p/ig, "\n<p").replace(/(<([^>]+)>)/ig, "").replace(/\n\n/ig, "\n").replace(/^\n/ig, "").replace(/\n$/ig, "");
    return text
};
SystemMessageManager.LocalizedText = function(id) {
    if (SystemMessageManager.localizedTexts == null) return "*" + id + "*";
    var txt = SystemMessageManager.localizedTexts[id];
    if (txt == undefined) return "**" + id + "**";
    return SystemMessageManager.ProcessText(txt)
};
SystemMessageManager.RealMoney = function() {
    console.warn("real money");
    UHTEventBroker.Trigger(UHTEventBroker.Type.Adapter, JSON.stringify({
        common: "EVT_OPEN_CASHIER",
        args: null
    }))
};
SystemMessageManager.CloseGame = function() {
    console.warn("CloseGame");
    UHTEventBroker.Trigger(UHTEventBroker.Type.Adapter, JSON.stringify({
        common: "EVT_CLOSE_GAME",
        args: null
    }))
};
SystemMessageManager.Reload = function(link) {
    console.warn("Reload");
    location.assign(link)
};
SystemMessageManager.BrowserWarningShown = function() {
    SystemMessageManager.browserWarningShownCallback.call()
};
SystemMessageManager.RegulationContinuePressed = function() {
    SystemMessageManager.SendRegulationChoice(true)
};
SystemMessageManager.RegulationStopPressed = function() {
    SystemMessageManager.SendRegulationChoice(false)
};
SystemMessageManager.SendRegulationChoice = function(_continue) {
    var xhr = new XMLHttpRequest;
    xhr.open("POST", UHT_GAME_CONFIG["REGULATION"], true);
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
            var data = {};
            try {
                data = JSON.parse(_string.Trim(xhr.responseText))
            } catch (e) {}
            if (data["status"] == "OK")
                if (_continue) SystemMessageManager.CloseMessage();
                else SystemMessageManager.RCClose();
            else setTimeout(function() {
                    SystemMessageManager.SendRegulationChoice(_continue)
                },
                1E3)
        }
    };
    var params = [];
    params.push(["action", _continue ? "RESUME" : "STOP"].join("="));
    params.push(["type", SystemMessageManager.regulationType].join("="));
    xhr.send(params.join("&"))
};
SystemMessageManager.SendTimeout = function() {
    var xhr = new XMLHttpRequest;
    xhr.open("POST", UHT_GAME_CONFIG["LOGOUT"], true);
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4)
            if (xhr.responseText == "OK");
            else setTimeout(function() {
                SystemMessageManager.SendTimeout()
            }, 2E3)
    };
    xhr.send()
};
SystemMessageManager.OnLoad();
var LastInteractionTime = (new Date).getTime();
SystemMessageManager.UserInteraction = function() {
    LastInteractionTime = (new Date).getTime()
};
var RC_timer = -1;
var RC_sessionTimer = -1;
var RC_WindowShown = false;

function RC_CheckShowWindow() {
    if (RC_timer == -1) return;
    if (UHT_GAME_CONFIG["rcSettings"] == null) return;
    if (UHT_GAME_CONFIG["rcSettings"]["rctype"] != "RC0") return;
    if (RC_WindowShown) return;
    var now = (new Date).getTime();
    var interval = UHT_GAME_CONFIG["rcSettings"]["interval"];
    var minutes_passed = (Math.floor((now - RC_timer) / 6E4) | 0) + (UHT_GAME_CONFIG["rcSettings"]["elapsed"] || 0);
    var all_minutes_passed = Math.floor((now - RC_sessionTimer) / 6E4) | 0;
    if (minutes_passed >= interval) {
        SystemMessageManager.ShowMessage(SystemMessageType.ClientRegulation,
            false, UHT_GAME_CONFIG["rcSettings"]["msg"].replace("{0}", interval.toString()).replace("{1}", all_minutes_passed));
        UHT_GAME_CONFIG["rcSettings"]["elapsed"] = 0;
        RC_WindowShown = true
    }
}

function CheckTimeout() {
    if (UHT_GAME_CONFIG["sessionTimeout"] == "-1" || ServerOptions.isReplay) return;
    if ((new Date).getTime() - LastInteractionTime > UHT_GAME_CONFIG["sessionTimeout"] * 60 * 1E3) {
        if (!TimeoutWindowShown) {
            SystemMessageManager.ShowMessage(SystemMessageType.Timeout, true);
            SystemMessageManager.SendTimeout()
        }
        TimeoutWindowShown = true
    } else setTimeout(CheckTimeout, 1E4)
}
setTimeout(CheckTimeout, 6E4);

function IPhone7Helper() {}
IPhone8Helper.prototype = Object.create(IPhone7Helper.prototype);
IPhone8Helper.prototype.constructor = IPhone8Helper;

function IPhone8Helper() {
    IPhone7Helper.call(this);
    this.root = null;
    this.canvas = null;
    this.isLandscape = false;
    this.clientHeight = 0;
    this.timeoutOrientationChanged = null
}
IPhone8Helper.prototype.GameStarted = function() {
    var logoVisible = window["UHTLogoIsVisible"];
    var loaderVisible = window["loaderIsVisible"] != undefined ? window["loaderIsVisible"] : true;
    return !logoVisible && !loaderVisible
};
IPhone8Helper.prototype.CreateElement = function(className, append) {
    var el = document.createElement("div");
    el.className = className;
    if (append) document.body.appendChild(el);
    return el
};
IPhone8Helper.prototype.InitElements = function() {
    var self = this;
    this.CreateElement("fullscreen-reserve", true);
    this.root = this.CreateElement("fullscreen-root-hidden", true);
    this.root.addEventListener("touchend", function() {
        self.HandleTouchEnd.apply(self, arguments)
    }, false);
    this.root.addEventListener("touchcancel", function() {
        self.HandleTouchEnd.apply(self, arguments)
    }, false);
    this.root.addEventListener("gesturestart", function() {
        self.PreventEvent.apply(self, arguments)
    }, false);
    this.root.addEventListener("gesturechange",
        function() {
            self.PreventEvent.apply(self, arguments)
        }, false);
    this.root.addEventListener("gestureend", function() {
        self.PreventEvent.apply(self, arguments)
    }, false);
    this.canvas = document.getElementsByTagName("canvas")[0];
    this.canvas.style.position = "fixed";
    document.body.style.overflowY = "scroll";
    document.body.style.scrollBehavior = "smooth"
};
IPhone8Helper.prototype.PreventEvent = function(e) {
    e.preventDefault()
};
IPhone8Helper.prototype.ResizeHandler = function(e) {
    var self = this;
    if (!this.GameStarted() || Globals.WatchingReplay) {
        setTimeout(function() {
            self.ResizeHandler()
        }, 100);
        return
    }
    if (this.root == null) this.InitElements();
    this.isLandscape = window.innerWidth > window.innerHeight;
    var screenHeight = this.isLandscape ? Math.min(screen.width, screen.height) : Math.max(screen.width, screen.height);
    this.clientHeight = this.GetClientHeight();
    if (this.isLandscape)
        if (this.clientHeight <= window.innerHeight && window.innerHeight == screenHeight) {
            this.UpdateStyle(false);
            UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
                common: "EVT_FULLSCREEN_OVERLAY_HIDDEN",
                args: null
            }));
            window.scrollTo(0, 0)
        } else {
            this.UpdateStyle(true);
            UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
                common: "EVT_FULLSCREEN_OVERLAY_SHOWN",
                args: null
            }))
        }
    else if (this.clientHeight < window.innerHeight && window.innerHeight <= screenHeight) {
        this.UpdateStyle(false);
        UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
            common: "EVT_FULLSCREEN_OVERLAY_HIDDEN",
            args: null
        }));
        window.scrollTo(0,
            0)
    } else {
        this.UpdateStyle(true);
        UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
            common: "EVT_FULLSCREEN_OVERLAY_SHOWN",
            args: null
        }))
    }
    if (!this.isLandscape) this.QueueFullscreenHide();
    else if (this.timeoutOrientationChanged != null) clearTimeout(this.timeoutOrientationChanged);
    if (e !== undefined) setTimeout(function() {
        self.ResizeHandler()
    }, 100)
};
IPhone8Helper.prototype.QueueFullscreenHide = function() {
    var self = this;
    if (this.timeoutOrientationChanged != null) clearTimeout(this.timeoutOrientationChanged);
    this.timeoutOrientationChanged = setTimeout(self.HideFullScreen, 3E3, self)
};
IPhone8Helper.prototype.HideFullScreen = function(obj) {
    obj.UpdateStyle(false);
    UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
        common: "EVT_FULLSCREEN_OVERLAY_HIDDEN",
        args: null
    }))
};
IPhone8Helper.prototype.UpdateStyle = function(visible) {
    var c = String(document.documentElement.className).replace("fullscreen-visible", "").split(" ");
    var cn = [];
    for (var i = 0; i < c.length; ++i)
        if (c[i] != "") cn.push(c[i]);
    if (visible) cn.push("fullscreen-visible");
    document.documentElement.className = cn.join(" ");
    this.root.className = visible ? "fullscreen-root-visible" : "fullscreen-root-hidden"
};
IPhone8Helper.prototype.HandleTouchEnd = function() {
    window.scrollTo(0, 0)
};
IPhone8Helper.prototype.ScrollHandler = function() {
    if (this.clientHeight != this.GetClientHeight()) {
        var event = document.createEvent("HTMLEvents");
        event.initEvent("resize", true, true);
        window.dispatchEvent(event)
    }
};
IPhone8Helper.prototype.GetClientHeight = function() {
    return document.documentElement.clientHeight
};
var FullScreenIPhoneHelper = {};
FullScreenIPhoneHelper.Init = function() {
    if (UHT_FRAME) return;
    if (!(UHT_UA_INFO.device.model == "iPhone" && UHT_UA_INFO.browser.name == "Mobile Safari")) return;
    var version = _number.otoui(UHT_UA_INFO.os.version);
    if (version == 7) var h = new IPhone7Helper;
    else {
        var h = new IPhone8Helper;
        var onResize = function() {
            h.ResizeHandler.apply(h, arguments)
        };
        window.addEventListener("resize", onResize, false);
        h.ResizeHandler()
    }
};
FullScreenIPhoneHelper.USING_NEW_IMPLEMENTATION = true;
(function() {
    var keyboardAllowed = typeof Element !== "undefined" && "ALLOW_KEYBOARD_INPUT" in Element;
    var fn = function() {
        var val;
        var valLength;
        var fnMap = [
            ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
            ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"],
            ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen",
                "webkitfullscreenchange", "webkitfullscreenerror"
            ],
            ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"],
            ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]
        ];
        var i = 0;
        var l = fnMap.length;
        var ret = {};
        for (; i < l; i++) {
            val = fnMap[i];
            if (val && val[1] in document) {
                for (i = 0, valLength = val.length; i < valLength; i++) ret[fnMap[0][i]] = val[i];
                return ret
            }
        }
        return false
    }();
    var screenfull = {
        request: function(elem) {
            if (UHT_UA_INFO.os.name == "iOS") return;
            var request = fn.requestFullscreen;
            elem = elem || document.documentElement;
            var isAndroidChrome71Plus = UHT_UA_INFO.os.name == "Android" && UHT_UA_INFO.browser.name == "Chrome" && _number.otoui(UHT_UA_INFO.browser.version) >= 71;
            if (isAndroidChrome71Plus) elem[request]({
                navigationUI: "hide"
            });
            else if (/5\.1[\.\d]* Safari/.test(navigator.userAgent)) elem[request]();
            else elem[request](keyboardAllowed && Element.ALLOW_KEYBOARD_INPUT)
        },
        exit: function() {
            document[fn.exitFullscreen]()
        },
        toggle: function(elem) {
            if (this.isFullscreen) this.exit();
            else this.request(elem)
        },
        raw: fn
    };
    if (!fn) {
        window.screenfull = false;
        return
    }
    Object.defineProperties(screenfull, {
        isFullscreen: {
            get: function() {
                return !!document[fn.fullscreenElement]
            }
        },
        element: {
            enumerable: true,
            get: function() {
                return document[fn.fullscreenElement]
            }
        },
        enabled: {
            enumerable: true,
            get: function() {
                return !!document[fn.fullscreenEnabled]
            }
        }
    });
    window.screenfull = screenfull
})();
var FullScreenManager = {};
FullScreenManager.overlay = null;
FullScreenManager.reserve = null;
FullScreenManager.RequestFullscreen = function() {
    if (!window.screenfull.isFullscreen) window.screenfull.request()
};
FullScreenManager.ExitFullscreen = function() {
    if (window.screenfull.isFullscreen) window.screenfull.exit()
};
FullScreenManager.IsFullscreen = function() {
    return window.screenfull.isFullscreen
};
FullScreenManager.Init = function() {
    if (!UHT_DEVICE_TYPE.MOBILE) return;
    if (UHT_GAME_CONFIG_SRC["allowFullscreen"] != undefined)
        if (window.top != window && !UHT_GAME_CONFIG_SRC["allowFullscreen"]) return;
    var self = FullScreenManager;
    var inputMng = globalColliderInputManager;
    if (inputMng == undefined) {
        setTimeout(self.Init, 50);
        return
    }
    if (window.screenfull && window.screenfull.enabled) inputMng.addEventHandler(ColliderEvent.ButtonUp, new EventHandler(self, self.RequestFullscreen));
    FullScreenIPhoneHelper.Init()
};
FullScreenManager.OnLoad = function() {
    var self = FullScreenManager;
    self.Init();
    window.RequestFullscreen = self.RequestFullscreen;
    window.ExitFullscreen = self.ExitFullscreen;
    window.IsFullscreen = self.IsFullscreen
};
FullScreenManager.OnLoad();

function IPhoneChromeFullscreen() {
    this.root = null;
    this.reserve = null;
    this.minHeight = -1;
    this.maxHeight = -1;
    this.topBarHeightLand = -1;
    this.topBarHeightPort = -1;
    this.isInit = false;
    this.isLand = false;
    this.isVisible = false;
    this.isResized = false;
    this.gameJustStarted = true;
    this.timer = 0;
    this.CreateElement = IPhone8Helper.prototype.CreateElement;
    this.UpdateStyle = IPhone8Helper.prototype.UpdateStyle;
    this.GameStarted = IPhone8Helper.prototype.GameStarted
}
IPhoneChromeFullscreen.instance = null;
IPhoneChromeFullscreen.prototype.UpdateReserve = function() {
    this.reserve.style.height = (this.isLand ? this.minHeight : this.maxHeight) + Math.max(0, window.scrollY) + "px"
};
IPhoneChromeFullscreen.prototype.FixScroll = function() {
    if (window.scrollY < this.scrollY) window.scrollTo(0, this.scrollY);
    this.UpdateReserve()
};
IPhoneChromeFullscreen.prototype.Init = function() {
    var min = Math.min(screen.width, screen.height);
    var max = Math.max(screen.width, screen.height);
    if (min == 320 && max == 568) this.topBarHeightLand = this.topBarHeightPort = this.scrollY = 76;
    if (min == 375 && max == 667) this.topBarHeightLand = this.topBarHeightPort = this.scrollY = 76;
    if (min == 414 && max == 736) this.topBarHeightLand = this.topBarHeightPort = this.scrollY = 76;
    if (min == 375 && max == 812) {
        this.topBarHeightLand = 56;
        this.topBarHeightPort = this.scrollY = 100
    }
    if (min == 414 && max == 896) {
        this.topBarHeightLand =
            56;
        this.topBarHeightPort = this.scrollY = 100
    }
    this.minHeight = min;
    this.maxHeight = max;
    this.root = this.CreateElement("fullscreen-root-hidden", true);
    this.reserve = document.createElement("div");
    document.body.insertBefore(this.reserve, document.getElementsByTagName("canvas")[0]);
    this.UpdateReserve();
    this.isInit = true
};
IPhoneChromeFullscreen.prototype.IsMinimalMode = function() {
    this.isLand = window.innerWidth > window.innerHeight;
    var h = this.isLand ? this.minHeight : this.maxHeight;
    return h - window.innerHeight < (this.isLand ? this.topBarHeightLand : this.topBarHeightPort)
};
IPhoneChromeFullscreen.prototype.OnUHTResize = function(unused) {
    if (Globals.WatchingReplay) return;
    if (!this.isInit) this.Init();
    if (!this.IsMinimalMode()) {
        if (!this.isVisible) {
            window.scrollTo(0, 0);
            this.UpdateReserve();
            this.isVisible = true;
            this.UpdateStyle(true);
            UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
                common: "EVT_FULLSCREEN_OVERLAY_SHOWN",
                args: null
            }))
        }
    } else if (this.isVisible) {
        this.isVisible = false;
        this.UpdateStyle(false);
        UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
            common: "EVT_FULLSCREEN_OVERLAY_HIDDEN",
            args: null
        }))
    }
    this.isResized = true
};
IPhoneChromeFullscreen.prototype.OnUHTUpdate = function(unused) {
    if (this.gameJustStarted)
        if (this.GameStarted()) {
            this.OnUHTResize(null);
            this.gameJustStarted = false
        }
    if (!this.isInit) return;
    if (this.isResized) {
        this.isResized = false;
        this.timer = 0;
        return
    }
    if (this.IsMinimalMode())
        if (this.timer > 1) {
            this.timer = 0;
            this.FixScroll()
        } else this.timer += Time.deltaTime
};
IPhoneChromeFullscreen.OnLoad = function() {
    if (!UHT_FRAME && UHT_UA_INFO.device.model == "iPhone" && UHT_UA_INFO.browser.name == "Chrome") {
        var instance = IPhoneChromeFullscreen.instance = new IPhoneChromeFullscreen;
        EventManager.AddHandler("EVT_UHT_RESIZE", instance.OnUHTResize, instance);
        EventManager.AddHandler("EVT_UHT_UPDATE", instance.OnUHTUpdate, instance)
    }
};
var NoSleep = {};
NoSleep.os = null;
NoSleep.uap = null;
NoSleep.browserName = "";
NoSleep.Android = function() {
    var srcWebM = document.createElement("source");
    srcWebM.src = "data:video/webm;base64,GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4EEQoWBAhhTgGcBAAAAAAAVkhFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsghV17AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU1LjMzLjEwMFdBjUxhdmY1NS4zMy4xMDBzpJBlrrXf3DCDVB8KcgbMpcr+RImIQJBgAAAAAAAWVK5rAQAAAAAAD++uAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDiDgQEj44OEAmJaAOABAAAAAAAABrCBsLqBkK4BAAAAAAAPq9eBAnPFgQKcgQAitZyDdW5khohBX1ZPUkJJU4OBAuEBAAAAAAAAEZ+BArWIQOdwAAAAAABiZIEgY6JPbwIeVgF2b3JiaXMAAAAAAoC7AAAAAAAAgLUBAAAAAAC4AQN2b3JiaXMtAAAAWGlwaC5PcmcgbGliVm9yYmlzIEkgMjAxMDExMDEgKFNjaGF1ZmVudWdnZXQpAQAAABUAAABlbmNvZGVyPUxhdmM1NS41Mi4xMDIBBXZvcmJpcyVCQ1YBAEAAACRzGCpGpXMWhBAaQlAZ4xxCzmvsGUJMEYIcMkxbyyVzkCGkoEKIWyiB0JBVAABAAACHQXgUhIpBCCGEJT1YkoMnPQghhIg5eBSEaUEIIYQQQgghhBBCCCGERTlokoMnQQgdhOMwOAyD5Tj4HIRFOVgQgydB6CCED0K4moOsOQghhCQ1SFCDBjnoHITCLCiKgsQwuBaEBDUojILkMMjUgwtCiJqDSTX4GoRnQXgWhGlBCCGEJEFIkIMGQcgYhEZBWJKDBjm4FITLQagahCo5CB+EIDRkFQCQAACgoiiKoigKEBqyCgDIAAAQQFEUx3EcyZEcybEcCwgNWQUAAAEACAAAoEiKpEiO5EiSJFmSJVmSJVmS5omqLMuyLMuyLMsyEBqyCgBIAABQUQxFcRQHCA1ZBQBkAAAIoDiKpViKpWiK54iOCISGrAIAgAAABAAAEDRDUzxHlETPVFXXtm3btm3btm3btm3btm1blmUZCA1ZBQBAAAAQ0mlmqQaIMAMZBkJDVgEACAAAgBGKMMSA0JBVAABAAACAGEoOogmtOd+c46BZDppKsTkdnEi1eZKbirk555xzzsnmnDHOOeecopxZDJoJrTnnnMSgWQqaCa0555wnsXnQmiqtOeeccc7pYJwRxjnnnCateZCajbU555wFrWmOmkuxOeecSLl5UptLtTnnnHPOOeecc84555zqxekcnBPOOeecqL25lpvQxTnnnE/G6d6cEM4555xzzjnnnHPOOeecIDRkFQAABABAEIaNYdwpCNLnaCBGEWIaMulB9+gwCRqDnELq0ehopJQ6CCWVcVJKJwgNWQUAAAIAQAghhRRSSCGFFFJIIYUUYoghhhhyyimnoIJKKqmooowyyyyzzDLLLLPMOuyssw47DDHEEEMrrcRSU2011lhr7jnnmoO0VlprrbVSSimllFIKQkNWAQAgAAAEQgYZZJBRSCGFFGKIKaeccgoqqIDQkFUAACAAgAAAAABP8hzRER3RER3RER3RER3R8RzPESVREiVREi3TMjXTU0VVdWXXlnVZt31b2IVd933d933d+HVhWJZlWZZlWZZlWZZlWZZlWZYgNGQVAAACAAAghBBCSCGFFFJIKcYYc8w56CSUEAgNWQUAAAIACAAAAHAUR3EcyZEcSbIkS9IkzdIsT/M0TxM9URRF0zRV0RVdUTdtUTZl0zVdUzZdVVZtV5ZtW7Z125dl2/d93/d93/d93/d93/d9XQdCQ1YBABIAADqSIymSIimS4ziOJElAaMgqAEAGAEAAAIriKI7jOJIkSZIlaZJneZaomZrpmZ4qqkBoyCoAABAAQAAAAAAAAIqmeIqpeIqoeI7oiJJomZaoqZoryqbsuq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq4LhIasAgAkAAB0JEdyJEdSJEVSJEdygNCQVQCADACAAAAcwzEkRXIsy9I0T/M0TxM90RM901NFV3SB0JBVAAAgAIAAAAAAAAAMybAUy9EcTRIl1VItVVMt1VJF1VNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVN0zRNEwgNWQkAkAEAkBBTLS3GmgmLJGLSaqugYwxS7KWxSCpntbfKMYUYtV4ah5RREHupJGOKQcwtpNApJq3WVEKFFKSYYyoVUg5SIDRkhQAQmgHgcBxAsixAsiwAAAAAAAAAkDQN0DwPsDQPAAAAAAAAACRNAyxPAzTPAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA0jRA8zxA8zwAAAAAAAAA0DwP8DwR8EQRAAAAAAAAACzPAzTRAzxRBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA0jRA8zxA8zwAAAAAAAAAsDwP8EQR0DwRAAAAAAAAACzPAzxRBDzRAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEOAAABBgIRQasiIAiBMAcEgSJAmSBM0DSJYFTYOmwTQBkmVB06BpME0AAAAAAAAAAAAAJE2DpkHTIIoASdOgadA0iCIAAAAAAAAAAAAAkqZB06BpEEWApGnQNGgaRBEAAAAAAAAAAAAAzzQhihBFmCbAM02IIkQRpgkAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAGHAAAAgwoQwUGrIiAIgTAHA4imUBAIDjOJYFAACO41gWAABYliWKAABgWZooAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAYcAAACDChDBQashIAiAIAcCiKZQHHsSzgOJYFJMmyAJYF0DyApgFEEQAIAAAocAAACLBBU2JxgEJDVgIAUQAABsWxLE0TRZKkaZoniiRJ0zxPFGma53meacLzPM80IYqiaJoQRVE0TZimaaoqME1VFQAAUOAAABBgg6bE4gCFhqwEAEICAByKYlma5nmeJ4qmqZokSdM8TxRF0TRNU1VJkqZ5niiKommapqqyLE3zPFEURdNUVVWFpnmeKIqiaaqq6sLzPE8URdE0VdV14XmeJ4qiaJqq6roQRVE0TdNUTVV1XSCKpmmaqqqqrgtETxRNU1Vd13WB54miaaqqq7ouEE3TVFVVdV1ZBpimaaqq68oyQFVV1XVdV5YBqqqqruu6sgxQVdd1XVmWZQCu67qyLMsCAAAOHAAAAoygk4wqi7DRhAsPQKEhKwKAKAAAwBimFFPKMCYhpBAaxiSEFEImJaXSUqogpFJSKRWEVEoqJaOUUmopVRBSKamUCkIqJZVSAADYgQMA2IGFUGjISgAgDwCAMEYpxhhzTiKkFGPOOScRUoox55yTSjHmnHPOSSkZc8w556SUzjnnnHNSSuacc845KaVzzjnnnJRSSuecc05KKSWEzkEnpZTSOeecEwAAVOAAABBgo8jmBCNBhYasBABSAQAMjmNZmuZ5omialiRpmud5niiapiZJmuZ5nieKqsnzPE8URdE0VZXneZ4oiqJpqirXFUXTNE1VVV2yLIqmaZqq6rowTdNUVdd1XZimaaqq67oubFtVVdV1ZRm2raqq6rqyDFzXdWXZloEsu67s2rIAAPAEBwCgAhtWRzgpGgssNGQlAJABAEAYg5BCCCFlEEIKIYSUUggJAAAYcAAACDChDBQashIASAUAAIyx1lprrbXWQGettdZaa62AzFprrbXWWmuttdZaa6211lJrrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmstpZRSSimllFJKKaWUUkoppZRSSgUA+lU4APg/2LA6wknRWGChISsBgHAAAMAYpRhzDEIppVQIMeacdFRai7FCiDHnJKTUWmzFc85BKCGV1mIsnnMOQikpxVZjUSmEUlJKLbZYi0qho5JSSq3VWIwxqaTWWoutxmKMSSm01FqLMRYjbE2ptdhqq7EYY2sqLbQYY4zFCF9kbC2m2moNxggjWywt1VprMMYY3VuLpbaaizE++NpSLDHWXAAAd4MDAESCjTOsJJ0VjgYXGrISAAgJACAQUooxxhhzzjnnpFKMOeaccw5CCKFUijHGnHMOQgghlIwx5pxzEEIIIYRSSsaccxBCCCGEkFLqnHMQQgghhBBKKZ1zDkIIIYQQQimlgxBCCCGEEEoopaQUQgghhBBCCKmklEIIIYRSQighlZRSCCGEEEIpJaSUUgohhFJCCKGElFJKKYUQQgillJJSSimlEkoJJYQSUikppRRKCCGUUkpKKaVUSgmhhBJKKSWllFJKIYQQSikFAAAcOAAABBhBJxlVFmGjCRcegEJDVgIAZAAAkKKUUiktRYIipRikGEtGFXNQWoqocgxSzalSziDmJJaIMYSUk1Qy5hRCDELqHHVMKQYtlRhCxhik2HJLoXMOAAAAQQCAgJAAAAMEBTMAwOAA4XMQdAIERxsAgCBEZohEw0JweFAJEBFTAUBigkIuAFRYXKRdXECXAS7o4q4DIQQhCEEsDqCABByccMMTb3jCDU7QKSp1IAAAAAAADADwAACQXAAREdHMYWRobHB0eHyAhIiMkAgAAAAAABcAfAAAJCVAREQ0cxgZGhscHR4fICEiIyQBAIAAAgAAAAAggAAEBAQAAAAAAAIAAAAEBB9DtnUBAAAAAAAEPueBAKOFggAAgACjzoEAA4BwBwCdASqwAJAAAEcIhYWIhYSIAgIABhwJ7kPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99YAD+/6tQgKOFggADgAqjhYIAD4AOo4WCACSADqOZgQArADECAAEQEAAYABhYL/QACIBDmAYAAKOFggA6gA6jhYIAT4AOo5mBAFMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAGSADqOFggB6gA6jmYEAewAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIAj4AOo5mBAKMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAKSADqOFggC6gA6jmYEAywAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIAz4AOo4WCAOSADqOZgQDzADECAAEQEAAYABhYL/QACIBDmAYAAKOFggD6gA6jhYIBD4AOo5iBARsAEQIAARAQFGAAYWC/0AAiAQ5gGACjhYIBJIAOo4WCATqADqOZgQFDADECAAEQEAAYABhYL/QACIBDmAYAAKOFggFPgA6jhYIBZIAOo5mBAWsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAXqADqOFggGPgA6jmYEBkwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIBpIAOo4WCAbqADqOZgQG7ADECAAEQEAAYABhYL/QACIBDmAYAAKOFggHPgA6jmYEB4wAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIB5IAOo4WCAfqADqOZgQILADECAAEQEAAYABhYL/QACIBDmAYAAKOFggIPgA6jhYICJIAOo5mBAjMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAjqADqOFggJPgA6jmYECWwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYICZIAOo4WCAnqADqOZgQKDADECAAEQEAAYABhYL/QACIBDmAYAAKOFggKPgA6jhYICpIAOo5mBAqsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCArqADqOFggLPgA6jmIEC0wARAgABEBAUYABhYL/QACIBDmAYAKOFggLkgA6jhYIC+oAOo5mBAvsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAw+ADqOZgQMjADECAAEQEAAYABhYL/QACIBDmAYAAKOFggMkgA6jhYIDOoAOo5mBA0sAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCA0+ADqOFggNkgA6jmYEDcwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIDeoAOo4WCA4+ADqOZgQObADECAAEQEAAYABhYL/QACIBDmAYAAKOFggOkgA6jhYIDuoAOo5mBA8MAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCA8+ADqOFggPkgA6jhYID+oAOo4WCBA+ADhxTu2sBAAAAAAAAEbuPs4EDt4r3gQHxghEr8IEK";
    srcWebM.type = "video/webm";
    var srcMP4 = document.createElement("source");
    srcMP4.src = "data:video/mp4;base64,AAAAHGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMQAAAAhmcmVlAAAGF21kYXTeBAAAbGliZmFhYyAxLjI4AABCAJMgBDIARwAAArEGBf//rdxF6b3m2Ui3lizYINkj7u94MjY0IC0gY29yZSAxNDIgcjIgOTU2YzhkOCAtIEguMjY0L01QRUctNCBBVkMgY29kZWMgLSBDb3B5bGVmdCAyMDAzLTIwMTQgLSBodHRwOi8vd3d3LnZpZGVvbGFuLm9yZy94MjY0Lmh0bWwgLSBvcHRpb25zOiBjYWJhYz0wIHJlZj0zIGRlYmxvY2s9MTowOjAgYW5hbHlzZT0weDE6MHgxMTEgbWU9aGV4IHN1Ym1lPTcgcHN5PTEgcHN5X3JkPTEuMDA6MC4wMCBtaXhlZF9yZWY9MSBtZV9yYW5nZT0xNiBjaHJvbWFfbWU9MSB0cmVsbGlzPTEgOHg4ZGN0PTAgY3FtPTAgZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0xIGNocm9tYV9xcF9vZmZzZXQ9LTIgdGhyZWFkcz02IGxvb2thaGVhZF90aHJlYWRzPTEgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNlZD0wIGJsdXJheV9jb21wYXQ9MCBjb25zdHJhaW5lZF9pbnRyYT0wIGJmcmFtZXM9MCB3ZWlnaHRwPTAga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCB2YnZfbWF4cmF0ZT03NjggdmJ2X2J1ZnNpemU9MzAwMCBjcmZfbWF4PTAuMCBuYWxfaHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAAFZliIQL8mKAAKvMnJycnJycnJycnXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXiEASZACGQAjgCEASZACGQAjgAAAAAdBmjgX4GSAIQBJkAIZACOAAAAAB0GaVAX4GSAhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGagC/AySEASZACGQAjgAAAAAZBmqAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZrAL8DJIQBJkAIZACOAAAAABkGa4C/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmwAvwMkhAEmQAhkAI4AAAAAGQZsgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGbQC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm2AvwMkhAEmQAhkAI4AAAAAGQZuAL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGboC/AySEASZACGQAjgAAAAAZBm8AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZvgL8DJIQBJkAIZACOAAAAABkGaAC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmiAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpAL8DJIQBJkAIZACOAAAAABkGaYC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmoAvwMkhAEmQAhkAI4AAAAAGQZqgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGawC/AySEASZACGQAjgAAAAAZBmuAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZsAL8DJIQBJkAIZACOAAAAABkGbIC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm0AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZtgL8DJIQBJkAIZACOAAAAABkGbgCvAySEASZACGQAjgCEASZACGQAjgAAAAAZBm6AnwMkhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AAAAhubW9vdgAAAGxtdmhkAAAAAAAAAAAAAAAAAAAD6AAABDcAAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAzB0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAABAAAAAAAAA+kAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAALAAAACQAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAPpAAAAAAABAAAAAAKobWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAB1MAAAdU5VxAAAAAAALWhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABWaWRlb0hhbmRsZXIAAAACU21pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAhNzdGJsAAAAr3N0c2QAAAAAAAAAAQAAAJ9hdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAALAAkABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAALWF2Y0MBQsAN/+EAFWdCwA3ZAsTsBEAAAPpAADqYA8UKkgEABWjLg8sgAAAAHHV1aWRraEDyXyRPxbo5pRvPAyPzAAAAAAAAABhzdHRzAAAAAAAAAAEAAAAeAAAD6QAAABRzdHNzAAAAAAAAAAEAAAABAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAABAAAAAQAAAIxzdHN6AAAAAAAAAAAAAAAeAAADDwAAAAsAAAALAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAAiHN0Y28AAAAAAAAAHgAAAEYAAANnAAADewAAA5gAAAO0AAADxwAAA+MAAAP2AAAEEgAABCUAAARBAAAEXQAABHAAAASMAAAEnwAABLsAAATOAAAE6gAABQYAAAUZAAAFNQAABUgAAAVkAAAFdwAABZMAAAWmAAAFwgAABd4AAAXxAAAGDQAABGh0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAABDcAAAAAAAAAAAAAAAEBAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAQkAAADcAABAAAAAAPgbWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAC7gAAAykBVxAAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAADi21pbmYAAAAQc21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAADT3N0YmwAAABnc3RzZAAAAAAAAAABAAAAV21wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAAC7gAAAAAAAM2VzZHMAAAAAA4CAgCIAAgAEgICAFEAVBbjYAAu4AAAADcoFgICAAhGQBoCAgAECAAAAIHN0dHMAAAAAAAAAAgAAADIAAAQAAAAAAQAAAkAAAAFUc3RzYwAAAAAAAAAbAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAwAAAAEAAAABAAAABAAAAAIAAAABAAAABgAAAAEAAAABAAAABwAAAAIAAAABAAAACAAAAAEAAAABAAAACQAAAAIAAAABAAAACgAAAAEAAAABAAAACwAAAAIAAAABAAAADQAAAAEAAAABAAAADgAAAAIAAAABAAAADwAAAAEAAAABAAAAEAAAAAIAAAABAAAAEQAAAAEAAAABAAAAEgAAAAIAAAABAAAAFAAAAAEAAAABAAAAFQAAAAIAAAABAAAAFgAAAAEAAAABAAAAFwAAAAIAAAABAAAAGAAAAAEAAAABAAAAGQAAAAIAAAABAAAAGgAAAAEAAAABAAAAGwAAAAIAAAABAAAAHQAAAAEAAAABAAAAHgAAAAIAAAABAAAAHwAAAAQAAAABAAAA4HN0c3oAAAAAAAAAAAAAADMAAAAaAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAACMc3RjbwAAAAAAAAAfAAAALAAAA1UAAANyAAADhgAAA6IAAAO+AAAD0QAAA+0AAAQAAAAEHAAABC8AAARLAAAEZwAABHoAAASWAAAEqQAABMUAAATYAAAE9AAABRAAAAUjAAAFPwAABVIAAAVuAAAFgQAABZ0AAAWwAAAFzAAABegAAAX7AAAGFwAAAGJ1ZHRhAAAAWm1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALWlsc3QAAAAlqXRvbwAAAB1kYXRhAAAAAQAAAABMYXZmNTUuMzMuMTAw";
    srcMP4.type = "video/mp4";
    var video = document.createElement("video");
    video.setAttribute("loop", "");
    video.appendChild(srcWebM);
    video.appendChild(srcMP4);
    video.play();
    renderCanvas.removeEventListener("touchend", NoSleep.Android, false);
    NoSleep = null
};
NoSleep.IOS10 = function() {
    var video = document.createElement("video");
    video.setAttribute("playsinline", "");
    video.setAttribute("src", "data:video/mp4;base64,AAAAHGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMQAAAAhmcmVlAAAGF21kYXTeBAAAbGliZmFhYyAxLjI4AABCAJMgBDIARwAAArEGBf//rdxF6b3m2Ui3lizYINkj7u94MjY0IC0gY29yZSAxNDIgcjIgOTU2YzhkOCAtIEguMjY0L01QRUctNCBBVkMgY29kZWMgLSBDb3B5bGVmdCAyMDAzLTIwMTQgLSBodHRwOi8vd3d3LnZpZGVvbGFuLm9yZy94MjY0Lmh0bWwgLSBvcHRpb25zOiBjYWJhYz0wIHJlZj0zIGRlYmxvY2s9MTowOjAgYW5hbHlzZT0weDE6MHgxMTEgbWU9aGV4IHN1Ym1lPTcgcHN5PTEgcHN5X3JkPTEuMDA6MC4wMCBtaXhlZF9yZWY9MSBtZV9yYW5nZT0xNiBjaHJvbWFfbWU9MSB0cmVsbGlzPTEgOHg4ZGN0PTAgY3FtPTAgZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0xIGNocm9tYV9xcF9vZmZzZXQ9LTIgdGhyZWFkcz02IGxvb2thaGVhZF90aHJlYWRzPTEgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNlZD0wIGJsdXJheV9jb21wYXQ9MCBjb25zdHJhaW5lZF9pbnRyYT0wIGJmcmFtZXM9MCB3ZWlnaHRwPTAga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCB2YnZfbWF4cmF0ZT03NjggdmJ2X2J1ZnNpemU9MzAwMCBjcmZfbWF4PTAuMCBuYWxfaHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAAFZliIQL8mKAAKvMnJycnJycnJycnXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXiEASZACGQAjgCEASZACGQAjgAAAAAdBmjgX4GSAIQBJkAIZACOAAAAAB0GaVAX4GSAhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGagC/AySEASZACGQAjgAAAAAZBmqAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZrAL8DJIQBJkAIZACOAAAAABkGa4C/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmwAvwMkhAEmQAhkAI4AAAAAGQZsgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGbQC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm2AvwMkhAEmQAhkAI4AAAAAGQZuAL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGboC/AySEASZACGQAjgAAAAAZBm8AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZvgL8DJIQBJkAIZACOAAAAABkGaAC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmiAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpAL8DJIQBJkAIZACOAAAAABkGaYC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmoAvwMkhAEmQAhkAI4AAAAAGQZqgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGawC/AySEASZACGQAjgAAAAAZBmuAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZsAL8DJIQBJkAIZACOAAAAABkGbIC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm0AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZtgL8DJIQBJkAIZACOAAAAABkGbgCvAySEASZACGQAjgCEASZACGQAjgAAAAAZBm6AnwMkhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AAAAhubW9vdgAAAGxtdmhkAAAAAAAAAAAAAAAAAAAD6AAABDcAAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAzB0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAABAAAAAAAAA+kAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAALAAAACQAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAPpAAAAAAABAAAAAAKobWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAB1MAAAdU5VxAAAAAAALWhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABWaWRlb0hhbmRsZXIAAAACU21pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAhNzdGJsAAAAr3N0c2QAAAAAAAAAAQAAAJ9hdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAALAAkABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAALWF2Y0MBQsAN/+EAFWdCwA3ZAsTsBEAAAPpAADqYA8UKkgEABWjLg8sgAAAAHHV1aWRraEDyXyRPxbo5pRvPAyPzAAAAAAAAABhzdHRzAAAAAAAAAAEAAAAeAAAD6QAAABRzdHNzAAAAAAAAAAEAAAABAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAABAAAAAQAAAIxzdHN6AAAAAAAAAAAAAAAeAAADDwAAAAsAAAALAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAAiHN0Y28AAAAAAAAAHgAAAEYAAANnAAADewAAA5gAAAO0AAADxwAAA+MAAAP2AAAEEgAABCUAAARBAAAEXQAABHAAAASMAAAEnwAABLsAAATOAAAE6gAABQYAAAUZAAAFNQAABUgAAAVkAAAFdwAABZMAAAWmAAAFwgAABd4AAAXxAAAGDQAABGh0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAABDcAAAAAAAAAAAAAAAEBAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAQkAAADcAABAAAAAAPgbWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAC7gAAAykBVxAAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAADi21pbmYAAAAQc21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAADT3N0YmwAAABnc3RzZAAAAAAAAAABAAAAV21wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAAC7gAAAAAAAM2VzZHMAAAAAA4CAgCIAAgAEgICAFEAVBbjYAAu4AAAADcoFgICAAhGQBoCAgAECAAAAIHN0dHMAAAAAAAAAAgAAADIAAAQAAAAAAQAAAkAAAAFUc3RzYwAAAAAAAAAbAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAwAAAAEAAAABAAAABAAAAAIAAAABAAAABgAAAAEAAAABAAAABwAAAAIAAAABAAAACAAAAAEAAAABAAAACQAAAAIAAAABAAAACgAAAAEAAAABAAAACwAAAAIAAAABAAAADQAAAAEAAAABAAAADgAAAAIAAAABAAAADwAAAAEAAAABAAAAEAAAAAIAAAABAAAAEQAAAAEAAAABAAAAEgAAAAIAAAABAAAAFAAAAAEAAAABAAAAFQAAAAIAAAABAAAAFgAAAAEAAAABAAAAFwAAAAIAAAABAAAAGAAAAAEAAAABAAAAGQAAAAIAAAABAAAAGgAAAAEAAAABAAAAGwAAAAIAAAABAAAAHQAAAAEAAAABAAAAHgAAAAIAAAABAAAAHwAAAAQAAAABAAAA4HN0c3oAAAAAAAAAAAAAADMAAAAaAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAACMc3RjbwAAAAAAAAAfAAAALAAAA1UAAANyAAADhgAAA6IAAAO+AAAD0QAAA+0AAAQAAAAEHAAABC8AAARLAAAEZwAABHoAAASWAAAEqQAABMUAAATYAAAE9AAABRAAAAUjAAAFPwAABVIAAAVuAAAFgQAABZ0AAAWwAAAFzAAABegAAAX7AAAGFwAAAGJ1ZHRhAAAAWm1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALWlsc3QAAAAlqXRvbwAAAB1kYXRhAAAAAQAAAABMYXZmNTUuMzMuMTAw");
    video.addEventListener("timeupdate",
        function() {
            if (video.currentTime > .5) video.currentTime = Math.random()
        });
    video.play();
    document.removeEventListener("touchend", NoSleep.IOS10, false);
    NoSleep = null
};
NoSleep.Init = function() {
    if (NoSleep.uap == null) {
        NoSleep.uap = new UAParser2;
        NoSleep.os = NoSleep.uap.getOS() || {
            name: "",
            version: "0"
        };
        NoSleep.browserName = NoSleep.uap.getBrowser().name
    }
    if (NoSleep.os.name == "Android" && NoSleep.uap.getBrowser().name == "Chrome" && !IS_UCBROWSER) {
        if (renderCanvas == undefined) {
            setTimeout(NoSleep.Init, 100);
            return
        }
        renderCanvas.addEventListener("touchend", NoSleep.Android, false)
    } else if (NoSleep.os.name == "iOS" && (NoSleep.browserName.indexOf("Safari") != -1 || NoSleep.browserName.indexOf("Chrome") !=
            -1))
        if (parseFloat(NoSleep.os.version) >= 10) document.addEventListener("touchend", NoSleep.IOS10, false)
};
NoSleep.Init();